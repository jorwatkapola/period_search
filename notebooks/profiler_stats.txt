Total duration: 5.40663s
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py
File duration: 1.24215s (22.97%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Lite version of scipy.linalg.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|Notes
     4|         0|            0|            0|  0.00%|-----
     5|         0|            0|            0|  0.00%|This module is a lite version of the linalg.py module in SciPy which
     6|         0|            0|            0|  0.00%|contains high-level Python interface to the LAPACK library.  The lite
     7|         0|            0|            0|  0.00%|version only accesses the following LAPACK functions: dgesv, zgesv,
     8|         0|            0|            0|  0.00%|dgeev, zgeev, dgesdd, zgesdd, dgelsd, zgelsd, dsyevd, zheevd, dgetrf,
     9|         0|            0|            0|  0.00%|zgetrf, dpotrf, zpotrf, dgeqrf, zgeqrf, zungqr, dorgqr.
    10|         0|            0|            0|  0.00%|"""
    11|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|__all__ = ['matrix_power', 'solve', 'tensorsolve', 'tensorinv', 'inv',
    15|         0|            0|            0|  0.00%|           'cholesky', 'eigvals', 'eigvalsh', 'pinv', 'slogdet', 'det',
    16|         0|            0|            0|  0.00%|           'svd', 'eig', 'eigh', 'lstsq', 'norm', 'qr', 'cond', 'matrix_rank',
    17|         0|            0|            0|  0.00%|           'LinAlgError', 'multi_dot']
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|import functools
    20|         0|            0|            0|  0.00%|import operator
    21|         0|            0|            0|  0.00%|import warnings
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|from numpy.core import (
    24|         0|            0|            0|  0.00%|    array, asarray, zeros, empty, empty_like, intc, single, double,
    25|         0|            0|            0|  0.00%|    csingle, cdouble, inexact, complexfloating, newaxis, all, Inf, dot,
    26|         0|            0|            0|  0.00%|    add, multiply, sqrt, fastCopyAndTranspose, sum, isfinite,
    27|         0|            0|            0|  0.00%|    finfo, errstate, geterrobj, moveaxis, amin, amax, product, abs,
    28|         0|            0|            0|  0.00%|    atleast_2d, intp, asanyarray, object_, matmul,
    29|         0|            0|            0|  0.00%|    swapaxes, divide, count_nonzero, isnan, sign
    30|         0|            0|            0|  0.00%|)
    31|         0|            0|            0|  0.00%|from numpy.core.multiarray import normalize_axis_index
    32|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    33|         0|            0|            0|  0.00%|from numpy.core import overrides
    34|         0|            0|            0|  0.00%|from numpy.lib.twodim_base import triu, eye
    35|         0|            0|            0|  0.00%|from numpy.linalg import lapack_lite, _umath_linalg
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|
    38|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    39|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy.linalg')
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|# For Python2/3 compatibility
    43|         0|            0|            0|  0.00%|_N = b'N'
    44|         0|            0|            0|  0.00%|_V = b'V'
    45|         0|            0|            0|  0.00%|_A = b'A'
    46|         0|            0|            0|  0.00%|_S = b'S'
    47|         0|            0|            0|  0.00%|_L = b'L'
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|fortran_int = intc
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|@set_module('numpy.linalg')
    53|         0|            0|            0|  0.00%|class LinAlgError(Exception):
    54|         0|            0|            0|  0.00%|    """
    55|         0|            0|            0|  0.00%|    Generic Python-exception-derived object raised by linalg functions.
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|    General purpose exception class, derived from Python's exception.Exception
    58|         0|            0|            0|  0.00%|    class, programmatically raised in linalg functions when a Linear
    59|         0|            0|            0|  0.00%|    Algebra-related condition would prevent further correct execution of the
    60|         0|            0|            0|  0.00%|    function.
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    Parameters
    63|         0|            0|            0|  0.00%|    ----------
    64|         0|            0|            0|  0.00%|    None
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    Examples
    67|         0|            0|            0|  0.00%|    --------
    68|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
    69|         0|            0|            0|  0.00%|    >>> LA.inv(np.zeros((2,2)))
    70|         0|            0|            0|  0.00%|    Traceback (most recent call last):
    71|         0|            0|            0|  0.00%|      File "<stdin>", line 1, in <module>
    72|         0|            0|            0|  0.00%|      File "...linalg.py", line 350,
    73|         0|            0|            0|  0.00%|        in inv return wrap(solve(a, identity(a.shape[0], dtype=a.dtype)))
    74|         0|            0|            0|  0.00%|      File "...linalg.py", line 249,
    75|         0|            0|            0|  0.00%|        in solve
    76|         0|            0|            0|  0.00%|        raise LinAlgError('Singular matrix')
    77|         0|            0|            0|  0.00%|    numpy.linalg.LinAlgError: Singular matrix
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    """
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|def _determine_error_states():
    83|         0|            0|            0|  0.00%|    errobj = geterrobj()
    84|         0|            0|            0|  0.00%|    bufsize = errobj[0]
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    with errstate(invalid='call', over='ignore',
    87|         0|            0|            0|  0.00%|                  divide='ignore', under='ignore'):
    88|         0|            0|            0|  0.00%|        invalid_call_errmask = geterrobj()[1]
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    return [bufsize, invalid_call_errmask, None]
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|# Dealing with errors in _umath_linalg
    93|         0|            0|            0|  0.00%|_linalg_error_extobj = _determine_error_states()
    94|         0|            0|            0|  0.00%|del _determine_error_states
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|def _raise_linalgerror_singular(err, flag):
    97|         0|            0|            0|  0.00%|    raise LinAlgError("Singular matrix")
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|def _raise_linalgerror_nonposdef(err, flag):
   100|         0|            0|            0|  0.00%|    raise LinAlgError("Matrix is not positive definite")
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|def _raise_linalgerror_eigenvalues_nonconvergence(err, flag):
   103|         0|            0|            0|  0.00%|    raise LinAlgError("Eigenvalues did not converge")
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|def _raise_linalgerror_svd_nonconvergence(err, flag):
   106|         0|            0|            0|  0.00%|    raise LinAlgError("SVD did not converge")
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|def _raise_linalgerror_lstsq(err, flag):
   109|         0|            0|            0|  0.00%|    raise LinAlgError("SVD did not converge in Linear Least Squares")
   110|         0|            0|            0|  0.00%|
   111|      4000|   0.00736785|  1.84196e-06|  0.14%|def get_linalg_error_extobj(callback):
   112|      4000|    0.0111687|  2.79218e-06|  0.21%|    extobj = list(_linalg_error_extobj)  # make a copy
   113|      4000|   0.00867105|  2.16776e-06|  0.16%|    extobj[2] = callback
   114|      4000|   0.00804257|  2.01064e-06|  0.15%|    return extobj
   115|         0|            0|            0|  0.00%|
   116|      4000|   0.00784826|  1.96207e-06|  0.15%|def _makearray(a):
   117|      4000|    0.0278726|  6.96814e-06|  0.52%|    new = asarray(a)
(call)|      4000|    0.0177641|  4.44102e-06|  0.33%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:16 asarray
   118|      4000|    0.0114973|  2.87431e-06|  0.21%|    wrap = getattr(a, "__array_prepare__", new.__array_wrap__)
   119|      4000|   0.00906348|  2.26587e-06|  0.17%|    return new, wrap
   120|         0|            0|            0|  0.00%|
   121|     16000|    0.0267339|  1.67087e-06|  0.49%|def isComplexType(t):
   122|     16000|    0.0355866|  2.22416e-06|  0.66%|    return issubclass(t, complexfloating)
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|_real_types_map = {single : single,
   125|         0|            0|            0|  0.00%|                   double : double,
   126|         0|            0|            0|  0.00%|                   csingle : single,
   127|         0|            0|            0|  0.00%|                   cdouble : double}
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|_complex_types_map = {single : csingle,
   130|         0|            0|            0|  0.00%|                      double : cdouble,
   131|         0|            0|            0|  0.00%|                      csingle : csingle,
   132|         0|            0|            0|  0.00%|                      cdouble : cdouble}
   133|         0|            0|            0|  0.00%|
   134|      8000|    0.0138102|  1.72627e-06|  0.26%|def _realType(t, default=double):
   135|      8000|    0.0200963|  2.51204e-06|  0.37%|    return _real_types_map.get(t, default)
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|def _complexType(t, default=cdouble):
   138|         0|            0|            0|  0.00%|    return _complex_types_map.get(t, default)
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|def _linalgRealType(t):
   141|         0|            0|            0|  0.00%|    """Cast the type t to either double or cdouble."""
   142|         0|            0|            0|  0.00%|    return double
   143|         0|            0|            0|  0.00%|
   144|      8000|     0.018775|  2.34687e-06|  0.35%|def _commonType(*arrays):
   145|         0|            0|            0|  0.00%|    # in lite version, use higher precision (always double or cdouble)
   146|      8000|    0.0214977|  2.68722e-06|  0.40%|    result_type = single
   147|      8000|    0.0201135|  2.51418e-06|  0.37%|    is_complex = False
   148|     16000|    0.0390348|  2.43968e-06|  0.72%|    for a in arrays:
   149|      8000|    0.0229983|  2.87479e-06|  0.43%|        if issubclass(a.dtype.type, inexact):
   150|      8000|    0.0548773|  6.85966e-06|  1.01%|            if isComplexType(a.dtype.type):
(call)|      8000|    0.0309975|  3.87469e-06|  0.57%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:121 isComplexType
   151|         0|            0|            0|  0.00%|                is_complex = True
   152|      8000|    0.0569582|  7.11977e-06|  1.05%|            rt = _realType(a.dtype.type, default=None)
(call)|      8000|    0.0339065|  4.23831e-06|  0.63%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:134 _realType
   153|      8000|    0.0203221|  2.54026e-06|  0.38%|            if rt is None:
   154|         0|            0|            0|  0.00%|                # unsupported inexact scalar
   155|         0|            0|            0|  0.00%|                raise TypeError("array type %s is unsupported in linalg" %
   156|         0|            0|            0|  0.00%|                        (a.dtype.name,))
   157|         0|            0|            0|  0.00%|        else:
   158|         0|            0|            0|  0.00%|            rt = double
   159|      8000|    0.0194373|  2.42966e-06|  0.36%|        if rt is double:
   160|      8000|    0.0186572|  2.33215e-06|  0.35%|            result_type = double
   161|      8000|    0.0182955|  2.28694e-06|  0.34%|    if is_complex:
   162|         0|            0|            0|  0.00%|        t = cdouble
   163|         0|            0|            0|  0.00%|        result_type = _complex_types_map[result_type]
   164|         0|            0|            0|  0.00%|    else:
   165|      8000|     0.019325|  2.41563e-06|  0.36%|        t = double
   166|      8000|    0.0185125|  2.31406e-06|  0.34%|    return t, result_type
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|# _fastCopyAndTranpose assumes the input is 2D (as all the calls in here are).
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|_fastCT = fastCopyAndTranspose
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|def _to_native_byte_order(*arrays):
   174|         0|            0|            0|  0.00%|    ret = []
   175|         0|            0|            0|  0.00%|    for arr in arrays:
   176|         0|            0|            0|  0.00%|        if arr.dtype.byteorder not in ('=', '|'):
   177|         0|            0|            0|  0.00%|            ret.append(asarray(arr, dtype=arr.dtype.newbyteorder('=')))
   178|         0|            0|            0|  0.00%|        else:
   179|         0|            0|            0|  0.00%|            ret.append(arr)
   180|         0|            0|            0|  0.00%|    if len(ret) == 1:
   181|         0|            0|            0|  0.00%|        return ret[0]
   182|         0|            0|            0|  0.00%|    else:
   183|         0|            0|            0|  0.00%|        return ret
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|def _fastCopyAndTranspose(type, *arrays):
   186|         0|            0|            0|  0.00%|    cast_arrays = ()
   187|         0|            0|            0|  0.00%|    for a in arrays:
   188|         0|            0|            0|  0.00%|        if a.dtype.type is type:
   189|         0|            0|            0|  0.00%|            cast_arrays = cast_arrays + (_fastCT(a),)
   190|         0|            0|            0|  0.00%|        else:
   191|         0|            0|            0|  0.00%|            cast_arrays = cast_arrays + (_fastCT(a.astype(type)),)
   192|         0|            0|            0|  0.00%|    if len(cast_arrays) == 1:
   193|         0|            0|            0|  0.00%|        return cast_arrays[0]
   194|         0|            0|            0|  0.00%|    else:
   195|         0|            0|            0|  0.00%|        return cast_arrays
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|def _assertRank2(*arrays):
   198|         0|            0|            0|  0.00%|    for a in arrays:
   199|         0|            0|            0|  0.00%|        if a.ndim != 2:
   200|         0|            0|            0|  0.00%|            raise LinAlgError('%d-dimensional array given. Array must be '
   201|         0|            0|            0|  0.00%|                    'two-dimensional' % a.ndim)
   202|         0|            0|            0|  0.00%|
   203|      8000|    0.0149634|  1.87042e-06|  0.28%|def _assertRankAtLeast2(*arrays):
   204|     16000|    0.0365238|  2.28274e-06|  0.68%|    for a in arrays:
   205|      8000|    0.0180373|  2.25466e-06|  0.33%|        if a.ndim < 2:
   206|         0|            0|            0|  0.00%|            raise LinAlgError('%d-dimensional array given. Array must be '
   207|         0|            0|            0|  0.00%|                    'at least two-dimensional' % a.ndim)
   208|         0|            0|            0|  0.00%|
   209|      8000|    0.0161498|  2.01872e-06|  0.30%|def _assertNdSquareness(*arrays):
   210|     16000|    0.0377421|  2.35888e-06|  0.70%|    for a in arrays:
   211|      8000|    0.0218291|  2.72864e-06|  0.40%|        m, n = a.shape[-2:]
   212|      8000|    0.0180111|  2.25139e-06|  0.33%|        if m != n:
   213|         0|            0|            0|  0.00%|            raise LinAlgError('Last 2 dimensions of the array must be square')
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|def _assertFinite(*arrays):
   216|         0|            0|            0|  0.00%|    for a in arrays:
   217|         0|            0|            0|  0.00%|        if not (isfinite(a).all()):
   218|         0|            0|            0|  0.00%|            raise LinAlgError("Array must not contain infs or NaNs")
   219|         0|            0|            0|  0.00%|
   220|         0|            0|            0|  0.00%|def _isEmpty2d(arr):
   221|         0|            0|            0|  0.00%|    # check size first for efficiency
   222|         0|            0|            0|  0.00%|    return arr.size == 0 and product(arr.shape[-2:]) == 0
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|def _assertNoEmpty2d(*arrays):
   225|         0|            0|            0|  0.00%|    for a in arrays:
   226|         0|            0|            0|  0.00%|        if _isEmpty2d(a):
   227|         0|            0|            0|  0.00%|            raise LinAlgError("Arrays cannot be empty")
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|def transpose(a):
   230|         0|            0|            0|  0.00%|    """
   231|         0|            0|            0|  0.00%|    Transpose each matrix in a stack of matrices.
   232|         0|            0|            0|  0.00%|
   233|         0|            0|            0|  0.00%|    Unlike np.transpose, this only swaps the last two axes, rather than all of
   234|         0|            0|            0|  0.00%|    them
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|    Parameters
   237|         0|            0|            0|  0.00%|    ----------
   238|         0|            0|            0|  0.00%|    a : (...,M,N) array_like
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    Returns
   241|         0|            0|            0|  0.00%|    -------
   242|         0|            0|            0|  0.00%|    aT : (...,N,M) ndarray
   243|         0|            0|            0|  0.00%|    """
   244|         0|            0|            0|  0.00%|    return swapaxes(a, -1, -2)
   245|         0|            0|            0|  0.00%|
   246|         0|            0|            0|  0.00%|# Linear equations
   247|         0|            0|            0|  0.00%|
   248|         0|            0|            0|  0.00%|def _tensorsolve_dispatcher(a, b, axes=None):
   249|         0|            0|            0|  0.00%|    return (a, b)
   250|         0|            0|            0|  0.00%|
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|@array_function_dispatch(_tensorsolve_dispatcher)
   253|         0|            0|            0|  0.00%|def tensorsolve(a, b, axes=None):
   254|         0|            0|            0|  0.00%|    """
   255|         0|            0|            0|  0.00%|    Solve the tensor equation ``a x = b`` for x.
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    It is assumed that all indices of `x` are summed over in the product,
   258|         0|            0|            0|  0.00%|    together with the rightmost indices of `a`, as is done in, for example,
   259|         0|            0|            0|  0.00%|    ``tensordot(a, x, axes=b.ndim)``.
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    Parameters
   262|         0|            0|            0|  0.00%|    ----------
   263|         0|            0|            0|  0.00%|    a : array_like
   264|         0|            0|            0|  0.00%|        Coefficient tensor, of shape ``b.shape + Q``. `Q`, a tuple, equals
   265|         0|            0|            0|  0.00%|        the shape of that sub-tensor of `a` consisting of the appropriate
   266|         0|            0|            0|  0.00%|        number of its rightmost indices, and must be such that
   267|         0|            0|            0|  0.00%|        ``prod(Q) == prod(b.shape)`` (in which sense `a` is said to be
   268|         0|            0|            0|  0.00%|        'square').
   269|         0|            0|            0|  0.00%|    b : array_like
   270|         0|            0|            0|  0.00%|        Right-hand tensor, which can be of any shape.
   271|         0|            0|            0|  0.00%|    axes : tuple of ints, optional
   272|         0|            0|            0|  0.00%|        Axes in `a` to reorder to the right, before inversion.
   273|         0|            0|            0|  0.00%|        If None (default), no reordering is done.
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    Returns
   276|         0|            0|            0|  0.00%|    -------
   277|         0|            0|            0|  0.00%|    x : ndarray, shape Q
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    Raises
   280|         0|            0|            0|  0.00%|    ------
   281|         0|            0|            0|  0.00%|    LinAlgError
   282|         0|            0|            0|  0.00%|        If `a` is singular or not 'square' (in the above sense).
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    See Also
   285|         0|            0|            0|  0.00%|    --------
   286|         0|            0|            0|  0.00%|    numpy.tensordot, tensorinv, numpy.einsum
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    Examples
   289|         0|            0|            0|  0.00%|    --------
   290|         0|            0|            0|  0.00%|    >>> a = np.eye(2*3*4)
   291|         0|            0|            0|  0.00%|    >>> a.shape = (2*3, 4, 2, 3, 4)
   292|         0|            0|            0|  0.00%|    >>> b = np.random.randn(2*3, 4)
   293|         0|            0|            0|  0.00%|    >>> x = np.linalg.tensorsolve(a, b)
   294|         0|            0|            0|  0.00%|    >>> x.shape
   295|         0|            0|            0|  0.00%|    (2, 3, 4)
   296|         0|            0|            0|  0.00%|    >>> np.allclose(np.tensordot(a, x, axes=3), b)
   297|         0|            0|            0|  0.00%|    True
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    """
   300|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
   301|         0|            0|            0|  0.00%|    b = asarray(b)
   302|         0|            0|            0|  0.00%|    an = a.ndim
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    if axes is not None:
   305|         0|            0|            0|  0.00%|        allaxes = list(range(0, an))
   306|         0|            0|            0|  0.00%|        for k in axes:
   307|         0|            0|            0|  0.00%|            allaxes.remove(k)
   308|         0|            0|            0|  0.00%|            allaxes.insert(an, k)
   309|         0|            0|            0|  0.00%|        a = a.transpose(allaxes)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|    oldshape = a.shape[-(an-b.ndim):]
   312|         0|            0|            0|  0.00%|    prod = 1
   313|         0|            0|            0|  0.00%|    for k in oldshape:
   314|         0|            0|            0|  0.00%|        prod *= k
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    a = a.reshape(-1, prod)
   317|         0|            0|            0|  0.00%|    b = b.ravel()
   318|         0|            0|            0|  0.00%|    res = wrap(solve(a, b))
   319|         0|            0|            0|  0.00%|    res.shape = oldshape
   320|         0|            0|            0|  0.00%|    return res
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|def _solve_dispatcher(a, b):
   324|         0|            0|            0|  0.00%|    return (a, b)
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|@array_function_dispatch(_solve_dispatcher)
   328|         0|            0|            0|  0.00%|def solve(a, b):
   329|         0|            0|            0|  0.00%|    """
   330|         0|            0|            0|  0.00%|    Solve a linear matrix equation, or system of linear scalar equations.
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|    Computes the "exact" solution, `x`, of the well-determined, i.e., full
   333|         0|            0|            0|  0.00%|    rank, linear matrix equation `ax = b`.
   334|         0|            0|            0|  0.00%|
   335|         0|            0|            0|  0.00%|    Parameters
   336|         0|            0|            0|  0.00%|    ----------
   337|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
   338|         0|            0|            0|  0.00%|        Coefficient matrix.
   339|         0|            0|            0|  0.00%|    b : {(..., M,), (..., M, K)}, array_like
   340|         0|            0|            0|  0.00%|        Ordinate or "dependent variable" values.
   341|         0|            0|            0|  0.00%|
   342|         0|            0|            0|  0.00%|    Returns
   343|         0|            0|            0|  0.00%|    -------
   344|         0|            0|            0|  0.00%|    x : {(..., M,), (..., M, K)} ndarray
   345|         0|            0|            0|  0.00%|        Solution to the system a x = b.  Returned shape is identical to `b`.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    Raises
   348|         0|            0|            0|  0.00%|    ------
   349|         0|            0|            0|  0.00%|    LinAlgError
   350|         0|            0|            0|  0.00%|        If `a` is singular or not square.
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    Notes
   353|         0|            0|            0|  0.00%|    -----
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   356|         0|            0|            0|  0.00%|
   357|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
   358|         0|            0|            0|  0.00%|    details.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|    The solutions are computed using LAPACK routine ``_gesv``.
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    `a` must be square and of full-rank, i.e., all rows (or, equivalently,
   363|         0|            0|            0|  0.00%|    columns) must be linearly independent; if either is not true, use
   364|         0|            0|            0|  0.00%|    `lstsq` for the least-squares best "solution" of the
   365|         0|            0|            0|  0.00%|    system/equation.
   366|         0|            0|            0|  0.00%|
   367|         0|            0|            0|  0.00%|    References
   368|         0|            0|            0|  0.00%|    ----------
   369|         0|            0|            0|  0.00%|    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
   370|         0|            0|            0|  0.00%|           FL, Academic Press, Inc., 1980, pg. 22.
   371|         0|            0|            0|  0.00%|
   372|         0|            0|            0|  0.00%|    Examples
   373|         0|            0|            0|  0.00%|    --------
   374|         0|            0|            0|  0.00%|    Solve the system of equations ``3 * x0 + x1 = 9`` and ``x0 + 2 * x1 = 8``:
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    >>> a = np.array([[3,1], [1,2]])
   377|         0|            0|            0|  0.00%|    >>> b = np.array([9,8])
   378|         0|            0|            0|  0.00%|    >>> x = np.linalg.solve(a, b)
   379|         0|            0|            0|  0.00%|    >>> x
   380|         0|            0|            0|  0.00%|    array([2.,  3.])
   381|         0|            0|            0|  0.00%|
   382|         0|            0|            0|  0.00%|    Check that the solution is correct:
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    >>> np.allclose(np.dot(a, x), b)
   385|         0|            0|            0|  0.00%|    True
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|    """
   388|         0|            0|            0|  0.00%|    a, _ = _makearray(a)
   389|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
   390|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
   391|         0|            0|            0|  0.00%|    b, wrap = _makearray(b)
   392|         0|            0|            0|  0.00%|    t, result_t = _commonType(a, b)
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    # We use the b = (..., M,) logic, only if the number of extra dimensions
   395|         0|            0|            0|  0.00%|    # match exactly
   396|         0|            0|            0|  0.00%|    if b.ndim == a.ndim - 1:
   397|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.solve1
   398|         0|            0|            0|  0.00%|    else:
   399|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.solve
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    signature = 'DD->D' if isComplexType(t) else 'dd->d'
   402|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(_raise_linalgerror_singular)
   403|         0|            0|            0|  0.00%|    r = gufunc(a, b, signature=signature, extobj=extobj)
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|    return wrap(r.astype(result_t, copy=False))
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|def _tensorinv_dispatcher(a, ind=None):
   409|         0|            0|            0|  0.00%|    return (a,)
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|@array_function_dispatch(_tensorinv_dispatcher)
   413|         0|            0|            0|  0.00%|def tensorinv(a, ind=2):
   414|         0|            0|            0|  0.00%|    """
   415|         0|            0|            0|  0.00%|    Compute the 'inverse' of an N-dimensional array.
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|    The result is an inverse for `a` relative to the tensordot operation
   418|         0|            0|            0|  0.00%|    ``tensordot(a, b, ind)``, i. e., up to floating-point accuracy,
   419|         0|            0|            0|  0.00%|    ``tensordot(tensorinv(a), a, ind)`` is the "identity" tensor for the
   420|         0|            0|            0|  0.00%|    tensordot operation.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    Parameters
   423|         0|            0|            0|  0.00%|    ----------
   424|         0|            0|            0|  0.00%|    a : array_like
   425|         0|            0|            0|  0.00%|        Tensor to 'invert'. Its shape must be 'square', i. e.,
   426|         0|            0|            0|  0.00%|        ``prod(a.shape[:ind]) == prod(a.shape[ind:])``.
   427|         0|            0|            0|  0.00%|    ind : int, optional
   428|         0|            0|            0|  0.00%|        Number of first indices that are involved in the inverse sum.
   429|         0|            0|            0|  0.00%|        Must be a positive integer, default is 2.
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    Returns
   432|         0|            0|            0|  0.00%|    -------
   433|         0|            0|            0|  0.00%|    b : ndarray
   434|         0|            0|            0|  0.00%|        `a`'s tensordot inverse, shape ``a.shape[ind:] + a.shape[:ind]``.
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|    Raises
   437|         0|            0|            0|  0.00%|    ------
   438|         0|            0|            0|  0.00%|    LinAlgError
   439|         0|            0|            0|  0.00%|        If `a` is singular or not 'square' (in the above sense).
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|    See Also
   442|         0|            0|            0|  0.00%|    --------
   443|         0|            0|            0|  0.00%|    numpy.tensordot, tensorsolve
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    Examples
   446|         0|            0|            0|  0.00%|    --------
   447|         0|            0|            0|  0.00%|    >>> a = np.eye(4*6)
   448|         0|            0|            0|  0.00%|    >>> a.shape = (4, 6, 8, 3)
   449|         0|            0|            0|  0.00%|    >>> ainv = np.linalg.tensorinv(a, ind=2)
   450|         0|            0|            0|  0.00%|    >>> ainv.shape
   451|         0|            0|            0|  0.00%|    (8, 3, 4, 6)
   452|         0|            0|            0|  0.00%|    >>> b = np.random.randn(4, 6)
   453|         0|            0|            0|  0.00%|    >>> np.allclose(np.tensordot(ainv, b), np.linalg.tensorsolve(a, b))
   454|         0|            0|            0|  0.00%|    True
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    >>> a = np.eye(4*6)
   457|         0|            0|            0|  0.00%|    >>> a.shape = (24, 8, 3)
   458|         0|            0|            0|  0.00%|    >>> ainv = np.linalg.tensorinv(a, ind=1)
   459|         0|            0|            0|  0.00%|    >>> ainv.shape
   460|         0|            0|            0|  0.00%|    (8, 3, 24)
   461|         0|            0|            0|  0.00%|    >>> b = np.random.randn(24)
   462|         0|            0|            0|  0.00%|    >>> np.allclose(np.tensordot(ainv, b, 1), np.linalg.tensorsolve(a, b))
   463|         0|            0|            0|  0.00%|    True
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    """
   466|         0|            0|            0|  0.00%|    a = asarray(a)
   467|         0|            0|            0|  0.00%|    oldshape = a.shape
   468|         0|            0|            0|  0.00%|    prod = 1
   469|         0|            0|            0|  0.00%|    if ind > 0:
   470|         0|            0|            0|  0.00%|        invshape = oldshape[ind:] + oldshape[:ind]
   471|         0|            0|            0|  0.00%|        for k in oldshape[ind:]:
   472|         0|            0|            0|  0.00%|            prod *= k
   473|         0|            0|            0|  0.00%|    else:
   474|         0|            0|            0|  0.00%|        raise ValueError("Invalid ind argument.")
   475|         0|            0|            0|  0.00%|    a = a.reshape(prod, -1)
   476|         0|            0|            0|  0.00%|    ia = inv(a)
   477|         0|            0|            0|  0.00%|    return ia.reshape(*invshape)
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|# Matrix inversion
   481|         0|            0|            0|  0.00%|
   482|      8000|    0.0138817|  1.73521e-06|  0.26%|def _unary_dispatcher(a):
   483|      8000|    0.0187674|  2.34592e-06|  0.35%|    return (a,)
   484|         0|            0|            0|  0.00%|
   485|         0|            0|            0|  0.00%|
   486|      4000|   0.00993371|  2.48343e-06|  0.18%|@array_function_dispatch(_unary_dispatcher)
   487|         0|            0|            0|  0.00%|def inv(a):
   488|         0|            0|            0|  0.00%|    """
   489|         0|            0|            0|  0.00%|    Compute the (multiplicative) inverse of a matrix.
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    Given a square matrix `a`, return the matrix `ainv` satisfying
   492|         0|            0|            0|  0.00%|    ``dot(a, ainv) = dot(ainv, a) = eye(a.shape[0])``.
   493|         0|            0|            0|  0.00%|
   494|         0|            0|            0|  0.00%|    Parameters
   495|         0|            0|            0|  0.00%|    ----------
   496|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
   497|         0|            0|            0|  0.00%|        Matrix to be inverted.
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    Returns
   500|         0|            0|            0|  0.00%|    -------
   501|         0|            0|            0|  0.00%|    ainv : (..., M, M) ndarray or matrix
   502|         0|            0|            0|  0.00%|        (Multiplicative) inverse of the matrix `a`.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    Raises
   505|         0|            0|            0|  0.00%|    ------
   506|         0|            0|            0|  0.00%|    LinAlgError
   507|         0|            0|            0|  0.00%|        If `a` is not square or inversion fails.
   508|         0|            0|            0|  0.00%|
   509|         0|            0|            0|  0.00%|    Notes
   510|         0|            0|            0|  0.00%|    -----
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
   515|         0|            0|            0|  0.00%|    details.
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|    Examples
   518|         0|            0|            0|  0.00%|    --------
   519|         0|            0|            0|  0.00%|    >>> from numpy.linalg import inv
   520|         0|            0|            0|  0.00%|    >>> a = np.array([[1., 2.], [3., 4.]])
   521|         0|            0|            0|  0.00%|    >>> ainv = inv(a)
   522|         0|            0|            0|  0.00%|    >>> np.allclose(np.dot(a, ainv), np.eye(2))
   523|         0|            0|            0|  0.00%|    True
   524|         0|            0|            0|  0.00%|    >>> np.allclose(np.dot(ainv, a), np.eye(2))
   525|         0|            0|            0|  0.00%|    True
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    If a is a matrix object, then the return value is a matrix as well:
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    >>> ainv = inv(np.matrix(a))
   530|         0|            0|            0|  0.00%|    >>> ainv
   531|         0|            0|            0|  0.00%|    matrix([[-2. ,  1. ],
   532|         0|            0|            0|  0.00%|            [ 1.5, -0.5]])
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    Inverses of several matrices can be computed at once:
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    >>> a = np.array([[[1., 2.], [3., 4.]], [[1, 3], [3, 5]]])
   537|         0|            0|            0|  0.00%|    >>> inv(a)
   538|         0|            0|            0|  0.00%|    array([[[-2.  ,  1.  ],
   539|         0|            0|            0|  0.00%|            [ 1.5 , -0.5 ]],
   540|         0|            0|            0|  0.00%|           [[-1.25,  0.75],
   541|         0|            0|            0|  0.00%|            [ 0.75, -0.25]]])
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    """
   544|      4000|    0.0305352|  7.63381e-06|  0.56%|    a, wrap = _makearray(a)
(call)|      4000|    0.0740457|  1.85114e-05|  1.37%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:116 _makearray
   545|      4000|    0.0299206|  7.48014e-06|  0.55%|    _assertRankAtLeast2(a)
(call)|      4000|    0.0343876|   8.5969e-06|  0.64%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:203 _assertRankAtLeast2
   546|      4000|    0.0304723|  7.61807e-06|  0.56%|    _assertNdSquareness(a)
(call)|      4000|    0.0466301|  1.16575e-05|  0.86%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:209 _assertNdSquareness
   547|      4000|    0.0319753|  7.99382e-06|  0.59%|    t, result_t = _commonType(a)
(call)|      4000|     0.204369|  5.10923e-05|  3.78%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:144 _commonType
   548|         0|            0|            0|  0.00%|
   549|      4000|    0.0287142|  7.17854e-06|  0.53%|    signature = 'D->D' if isComplexType(t) else 'd->d'
(call)|      4000|    0.0155616|   3.8904e-06|  0.29%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:121 isComplexType
   550|      4000|    0.0292075|  7.30187e-06|  0.54%|    extobj = get_linalg_error_extobj(_raise_linalgerror_singular)
(call)|      4000|    0.0352502|  8.81255e-06|  0.65%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:111 get_linalg_error_extobj
   551|      4000|     0.045594|  1.13985e-05|  0.84%|    ainv = _umath_linalg.inv(a, signature=signature, extobj=extobj)
   552|      4000|    0.0249763|  6.24406e-06|  0.46%|    return wrap(ainv.astype(result_t, copy=False))
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|def _matrix_power_dispatcher(a, n):
   556|         0|            0|            0|  0.00%|    return (a,)
   557|         0|            0|            0|  0.00%|
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|@array_function_dispatch(_matrix_power_dispatcher)
   560|         0|            0|            0|  0.00%|def matrix_power(a, n):
   561|         0|            0|            0|  0.00%|    """
   562|         0|            0|            0|  0.00%|    Raise a square matrix to the (integer) power `n`.
   563|         0|            0|            0|  0.00%|
   564|         0|            0|            0|  0.00%|    For positive integers `n`, the power is computed by repeated matrix
   565|         0|            0|            0|  0.00%|    squarings and matrix multiplications. If ``n == 0``, the identity matrix
   566|         0|            0|            0|  0.00%|    of the same shape as M is returned. If ``n < 0``, the inverse
   567|         0|            0|            0|  0.00%|    is computed and then raised to the ``abs(n)``.
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    .. note:: Stacks of object matrices are not currently supported.
   570|         0|            0|            0|  0.00%|
   571|         0|            0|            0|  0.00%|    Parameters
   572|         0|            0|            0|  0.00%|    ----------
   573|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
   574|         0|            0|            0|  0.00%|        Matrix to be "powered".
   575|         0|            0|            0|  0.00%|    n : int
   576|         0|            0|            0|  0.00%|        The exponent can be any integer or long integer, positive,
   577|         0|            0|            0|  0.00%|        negative, or zero.
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    Returns
   580|         0|            0|            0|  0.00%|    -------
   581|         0|            0|            0|  0.00%|    a**n : (..., M, M) ndarray or matrix object
   582|         0|            0|            0|  0.00%|        The return value is the same shape and type as `M`;
   583|         0|            0|            0|  0.00%|        if the exponent is positive or zero then the type of the
   584|         0|            0|            0|  0.00%|        elements is the same as those of `M`. If the exponent is
   585|         0|            0|            0|  0.00%|        negative the elements are floating-point.
   586|         0|            0|            0|  0.00%|
   587|         0|            0|            0|  0.00%|    Raises
   588|         0|            0|            0|  0.00%|    ------
   589|         0|            0|            0|  0.00%|    LinAlgError
   590|         0|            0|            0|  0.00%|        For matrices that are not square or that (for negative powers) cannot
   591|         0|            0|            0|  0.00%|        be inverted numerically.
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    Examples
   594|         0|            0|            0|  0.00%|    --------
   595|         0|            0|            0|  0.00%|    >>> from numpy.linalg import matrix_power
   596|         0|            0|            0|  0.00%|    >>> i = np.array([[0, 1], [-1, 0]]) # matrix equiv. of the imaginary unit
   597|         0|            0|            0|  0.00%|    >>> matrix_power(i, 3) # should = -i
   598|         0|            0|            0|  0.00%|    array([[ 0, -1],
   599|         0|            0|            0|  0.00%|           [ 1,  0]])
   600|         0|            0|            0|  0.00%|    >>> matrix_power(i, 0)
   601|         0|            0|            0|  0.00%|    array([[1, 0],
   602|         0|            0|            0|  0.00%|           [0, 1]])
   603|         0|            0|            0|  0.00%|    >>> matrix_power(i, -3) # should = 1/(-i) = i, but w/ f.p. elements
   604|         0|            0|            0|  0.00%|    array([[ 0.,  1.],
   605|         0|            0|            0|  0.00%|           [-1.,  0.]])
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|    Somewhat more sophisticated example
   608|         0|            0|            0|  0.00%|
   609|         0|            0|            0|  0.00%|    >>> q = np.zeros((4, 4))
   610|         0|            0|            0|  0.00%|    >>> q[0:2, 0:2] = -i
   611|         0|            0|            0|  0.00%|    >>> q[2:4, 2:4] = i
   612|         0|            0|            0|  0.00%|    >>> q # one of the three quaternion units not equal to 1
   613|         0|            0|            0|  0.00%|    array([[ 0., -1.,  0.,  0.],
   614|         0|            0|            0|  0.00%|           [ 1.,  0.,  0.,  0.],
   615|         0|            0|            0|  0.00%|           [ 0.,  0.,  0.,  1.],
   616|         0|            0|            0|  0.00%|           [ 0.,  0., -1.,  0.]])
   617|         0|            0|            0|  0.00%|    >>> matrix_power(q, 2) # = -np.eye(4)
   618|         0|            0|            0|  0.00%|    array([[-1.,  0.,  0.,  0.],
   619|         0|            0|            0|  0.00%|           [ 0., -1.,  0.,  0.],
   620|         0|            0|            0|  0.00%|           [ 0.,  0., -1.,  0.],
   621|         0|            0|            0|  0.00%|           [ 0.,  0.,  0., -1.]])
   622|         0|            0|            0|  0.00%|
   623|         0|            0|            0|  0.00%|    """
   624|         0|            0|            0|  0.00%|    a = asanyarray(a)
   625|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
   626|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    try:
   629|         0|            0|            0|  0.00%|        n = operator.index(n)
   630|         0|            0|            0|  0.00%|    except TypeError:
   631|         0|            0|            0|  0.00%|        raise TypeError("exponent must be an integer")
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    # Fall back on dot for object arrays. Object arrays are not supported by
   634|         0|            0|            0|  0.00%|    # the current implementation of matmul using einsum
   635|         0|            0|            0|  0.00%|    if a.dtype != object:
   636|         0|            0|            0|  0.00%|        fmatmul = matmul
   637|         0|            0|            0|  0.00%|    elif a.ndim == 2:
   638|         0|            0|            0|  0.00%|        fmatmul = dot
   639|         0|            0|            0|  0.00%|    else:
   640|         0|            0|            0|  0.00%|        raise NotImplementedError(
   641|         0|            0|            0|  0.00%|            "matrix_power not supported for stacks of object arrays")
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    if n == 0:
   644|         0|            0|            0|  0.00%|        a = empty_like(a)
   645|         0|            0|            0|  0.00%|        a[...] = eye(a.shape[-2], dtype=a.dtype)
   646|         0|            0|            0|  0.00%|        return a
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    elif n < 0:
   649|         0|            0|            0|  0.00%|        a = inv(a)
   650|         0|            0|            0|  0.00%|        n = abs(n)
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|    # short-cuts.
   653|         0|            0|            0|  0.00%|    if n == 1:
   654|         0|            0|            0|  0.00%|        return a
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|    elif n == 2:
   657|         0|            0|            0|  0.00%|        return fmatmul(a, a)
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    elif n == 3:
   660|         0|            0|            0|  0.00%|        return fmatmul(fmatmul(a, a), a)
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|    # Use binary decomposition to reduce the number of matrix multiplications.
   663|         0|            0|            0|  0.00%|    # Here, we iterate over the bits of n, from LSB to MSB, raise `a` to
   664|         0|            0|            0|  0.00%|    # increasing powers of 2, and multiply into the result as needed.
   665|         0|            0|            0|  0.00%|    z = result = None
   666|         0|            0|            0|  0.00%|    while n > 0:
   667|         0|            0|            0|  0.00%|        z = a if z is None else fmatmul(z, z)
   668|         0|            0|            0|  0.00%|        n, bit = divmod(n, 2)
   669|         0|            0|            0|  0.00%|        if bit:
   670|         0|            0|            0|  0.00%|            result = z if result is None else fmatmul(result, z)
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    return result
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|# Cholesky decomposition
   676|         0|            0|            0|  0.00%|
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|@array_function_dispatch(_unary_dispatcher)
   679|         0|            0|            0|  0.00%|def cholesky(a):
   680|         0|            0|            0|  0.00%|    """
   681|         0|            0|            0|  0.00%|    Cholesky decomposition.
   682|         0|            0|            0|  0.00%|
   683|         0|            0|            0|  0.00%|    Return the Cholesky decomposition, `L * L.H`, of the square matrix `a`,
   684|         0|            0|            0|  0.00%|    where `L` is lower-triangular and .H is the conjugate transpose operator
   685|         0|            0|            0|  0.00%|    (which is the ordinary transpose if `a` is real-valued).  `a` must be
   686|         0|            0|            0|  0.00%|    Hermitian (symmetric if real-valued) and positive-definite.  Only `L` is
   687|         0|            0|            0|  0.00%|    actually returned.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    Parameters
   690|         0|            0|            0|  0.00%|    ----------
   691|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
   692|         0|            0|            0|  0.00%|        Hermitian (symmetric if all elements are real), positive-definite
   693|         0|            0|            0|  0.00%|        input matrix.
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    Returns
   696|         0|            0|            0|  0.00%|    -------
   697|         0|            0|            0|  0.00%|    L : (..., M, M) array_like
   698|         0|            0|            0|  0.00%|        Upper or lower-triangular Cholesky factor of `a`.  Returns a
   699|         0|            0|            0|  0.00%|        matrix object if `a` is a matrix object.
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|    Raises
   702|         0|            0|            0|  0.00%|    ------
   703|         0|            0|            0|  0.00%|    LinAlgError
   704|         0|            0|            0|  0.00%|       If the decomposition fails, for example, if `a` is not
   705|         0|            0|            0|  0.00%|       positive-definite.
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    Notes
   708|         0|            0|            0|  0.00%|    -----
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
   713|         0|            0|            0|  0.00%|    details.
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    The Cholesky decomposition is often used as a fast way of solving
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    .. math:: A \\mathbf{x} = \\mathbf{b}
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    (when `A` is both Hermitian/symmetric and positive-definite).
   720|         0|            0|            0|  0.00%|
   721|         0|            0|            0|  0.00%|    First, we solve for :math:`\\mathbf{y}` in
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|    .. math:: L \\mathbf{y} = \\mathbf{b},
   724|         0|            0|            0|  0.00%|
   725|         0|            0|            0|  0.00%|    and then for :math:`\\mathbf{x}` in
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|    .. math:: L.H \\mathbf{x} = \\mathbf{y}.
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|    Examples
   730|         0|            0|            0|  0.00%|    --------
   731|         0|            0|            0|  0.00%|    >>> A = np.array([[1,-2j],[2j,5]])
   732|         0|            0|            0|  0.00%|    >>> A
   733|         0|            0|            0|  0.00%|    array([[ 1.+0.j, -0.-2.j],
   734|         0|            0|            0|  0.00%|           [ 0.+2.j,  5.+0.j]])
   735|         0|            0|            0|  0.00%|    >>> L = np.linalg.cholesky(A)
   736|         0|            0|            0|  0.00%|    >>> L
   737|         0|            0|            0|  0.00%|    array([[1.+0.j, 0.+0.j],
   738|         0|            0|            0|  0.00%|           [0.+2.j, 1.+0.j]])
   739|         0|            0|            0|  0.00%|    >>> np.dot(L, L.T.conj()) # verify that L * L.H = A
   740|         0|            0|            0|  0.00%|    array([[1.+0.j, 0.-2.j],
   741|         0|            0|            0|  0.00%|           [0.+2.j, 5.+0.j]])
   742|         0|            0|            0|  0.00%|    >>> A = [[1,-2j],[2j,5]] # what happens if A is only array_like?
   743|         0|            0|            0|  0.00%|    >>> np.linalg.cholesky(A) # an ndarray object is returned
   744|         0|            0|            0|  0.00%|    array([[1.+0.j, 0.+0.j],
   745|         0|            0|            0|  0.00%|           [0.+2.j, 1.+0.j]])
   746|         0|            0|            0|  0.00%|    >>> # But a matrix object is returned if A is a matrix object
   747|         0|            0|            0|  0.00%|    >>> np.linalg.cholesky(np.matrix(A))
   748|         0|            0|            0|  0.00%|    matrix([[ 1.+0.j,  0.+0.j],
   749|         0|            0|            0|  0.00%|            [ 0.+2.j,  1.+0.j]])
   750|         0|            0|            0|  0.00%|
   751|         0|            0|            0|  0.00%|    """
   752|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(_raise_linalgerror_nonposdef)
   753|         0|            0|            0|  0.00%|    gufunc = _umath_linalg.cholesky_lo
   754|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
   755|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
   756|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
   757|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
   758|         0|            0|            0|  0.00%|    signature = 'D->D' if isComplexType(t) else 'd->d'
   759|         0|            0|            0|  0.00%|    r = gufunc(a, signature=signature, extobj=extobj)
   760|         0|            0|            0|  0.00%|    return wrap(r.astype(result_t, copy=False))
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|# QR decompostion
   764|         0|            0|            0|  0.00%|
   765|         0|            0|            0|  0.00%|def _qr_dispatcher(a, mode=None):
   766|         0|            0|            0|  0.00%|    return (a,)
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|
   769|         0|            0|            0|  0.00%|@array_function_dispatch(_qr_dispatcher)
   770|         0|            0|            0|  0.00%|def qr(a, mode='reduced'):
   771|         0|            0|            0|  0.00%|    """
   772|         0|            0|            0|  0.00%|    Compute the qr factorization of a matrix.
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    Factor the matrix `a` as *qr*, where `q` is orthonormal and `r` is
   775|         0|            0|            0|  0.00%|    upper-triangular.
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|    Parameters
   778|         0|            0|            0|  0.00%|    ----------
   779|         0|            0|            0|  0.00%|    a : array_like, shape (M, N)
   780|         0|            0|            0|  0.00%|        Matrix to be factored.
   781|         0|            0|            0|  0.00%|    mode : {'reduced', 'complete', 'r', 'raw', 'full', 'economic'}, optional
   782|         0|            0|            0|  0.00%|        If K = min(M, N), then
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|        * 'reduced'  : returns q, r with dimensions (M, K), (K, N) (default)
   785|         0|            0|            0|  0.00%|        * 'complete' : returns q, r with dimensions (M, M), (M, N)
   786|         0|            0|            0|  0.00%|        * 'r'        : returns r only with dimensions (K, N)
   787|         0|            0|            0|  0.00%|        * 'raw'      : returns h, tau with dimensions (N, M), (K,)
   788|         0|            0|            0|  0.00%|        * 'full'     : alias of 'reduced', deprecated
   789|         0|            0|            0|  0.00%|        * 'economic' : returns h from 'raw', deprecated.
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|        The options 'reduced', 'complete, and 'raw' are new in numpy 1.8,
   792|         0|            0|            0|  0.00%|        see the notes for more information. The default is 'reduced', and to
   793|         0|            0|            0|  0.00%|        maintain backward compatibility with earlier versions of numpy both
   794|         0|            0|            0|  0.00%|        it and the old default 'full' can be omitted. Note that array h
   795|         0|            0|            0|  0.00%|        returned in 'raw' mode is transposed for calling Fortran. The
   796|         0|            0|            0|  0.00%|        'economic' mode is deprecated.  The modes 'full' and 'economic' may
   797|         0|            0|            0|  0.00%|        be passed using only the first letter for backwards compatibility,
   798|         0|            0|            0|  0.00%|        but all others must be spelled out. See the Notes for more
   799|         0|            0|            0|  0.00%|        explanation.
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|    Returns
   803|         0|            0|            0|  0.00%|    -------
   804|         0|            0|            0|  0.00%|    q : ndarray of float or complex, optional
   805|         0|            0|            0|  0.00%|        A matrix with orthonormal columns. When mode = 'complete' the
   806|         0|            0|            0|  0.00%|        result is an orthogonal/unitary matrix depending on whether or not
   807|         0|            0|            0|  0.00%|        a is real/complex. The determinant may be either +/- 1 in that
   808|         0|            0|            0|  0.00%|        case.
   809|         0|            0|            0|  0.00%|    r : ndarray of float or complex, optional
   810|         0|            0|            0|  0.00%|        The upper-triangular matrix.
   811|         0|            0|            0|  0.00%|    (h, tau) : ndarrays of np.double or np.cdouble, optional
   812|         0|            0|            0|  0.00%|        The array h contains the Householder reflectors that generate q
   813|         0|            0|            0|  0.00%|        along with r. The tau array contains scaling factors for the
   814|         0|            0|            0|  0.00%|        reflectors. In the deprecated  'economic' mode only h is returned.
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|    Raises
   817|         0|            0|            0|  0.00%|    ------
   818|         0|            0|            0|  0.00%|    LinAlgError
   819|         0|            0|            0|  0.00%|        If factoring fails.
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|    Notes
   822|         0|            0|            0|  0.00%|    -----
   823|         0|            0|            0|  0.00%|    This is an interface to the LAPACK routines ``dgeqrf``, ``zgeqrf``,
   824|         0|            0|            0|  0.00%|    ``dorgqr``, and ``zungqr``.
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|    For more information on the qr factorization, see for example:
   827|         0|            0|            0|  0.00%|    https://en.wikipedia.org/wiki/QR_factorization
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    Subclasses of `ndarray` are preserved except for the 'raw' mode. So if
   830|         0|            0|            0|  0.00%|    `a` is of type `matrix`, all the return values will be matrices too.
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|    New 'reduced', 'complete', and 'raw' options for mode were added in
   833|         0|            0|            0|  0.00%|    NumPy 1.8.0 and the old option 'full' was made an alias of 'reduced'.  In
   834|         0|            0|            0|  0.00%|    addition the options 'full' and 'economic' were deprecated.  Because
   835|         0|            0|            0|  0.00%|    'full' was the previous default and 'reduced' is the new default,
   836|         0|            0|            0|  0.00%|    backward compatibility can be maintained by letting `mode` default.
   837|         0|            0|            0|  0.00%|    The 'raw' option was added so that LAPACK routines that can multiply
   838|         0|            0|            0|  0.00%|    arrays by q using the Householder reflectors can be used. Note that in
   839|         0|            0|            0|  0.00%|    this case the returned arrays are of type np.double or np.cdouble and
   840|         0|            0|            0|  0.00%|    the h array is transposed to be FORTRAN compatible.  No routines using
   841|         0|            0|            0|  0.00%|    the 'raw' return are currently exposed by numpy, but some are available
   842|         0|            0|            0|  0.00%|    in lapack_lite and just await the necessary work.
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    Examples
   845|         0|            0|            0|  0.00%|    --------
   846|         0|            0|            0|  0.00%|    >>> a = np.random.randn(9, 6)
   847|         0|            0|            0|  0.00%|    >>> q, r = np.linalg.qr(a)
   848|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(q, r))  # a does equal qr
   849|         0|            0|            0|  0.00%|    True
   850|         0|            0|            0|  0.00%|    >>> r2 = np.linalg.qr(a, mode='r')
   851|         0|            0|            0|  0.00%|    >>> r3 = np.linalg.qr(a, mode='economic')
   852|         0|            0|            0|  0.00%|    >>> np.allclose(r, r2)  # mode='r' returns the same r as mode='full'
   853|         0|            0|            0|  0.00%|    True
   854|         0|            0|            0|  0.00%|    >>> # But only triu parts are guaranteed equal when mode='economic'
   855|         0|            0|            0|  0.00%|    >>> np.allclose(r, np.triu(r3[:6,:6], k=0))
   856|         0|            0|            0|  0.00%|    True
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|    Example illustrating a common use of `qr`: solving of least squares
   859|         0|            0|            0|  0.00%|    problems
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|    What are the least-squares-best `m` and `y0` in ``y = y0 + mx`` for
   862|         0|            0|            0|  0.00%|    the following data: {(0,1), (1,0), (1,2), (2,1)}. (Graph the points
   863|         0|            0|            0|  0.00%|    and you'll see that it should be y0 = 0, m = 1.)  The answer is provided
   864|         0|            0|            0|  0.00%|    by solving the over-determined matrix equation ``Ax = b``, where::
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|      A = array([[0, 1], [1, 1], [1, 1], [2, 1]])
   867|         0|            0|            0|  0.00%|      x = array([[y0], [m]])
   868|         0|            0|            0|  0.00%|      b = array([[1], [0], [2], [1]])
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    If A = qr such that q is orthonormal (which is always possible via
   871|         0|            0|            0|  0.00%|    Gram-Schmidt), then ``x = inv(r) * (q.T) * b``.  (In numpy practice,
   872|         0|            0|            0|  0.00%|    however, we simply use `lstsq`.)
   873|         0|            0|            0|  0.00%|
   874|         0|            0|            0|  0.00%|    >>> A = np.array([[0, 1], [1, 1], [1, 1], [2, 1]])
   875|         0|            0|            0|  0.00%|    >>> A
   876|         0|            0|            0|  0.00%|    array([[0, 1],
   877|         0|            0|            0|  0.00%|           [1, 1],
   878|         0|            0|            0|  0.00%|           [1, 1],
   879|         0|            0|            0|  0.00%|           [2, 1]])
   880|         0|            0|            0|  0.00%|    >>> b = np.array([1, 0, 2, 1])
   881|         0|            0|            0|  0.00%|    >>> q, r = np.linalg.qr(A)
   882|         0|            0|            0|  0.00%|    >>> p = np.dot(q.T, b)
   883|         0|            0|            0|  0.00%|    >>> np.dot(np.linalg.inv(r), p)
   884|         0|            0|            0|  0.00%|    array([  1.1e-16,   1.0e+00])
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|    """
   887|         0|            0|            0|  0.00%|    if mode not in ('reduced', 'complete', 'r', 'raw'):
   888|         0|            0|            0|  0.00%|        if mode in ('f', 'full'):
   889|         0|            0|            0|  0.00%|            # 2013-04-01, 1.8
   890|         0|            0|            0|  0.00%|            msg = "".join((
   891|         0|            0|            0|  0.00%|                    "The 'full' option is deprecated in favor of 'reduced'.\n",
   892|         0|            0|            0|  0.00%|                    "For backward compatibility let mode default."))
   893|         0|            0|            0|  0.00%|            warnings.warn(msg, DeprecationWarning, stacklevel=3)
   894|         0|            0|            0|  0.00%|            mode = 'reduced'
   895|         0|            0|            0|  0.00%|        elif mode in ('e', 'economic'):
   896|         0|            0|            0|  0.00%|            # 2013-04-01, 1.8
   897|         0|            0|            0|  0.00%|            msg = "The 'economic' option is deprecated."
   898|         0|            0|            0|  0.00%|            warnings.warn(msg, DeprecationWarning, stacklevel=3)
   899|         0|            0|            0|  0.00%|            mode = 'economic'
   900|         0|            0|            0|  0.00%|        else:
   901|         0|            0|            0|  0.00%|            raise ValueError("Unrecognized mode '%s'" % mode)
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
   904|         0|            0|            0|  0.00%|    _assertRank2(a)
   905|         0|            0|            0|  0.00%|    m, n = a.shape
   906|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
   907|         0|            0|            0|  0.00%|    a = _fastCopyAndTranspose(t, a)
   908|         0|            0|            0|  0.00%|    a = _to_native_byte_order(a)
   909|         0|            0|            0|  0.00%|    mn = min(m, n)
   910|         0|            0|            0|  0.00%|    tau = zeros((mn,), t)
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|    if isComplexType(t):
   913|         0|            0|            0|  0.00%|        lapack_routine = lapack_lite.zgeqrf
   914|         0|            0|            0|  0.00%|        routine_name = 'zgeqrf'
   915|         0|            0|            0|  0.00%|    else:
   916|         0|            0|            0|  0.00%|        lapack_routine = lapack_lite.dgeqrf
   917|         0|            0|            0|  0.00%|        routine_name = 'dgeqrf'
   918|         0|            0|            0|  0.00%|
   919|         0|            0|            0|  0.00%|    # calculate optimal size of work data 'work'
   920|         0|            0|            0|  0.00%|    lwork = 1
   921|         0|            0|            0|  0.00%|    work = zeros((lwork,), t)
   922|         0|            0|            0|  0.00%|    results = lapack_routine(m, n, a, max(1, m), tau, work, -1, 0)
   923|         0|            0|            0|  0.00%|    if results['info'] != 0:
   924|         0|            0|            0|  0.00%|        raise LinAlgError('%s returns %d' % (routine_name, results['info']))
   925|         0|            0|            0|  0.00%|
   926|         0|            0|            0|  0.00%|    # do qr decomposition
   927|         0|            0|            0|  0.00%|    lwork = max(1, n, int(abs(work[0])))
   928|         0|            0|            0|  0.00%|    work = zeros((lwork,), t)
   929|         0|            0|            0|  0.00%|    results = lapack_routine(m, n, a, max(1, m), tau, work, lwork, 0)
   930|         0|            0|            0|  0.00%|    if results['info'] != 0:
   931|         0|            0|            0|  0.00%|        raise LinAlgError('%s returns %d' % (routine_name, results['info']))
   932|         0|            0|            0|  0.00%|
   933|         0|            0|            0|  0.00%|    # handle modes that don't return q
   934|         0|            0|            0|  0.00%|    if mode == 'r':
   935|         0|            0|            0|  0.00%|        r = _fastCopyAndTranspose(result_t, a[:, :mn])
   936|         0|            0|            0|  0.00%|        return wrap(triu(r))
   937|         0|            0|            0|  0.00%|
   938|         0|            0|            0|  0.00%|    if mode == 'raw':
   939|         0|            0|            0|  0.00%|        return a, tau
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|    if mode == 'economic':
   942|         0|            0|            0|  0.00%|        if t != result_t :
   943|         0|            0|            0|  0.00%|            a = a.astype(result_t, copy=False)
   944|         0|            0|            0|  0.00%|        return wrap(a.T)
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|    #  generate q from a
   947|         0|            0|            0|  0.00%|    if mode == 'complete' and m > n:
   948|         0|            0|            0|  0.00%|        mc = m
   949|         0|            0|            0|  0.00%|        q = empty((m, m), t)
   950|         0|            0|            0|  0.00%|    else:
   951|         0|            0|            0|  0.00%|        mc = mn
   952|         0|            0|            0|  0.00%|        q = empty((n, m), t)
   953|         0|            0|            0|  0.00%|    q[:n] = a
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    if isComplexType(t):
   956|         0|            0|            0|  0.00%|        lapack_routine = lapack_lite.zungqr
   957|         0|            0|            0|  0.00%|        routine_name = 'zungqr'
   958|         0|            0|            0|  0.00%|    else:
   959|         0|            0|            0|  0.00%|        lapack_routine = lapack_lite.dorgqr
   960|         0|            0|            0|  0.00%|        routine_name = 'dorgqr'
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|    # determine optimal lwork
   963|         0|            0|            0|  0.00%|    lwork = 1
   964|         0|            0|            0|  0.00%|    work = zeros((lwork,), t)
   965|         0|            0|            0|  0.00%|    results = lapack_routine(m, mc, mn, q, max(1, m), tau, work, -1, 0)
   966|         0|            0|            0|  0.00%|    if results['info'] != 0:
   967|         0|            0|            0|  0.00%|        raise LinAlgError('%s returns %d' % (routine_name, results['info']))
   968|         0|            0|            0|  0.00%|
   969|         0|            0|            0|  0.00%|    # compute q
   970|         0|            0|            0|  0.00%|    lwork = max(1, n, int(abs(work[0])))
   971|         0|            0|            0|  0.00%|    work = zeros((lwork,), t)
   972|         0|            0|            0|  0.00%|    results = lapack_routine(m, mc, mn, q, max(1, m), tau, work, lwork, 0)
   973|         0|            0|            0|  0.00%|    if results['info'] != 0:
   974|         0|            0|            0|  0.00%|        raise LinAlgError('%s returns %d' % (routine_name, results['info']))
   975|         0|            0|            0|  0.00%|
   976|         0|            0|            0|  0.00%|    q = _fastCopyAndTranspose(result_t, q[:mc])
   977|         0|            0|            0|  0.00%|    r = _fastCopyAndTranspose(result_t, a[:, :mc])
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    return wrap(q), wrap(triu(r))
   980|         0|            0|            0|  0.00%|
   981|         0|            0|            0|  0.00%|
   982|         0|            0|            0|  0.00%|# Eigenvalues
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|@array_function_dispatch(_unary_dispatcher)
   986|         0|            0|            0|  0.00%|def eigvals(a):
   987|         0|            0|            0|  0.00%|    """
   988|         0|            0|            0|  0.00%|    Compute the eigenvalues of a general matrix.
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|    Main difference between `eigvals` and `eig`: the eigenvectors aren't
   991|         0|            0|            0|  0.00%|    returned.
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    Parameters
   994|         0|            0|            0|  0.00%|    ----------
   995|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
   996|         0|            0|            0|  0.00%|        A complex- or real-valued matrix whose eigenvalues will be computed.
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|    Returns
   999|         0|            0|            0|  0.00%|    -------
  1000|         0|            0|            0|  0.00%|    w : (..., M,) ndarray
  1001|         0|            0|            0|  0.00%|        The eigenvalues, each repeated according to its multiplicity.
  1002|         0|            0|            0|  0.00%|        They are not necessarily ordered, nor are they necessarily
  1003|         0|            0|            0|  0.00%|        real for real matrices.
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|    Raises
  1006|         0|            0|            0|  0.00%|    ------
  1007|         0|            0|            0|  0.00%|    LinAlgError
  1008|         0|            0|            0|  0.00%|        If the eigenvalue computation does not converge.
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|    See Also
  1011|         0|            0|            0|  0.00%|    --------
  1012|         0|            0|            0|  0.00%|    eig : eigenvalues and right eigenvectors of general arrays
  1013|         0|            0|            0|  0.00%|    eigvalsh : eigenvalues of real symmetric or complex Hermitian
  1014|         0|            0|            0|  0.00%|               (conjugate symmetric) arrays.
  1015|         0|            0|            0|  0.00%|    eigh : eigenvalues and eigenvectors of real symmetric or complex
  1016|         0|            0|            0|  0.00%|           Hermitian (conjugate symmetric) arrays.
  1017|         0|            0|            0|  0.00%|
  1018|         0|            0|            0|  0.00%|    Notes
  1019|         0|            0|            0|  0.00%|    -----
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  1024|         0|            0|            0|  0.00%|    details.
  1025|         0|            0|            0|  0.00%|
  1026|         0|            0|            0|  0.00%|    This is implemented using the ``_geev`` LAPACK routines which compute
  1027|         0|            0|            0|  0.00%|    the eigenvalues and eigenvectors of general square arrays.
  1028|         0|            0|            0|  0.00%|
  1029|         0|            0|            0|  0.00%|    Examples
  1030|         0|            0|            0|  0.00%|    --------
  1031|         0|            0|            0|  0.00%|    Illustration, using the fact that the eigenvalues of a diagonal matrix
  1032|         0|            0|            0|  0.00%|    are its diagonal elements, that multiplying a matrix on the left
  1033|         0|            0|            0|  0.00%|    by an orthogonal matrix, `Q`, and on the right by `Q.T` (the transpose
  1034|         0|            0|            0|  0.00%|    of `Q`), preserves the eigenvalues of the "middle" matrix.  In other words,
  1035|         0|            0|            0|  0.00%|    if `Q` is orthogonal, then ``Q * A * Q.T`` has the same eigenvalues as
  1036|         0|            0|            0|  0.00%|    ``A``:
  1037|         0|            0|            0|  0.00%|
  1038|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  1039|         0|            0|            0|  0.00%|    >>> x = np.random.random()
  1040|         0|            0|            0|  0.00%|    >>> Q = np.array([[np.cos(x), -np.sin(x)], [np.sin(x), np.cos(x)]])
  1041|         0|            0|            0|  0.00%|    >>> LA.norm(Q[0, :]), LA.norm(Q[1, :]), np.dot(Q[0, :],Q[1, :])
  1042|         0|            0|            0|  0.00%|    (1.0, 1.0, 0.0)
  1043|         0|            0|            0|  0.00%|
  1044|         0|            0|            0|  0.00%|    Now multiply a diagonal matrix by ``Q`` on one side and by ``Q.T`` on the other:
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|    >>> D = np.diag((-1,1))
  1047|         0|            0|            0|  0.00%|    >>> LA.eigvals(D)
  1048|         0|            0|            0|  0.00%|    array([-1.,  1.])
  1049|         0|            0|            0|  0.00%|    >>> A = np.dot(Q, D)
  1050|         0|            0|            0|  0.00%|    >>> A = np.dot(A, Q.T)
  1051|         0|            0|            0|  0.00%|    >>> LA.eigvals(A)
  1052|         0|            0|            0|  0.00%|    array([ 1., -1.]) # random
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|    """
  1055|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1056|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  1057|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
  1058|         0|            0|            0|  0.00%|    _assertFinite(a)
  1059|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(
  1062|         0|            0|            0|  0.00%|        _raise_linalgerror_eigenvalues_nonconvergence)
  1063|         0|            0|            0|  0.00%|    signature = 'D->D' if isComplexType(t) else 'd->D'
  1064|         0|            0|            0|  0.00%|    w = _umath_linalg.eigvals(a, signature=signature, extobj=extobj)
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|    if not isComplexType(t):
  1067|         0|            0|            0|  0.00%|        if all(w.imag == 0):
  1068|         0|            0|            0|  0.00%|            w = w.real
  1069|         0|            0|            0|  0.00%|            result_t = _realType(result_t)
  1070|         0|            0|            0|  0.00%|        else:
  1071|         0|            0|            0|  0.00%|            result_t = _complexType(result_t)
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|    return w.astype(result_t, copy=False)
  1074|         0|            0|            0|  0.00%|
  1075|         0|            0|            0|  0.00%|
  1076|         0|            0|            0|  0.00%|def _eigvalsh_dispatcher(a, UPLO=None):
  1077|         0|            0|            0|  0.00%|    return (a,)
  1078|         0|            0|            0|  0.00%|
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|@array_function_dispatch(_eigvalsh_dispatcher)
  1081|         0|            0|            0|  0.00%|def eigvalsh(a, UPLO='L'):
  1082|         0|            0|            0|  0.00%|    """
  1083|         0|            0|            0|  0.00%|    Compute the eigenvalues of a complex Hermitian or real symmetric matrix.
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|    Main difference from eigh: the eigenvectors are not computed.
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    Parameters
  1088|         0|            0|            0|  0.00%|    ----------
  1089|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
  1090|         0|            0|            0|  0.00%|        A complex- or real-valued matrix whose eigenvalues are to be
  1091|         0|            0|            0|  0.00%|        computed.
  1092|         0|            0|            0|  0.00%|    UPLO : {'L', 'U'}, optional
  1093|         0|            0|            0|  0.00%|        Specifies whether the calculation is done with the lower triangular
  1094|         0|            0|            0|  0.00%|        part of `a` ('L', default) or the upper triangular part ('U').
  1095|         0|            0|            0|  0.00%|        Irrespective of this value only the real parts of the diagonal will
  1096|         0|            0|            0|  0.00%|        be considered in the computation to preserve the notion of a Hermitian
  1097|         0|            0|            0|  0.00%|        matrix. It therefore follows that the imaginary part of the diagonal
  1098|         0|            0|            0|  0.00%|        will always be treated as zero.
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|    Returns
  1101|         0|            0|            0|  0.00%|    -------
  1102|         0|            0|            0|  0.00%|    w : (..., M,) ndarray
  1103|         0|            0|            0|  0.00%|        The eigenvalues in ascending order, each repeated according to
  1104|         0|            0|            0|  0.00%|        its multiplicity.
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|    Raises
  1107|         0|            0|            0|  0.00%|    ------
  1108|         0|            0|            0|  0.00%|    LinAlgError
  1109|         0|            0|            0|  0.00%|        If the eigenvalue computation does not converge.
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|    See Also
  1112|         0|            0|            0|  0.00%|    --------
  1113|         0|            0|            0|  0.00%|    eigh : eigenvalues and eigenvectors of real symmetric or complex Hermitian
  1114|         0|            0|            0|  0.00%|           (conjugate symmetric) arrays.
  1115|         0|            0|            0|  0.00%|    eigvals : eigenvalues of general real or complex arrays.
  1116|         0|            0|            0|  0.00%|    eig : eigenvalues and right eigenvectors of general real or complex
  1117|         0|            0|            0|  0.00%|          arrays.
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    Notes
  1120|         0|            0|            0|  0.00%|    -----
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  1125|         0|            0|            0|  0.00%|    details.
  1126|         0|            0|            0|  0.00%|
  1127|         0|            0|            0|  0.00%|    The eigenvalues are computed using LAPACK routines ``_syevd``, ``_heevd``.
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|    Examples
  1130|         0|            0|            0|  0.00%|    --------
  1131|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  1132|         0|            0|            0|  0.00%|    >>> a = np.array([[1, -2j], [2j, 5]])
  1133|         0|            0|            0|  0.00%|    >>> LA.eigvalsh(a)
  1134|         0|            0|            0|  0.00%|    array([ 0.17157288,  5.82842712]) # may vary
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|    >>> # demonstrate the treatment of the imaginary part of the diagonal
  1137|         0|            0|            0|  0.00%|    >>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
  1138|         0|            0|            0|  0.00%|    >>> a
  1139|         0|            0|            0|  0.00%|    array([[5.+2.j, 9.-2.j],
  1140|         0|            0|            0|  0.00%|           [0.+2.j, 2.-1.j]])
  1141|         0|            0|            0|  0.00%|    >>> # with UPLO='L' this is numerically equivalent to using LA.eigvals()
  1142|         0|            0|            0|  0.00%|    >>> # with:
  1143|         0|            0|            0|  0.00%|    >>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
  1144|         0|            0|            0|  0.00%|    >>> b
  1145|         0|            0|            0|  0.00%|    array([[5.+0.j, 0.-2.j],
  1146|         0|            0|            0|  0.00%|           [0.+2.j, 2.+0.j]])
  1147|         0|            0|            0|  0.00%|    >>> wa = LA.eigvalsh(a)
  1148|         0|            0|            0|  0.00%|    >>> wb = LA.eigvals(b)
  1149|         0|            0|            0|  0.00%|    >>> wa; wb
  1150|         0|            0|            0|  0.00%|    array([1., 6.])
  1151|         0|            0|            0|  0.00%|    array([6.+0.j, 1.+0.j])
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|    """
  1154|         0|            0|            0|  0.00%|    UPLO = UPLO.upper()
  1155|         0|            0|            0|  0.00%|    if UPLO not in ('L', 'U'):
  1156|         0|            0|            0|  0.00%|        raise ValueError("UPLO argument must be 'L' or 'U'")
  1157|         0|            0|            0|  0.00%|
  1158|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(
  1159|         0|            0|            0|  0.00%|        _raise_linalgerror_eigenvalues_nonconvergence)
  1160|         0|            0|            0|  0.00%|    if UPLO == 'L':
  1161|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.eigvalsh_lo
  1162|         0|            0|            0|  0.00%|    else:
  1163|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.eigvalsh_up
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1166|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  1167|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
  1168|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1169|         0|            0|            0|  0.00%|    signature = 'D->d' if isComplexType(t) else 'd->d'
  1170|         0|            0|            0|  0.00%|    w = gufunc(a, signature=signature, extobj=extobj)
  1171|         0|            0|            0|  0.00%|    return w.astype(_realType(result_t), copy=False)
  1172|         0|            0|            0|  0.00%|
  1173|         0|            0|            0|  0.00%|def _convertarray(a):
  1174|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1175|         0|            0|            0|  0.00%|    a = _fastCT(a.astype(t))
  1176|         0|            0|            0|  0.00%|    return a, t, result_t
  1177|         0|            0|            0|  0.00%|
  1178|         0|            0|            0|  0.00%|
  1179|         0|            0|            0|  0.00%|# Eigenvectors
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|@array_function_dispatch(_unary_dispatcher)
  1183|         0|            0|            0|  0.00%|def eig(a):
  1184|         0|            0|            0|  0.00%|    """
  1185|         0|            0|            0|  0.00%|    Compute the eigenvalues and right eigenvectors of a square array.
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|    Parameters
  1188|         0|            0|            0|  0.00%|    ----------
  1189|         0|            0|            0|  0.00%|    a : (..., M, M) array
  1190|         0|            0|            0|  0.00%|        Matrices for which the eigenvalues and right eigenvectors will
  1191|         0|            0|            0|  0.00%|        be computed
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    Returns
  1194|         0|            0|            0|  0.00%|    -------
  1195|         0|            0|            0|  0.00%|    w : (..., M) array
  1196|         0|            0|            0|  0.00%|        The eigenvalues, each repeated according to its multiplicity.
  1197|         0|            0|            0|  0.00%|        The eigenvalues are not necessarily ordered. The resulting
  1198|         0|            0|            0|  0.00%|        array will be of complex type, unless the imaginary part is
  1199|         0|            0|            0|  0.00%|        zero in which case it will be cast to a real type. When `a`
  1200|         0|            0|            0|  0.00%|        is real the resulting eigenvalues will be real (0 imaginary
  1201|         0|            0|            0|  0.00%|        part) or occur in conjugate pairs
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|    v : (..., M, M) array
  1204|         0|            0|            0|  0.00%|        The normalized (unit "length") eigenvectors, such that the
  1205|         0|            0|            0|  0.00%|        column ``v[:,i]`` is the eigenvector corresponding to the
  1206|         0|            0|            0|  0.00%|        eigenvalue ``w[i]``.
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|    Raises
  1209|         0|            0|            0|  0.00%|    ------
  1210|         0|            0|            0|  0.00%|    LinAlgError
  1211|         0|            0|            0|  0.00%|        If the eigenvalue computation does not converge.
  1212|         0|            0|            0|  0.00%|
  1213|         0|            0|            0|  0.00%|    See Also
  1214|         0|            0|            0|  0.00%|    --------
  1215|         0|            0|            0|  0.00%|    eigvals : eigenvalues of a non-symmetric array.
  1216|         0|            0|            0|  0.00%|
  1217|         0|            0|            0|  0.00%|    eigh : eigenvalues and eigenvectors of a real symmetric or complex
  1218|         0|            0|            0|  0.00%|           Hermitian (conjugate symmetric) array.
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|    eigvalsh : eigenvalues of a real symmetric or complex Hermitian
  1221|         0|            0|            0|  0.00%|               (conjugate symmetric) array.
  1222|         0|            0|            0|  0.00%|
  1223|         0|            0|            0|  0.00%|    Notes
  1224|         0|            0|            0|  0.00%|    -----
  1225|         0|            0|            0|  0.00%|
  1226|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  1229|         0|            0|            0|  0.00%|    details.
  1230|         0|            0|            0|  0.00%|
  1231|         0|            0|            0|  0.00%|    This is implemented using the ``_geev`` LAPACK routines which compute
  1232|         0|            0|            0|  0.00%|    the eigenvalues and eigenvectors of general square arrays.
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|    The number `w` is an eigenvalue of `a` if there exists a vector
  1235|         0|            0|            0|  0.00%|    `v` such that ``dot(a,v) = w * v``. Thus, the arrays `a`, `w`, and
  1236|         0|            0|            0|  0.00%|    `v` satisfy the equations ``dot(a[:,:], v[:,i]) = w[i] * v[:,i]``
  1237|         0|            0|            0|  0.00%|    for :math:`i \\in \\{0,...,M-1\\}`.
  1238|         0|            0|            0|  0.00%|
  1239|         0|            0|            0|  0.00%|    The array `v` of eigenvectors may not be of maximum rank, that is, some
  1240|         0|            0|            0|  0.00%|    of the columns may be linearly dependent, although round-off error may
  1241|         0|            0|            0|  0.00%|    obscure that fact. If the eigenvalues are all different, then theoretically
  1242|         0|            0|            0|  0.00%|    the eigenvectors are linearly independent. Likewise, the (complex-valued)
  1243|         0|            0|            0|  0.00%|    matrix of eigenvectors `v` is unitary if the matrix `a` is normal, i.e.,
  1244|         0|            0|            0|  0.00%|    if ``dot(a, a.H) = dot(a.H, a)``, where `a.H` denotes the conjugate
  1245|         0|            0|            0|  0.00%|    transpose of `a`.
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|    Finally, it is emphasized that `v` consists of the *right* (as in
  1248|         0|            0|            0|  0.00%|    right-hand side) eigenvectors of `a`.  A vector `y` satisfying
  1249|         0|            0|            0|  0.00%|    ``dot(y.T, a) = z * y.T`` for some number `z` is called a *left*
  1250|         0|            0|            0|  0.00%|    eigenvector of `a`, and, in general, the left and right eigenvectors
  1251|         0|            0|            0|  0.00%|    of a matrix are not necessarily the (perhaps conjugate) transposes
  1252|         0|            0|            0|  0.00%|    of each other.
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|    References
  1255|         0|            0|            0|  0.00%|    ----------
  1256|         0|            0|            0|  0.00%|    G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando, FL,
  1257|         0|            0|            0|  0.00%|    Academic Press, Inc., 1980, Various pp.
  1258|         0|            0|            0|  0.00%|
  1259|         0|            0|            0|  0.00%|    Examples
  1260|         0|            0|            0|  0.00%|    --------
  1261|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|    (Almost) trivial example with real e-values and e-vectors.
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|    >>> w, v = LA.eig(np.diag((1, 2, 3)))
  1266|         0|            0|            0|  0.00%|    >>> w; v
  1267|         0|            0|            0|  0.00%|    array([1., 2., 3.])
  1268|         0|            0|            0|  0.00%|    array([[1., 0., 0.],
  1269|         0|            0|            0|  0.00%|           [0., 1., 0.],
  1270|         0|            0|            0|  0.00%|           [0., 0., 1.]])
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|    Real matrix possessing complex e-values and e-vectors; note that the
  1273|         0|            0|            0|  0.00%|    e-values are complex conjugates of each other.
  1274|         0|            0|            0|  0.00%|
  1275|         0|            0|            0|  0.00%|    >>> w, v = LA.eig(np.array([[1, -1], [1, 1]]))
  1276|         0|            0|            0|  0.00%|    >>> w; v
  1277|         0|            0|            0|  0.00%|    array([1.+1.j, 1.-1.j])
  1278|         0|            0|            0|  0.00%|    array([[0.70710678+0.j        , 0.70710678-0.j        ],
  1279|         0|            0|            0|  0.00%|           [0.        -0.70710678j, 0.        +0.70710678j]])
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|    Complex-valued matrix with real e-values (but complex-valued e-vectors);
  1282|         0|            0|            0|  0.00%|    note that ``a.conj().T == a``, i.e., `a` is Hermitian.
  1283|         0|            0|            0|  0.00%|
  1284|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 1j], [-1j, 1]])
  1285|         0|            0|            0|  0.00%|    >>> w, v = LA.eig(a)
  1286|         0|            0|            0|  0.00%|    >>> w; v
  1287|         0|            0|            0|  0.00%|    array([2.+0.j, 0.+0.j])
  1288|         0|            0|            0|  0.00%|    array([[ 0.        +0.70710678j,  0.70710678+0.j        ], # may vary
  1289|         0|            0|            0|  0.00%|           [ 0.70710678+0.j        , -0.        +0.70710678j]])
  1290|         0|            0|            0|  0.00%|
  1291|         0|            0|            0|  0.00%|    Be careful about round-off error!
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|    >>> a = np.array([[1 + 1e-9, 0], [0, 1 - 1e-9]])
  1294|         0|            0|            0|  0.00%|    >>> # Theor. e-values are 1 +/- 1e-9
  1295|         0|            0|            0|  0.00%|    >>> w, v = LA.eig(a)
  1296|         0|            0|            0|  0.00%|    >>> w; v
  1297|         0|            0|            0|  0.00%|    array([1., 1.])
  1298|         0|            0|            0|  0.00%|    array([[1., 0.],
  1299|         0|            0|            0|  0.00%|           [0., 1.]])
  1300|         0|            0|            0|  0.00%|
  1301|         0|            0|            0|  0.00%|    """
  1302|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1303|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  1304|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
  1305|         0|            0|            0|  0.00%|    _assertFinite(a)
  1306|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1307|         0|            0|            0|  0.00%|
  1308|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(
  1309|         0|            0|            0|  0.00%|        _raise_linalgerror_eigenvalues_nonconvergence)
  1310|         0|            0|            0|  0.00%|    signature = 'D->DD' if isComplexType(t) else 'd->DD'
  1311|         0|            0|            0|  0.00%|    w, vt = _umath_linalg.eig(a, signature=signature, extobj=extobj)
  1312|         0|            0|            0|  0.00%|
  1313|         0|            0|            0|  0.00%|    if not isComplexType(t) and all(w.imag == 0.0):
  1314|         0|            0|            0|  0.00%|        w = w.real
  1315|         0|            0|            0|  0.00%|        vt = vt.real
  1316|         0|            0|            0|  0.00%|        result_t = _realType(result_t)
  1317|         0|            0|            0|  0.00%|    else:
  1318|         0|            0|            0|  0.00%|        result_t = _complexType(result_t)
  1319|         0|            0|            0|  0.00%|
  1320|         0|            0|            0|  0.00%|    vt = vt.astype(result_t, copy=False)
  1321|         0|            0|            0|  0.00%|    return w.astype(result_t, copy=False), wrap(vt)
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|@array_function_dispatch(_eigvalsh_dispatcher)
  1325|         0|            0|            0|  0.00%|def eigh(a, UPLO='L'):
  1326|         0|            0|            0|  0.00%|    """
  1327|         0|            0|            0|  0.00%|    Return the eigenvalues and eigenvectors of a complex Hermitian
  1328|         0|            0|            0|  0.00%|    (conjugate symmetric) or a real symmetric matrix.
  1329|         0|            0|            0|  0.00%|
  1330|         0|            0|            0|  0.00%|    Returns two objects, a 1-D array containing the eigenvalues of `a`, and
  1331|         0|            0|            0|  0.00%|    a 2-D square array or matrix (depending on the input type) of the
  1332|         0|            0|            0|  0.00%|    corresponding eigenvectors (in columns).
  1333|         0|            0|            0|  0.00%|
  1334|         0|            0|            0|  0.00%|    Parameters
  1335|         0|            0|            0|  0.00%|    ----------
  1336|         0|            0|            0|  0.00%|    a : (..., M, M) array
  1337|         0|            0|            0|  0.00%|        Hermitian or real symmetric matrices whose eigenvalues and
  1338|         0|            0|            0|  0.00%|        eigenvectors are to be computed.
  1339|         0|            0|            0|  0.00%|    UPLO : {'L', 'U'}, optional
  1340|         0|            0|            0|  0.00%|        Specifies whether the calculation is done with the lower triangular
  1341|         0|            0|            0|  0.00%|        part of `a` ('L', default) or the upper triangular part ('U').
  1342|         0|            0|            0|  0.00%|        Irrespective of this value only the real parts of the diagonal will
  1343|         0|            0|            0|  0.00%|        be considered in the computation to preserve the notion of a Hermitian
  1344|         0|            0|            0|  0.00%|        matrix. It therefore follows that the imaginary part of the diagonal
  1345|         0|            0|            0|  0.00%|        will always be treated as zero.
  1346|         0|            0|            0|  0.00%|
  1347|         0|            0|            0|  0.00%|    Returns
  1348|         0|            0|            0|  0.00%|    -------
  1349|         0|            0|            0|  0.00%|    w : (..., M) ndarray
  1350|         0|            0|            0|  0.00%|        The eigenvalues in ascending order, each repeated according to
  1351|         0|            0|            0|  0.00%|        its multiplicity.
  1352|         0|            0|            0|  0.00%|    v : {(..., M, M) ndarray, (..., M, M) matrix}
  1353|         0|            0|            0|  0.00%|        The column ``v[:, i]`` is the normalized eigenvector corresponding
  1354|         0|            0|            0|  0.00%|        to the eigenvalue ``w[i]``.  Will return a matrix object if `a` is
  1355|         0|            0|            0|  0.00%|        a matrix object.
  1356|         0|            0|            0|  0.00%|
  1357|         0|            0|            0|  0.00%|    Raises
  1358|         0|            0|            0|  0.00%|    ------
  1359|         0|            0|            0|  0.00%|    LinAlgError
  1360|         0|            0|            0|  0.00%|        If the eigenvalue computation does not converge.
  1361|         0|            0|            0|  0.00%|
  1362|         0|            0|            0|  0.00%|    See Also
  1363|         0|            0|            0|  0.00%|    --------
  1364|         0|            0|            0|  0.00%|    eigvalsh : eigenvalues of real symmetric or complex Hermitian
  1365|         0|            0|            0|  0.00%|               (conjugate symmetric) arrays.
  1366|         0|            0|            0|  0.00%|    eig : eigenvalues and right eigenvectors for non-symmetric arrays.
  1367|         0|            0|            0|  0.00%|    eigvals : eigenvalues of non-symmetric arrays.
  1368|         0|            0|            0|  0.00%|
  1369|         0|            0|            0|  0.00%|    Notes
  1370|         0|            0|            0|  0.00%|    -----
  1371|         0|            0|            0|  0.00%|
  1372|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  1375|         0|            0|            0|  0.00%|    details.
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|    The eigenvalues/eigenvectors are computed using LAPACK routines ``_syevd``,
  1378|         0|            0|            0|  0.00%|    ``_heevd``.
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|    The eigenvalues of real symmetric or complex Hermitian matrices are
  1381|         0|            0|            0|  0.00%|    always real. [1]_ The array `v` of (column) eigenvectors is unitary
  1382|         0|            0|            0|  0.00%|    and `a`, `w`, and `v` satisfy the equations
  1383|         0|            0|            0|  0.00%|    ``dot(a, v[:, i]) = w[i] * v[:, i]``.
  1384|         0|            0|            0|  0.00%|
  1385|         0|            0|            0|  0.00%|    References
  1386|         0|            0|            0|  0.00%|    ----------
  1387|         0|            0|            0|  0.00%|    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
  1388|         0|            0|            0|  0.00%|           FL, Academic Press, Inc., 1980, pg. 222.
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|    Examples
  1391|         0|            0|            0|  0.00%|    --------
  1392|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  1393|         0|            0|            0|  0.00%|    >>> a = np.array([[1, -2j], [2j, 5]])
  1394|         0|            0|            0|  0.00%|    >>> a
  1395|         0|            0|            0|  0.00%|    array([[ 1.+0.j, -0.-2.j],
  1396|         0|            0|            0|  0.00%|           [ 0.+2.j,  5.+0.j]])
  1397|         0|            0|            0|  0.00%|    >>> w, v = LA.eigh(a)
  1398|         0|            0|            0|  0.00%|    >>> w; v
  1399|         0|            0|            0|  0.00%|    array([0.17157288, 5.82842712])
  1400|         0|            0|            0|  0.00%|    array([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
  1401|         0|            0|            0|  0.00%|           [ 0.        +0.38268343j,  0.        -0.92387953j]])
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|    >>> np.dot(a, v[:, 0]) - w[0] * v[:, 0] # verify 1st e-val/vec pair
  1404|         0|            0|            0|  0.00%|    array([5.55111512e-17+0.0000000e+00j, 0.00000000e+00+1.2490009e-16j])
  1405|         0|            0|            0|  0.00%|    >>> np.dot(a, v[:, 1]) - w[1] * v[:, 1] # verify 2nd e-val/vec pair
  1406|         0|            0|            0|  0.00%|    array([0.+0.j, 0.+0.j])
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|    >>> A = np.matrix(a) # what happens if input is a matrix object
  1409|         0|            0|            0|  0.00%|    >>> A
  1410|         0|            0|            0|  0.00%|    matrix([[ 1.+0.j, -0.-2.j],
  1411|         0|            0|            0|  0.00%|            [ 0.+2.j,  5.+0.j]])
  1412|         0|            0|            0|  0.00%|    >>> w, v = LA.eigh(A)
  1413|         0|            0|            0|  0.00%|    >>> w; v
  1414|         0|            0|            0|  0.00%|    array([0.17157288, 5.82842712])
  1415|         0|            0|            0|  0.00%|    matrix([[-0.92387953+0.j        , -0.38268343+0.j        ], # may vary
  1416|         0|            0|            0|  0.00%|            [ 0.        +0.38268343j,  0.        -0.92387953j]])
  1417|         0|            0|            0|  0.00%|
  1418|         0|            0|            0|  0.00%|    >>> # demonstrate the treatment of the imaginary part of the diagonal
  1419|         0|            0|            0|  0.00%|    >>> a = np.array([[5+2j, 9-2j], [0+2j, 2-1j]])
  1420|         0|            0|            0|  0.00%|    >>> a
  1421|         0|            0|            0|  0.00%|    array([[5.+2.j, 9.-2.j],
  1422|         0|            0|            0|  0.00%|           [0.+2.j, 2.-1.j]])
  1423|         0|            0|            0|  0.00%|    >>> # with UPLO='L' this is numerically equivalent to using LA.eig() with:
  1424|         0|            0|            0|  0.00%|    >>> b = np.array([[5.+0.j, 0.-2.j], [0.+2.j, 2.-0.j]])
  1425|         0|            0|            0|  0.00%|    >>> b
  1426|         0|            0|            0|  0.00%|    array([[5.+0.j, 0.-2.j],
  1427|         0|            0|            0|  0.00%|           [0.+2.j, 2.+0.j]])
  1428|         0|            0|            0|  0.00%|    >>> wa, va = LA.eigh(a)
  1429|         0|            0|            0|  0.00%|    >>> wb, vb = LA.eig(b)
  1430|         0|            0|            0|  0.00%|    >>> wa; wb
  1431|         0|            0|            0|  0.00%|    array([1., 6.])
  1432|         0|            0|            0|  0.00%|    array([6.+0.j, 1.+0.j])
  1433|         0|            0|            0|  0.00%|    >>> va; vb
  1434|         0|            0|            0|  0.00%|    array([[-0.4472136 +0.j        , -0.89442719+0.j        ], # may vary
  1435|         0|            0|            0|  0.00%|           [ 0.        +0.89442719j,  0.        -0.4472136j ]])
  1436|         0|            0|            0|  0.00%|    array([[ 0.89442719+0.j       , -0.        +0.4472136j],
  1437|         0|            0|            0|  0.00%|           [-0.        +0.4472136j,  0.89442719+0.j       ]])
  1438|         0|            0|            0|  0.00%|    """
  1439|         0|            0|            0|  0.00%|    UPLO = UPLO.upper()
  1440|         0|            0|            0|  0.00%|    if UPLO not in ('L', 'U'):
  1441|         0|            0|            0|  0.00%|        raise ValueError("UPLO argument must be 'L' or 'U'")
  1442|         0|            0|            0|  0.00%|
  1443|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1444|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  1445|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
  1446|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1447|         0|            0|            0|  0.00%|
  1448|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(
  1449|         0|            0|            0|  0.00%|        _raise_linalgerror_eigenvalues_nonconvergence)
  1450|         0|            0|            0|  0.00%|    if UPLO == 'L':
  1451|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.eigh_lo
  1452|         0|            0|            0|  0.00%|    else:
  1453|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.eigh_up
  1454|         0|            0|            0|  0.00%|
  1455|         0|            0|            0|  0.00%|    signature = 'D->dD' if isComplexType(t) else 'd->dd'
  1456|         0|            0|            0|  0.00%|    w, vt = gufunc(a, signature=signature, extobj=extobj)
  1457|         0|            0|            0|  0.00%|    w = w.astype(_realType(result_t), copy=False)
  1458|         0|            0|            0|  0.00%|    vt = vt.astype(result_t, copy=False)
  1459|         0|            0|            0|  0.00%|    return w, wrap(vt)
  1460|         0|            0|            0|  0.00%|
  1461|         0|            0|            0|  0.00%|
  1462|         0|            0|            0|  0.00%|# Singular value decomposition
  1463|         0|            0|            0|  0.00%|
  1464|         0|            0|            0|  0.00%|def _svd_dispatcher(a, full_matrices=None, compute_uv=None, hermitian=None):
  1465|         0|            0|            0|  0.00%|    return (a,)
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|
  1468|         0|            0|            0|  0.00%|@array_function_dispatch(_svd_dispatcher)
  1469|         0|            0|            0|  0.00%|def svd(a, full_matrices=True, compute_uv=True, hermitian=False):
  1470|         0|            0|            0|  0.00%|    """
  1471|         0|            0|            0|  0.00%|    Singular Value Decomposition.
  1472|         0|            0|            0|  0.00%|
  1473|         0|            0|            0|  0.00%|    When `a` is a 2D array, it is factorized as ``u @ np.diag(s) @ vh
  1474|         0|            0|            0|  0.00%|    = (u * s) @ vh``, where `u` and `vh` are 2D unitary arrays and `s` is a 1D
  1475|         0|            0|            0|  0.00%|    array of `a`'s singular values. When `a` is higher-dimensional, SVD is
  1476|         0|            0|            0|  0.00%|    applied in stacked mode as explained below.
  1477|         0|            0|            0|  0.00%|
  1478|         0|            0|            0|  0.00%|    Parameters
  1479|         0|            0|            0|  0.00%|    ----------
  1480|         0|            0|            0|  0.00%|    a : (..., M, N) array_like
  1481|         0|            0|            0|  0.00%|        A real or complex array with ``a.ndim >= 2``.
  1482|         0|            0|            0|  0.00%|    full_matrices : bool, optional
  1483|         0|            0|            0|  0.00%|        If True (default), `u` and `vh` have the shapes ``(..., M, M)`` and
  1484|         0|            0|            0|  0.00%|        ``(..., N, N)``, respectively.  Otherwise, the shapes are
  1485|         0|            0|            0|  0.00%|        ``(..., M, K)`` and ``(..., K, N)``, respectively, where
  1486|         0|            0|            0|  0.00%|        ``K = min(M, N)``.
  1487|         0|            0|            0|  0.00%|    compute_uv : bool, optional
  1488|         0|            0|            0|  0.00%|        Whether or not to compute `u` and `vh` in addition to `s`.  True
  1489|         0|            0|            0|  0.00%|        by default.
  1490|         0|            0|            0|  0.00%|    hermitian : bool, optional
  1491|         0|            0|            0|  0.00%|        If True, `a` is assumed to be Hermitian (symmetric if real-valued),
  1492|         0|            0|            0|  0.00%|        enabling a more efficient method for finding singular values.
  1493|         0|            0|            0|  0.00%|        Defaults to False.
  1494|         0|            0|            0|  0.00%|
  1495|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1496|         0|            0|            0|  0.00%|
  1497|         0|            0|            0|  0.00%|    Returns
  1498|         0|            0|            0|  0.00%|    -------
  1499|         0|            0|            0|  0.00%|    u : { (..., M, M), (..., M, K) } array
  1500|         0|            0|            0|  0.00%|        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
  1501|         0|            0|            0|  0.00%|        size as those of the input `a`. The size of the last two dimensions
  1502|         0|            0|            0|  0.00%|        depends on the value of `full_matrices`. Only returned when
  1503|         0|            0|            0|  0.00%|        `compute_uv` is True.
  1504|         0|            0|            0|  0.00%|    s : (..., K) array
  1505|         0|            0|            0|  0.00%|        Vector(s) with the singular values, within each vector sorted in
  1506|         0|            0|            0|  0.00%|        descending order. The first ``a.ndim - 2`` dimensions have the same
  1507|         0|            0|            0|  0.00%|        size as those of the input `a`.
  1508|         0|            0|            0|  0.00%|    vh : { (..., N, N), (..., K, N) } array
  1509|         0|            0|            0|  0.00%|        Unitary array(s). The first ``a.ndim - 2`` dimensions have the same
  1510|         0|            0|            0|  0.00%|        size as those of the input `a`. The size of the last two dimensions
  1511|         0|            0|            0|  0.00%|        depends on the value of `full_matrices`. Only returned when
  1512|         0|            0|            0|  0.00%|        `compute_uv` is True.
  1513|         0|            0|            0|  0.00%|
  1514|         0|            0|            0|  0.00%|    Raises
  1515|         0|            0|            0|  0.00%|    ------
  1516|         0|            0|            0|  0.00%|    LinAlgError
  1517|         0|            0|            0|  0.00%|        If SVD computation does not converge.
  1518|         0|            0|            0|  0.00%|
  1519|         0|            0|            0|  0.00%|    Notes
  1520|         0|            0|            0|  0.00%|    -----
  1521|         0|            0|            0|  0.00%|
  1522|         0|            0|            0|  0.00%|    .. versionchanged:: 1.8.0
  1523|         0|            0|            0|  0.00%|       Broadcasting rules apply, see the `numpy.linalg` documentation for
  1524|         0|            0|            0|  0.00%|       details.
  1525|         0|            0|            0|  0.00%|
  1526|         0|            0|            0|  0.00%|    The decomposition is performed using LAPACK routine ``_gesdd``.
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|    SVD is usually described for the factorization of a 2D matrix :math:`A`.
  1529|         0|            0|            0|  0.00%|    The higher-dimensional case will be discussed below. In the 2D case, SVD is
  1530|         0|            0|            0|  0.00%|    written as :math:`A = U S V^H`, where :math:`A = a`, :math:`U= u`,
  1531|         0|            0|            0|  0.00%|    :math:`S= \\mathtt{np.diag}(s)` and :math:`V^H = vh`. The 1D array `s`
  1532|         0|            0|            0|  0.00%|    contains the singular values of `a` and `u` and `vh` are unitary. The rows
  1533|         0|            0|            0|  0.00%|    of `vh` are the eigenvectors of :math:`A^H A` and the columns of `u` are
  1534|         0|            0|            0|  0.00%|    the eigenvectors of :math:`A A^H`. In both cases the corresponding
  1535|         0|            0|            0|  0.00%|    (possibly non-zero) eigenvalues are given by ``s**2``.
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|    If `a` has more than two dimensions, then broadcasting rules apply, as
  1538|         0|            0|            0|  0.00%|    explained in :ref:`routines.linalg-broadcasting`. This means that SVD is
  1539|         0|            0|            0|  0.00%|    working in "stacked" mode: it iterates over all indices of the first
  1540|         0|            0|            0|  0.00%|    ``a.ndim - 2`` dimensions and for each combination SVD is applied to the
  1541|         0|            0|            0|  0.00%|    last two indices. The matrix `a` can be reconstructed from the
  1542|         0|            0|            0|  0.00%|    decomposition with either ``(u * s[..., None, :]) @ vh`` or
  1543|         0|            0|            0|  0.00%|    ``u @ (s[..., None] * vh)``. (The ``@`` operator can be replaced by the
  1544|         0|            0|            0|  0.00%|    function ``np.matmul`` for python versions below 3.5.)
  1545|         0|            0|            0|  0.00%|
  1546|         0|            0|            0|  0.00%|    If `a` is a ``matrix`` object (as opposed to an ``ndarray``), then so are
  1547|         0|            0|            0|  0.00%|    all the return values.
  1548|         0|            0|            0|  0.00%|
  1549|         0|            0|            0|  0.00%|    Examples
  1550|         0|            0|            0|  0.00%|    --------
  1551|         0|            0|            0|  0.00%|    >>> a = np.random.randn(9, 6) + 1j*np.random.randn(9, 6)
  1552|         0|            0|            0|  0.00%|    >>> b = np.random.randn(2, 7, 8, 3) + 1j*np.random.randn(2, 7, 8, 3)
  1553|         0|            0|            0|  0.00%|
  1554|         0|            0|            0|  0.00%|    Reconstruction based on full SVD, 2D case:
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|    >>> u, s, vh = np.linalg.svd(a, full_matrices=True)
  1557|         0|            0|            0|  0.00%|    >>> u.shape, s.shape, vh.shape
  1558|         0|            0|            0|  0.00%|    ((9, 9), (6,), (6, 6))
  1559|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(u[:, :6] * s, vh))
  1560|         0|            0|            0|  0.00%|    True
  1561|         0|            0|            0|  0.00%|    >>> smat = np.zeros((9, 6), dtype=complex)
  1562|         0|            0|            0|  0.00%|    >>> smat[:6, :6] = np.diag(s)
  1563|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
  1564|         0|            0|            0|  0.00%|    True
  1565|         0|            0|            0|  0.00%|
  1566|         0|            0|            0|  0.00%|    Reconstruction based on reduced SVD, 2D case:
  1567|         0|            0|            0|  0.00%|
  1568|         0|            0|            0|  0.00%|    >>> u, s, vh = np.linalg.svd(a, full_matrices=False)
  1569|         0|            0|            0|  0.00%|    >>> u.shape, s.shape, vh.shape
  1570|         0|            0|            0|  0.00%|    ((9, 6), (6,), (6, 6))
  1571|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(u * s, vh))
  1572|         0|            0|            0|  0.00%|    True
  1573|         0|            0|            0|  0.00%|    >>> smat = np.diag(s)
  1574|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(u, np.dot(smat, vh)))
  1575|         0|            0|            0|  0.00%|    True
  1576|         0|            0|            0|  0.00%|
  1577|         0|            0|            0|  0.00%|    Reconstruction based on full SVD, 4D case:
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|    >>> u, s, vh = np.linalg.svd(b, full_matrices=True)
  1580|         0|            0|            0|  0.00%|    >>> u.shape, s.shape, vh.shape
  1581|         0|            0|            0|  0.00%|    ((2, 7, 8, 8), (2, 7, 3), (2, 7, 3, 3))
  1582|         0|            0|            0|  0.00%|    >>> np.allclose(b, np.matmul(u[..., :3] * s[..., None, :], vh))
  1583|         0|            0|            0|  0.00%|    True
  1584|         0|            0|            0|  0.00%|    >>> np.allclose(b, np.matmul(u[..., :3], s[..., None] * vh))
  1585|         0|            0|            0|  0.00%|    True
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|    Reconstruction based on reduced SVD, 4D case:
  1588|         0|            0|            0|  0.00%|
  1589|         0|            0|            0|  0.00%|    >>> u, s, vh = np.linalg.svd(b, full_matrices=False)
  1590|         0|            0|            0|  0.00%|    >>> u.shape, s.shape, vh.shape
  1591|         0|            0|            0|  0.00%|    ((2, 7, 8, 3), (2, 7, 3), (2, 7, 3, 3))
  1592|         0|            0|            0|  0.00%|    >>> np.allclose(b, np.matmul(u * s[..., None, :], vh))
  1593|         0|            0|            0|  0.00%|    True
  1594|         0|            0|            0|  0.00%|    >>> np.allclose(b, np.matmul(u, s[..., None] * vh))
  1595|         0|            0|            0|  0.00%|    True
  1596|         0|            0|            0|  0.00%|
  1597|         0|            0|            0|  0.00%|    """
  1598|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1599|         0|            0|            0|  0.00%|
  1600|         0|            0|            0|  0.00%|    if hermitian:
  1601|         0|            0|            0|  0.00%|        # note: lapack returns eigenvalues in reverse order to our contract.
  1602|         0|            0|            0|  0.00%|        # reversing is cheap by design in numpy, so we do so to be consistent
  1603|         0|            0|            0|  0.00%|        if compute_uv:
  1604|         0|            0|            0|  0.00%|            s, u = eigh(a)
  1605|         0|            0|            0|  0.00%|            s = s[..., ::-1]
  1606|         0|            0|            0|  0.00%|            u = u[..., ::-1]
  1607|         0|            0|            0|  0.00%|            # singular values are unsigned, move the sign into v
  1608|         0|            0|            0|  0.00%|            vt = transpose(u * sign(s)[..., None, :]).conjugate()
  1609|         0|            0|            0|  0.00%|            s = abs(s)
  1610|         0|            0|            0|  0.00%|            return wrap(u), s, wrap(vt)
  1611|         0|            0|            0|  0.00%|        else:
  1612|         0|            0|            0|  0.00%|            s = eigvalsh(a)
  1613|         0|            0|            0|  0.00%|            s = s[..., ::-1]
  1614|         0|            0|            0|  0.00%|            s = abs(s)
  1615|         0|            0|            0|  0.00%|            return s
  1616|         0|            0|            0|  0.00%|
  1617|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  1618|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  1619|         0|            0|            0|  0.00%|
  1620|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(_raise_linalgerror_svd_nonconvergence)
  1621|         0|            0|            0|  0.00%|
  1622|         0|            0|            0|  0.00%|    m, n = a.shape[-2:]
  1623|         0|            0|            0|  0.00%|    if compute_uv:
  1624|         0|            0|            0|  0.00%|        if full_matrices:
  1625|         0|            0|            0|  0.00%|            if m < n:
  1626|         0|            0|            0|  0.00%|                gufunc = _umath_linalg.svd_m_f
  1627|         0|            0|            0|  0.00%|            else:
  1628|         0|            0|            0|  0.00%|                gufunc = _umath_linalg.svd_n_f
  1629|         0|            0|            0|  0.00%|        else:
  1630|         0|            0|            0|  0.00%|            if m < n:
  1631|         0|            0|            0|  0.00%|                gufunc = _umath_linalg.svd_m_s
  1632|         0|            0|            0|  0.00%|            else:
  1633|         0|            0|            0|  0.00%|                gufunc = _umath_linalg.svd_n_s
  1634|         0|            0|            0|  0.00%|
  1635|         0|            0|            0|  0.00%|        signature = 'D->DdD' if isComplexType(t) else 'd->ddd'
  1636|         0|            0|            0|  0.00%|        u, s, vh = gufunc(a, signature=signature, extobj=extobj)
  1637|         0|            0|            0|  0.00%|        u = u.astype(result_t, copy=False)
  1638|         0|            0|            0|  0.00%|        s = s.astype(_realType(result_t), copy=False)
  1639|         0|            0|            0|  0.00%|        vh = vh.astype(result_t, copy=False)
  1640|         0|            0|            0|  0.00%|        return wrap(u), s, wrap(vh)
  1641|         0|            0|            0|  0.00%|    else:
  1642|         0|            0|            0|  0.00%|        if m < n:
  1643|         0|            0|            0|  0.00%|            gufunc = _umath_linalg.svd_m
  1644|         0|            0|            0|  0.00%|        else:
  1645|         0|            0|            0|  0.00%|            gufunc = _umath_linalg.svd_n
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|        signature = 'D->d' if isComplexType(t) else 'd->d'
  1648|         0|            0|            0|  0.00%|        s = gufunc(a, signature=signature, extobj=extobj)
  1649|         0|            0|            0|  0.00%|        s = s.astype(_realType(result_t), copy=False)
  1650|         0|            0|            0|  0.00%|        return s
  1651|         0|            0|            0|  0.00%|
  1652|         0|            0|            0|  0.00%|
  1653|         0|            0|            0|  0.00%|def _cond_dispatcher(x, p=None):
  1654|         0|            0|            0|  0.00%|    return (x,)
  1655|         0|            0|            0|  0.00%|
  1656|         0|            0|            0|  0.00%|
  1657|         0|            0|            0|  0.00%|@array_function_dispatch(_cond_dispatcher)
  1658|         0|            0|            0|  0.00%|def cond(x, p=None):
  1659|         0|            0|            0|  0.00%|    """
  1660|         0|            0|            0|  0.00%|    Compute the condition number of a matrix.
  1661|         0|            0|            0|  0.00%|
  1662|         0|            0|            0|  0.00%|    This function is capable of returning the condition number using
  1663|         0|            0|            0|  0.00%|    one of seven different norms, depending on the value of `p` (see
  1664|         0|            0|            0|  0.00%|    Parameters below).
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|    Parameters
  1667|         0|            0|            0|  0.00%|    ----------
  1668|         0|            0|            0|  0.00%|    x : (..., M, N) array_like
  1669|         0|            0|            0|  0.00%|        The matrix whose condition number is sought.
  1670|         0|            0|            0|  0.00%|    p : {None, 1, -1, 2, -2, inf, -inf, 'fro'}, optional
  1671|         0|            0|            0|  0.00%|        Order of the norm:
  1672|         0|            0|            0|  0.00%|
  1673|         0|            0|            0|  0.00%|        =====  ============================
  1674|         0|            0|            0|  0.00%|        p      norm for matrices
  1675|         0|            0|            0|  0.00%|        =====  ============================
  1676|         0|            0|            0|  0.00%|        None   2-norm, computed directly using the ``SVD``
  1677|         0|            0|            0|  0.00%|        'fro'  Frobenius norm
  1678|         0|            0|            0|  0.00%|        inf    max(sum(abs(x), axis=1))
  1679|         0|            0|            0|  0.00%|        -inf   min(sum(abs(x), axis=1))
  1680|         0|            0|            0|  0.00%|        1      max(sum(abs(x), axis=0))
  1681|         0|            0|            0|  0.00%|        -1     min(sum(abs(x), axis=0))
  1682|         0|            0|            0|  0.00%|        2      2-norm (largest sing. value)
  1683|         0|            0|            0|  0.00%|        -2     smallest singular value
  1684|         0|            0|            0|  0.00%|        =====  ============================
  1685|         0|            0|            0|  0.00%|
  1686|         0|            0|            0|  0.00%|        inf means the numpy.inf object, and the Frobenius norm is
  1687|         0|            0|            0|  0.00%|        the root-of-sum-of-squares norm.
  1688|         0|            0|            0|  0.00%|
  1689|         0|            0|            0|  0.00%|    Returns
  1690|         0|            0|            0|  0.00%|    -------
  1691|         0|            0|            0|  0.00%|    c : {float, inf}
  1692|         0|            0|            0|  0.00%|        The condition number of the matrix. May be infinite.
  1693|         0|            0|            0|  0.00%|
  1694|         0|            0|            0|  0.00%|    See Also
  1695|         0|            0|            0|  0.00%|    --------
  1696|         0|            0|            0|  0.00%|    numpy.linalg.norm
  1697|         0|            0|            0|  0.00%|
  1698|         0|            0|            0|  0.00%|    Notes
  1699|         0|            0|            0|  0.00%|    -----
  1700|         0|            0|            0|  0.00%|    The condition number of `x` is defined as the norm of `x` times the
  1701|         0|            0|            0|  0.00%|    norm of the inverse of `x` [1]_; the norm can be the usual L2-norm
  1702|         0|            0|            0|  0.00%|    (root-of-sum-of-squares) or one of a number of other matrix norms.
  1703|         0|            0|            0|  0.00%|
  1704|         0|            0|            0|  0.00%|    References
  1705|         0|            0|            0|  0.00%|    ----------
  1706|         0|            0|            0|  0.00%|    .. [1] G. Strang, *Linear Algebra and Its Applications*, Orlando, FL,
  1707|         0|            0|            0|  0.00%|           Academic Press, Inc., 1980, pg. 285.
  1708|         0|            0|            0|  0.00%|
  1709|         0|            0|            0|  0.00%|    Examples
  1710|         0|            0|            0|  0.00%|    --------
  1711|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  1712|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 0, -1], [0, 1, 0], [1, 0, 1]])
  1713|         0|            0|            0|  0.00%|    >>> a
  1714|         0|            0|            0|  0.00%|    array([[ 1,  0, -1],
  1715|         0|            0|            0|  0.00%|           [ 0,  1,  0],
  1716|         0|            0|            0|  0.00%|           [ 1,  0,  1]])
  1717|         0|            0|            0|  0.00%|    >>> LA.cond(a)
  1718|         0|            0|            0|  0.00%|    1.4142135623730951
  1719|         0|            0|            0|  0.00%|    >>> LA.cond(a, 'fro')
  1720|         0|            0|            0|  0.00%|    3.1622776601683795
  1721|         0|            0|            0|  0.00%|    >>> LA.cond(a, np.inf)
  1722|         0|            0|            0|  0.00%|    2.0
  1723|         0|            0|            0|  0.00%|    >>> LA.cond(a, -np.inf)
  1724|         0|            0|            0|  0.00%|    1.0
  1725|         0|            0|            0|  0.00%|    >>> LA.cond(a, 1)
  1726|         0|            0|            0|  0.00%|    2.0
  1727|         0|            0|            0|  0.00%|    >>> LA.cond(a, -1)
  1728|         0|            0|            0|  0.00%|    1.0
  1729|         0|            0|            0|  0.00%|    >>> LA.cond(a, 2)
  1730|         0|            0|            0|  0.00%|    1.4142135623730951
  1731|         0|            0|            0|  0.00%|    >>> LA.cond(a, -2)
  1732|         0|            0|            0|  0.00%|    0.70710678118654746 # may vary
  1733|         0|            0|            0|  0.00%|    >>> min(LA.svd(a, compute_uv=0))*min(LA.svd(LA.inv(a), compute_uv=0))
  1734|         0|            0|            0|  0.00%|    0.70710678118654746 # may vary
  1735|         0|            0|            0|  0.00%|
  1736|         0|            0|            0|  0.00%|    """
  1737|         0|            0|            0|  0.00%|    x = asarray(x)  # in case we have a matrix
  1738|         0|            0|            0|  0.00%|    _assertNoEmpty2d(x)
  1739|         0|            0|            0|  0.00%|    if p is None or p == 2 or p == -2:
  1740|         0|            0|            0|  0.00%|        s = svd(x, compute_uv=False)
  1741|         0|            0|            0|  0.00%|        with errstate(all='ignore'):
  1742|         0|            0|            0|  0.00%|            if p == -2:
  1743|         0|            0|            0|  0.00%|                r = s[..., -1] / s[..., 0]
  1744|         0|            0|            0|  0.00%|            else:
  1745|         0|            0|            0|  0.00%|                r = s[..., 0] / s[..., -1]
  1746|         0|            0|            0|  0.00%|    else:
  1747|         0|            0|            0|  0.00%|        # Call inv(x) ignoring errors. The result array will
  1748|         0|            0|            0|  0.00%|        # contain nans in the entries where inversion failed.
  1749|         0|            0|            0|  0.00%|        _assertRankAtLeast2(x)
  1750|         0|            0|            0|  0.00%|        _assertNdSquareness(x)
  1751|         0|            0|            0|  0.00%|        t, result_t = _commonType(x)
  1752|         0|            0|            0|  0.00%|        signature = 'D->D' if isComplexType(t) else 'd->d'
  1753|         0|            0|            0|  0.00%|        with errstate(all='ignore'):
  1754|         0|            0|            0|  0.00%|            invx = _umath_linalg.inv(x, signature=signature)
  1755|         0|            0|            0|  0.00%|            r = norm(x, p, axis=(-2, -1)) * norm(invx, p, axis=(-2, -1))
  1756|         0|            0|            0|  0.00%|        r = r.astype(result_t, copy=False)
  1757|         0|            0|            0|  0.00%|
  1758|         0|            0|            0|  0.00%|    # Convert nans to infs unless the original array had nan entries
  1759|         0|            0|            0|  0.00%|    r = asarray(r)
  1760|         0|            0|            0|  0.00%|    nan_mask = isnan(r)
  1761|         0|            0|            0|  0.00%|    if nan_mask.any():
  1762|         0|            0|            0|  0.00%|        nan_mask &= ~isnan(x).any(axis=(-2, -1))
  1763|         0|            0|            0|  0.00%|        if r.ndim > 0:
  1764|         0|            0|            0|  0.00%|            r[nan_mask] = Inf
  1765|         0|            0|            0|  0.00%|        elif nan_mask:
  1766|         0|            0|            0|  0.00%|            r[()] = Inf
  1767|         0|            0|            0|  0.00%|
  1768|         0|            0|            0|  0.00%|    # Convention is to return scalars instead of 0d arrays
  1769|         0|            0|            0|  0.00%|    if r.ndim == 0:
  1770|         0|            0|            0|  0.00%|        r = r[()]
  1771|         0|            0|            0|  0.00%|
  1772|         0|            0|            0|  0.00%|    return r
  1773|         0|            0|            0|  0.00%|
  1774|         0|            0|            0|  0.00%|
  1775|         0|            0|            0|  0.00%|def _matrix_rank_dispatcher(M, tol=None, hermitian=None):
  1776|         0|            0|            0|  0.00%|    return (M,)
  1777|         0|            0|            0|  0.00%|
  1778|         0|            0|            0|  0.00%|
  1779|         0|            0|            0|  0.00%|@array_function_dispatch(_matrix_rank_dispatcher)
  1780|         0|            0|            0|  0.00%|def matrix_rank(M, tol=None, hermitian=False):
  1781|         0|            0|            0|  0.00%|    """
  1782|         0|            0|            0|  0.00%|    Return matrix rank of array using SVD method
  1783|         0|            0|            0|  0.00%|
  1784|         0|            0|            0|  0.00%|    Rank of the array is the number of singular values of the array that are
  1785|         0|            0|            0|  0.00%|    greater than `tol`.
  1786|         0|            0|            0|  0.00%|
  1787|         0|            0|            0|  0.00%|    .. versionchanged:: 1.14
  1788|         0|            0|            0|  0.00%|       Can now operate on stacks of matrices
  1789|         0|            0|            0|  0.00%|
  1790|         0|            0|            0|  0.00%|    Parameters
  1791|         0|            0|            0|  0.00%|    ----------
  1792|         0|            0|            0|  0.00%|    M : {(M,), (..., M, N)} array_like
  1793|         0|            0|            0|  0.00%|        Input vector or stack of matrices.
  1794|         0|            0|            0|  0.00%|    tol : (...) array_like, float, optional
  1795|         0|            0|            0|  0.00%|        Threshold below which SVD values are considered zero. If `tol` is
  1796|         0|            0|            0|  0.00%|        None, and ``S`` is an array with singular values for `M`, and
  1797|         0|            0|            0|  0.00%|        ``eps`` is the epsilon value for datatype of ``S``, then `tol` is
  1798|         0|            0|            0|  0.00%|        set to ``S.max() * max(M.shape) * eps``.
  1799|         0|            0|            0|  0.00%|
  1800|         0|            0|            0|  0.00%|        .. versionchanged:: 1.14
  1801|         0|            0|            0|  0.00%|           Broadcasted against the stack of matrices
  1802|         0|            0|            0|  0.00%|    hermitian : bool, optional
  1803|         0|            0|            0|  0.00%|        If True, `M` is assumed to be Hermitian (symmetric if real-valued),
  1804|         0|            0|            0|  0.00%|        enabling a more efficient method for finding singular values.
  1805|         0|            0|            0|  0.00%|        Defaults to False.
  1806|         0|            0|            0|  0.00%|
  1807|         0|            0|            0|  0.00%|        .. versionadded:: 1.14
  1808|         0|            0|            0|  0.00%|
  1809|         0|            0|            0|  0.00%|    Returns
  1810|         0|            0|            0|  0.00%|    -------
  1811|         0|            0|            0|  0.00%|    rank : (...) array_like
  1812|         0|            0|            0|  0.00%|        Rank of M.
  1813|         0|            0|            0|  0.00%|
  1814|         0|            0|            0|  0.00%|    Notes
  1815|         0|            0|            0|  0.00%|    -----
  1816|         0|            0|            0|  0.00%|    The default threshold to detect rank deficiency is a test on the magnitude
  1817|         0|            0|            0|  0.00%|    of the singular values of `M`.  By default, we identify singular values less
  1818|         0|            0|            0|  0.00%|    than ``S.max() * max(M.shape) * eps`` as indicating rank deficiency (with
  1819|         0|            0|            0|  0.00%|    the symbols defined above). This is the algorithm MATLAB uses [1].  It also
  1820|         0|            0|            0|  0.00%|    appears in *Numerical recipes* in the discussion of SVD solutions for linear
  1821|         0|            0|            0|  0.00%|    least squares [2].
  1822|         0|            0|            0|  0.00%|
  1823|         0|            0|            0|  0.00%|    This default threshold is designed to detect rank deficiency accounting for
  1824|         0|            0|            0|  0.00%|    the numerical errors of the SVD computation.  Imagine that there is a column
  1825|         0|            0|            0|  0.00%|    in `M` that is an exact (in floating point) linear combination of other
  1826|         0|            0|            0|  0.00%|    columns in `M`. Computing the SVD on `M` will not produce a singular value
  1827|         0|            0|            0|  0.00%|    exactly equal to 0 in general: any difference of the smallest SVD value from
  1828|         0|            0|            0|  0.00%|    0 will be caused by numerical imprecision in the calculation of the SVD.
  1829|         0|            0|            0|  0.00%|    Our threshold for small SVD values takes this numerical imprecision into
  1830|         0|            0|            0|  0.00%|    account, and the default threshold will detect such numerical rank
  1831|         0|            0|            0|  0.00%|    deficiency.  The threshold may declare a matrix `M` rank deficient even if
  1832|         0|            0|            0|  0.00%|    the linear combination of some columns of `M` is not exactly equal to
  1833|         0|            0|            0|  0.00%|    another column of `M` but only numerically very close to another column of
  1834|         0|            0|            0|  0.00%|    `M`.
  1835|         0|            0|            0|  0.00%|
  1836|         0|            0|            0|  0.00%|    We chose our default threshold because it is in wide use.  Other thresholds
  1837|         0|            0|            0|  0.00%|    are possible.  For example, elsewhere in the 2007 edition of *Numerical
  1838|         0|            0|            0|  0.00%|    recipes* there is an alternative threshold of ``S.max() *
  1839|         0|            0|            0|  0.00%|    np.finfo(M.dtype).eps / 2. * np.sqrt(m + n + 1.)``. The authors describe
  1840|         0|            0|            0|  0.00%|    this threshold as being based on "expected roundoff error" (p 71).
  1841|         0|            0|            0|  0.00%|
  1842|         0|            0|            0|  0.00%|    The thresholds above deal with floating point roundoff error in the
  1843|         0|            0|            0|  0.00%|    calculation of the SVD.  However, you may have more information about the
  1844|         0|            0|            0|  0.00%|    sources of error in `M` that would make you consider other tolerance values
  1845|         0|            0|            0|  0.00%|    to detect *effective* rank deficiency.  The most useful measure of the
  1846|         0|            0|            0|  0.00%|    tolerance depends on the operations you intend to use on your matrix.  For
  1847|         0|            0|            0|  0.00%|    example, if your data come from uncertain measurements with uncertainties
  1848|         0|            0|            0|  0.00%|    greater than floating point epsilon, choosing a tolerance near that
  1849|         0|            0|            0|  0.00%|    uncertainty may be preferable.  The tolerance may be absolute if the
  1850|         0|            0|            0|  0.00%|    uncertainties are absolute rather than relative.
  1851|         0|            0|            0|  0.00%|
  1852|         0|            0|            0|  0.00%|    References
  1853|         0|            0|            0|  0.00%|    ----------
  1854|         0|            0|            0|  0.00%|    .. [1] MATLAB reference documention, "Rank"
  1855|         0|            0|            0|  0.00%|           https://www.mathworks.com/help/techdoc/ref/rank.html
  1856|         0|            0|            0|  0.00%|    .. [2] W. H. Press, S. A. Teukolsky, W. T. Vetterling and B. P. Flannery,
  1857|         0|            0|            0|  0.00%|           "Numerical Recipes (3rd edition)", Cambridge University Press, 2007,
  1858|         0|            0|            0|  0.00%|           page 795.
  1859|         0|            0|            0|  0.00%|
  1860|         0|            0|            0|  0.00%|    Examples
  1861|         0|            0|            0|  0.00%|    --------
  1862|         0|            0|            0|  0.00%|    >>> from numpy.linalg import matrix_rank
  1863|         0|            0|            0|  0.00%|    >>> matrix_rank(np.eye(4)) # Full rank matrix
  1864|         0|            0|            0|  0.00%|    4
  1865|         0|            0|            0|  0.00%|    >>> I=np.eye(4); I[-1,-1] = 0. # rank deficient matrix
  1866|         0|            0|            0|  0.00%|    >>> matrix_rank(I)
  1867|         0|            0|            0|  0.00%|    3
  1868|         0|            0|            0|  0.00%|    >>> matrix_rank(np.ones((4,))) # 1 dimension - rank 1 unless all 0
  1869|         0|            0|            0|  0.00%|    1
  1870|         0|            0|            0|  0.00%|    >>> matrix_rank(np.zeros((4,)))
  1871|         0|            0|            0|  0.00%|    0
  1872|         0|            0|            0|  0.00%|    """
  1873|         0|            0|            0|  0.00%|    M = asarray(M)
  1874|         0|            0|            0|  0.00%|    if M.ndim < 2:
  1875|         0|            0|            0|  0.00%|        return int(not all(M==0))
  1876|         0|            0|            0|  0.00%|    S = svd(M, compute_uv=False, hermitian=hermitian)
  1877|         0|            0|            0|  0.00%|    if tol is None:
  1878|         0|            0|            0|  0.00%|        tol = S.max(axis=-1, keepdims=True) * max(M.shape[-2:]) * finfo(S.dtype).eps
  1879|         0|            0|            0|  0.00%|    else:
  1880|         0|            0|            0|  0.00%|        tol = asarray(tol)[..., newaxis]
  1881|         0|            0|            0|  0.00%|    return count_nonzero(S > tol, axis=-1)
  1882|         0|            0|            0|  0.00%|
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|# Generalized inverse
  1885|         0|            0|            0|  0.00%|
  1886|         0|            0|            0|  0.00%|def _pinv_dispatcher(a, rcond=None, hermitian=None):
  1887|         0|            0|            0|  0.00%|    return (a,)
  1888|         0|            0|            0|  0.00%|
  1889|         0|            0|            0|  0.00%|
  1890|         0|            0|            0|  0.00%|@array_function_dispatch(_pinv_dispatcher)
  1891|         0|            0|            0|  0.00%|def pinv(a, rcond=1e-15, hermitian=False):
  1892|         0|            0|            0|  0.00%|    """
  1893|         0|            0|            0|  0.00%|    Compute the (Moore-Penrose) pseudo-inverse of a matrix.
  1894|         0|            0|            0|  0.00%|
  1895|         0|            0|            0|  0.00%|    Calculate the generalized inverse of a matrix using its
  1896|         0|            0|            0|  0.00%|    singular-value decomposition (SVD) and including all
  1897|         0|            0|            0|  0.00%|    *large* singular values.
  1898|         0|            0|            0|  0.00%|
  1899|         0|            0|            0|  0.00%|    .. versionchanged:: 1.14
  1900|         0|            0|            0|  0.00%|       Can now operate on stacks of matrices
  1901|         0|            0|            0|  0.00%|
  1902|         0|            0|            0|  0.00%|    Parameters
  1903|         0|            0|            0|  0.00%|    ----------
  1904|         0|            0|            0|  0.00%|    a : (..., M, N) array_like
  1905|         0|            0|            0|  0.00%|        Matrix or stack of matrices to be pseudo-inverted.
  1906|         0|            0|            0|  0.00%|    rcond : (...) array_like of float
  1907|         0|            0|            0|  0.00%|        Cutoff for small singular values.
  1908|         0|            0|            0|  0.00%|        Singular values less than or equal to
  1909|         0|            0|            0|  0.00%|        ``rcond * largest_singular_value`` are set to zero.
  1910|         0|            0|            0|  0.00%|        Broadcasts against the stack of matrices.
  1911|         0|            0|            0|  0.00%|    hermitian : bool, optional
  1912|         0|            0|            0|  0.00%|        If True, `a` is assumed to be Hermitian (symmetric if real-valued),
  1913|         0|            0|            0|  0.00%|        enabling a more efficient method for finding singular values.
  1914|         0|            0|            0|  0.00%|        Defaults to False.
  1915|         0|            0|            0|  0.00%|
  1916|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1917|         0|            0|            0|  0.00%|
  1918|         0|            0|            0|  0.00%|    Returns
  1919|         0|            0|            0|  0.00%|    -------
  1920|         0|            0|            0|  0.00%|    B : (..., N, M) ndarray
  1921|         0|            0|            0|  0.00%|        The pseudo-inverse of `a`. If `a` is a `matrix` instance, then so
  1922|         0|            0|            0|  0.00%|        is `B`.
  1923|         0|            0|            0|  0.00%|
  1924|         0|            0|            0|  0.00%|    Raises
  1925|         0|            0|            0|  0.00%|    ------
  1926|         0|            0|            0|  0.00%|    LinAlgError
  1927|         0|            0|            0|  0.00%|        If the SVD computation does not converge.
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|    Notes
  1930|         0|            0|            0|  0.00%|    -----
  1931|         0|            0|            0|  0.00%|    The pseudo-inverse of a matrix A, denoted :math:`A^+`, is
  1932|         0|            0|            0|  0.00%|    defined as: "the matrix that 'solves' [the least-squares problem]
  1933|         0|            0|            0|  0.00%|    :math:`Ax = b`," i.e., if :math:`\\bar{x}` is said solution, then
  1934|         0|            0|            0|  0.00%|    :math:`A^+` is that matrix such that :math:`\\bar{x} = A^+b`.
  1935|         0|            0|            0|  0.00%|
  1936|         0|            0|            0|  0.00%|    It can be shown that if :math:`Q_1 \\Sigma Q_2^T = A` is the singular
  1937|         0|            0|            0|  0.00%|    value decomposition of A, then
  1938|         0|            0|            0|  0.00%|    :math:`A^+ = Q_2 \\Sigma^+ Q_1^T`, where :math:`Q_{1,2}` are
  1939|         0|            0|            0|  0.00%|    orthogonal matrices, :math:`\\Sigma` is a diagonal matrix consisting
  1940|         0|            0|            0|  0.00%|    of A's so-called singular values, (followed, typically, by
  1941|         0|            0|            0|  0.00%|    zeros), and then :math:`\\Sigma^+` is simply the diagonal matrix
  1942|         0|            0|            0|  0.00%|    consisting of the reciprocals of A's singular values
  1943|         0|            0|            0|  0.00%|    (again, followed by zeros). [1]_
  1944|         0|            0|            0|  0.00%|
  1945|         0|            0|            0|  0.00%|    References
  1946|         0|            0|            0|  0.00%|    ----------
  1947|         0|            0|            0|  0.00%|    .. [1] G. Strang, *Linear Algebra and Its Applications*, 2nd Ed., Orlando,
  1948|         0|            0|            0|  0.00%|           FL, Academic Press, Inc., 1980, pp. 139-142.
  1949|         0|            0|            0|  0.00%|
  1950|         0|            0|            0|  0.00%|    Examples
  1951|         0|            0|            0|  0.00%|    --------
  1952|         0|            0|            0|  0.00%|    The following example checks that ``a * a+ * a == a`` and
  1953|         0|            0|            0|  0.00%|    ``a+ * a * a+ == a+``:
  1954|         0|            0|            0|  0.00%|
  1955|         0|            0|            0|  0.00%|    >>> a = np.random.randn(9, 6)
  1956|         0|            0|            0|  0.00%|    >>> B = np.linalg.pinv(a)
  1957|         0|            0|            0|  0.00%|    >>> np.allclose(a, np.dot(a, np.dot(B, a)))
  1958|         0|            0|            0|  0.00%|    True
  1959|         0|            0|            0|  0.00%|    >>> np.allclose(B, np.dot(B, np.dot(a, B)))
  1960|         0|            0|            0|  0.00%|    True
  1961|         0|            0|            0|  0.00%|
  1962|         0|            0|            0|  0.00%|    """
  1963|         0|            0|            0|  0.00%|    a, wrap = _makearray(a)
  1964|         0|            0|            0|  0.00%|    rcond = asarray(rcond)
  1965|         0|            0|            0|  0.00%|    if _isEmpty2d(a):
  1966|         0|            0|            0|  0.00%|        m, n = a.shape[-2:]
  1967|         0|            0|            0|  0.00%|        res = empty(a.shape[:-2] + (n, m), dtype=a.dtype)
  1968|         0|            0|            0|  0.00%|        return wrap(res)
  1969|         0|            0|            0|  0.00%|    a = a.conjugate()
  1970|         0|            0|            0|  0.00%|    u, s, vt = svd(a, full_matrices=False, hermitian=hermitian)
  1971|         0|            0|            0|  0.00%|
  1972|         0|            0|            0|  0.00%|    # discard small singular values
  1973|         0|            0|            0|  0.00%|    cutoff = rcond[..., newaxis] * amax(s, axis=-1, keepdims=True)
  1974|         0|            0|            0|  0.00%|    large = s > cutoff
  1975|         0|            0|            0|  0.00%|    s = divide(1, s, where=large, out=s)
  1976|         0|            0|            0|  0.00%|    s[~large] = 0
  1977|         0|            0|            0|  0.00%|
  1978|         0|            0|            0|  0.00%|    res = matmul(transpose(vt), multiply(s[..., newaxis], transpose(u)))
  1979|         0|            0|            0|  0.00%|    return wrap(res)
  1980|         0|            0|            0|  0.00%|
  1981|         0|            0|            0|  0.00%|
  1982|         0|            0|            0|  0.00%|# Determinant
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|
  1985|         0|            0|            0|  0.00%|@array_function_dispatch(_unary_dispatcher)
  1986|         0|            0|            0|  0.00%|def slogdet(a):
  1987|         0|            0|            0|  0.00%|    """
  1988|         0|            0|            0|  0.00%|    Compute the sign and (natural) logarithm of the determinant of an array.
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|    If an array has a very small or very large determinant, then a call to
  1991|         0|            0|            0|  0.00%|    `det` may overflow or underflow. This routine is more robust against such
  1992|         0|            0|            0|  0.00%|    issues, because it computes the logarithm of the determinant rather than
  1993|         0|            0|            0|  0.00%|    the determinant itself.
  1994|         0|            0|            0|  0.00%|
  1995|         0|            0|            0|  0.00%|    Parameters
  1996|         0|            0|            0|  0.00%|    ----------
  1997|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
  1998|         0|            0|            0|  0.00%|        Input array, has to be a square 2-D array.
  1999|         0|            0|            0|  0.00%|
  2000|         0|            0|            0|  0.00%|    Returns
  2001|         0|            0|            0|  0.00%|    -------
  2002|         0|            0|            0|  0.00%|    sign : (...) array_like
  2003|         0|            0|            0|  0.00%|        A number representing the sign of the determinant. For a real matrix,
  2004|         0|            0|            0|  0.00%|        this is 1, 0, or -1. For a complex matrix, this is a complex number
  2005|         0|            0|            0|  0.00%|        with absolute value 1 (i.e., it is on the unit circle), or else 0.
  2006|         0|            0|            0|  0.00%|    logdet : (...) array_like
  2007|         0|            0|            0|  0.00%|        The natural log of the absolute value of the determinant.
  2008|         0|            0|            0|  0.00%|
  2009|         0|            0|            0|  0.00%|    If the determinant is zero, then `sign` will be 0 and `logdet` will be
  2010|         0|            0|            0|  0.00%|    -Inf. In all cases, the determinant is equal to ``sign * np.exp(logdet)``.
  2011|         0|            0|            0|  0.00%|
  2012|         0|            0|            0|  0.00%|    See Also
  2013|         0|            0|            0|  0.00%|    --------
  2014|         0|            0|            0|  0.00%|    det
  2015|         0|            0|            0|  0.00%|
  2016|         0|            0|            0|  0.00%|    Notes
  2017|         0|            0|            0|  0.00%|    -----
  2018|         0|            0|            0|  0.00%|
  2019|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  2020|         0|            0|            0|  0.00%|
  2021|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  2022|         0|            0|            0|  0.00%|    details.
  2023|         0|            0|            0|  0.00%|
  2024|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
  2025|         0|            0|            0|  0.00%|
  2026|         0|            0|            0|  0.00%|    The determinant is computed via LU factorization using the LAPACK
  2027|         0|            0|            0|  0.00%|    routine ``z/dgetrf``.
  2028|         0|            0|            0|  0.00%|
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|    Examples
  2031|         0|            0|            0|  0.00%|    --------
  2032|         0|            0|            0|  0.00%|    The determinant of a 2-D array ``[[a, b], [c, d]]`` is ``ad - bc``:
  2033|         0|            0|            0|  0.00%|
  2034|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  2035|         0|            0|            0|  0.00%|    >>> (sign, logdet) = np.linalg.slogdet(a)
  2036|         0|            0|            0|  0.00%|    >>> (sign, logdet)
  2037|         0|            0|            0|  0.00%|    (-1, 0.69314718055994529) # may vary
  2038|         0|            0|            0|  0.00%|    >>> sign * np.exp(logdet)
  2039|         0|            0|            0|  0.00%|    -2.0
  2040|         0|            0|            0|  0.00%|
  2041|         0|            0|            0|  0.00%|    Computing log-determinants for a stack of matrices:
  2042|         0|            0|            0|  0.00%|
  2043|         0|            0|            0|  0.00%|    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
  2044|         0|            0|            0|  0.00%|    >>> a.shape
  2045|         0|            0|            0|  0.00%|    (3, 2, 2)
  2046|         0|            0|            0|  0.00%|    >>> sign, logdet = np.linalg.slogdet(a)
  2047|         0|            0|            0|  0.00%|    >>> (sign, logdet)
  2048|         0|            0|            0|  0.00%|    (array([-1., -1., -1.]), array([ 0.69314718,  1.09861229,  2.07944154]))
  2049|         0|            0|            0|  0.00%|    >>> sign * np.exp(logdet)
  2050|         0|            0|            0|  0.00%|    array([-2., -3., -8.])
  2051|         0|            0|            0|  0.00%|
  2052|         0|            0|            0|  0.00%|    This routine succeeds where ordinary `det` does not:
  2053|         0|            0|            0|  0.00%|
  2054|         0|            0|            0|  0.00%|    >>> np.linalg.det(np.eye(500) * 0.1)
  2055|         0|            0|            0|  0.00%|    0.0
  2056|         0|            0|            0|  0.00%|    >>> np.linalg.slogdet(np.eye(500) * 0.1)
  2057|         0|            0|            0|  0.00%|    (1, -1151.2925464970228)
  2058|         0|            0|            0|  0.00%|
  2059|         0|            0|            0|  0.00%|    """
  2060|         0|            0|            0|  0.00%|    a = asarray(a)
  2061|         0|            0|            0|  0.00%|    _assertRankAtLeast2(a)
  2062|         0|            0|            0|  0.00%|    _assertNdSquareness(a)
  2063|         0|            0|            0|  0.00%|    t, result_t = _commonType(a)
  2064|         0|            0|            0|  0.00%|    real_t = _realType(result_t)
  2065|         0|            0|            0|  0.00%|    signature = 'D->Dd' if isComplexType(t) else 'd->dd'
  2066|         0|            0|            0|  0.00%|    sign, logdet = _umath_linalg.slogdet(a, signature=signature)
  2067|         0|            0|            0|  0.00%|    sign = sign.astype(result_t, copy=False)
  2068|         0|            0|            0|  0.00%|    logdet = logdet.astype(real_t, copy=False)
  2069|         0|            0|            0|  0.00%|    return sign, logdet
  2070|         0|            0|            0|  0.00%|
  2071|         0|            0|            0|  0.00%|
  2072|      4000|   0.00947642|  2.36911e-06|  0.18%|@array_function_dispatch(_unary_dispatcher)
  2073|         0|            0|            0|  0.00%|def det(a):
  2074|         0|            0|            0|  0.00%|    """
  2075|         0|            0|            0|  0.00%|    Compute the determinant of an array.
  2076|         0|            0|            0|  0.00%|
  2077|         0|            0|            0|  0.00%|    Parameters
  2078|         0|            0|            0|  0.00%|    ----------
  2079|         0|            0|            0|  0.00%|    a : (..., M, M) array_like
  2080|         0|            0|            0|  0.00%|        Input array to compute determinants for.
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|    Returns
  2083|         0|            0|            0|  0.00%|    -------
  2084|         0|            0|            0|  0.00%|    det : (...) array_like
  2085|         0|            0|            0|  0.00%|        Determinant of `a`.
  2086|         0|            0|            0|  0.00%|
  2087|         0|            0|            0|  0.00%|    See Also
  2088|         0|            0|            0|  0.00%|    --------
  2089|         0|            0|            0|  0.00%|    slogdet : Another way to represent the determinant, more suitable
  2090|         0|            0|            0|  0.00%|      for large matrices where underflow/overflow may occur.
  2091|         0|            0|            0|  0.00%|
  2092|         0|            0|            0|  0.00%|    Notes
  2093|         0|            0|            0|  0.00%|    -----
  2094|         0|            0|            0|  0.00%|
  2095|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
  2096|         0|            0|            0|  0.00%|
  2097|         0|            0|            0|  0.00%|    Broadcasting rules apply, see the `numpy.linalg` documentation for
  2098|         0|            0|            0|  0.00%|    details.
  2099|         0|            0|            0|  0.00%|
  2100|         0|            0|            0|  0.00%|    The determinant is computed via LU factorization using the LAPACK
  2101|         0|            0|            0|  0.00%|    routine ``z/dgetrf``.
  2102|         0|            0|            0|  0.00%|
  2103|         0|            0|            0|  0.00%|    Examples
  2104|         0|            0|            0|  0.00%|    --------
  2105|         0|            0|            0|  0.00%|    The determinant of a 2-D array [[a, b], [c, d]] is ad - bc:
  2106|         0|            0|            0|  0.00%|
  2107|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  2108|         0|            0|            0|  0.00%|    >>> np.linalg.det(a)
  2109|         0|            0|            0|  0.00%|    -2.0 # may vary
  2110|         0|            0|            0|  0.00%|
  2111|         0|            0|            0|  0.00%|    Computing determinants for a stack of matrices:
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|    >>> a = np.array([ [[1, 2], [3, 4]], [[1, 2], [2, 1]], [[1, 3], [3, 1]] ])
  2114|         0|            0|            0|  0.00%|    >>> a.shape
  2115|         0|            0|            0|  0.00%|    (3, 2, 2)
  2116|         0|            0|            0|  0.00%|    >>> np.linalg.det(a)
  2117|         0|            0|            0|  0.00%|    array([-2., -3., -8.])
  2118|         0|            0|            0|  0.00%|
  2119|         0|            0|            0|  0.00%|    """
  2120|      4000|    0.0313213|  7.83032e-06|  0.58%|    a = asarray(a)
(call)|      4000|     0.019382|   4.8455e-06|  0.36%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:16 asarray
  2121|      4000|    0.0295668|  7.39169e-06|  0.55%|    _assertRankAtLeast2(a)
(call)|      4000|    0.0351369|  8.78423e-06|  0.65%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:203 _assertRankAtLeast2
  2122|      4000|    0.0297468|  7.43669e-06|  0.55%|    _assertNdSquareness(a)
(call)|      4000|     0.047102|  1.17755e-05|  0.87%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:209 _assertNdSquareness
  2123|      4000|    0.0318584|  7.96461e-06|  0.59%|    t, result_t = _commonType(a)
(call)|      4000|     0.209339|  5.23348e-05|  3.87%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:144 _commonType
  2124|      4000|    0.0283434|  7.08586e-06|  0.52%|    signature = 'D->D' if isComplexType(t) else 'd->d'
(call)|      4000|    0.0157614|  3.94034e-06|  0.29%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:121 isComplexType
  2125|      4000|    0.0466292|  1.16573e-05|  0.86%|    r = _umath_linalg.det(a, signature=signature)
  2126|      4000|    0.0296166|  7.40415e-06|  0.55%|    r = r.astype(result_t, copy=False)
  2127|      4000|    0.0117896|  2.94739e-06|  0.22%|    return r
  2128|         0|            0|            0|  0.00%|
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|# Linear Least Squares
  2131|         0|            0|            0|  0.00%|
  2132|         0|            0|            0|  0.00%|def _lstsq_dispatcher(a, b, rcond=None):
  2133|         0|            0|            0|  0.00%|    return (a, b)
  2134|         0|            0|            0|  0.00%|
  2135|         0|            0|            0|  0.00%|
  2136|         0|            0|            0|  0.00%|@array_function_dispatch(_lstsq_dispatcher)
  2137|         0|            0|            0|  0.00%|def lstsq(a, b, rcond="warn"):
  2138|         0|            0|            0|  0.00%|    r"""
  2139|         0|            0|            0|  0.00%|    Return the least-squares solution to a linear matrix equation.
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|    Solves the equation :math:`a x = b` by computing a vector `x` that
  2142|         0|            0|            0|  0.00%|    minimizes the squared Euclidean 2-norm :math:`\| b - a x \|^2_2`.
  2143|         0|            0|            0|  0.00%|    The equation may be under-, well-, or over-determined (i.e., the
  2144|         0|            0|            0|  0.00%|    number of linearly independent rows of `a` can be less than, equal
  2145|         0|            0|            0|  0.00%|    to, or greater than its number of linearly independent columns).
  2146|         0|            0|            0|  0.00%|    If `a` is square and of full rank, then `x` (but for round-off error)
  2147|         0|            0|            0|  0.00%|    is the "exact" solution of the equation.
  2148|         0|            0|            0|  0.00%|
  2149|         0|            0|            0|  0.00%|    Parameters
  2150|         0|            0|            0|  0.00%|    ----------
  2151|         0|            0|            0|  0.00%|    a : (M, N) array_like
  2152|         0|            0|            0|  0.00%|        "Coefficient" matrix.
  2153|         0|            0|            0|  0.00%|    b : {(M,), (M, K)} array_like
  2154|         0|            0|            0|  0.00%|        Ordinate or "dependent variable" values. If `b` is two-dimensional,
  2155|         0|            0|            0|  0.00%|        the least-squares solution is calculated for each of the `K` columns
  2156|         0|            0|            0|  0.00%|        of `b`.
  2157|         0|            0|            0|  0.00%|    rcond : float, optional
  2158|         0|            0|            0|  0.00%|        Cut-off ratio for small singular values of `a`.
  2159|         0|            0|            0|  0.00%|        For the purposes of rank determination, singular values are treated
  2160|         0|            0|            0|  0.00%|        as zero if they are smaller than `rcond` times the largest singular
  2161|         0|            0|            0|  0.00%|        value of `a`.
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|        .. versionchanged:: 1.14.0
  2164|         0|            0|            0|  0.00%|           If not set, a FutureWarning is given. The previous default
  2165|         0|            0|            0|  0.00%|           of ``-1`` will use the machine precision as `rcond` parameter,
  2166|         0|            0|            0|  0.00%|           the new default will use the machine precision times `max(M, N)`.
  2167|         0|            0|            0|  0.00%|           To silence the warning and use the new default, use ``rcond=None``,
  2168|         0|            0|            0|  0.00%|           to keep using the old behavior, use ``rcond=-1``.
  2169|         0|            0|            0|  0.00%|
  2170|         0|            0|            0|  0.00%|    Returns
  2171|         0|            0|            0|  0.00%|    -------
  2172|         0|            0|            0|  0.00%|    x : {(N,), (N, K)} ndarray
  2173|         0|            0|            0|  0.00%|        Least-squares solution. If `b` is two-dimensional,
  2174|         0|            0|            0|  0.00%|        the solutions are in the `K` columns of `x`.
  2175|         0|            0|            0|  0.00%|    residuals : {(1,), (K,), (0,)} ndarray
  2176|         0|            0|            0|  0.00%|        Sums of residuals; squared Euclidean 2-norm for each column in
  2177|         0|            0|            0|  0.00%|        ``b - a*x``.
  2178|         0|            0|            0|  0.00%|        If the rank of `a` is < N or M <= N, this is an empty array.
  2179|         0|            0|            0|  0.00%|        If `b` is 1-dimensional, this is a (1,) shape array.
  2180|         0|            0|            0|  0.00%|        Otherwise the shape is (K,).
  2181|         0|            0|            0|  0.00%|    rank : int
  2182|         0|            0|            0|  0.00%|        Rank of matrix `a`.
  2183|         0|            0|            0|  0.00%|    s : (min(M, N),) ndarray
  2184|         0|            0|            0|  0.00%|        Singular values of `a`.
  2185|         0|            0|            0|  0.00%|
  2186|         0|            0|            0|  0.00%|    Raises
  2187|         0|            0|            0|  0.00%|    ------
  2188|         0|            0|            0|  0.00%|    LinAlgError
  2189|         0|            0|            0|  0.00%|        If computation does not converge.
  2190|         0|            0|            0|  0.00%|
  2191|         0|            0|            0|  0.00%|    Notes
  2192|         0|            0|            0|  0.00%|    -----
  2193|         0|            0|            0|  0.00%|    If `b` is a matrix, then all array results are returned as matrices.
  2194|         0|            0|            0|  0.00%|
  2195|         0|            0|            0|  0.00%|    Examples
  2196|         0|            0|            0|  0.00%|    --------
  2197|         0|            0|            0|  0.00%|    Fit a line, ``y = mx + c``, through some noisy data-points:
  2198|         0|            0|            0|  0.00%|
  2199|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 2, 3])
  2200|         0|            0|            0|  0.00%|    >>> y = np.array([-1, 0.2, 0.9, 2.1])
  2201|         0|            0|            0|  0.00%|
  2202|         0|            0|            0|  0.00%|    By examining the coefficients, we see that the line should have a
  2203|         0|            0|            0|  0.00%|    gradient of roughly 1 and cut the y-axis at, more or less, -1.
  2204|         0|            0|            0|  0.00%|
  2205|         0|            0|            0|  0.00%|    We can rewrite the line equation as ``y = Ap``, where ``A = [[x 1]]``
  2206|         0|            0|            0|  0.00%|    and ``p = [[m], [c]]``.  Now use `lstsq` to solve for `p`:
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|    >>> A = np.vstack([x, np.ones(len(x))]).T
  2209|         0|            0|            0|  0.00%|    >>> A
  2210|         0|            0|            0|  0.00%|    array([[ 0.,  1.],
  2211|         0|            0|            0|  0.00%|           [ 1.,  1.],
  2212|         0|            0|            0|  0.00%|           [ 2.,  1.],
  2213|         0|            0|            0|  0.00%|           [ 3.,  1.]])
  2214|         0|            0|            0|  0.00%|
  2215|         0|            0|            0|  0.00%|    >>> m, c = np.linalg.lstsq(A, y, rcond=None)[0]
  2216|         0|            0|            0|  0.00%|    >>> m, c
  2217|         0|            0|            0|  0.00%|    (1.0 -0.95) # may vary
  2218|         0|            0|            0|  0.00%|
  2219|         0|            0|            0|  0.00%|    Plot the data along with the fitted line:
  2220|         0|            0|            0|  0.00%|
  2221|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2222|         0|            0|            0|  0.00%|    >>> _ = plt.plot(x, y, 'o', label='Original data', markersize=10)
  2223|         0|            0|            0|  0.00%|    >>> _ = plt.plot(x, m*x + c, 'r', label='Fitted line')
  2224|         0|            0|            0|  0.00%|    >>> _ = plt.legend()
  2225|         0|            0|            0|  0.00%|    >>> plt.show()
  2226|         0|            0|            0|  0.00%|
  2227|         0|            0|            0|  0.00%|    """
  2228|         0|            0|            0|  0.00%|    a, _ = _makearray(a)
  2229|         0|            0|            0|  0.00%|    b, wrap = _makearray(b)
  2230|         0|            0|            0|  0.00%|    is_1d = b.ndim == 1
  2231|         0|            0|            0|  0.00%|    if is_1d:
  2232|         0|            0|            0|  0.00%|        b = b[:, newaxis]
  2233|         0|            0|            0|  0.00%|    _assertRank2(a, b)
  2234|         0|            0|            0|  0.00%|    m, n = a.shape[-2:]
  2235|         0|            0|            0|  0.00%|    m2, n_rhs = b.shape[-2:]
  2236|         0|            0|            0|  0.00%|    if m != m2:
  2237|         0|            0|            0|  0.00%|        raise LinAlgError('Incompatible dimensions')
  2238|         0|            0|            0|  0.00%|
  2239|         0|            0|            0|  0.00%|    t, result_t = _commonType(a, b)
  2240|         0|            0|            0|  0.00%|    # FIXME: real_t is unused
  2241|         0|            0|            0|  0.00%|    real_t = _linalgRealType(t)
  2242|         0|            0|            0|  0.00%|    result_real_t = _realType(result_t)
  2243|         0|            0|            0|  0.00%|
  2244|         0|            0|            0|  0.00%|    # Determine default rcond value
  2245|         0|            0|            0|  0.00%|    if rcond == "warn":
  2246|         0|            0|            0|  0.00%|        # 2017-08-19, 1.14.0
  2247|         0|            0|            0|  0.00%|        warnings.warn("`rcond` parameter will change to the default of "
  2248|         0|            0|            0|  0.00%|                      "machine precision times ``max(M, N)`` where M and N "
  2249|         0|            0|            0|  0.00%|                      "are the input matrix dimensions.\n"
  2250|         0|            0|            0|  0.00%|                      "To use the future default and silence this warning "
  2251|         0|            0|            0|  0.00%|                      "we advise to pass `rcond=None`, to keep using the old, "
  2252|         0|            0|            0|  0.00%|                      "explicitly pass `rcond=-1`.",
  2253|         0|            0|            0|  0.00%|                      FutureWarning, stacklevel=3)
  2254|         0|            0|            0|  0.00%|        rcond = -1
  2255|         0|            0|            0|  0.00%|    if rcond is None:
  2256|         0|            0|            0|  0.00%|        rcond = finfo(t).eps * max(n, m)
  2257|         0|            0|            0|  0.00%|
  2258|         0|            0|            0|  0.00%|    if m <= n:
  2259|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.lstsq_m
  2260|         0|            0|            0|  0.00%|    else:
  2261|         0|            0|            0|  0.00%|        gufunc = _umath_linalg.lstsq_n
  2262|         0|            0|            0|  0.00%|
  2263|         0|            0|            0|  0.00%|    signature = 'DDd->Ddid' if isComplexType(t) else 'ddd->ddid'
  2264|         0|            0|            0|  0.00%|    extobj = get_linalg_error_extobj(_raise_linalgerror_lstsq)
  2265|         0|            0|            0|  0.00%|    if n_rhs == 0:
  2266|         0|            0|            0|  0.00%|        # lapack can't handle n_rhs = 0 - so allocate the array one larger in that axis
  2267|         0|            0|            0|  0.00%|        b = zeros(b.shape[:-2] + (m, n_rhs + 1), dtype=b.dtype)
  2268|         0|            0|            0|  0.00%|    x, resids, rank, s = gufunc(a, b, rcond, signature=signature, extobj=extobj)
  2269|         0|            0|            0|  0.00%|    if m == 0:
  2270|         0|            0|            0|  0.00%|        x[...] = 0
  2271|         0|            0|            0|  0.00%|    if n_rhs == 0:
  2272|         0|            0|            0|  0.00%|        # remove the item we added
  2273|         0|            0|            0|  0.00%|        x = x[..., :n_rhs]
  2274|         0|            0|            0|  0.00%|        resids = resids[..., :n_rhs]
  2275|         0|            0|            0|  0.00%|
  2276|         0|            0|            0|  0.00%|    # remove the axis we added
  2277|         0|            0|            0|  0.00%|    if is_1d:
  2278|         0|            0|            0|  0.00%|        x = x.squeeze(axis=-1)
  2279|         0|            0|            0|  0.00%|        # we probably should squeeze resids too, but we can't
  2280|         0|            0|            0|  0.00%|        # without breaking compatibility.
  2281|         0|            0|            0|  0.00%|
  2282|         0|            0|            0|  0.00%|    # as documented
  2283|         0|            0|            0|  0.00%|    if rank != n or m <= n:
  2284|         0|            0|            0|  0.00%|        resids = array([], result_real_t)
  2285|         0|            0|            0|  0.00%|
  2286|         0|            0|            0|  0.00%|    # coerce output arrays
  2287|         0|            0|            0|  0.00%|    s = s.astype(result_real_t, copy=False)
  2288|         0|            0|            0|  0.00%|    resids = resids.astype(result_real_t, copy=False)
  2289|         0|            0|            0|  0.00%|    x = x.astype(result_t, copy=True)  # Copying lets the memory in r_parts be freed
  2290|         0|            0|            0|  0.00%|    return wrap(x), wrap(resids), rank, s
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|
  2293|         0|            0|            0|  0.00%|def _multi_svd_norm(x, row_axis, col_axis, op):
  2294|         0|            0|            0|  0.00%|    """Compute a function of the singular values of the 2-D matrices in `x`.
  2295|         0|            0|            0|  0.00%|
  2296|         0|            0|            0|  0.00%|    This is a private utility function used by `numpy.linalg.norm()`.
  2297|         0|            0|            0|  0.00%|
  2298|         0|            0|            0|  0.00%|    Parameters
  2299|         0|            0|            0|  0.00%|    ----------
  2300|         0|            0|            0|  0.00%|    x : ndarray
  2301|         0|            0|            0|  0.00%|    row_axis, col_axis : int
  2302|         0|            0|            0|  0.00%|        The axes of `x` that hold the 2-D matrices.
  2303|         0|            0|            0|  0.00%|    op : callable
  2304|         0|            0|            0|  0.00%|        This should be either numpy.amin or `numpy.amax` or `numpy.sum`.
  2305|         0|            0|            0|  0.00%|
  2306|         0|            0|            0|  0.00%|    Returns
  2307|         0|            0|            0|  0.00%|    -------
  2308|         0|            0|            0|  0.00%|    result : float or ndarray
  2309|         0|            0|            0|  0.00%|        If `x` is 2-D, the return values is a float.
  2310|         0|            0|            0|  0.00%|        Otherwise, it is an array with ``x.ndim - 2`` dimensions.
  2311|         0|            0|            0|  0.00%|        The return values are either the minimum or maximum or sum of the
  2312|         0|            0|            0|  0.00%|        singular values of the matrices, depending on whether `op`
  2313|         0|            0|            0|  0.00%|        is `numpy.amin` or `numpy.amax` or `numpy.sum`.
  2314|         0|            0|            0|  0.00%|
  2315|         0|            0|            0|  0.00%|    """
  2316|         0|            0|            0|  0.00%|    y = moveaxis(x, (row_axis, col_axis), (-2, -1))
  2317|         0|            0|            0|  0.00%|    result = op(svd(y, compute_uv=0), axis=-1)
  2318|         0|            0|            0|  0.00%|    return result
  2319|         0|            0|            0|  0.00%|
  2320|         0|            0|            0|  0.00%|
  2321|         0|            0|            0|  0.00%|def _norm_dispatcher(x, ord=None, axis=None, keepdims=None):
  2322|         0|            0|            0|  0.00%|    return (x,)
  2323|         0|            0|            0|  0.00%|
  2324|         0|            0|            0|  0.00%|
  2325|         0|            0|            0|  0.00%|@array_function_dispatch(_norm_dispatcher)
  2326|         0|            0|            0|  0.00%|def norm(x, ord=None, axis=None, keepdims=False):
  2327|         0|            0|            0|  0.00%|    """
  2328|         0|            0|            0|  0.00%|    Matrix or vector norm.
  2329|         0|            0|            0|  0.00%|
  2330|         0|            0|            0|  0.00%|    This function is able to return one of eight different matrix norms,
  2331|         0|            0|            0|  0.00%|    or one of an infinite number of vector norms (described below), depending
  2332|         0|            0|            0|  0.00%|    on the value of the ``ord`` parameter.
  2333|         0|            0|            0|  0.00%|
  2334|         0|            0|            0|  0.00%|    Parameters
  2335|         0|            0|            0|  0.00%|    ----------
  2336|         0|            0|            0|  0.00%|    x : array_like
  2337|         0|            0|            0|  0.00%|        Input array.  If `axis` is None, `x` must be 1-D or 2-D.
  2338|         0|            0|            0|  0.00%|    ord : {non-zero int, inf, -inf, 'fro', 'nuc'}, optional
  2339|         0|            0|            0|  0.00%|        Order of the norm (see table under ``Notes``). inf means numpy's
  2340|         0|            0|            0|  0.00%|        `inf` object.
  2341|         0|            0|            0|  0.00%|    axis : {int, 2-tuple of ints, None}, optional
  2342|         0|            0|            0|  0.00%|        If `axis` is an integer, it specifies the axis of `x` along which to
  2343|         0|            0|            0|  0.00%|        compute the vector norms.  If `axis` is a 2-tuple, it specifies the
  2344|         0|            0|            0|  0.00%|        axes that hold 2-D matrices, and the matrix norms of these matrices
  2345|         0|            0|            0|  0.00%|        are computed.  If `axis` is None then either a vector norm (when `x`
  2346|         0|            0|            0|  0.00%|        is 1-D) or a matrix norm (when `x` is 2-D) is returned.
  2347|         0|            0|            0|  0.00%|
  2348|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2351|         0|            0|            0|  0.00%|        If this is set to True, the axes which are normed over are left in the
  2352|         0|            0|            0|  0.00%|        result as dimensions with size one.  With this option the result will
  2353|         0|            0|            0|  0.00%|        broadcast correctly against the original `x`.
  2354|         0|            0|            0|  0.00%|
  2355|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  2356|         0|            0|            0|  0.00%|
  2357|         0|            0|            0|  0.00%|    Returns
  2358|         0|            0|            0|  0.00%|    -------
  2359|         0|            0|            0|  0.00%|    n : float or ndarray
  2360|         0|            0|            0|  0.00%|        Norm of the matrix or vector(s).
  2361|         0|            0|            0|  0.00%|
  2362|         0|            0|            0|  0.00%|    Notes
  2363|         0|            0|            0|  0.00%|    -----
  2364|         0|            0|            0|  0.00%|    For values of ``ord <= 0``, the result is, strictly speaking, not a
  2365|         0|            0|            0|  0.00%|    mathematical 'norm', but it may still be useful for various numerical
  2366|         0|            0|            0|  0.00%|    purposes.
  2367|         0|            0|            0|  0.00%|
  2368|         0|            0|            0|  0.00%|    The following norms can be calculated:
  2369|         0|            0|            0|  0.00%|
  2370|         0|            0|            0|  0.00%|    =====  ============================  ==========================
  2371|         0|            0|            0|  0.00%|    ord    norm for matrices             norm for vectors
  2372|         0|            0|            0|  0.00%|    =====  ============================  ==========================
  2373|         0|            0|            0|  0.00%|    None   Frobenius norm                2-norm
  2374|         0|            0|            0|  0.00%|    'fro'  Frobenius norm                --
  2375|         0|            0|            0|  0.00%|    'nuc'  nuclear norm                  --
  2376|         0|            0|            0|  0.00%|    inf    max(sum(abs(x), axis=1))      max(abs(x))
  2377|         0|            0|            0|  0.00%|    -inf   min(sum(abs(x), axis=1))      min(abs(x))
  2378|         0|            0|            0|  0.00%|    0      --                            sum(x != 0)
  2379|         0|            0|            0|  0.00%|    1      max(sum(abs(x), axis=0))      as below
  2380|         0|            0|            0|  0.00%|    -1     min(sum(abs(x), axis=0))      as below
  2381|         0|            0|            0|  0.00%|    2      2-norm (largest sing. value)  as below
  2382|         0|            0|            0|  0.00%|    -2     smallest singular value       as below
  2383|         0|            0|            0|  0.00%|    other  --                            sum(abs(x)**ord)**(1./ord)
  2384|         0|            0|            0|  0.00%|    =====  ============================  ==========================
  2385|         0|            0|            0|  0.00%|
  2386|         0|            0|            0|  0.00%|    The Frobenius norm is given by [1]_:
  2387|         0|            0|            0|  0.00%|
  2388|         0|            0|            0|  0.00%|        :math:`||A||_F = [\\sum_{i,j} abs(a_{i,j})^2]^{1/2}`
  2389|         0|            0|            0|  0.00%|
  2390|         0|            0|            0|  0.00%|    The nuclear norm is the sum of the singular values.
  2391|         0|            0|            0|  0.00%|
  2392|         0|            0|            0|  0.00%|    References
  2393|         0|            0|            0|  0.00%|    ----------
  2394|         0|            0|            0|  0.00%|    .. [1] G. H. Golub and C. F. Van Loan, *Matrix Computations*,
  2395|         0|            0|            0|  0.00%|           Baltimore, MD, Johns Hopkins University Press, 1985, pg. 15
  2396|         0|            0|            0|  0.00%|
  2397|         0|            0|            0|  0.00%|    Examples
  2398|         0|            0|            0|  0.00%|    --------
  2399|         0|            0|            0|  0.00%|    >>> from numpy import linalg as LA
  2400|         0|            0|            0|  0.00%|    >>> a = np.arange(9) - 4
  2401|         0|            0|            0|  0.00%|    >>> a
  2402|         0|            0|            0|  0.00%|    array([-4, -3, -2, ...,  2,  3,  4])
  2403|         0|            0|            0|  0.00%|    >>> b = a.reshape((3, 3))
  2404|         0|            0|            0|  0.00%|    >>> b
  2405|         0|            0|            0|  0.00%|    array([[-4, -3, -2],
  2406|         0|            0|            0|  0.00%|           [-1,  0,  1],
  2407|         0|            0|            0|  0.00%|           [ 2,  3,  4]])
  2408|         0|            0|            0|  0.00%|
  2409|         0|            0|            0|  0.00%|    >>> LA.norm(a)
  2410|         0|            0|            0|  0.00%|    7.745966692414834
  2411|         0|            0|            0|  0.00%|    >>> LA.norm(b)
  2412|         0|            0|            0|  0.00%|    7.745966692414834
  2413|         0|            0|            0|  0.00%|    >>> LA.norm(b, 'fro')
  2414|         0|            0|            0|  0.00%|    7.745966692414834
  2415|         0|            0|            0|  0.00%|    >>> LA.norm(a, np.inf)
  2416|         0|            0|            0|  0.00%|    4.0
  2417|         0|            0|            0|  0.00%|    >>> LA.norm(b, np.inf)
  2418|         0|            0|            0|  0.00%|    9.0
  2419|         0|            0|            0|  0.00%|    >>> LA.norm(a, -np.inf)
  2420|         0|            0|            0|  0.00%|    0.0
  2421|         0|            0|            0|  0.00%|    >>> LA.norm(b, -np.inf)
  2422|         0|            0|            0|  0.00%|    2.0
  2423|         0|            0|            0|  0.00%|
  2424|         0|            0|            0|  0.00%|    >>> LA.norm(a, 1)
  2425|         0|            0|            0|  0.00%|    20.0
  2426|         0|            0|            0|  0.00%|    >>> LA.norm(b, 1)
  2427|         0|            0|            0|  0.00%|    7.0
  2428|         0|            0|            0|  0.00%|    >>> LA.norm(a, -1)
  2429|         0|            0|            0|  0.00%|    -4.6566128774142013e-010
  2430|         0|            0|            0|  0.00%|    >>> LA.norm(b, -1)
  2431|         0|            0|            0|  0.00%|    6.0
  2432|         0|            0|            0|  0.00%|    >>> LA.norm(a, 2)
  2433|         0|            0|            0|  0.00%|    7.745966692414834
  2434|         0|            0|            0|  0.00%|    >>> LA.norm(b, 2)
  2435|         0|            0|            0|  0.00%|    7.3484692283495345
  2436|         0|            0|            0|  0.00%|
  2437|         0|            0|            0|  0.00%|    >>> LA.norm(a, -2)
  2438|         0|            0|            0|  0.00%|    0.0
  2439|         0|            0|            0|  0.00%|    >>> LA.norm(b, -2)
  2440|         0|            0|            0|  0.00%|    1.8570331885190563e-016 # may vary
  2441|         0|            0|            0|  0.00%|    >>> LA.norm(a, 3)
  2442|         0|            0|            0|  0.00%|    5.8480354764257312 # may vary
  2443|         0|            0|            0|  0.00%|    >>> LA.norm(a, -3)
  2444|         0|            0|            0|  0.00%|    0.0
  2445|         0|            0|            0|  0.00%|
  2446|         0|            0|            0|  0.00%|    Using the `axis` argument to compute vector norms:
  2447|         0|            0|            0|  0.00%|
  2448|         0|            0|            0|  0.00%|    >>> c = np.array([[ 1, 2, 3],
  2449|         0|            0|            0|  0.00%|    ...               [-1, 1, 4]])
  2450|         0|            0|            0|  0.00%|    >>> LA.norm(c, axis=0)
  2451|         0|            0|            0|  0.00%|    array([ 1.41421356,  2.23606798,  5.        ])
  2452|         0|            0|            0|  0.00%|    >>> LA.norm(c, axis=1)
  2453|         0|            0|            0|  0.00%|    array([ 3.74165739,  4.24264069])
  2454|         0|            0|            0|  0.00%|    >>> LA.norm(c, ord=1, axis=1)
  2455|         0|            0|            0|  0.00%|    array([ 6.,  6.])
  2456|         0|            0|            0|  0.00%|
  2457|         0|            0|            0|  0.00%|    Using the `axis` argument to compute matrix norms:
  2458|         0|            0|            0|  0.00%|
  2459|         0|            0|            0|  0.00%|    >>> m = np.arange(8).reshape(2,2,2)
  2460|         0|            0|            0|  0.00%|    >>> LA.norm(m, axis=(1,2))
  2461|         0|            0|            0|  0.00%|    array([  3.74165739,  11.22497216])
  2462|         0|            0|            0|  0.00%|    >>> LA.norm(m[0, :, :]), LA.norm(m[1, :, :])
  2463|         0|            0|            0|  0.00%|    (3.7416573867739413, 11.224972160321824)
  2464|         0|            0|            0|  0.00%|
  2465|         0|            0|            0|  0.00%|    """
  2466|         0|            0|            0|  0.00%|    x = asarray(x)
  2467|         0|            0|            0|  0.00%|
  2468|         0|            0|            0|  0.00%|    if not issubclass(x.dtype.type, (inexact, object_)):
  2469|         0|            0|            0|  0.00%|        x = x.astype(float)
  2470|         0|            0|            0|  0.00%|
  2471|         0|            0|            0|  0.00%|    # Immediately handle some default, simple, fast, and common cases.
  2472|         0|            0|            0|  0.00%|    if axis is None:
  2473|         0|            0|            0|  0.00%|        ndim = x.ndim
  2474|         0|            0|            0|  0.00%|        if ((ord is None) or
  2475|         0|            0|            0|  0.00%|            (ord in ('f', 'fro') and ndim == 2) or
  2476|         0|            0|            0|  0.00%|            (ord == 2 and ndim == 1)):
  2477|         0|            0|            0|  0.00%|
  2478|         0|            0|            0|  0.00%|            x = x.ravel(order='K')
  2479|         0|            0|            0|  0.00%|            if isComplexType(x.dtype.type):
  2480|         0|            0|            0|  0.00%|                sqnorm = dot(x.real, x.real) + dot(x.imag, x.imag)
  2481|         0|            0|            0|  0.00%|            else:
  2482|         0|            0|            0|  0.00%|                sqnorm = dot(x, x)
  2483|         0|            0|            0|  0.00%|            ret = sqrt(sqnorm)
  2484|         0|            0|            0|  0.00%|            if keepdims:
  2485|         0|            0|            0|  0.00%|                ret = ret.reshape(ndim*[1])
  2486|         0|            0|            0|  0.00%|            return ret
  2487|         0|            0|            0|  0.00%|
  2488|         0|            0|            0|  0.00%|    # Normalize the `axis` argument to a tuple.
  2489|         0|            0|            0|  0.00%|    nd = x.ndim
  2490|         0|            0|            0|  0.00%|    if axis is None:
  2491|         0|            0|            0|  0.00%|        axis = tuple(range(nd))
  2492|         0|            0|            0|  0.00%|    elif not isinstance(axis, tuple):
  2493|         0|            0|            0|  0.00%|        try:
  2494|         0|            0|            0|  0.00%|            axis = int(axis)
  2495|         0|            0|            0|  0.00%|        except Exception:
  2496|         0|            0|            0|  0.00%|            raise TypeError("'axis' must be None, an integer or a tuple of integers")
  2497|         0|            0|            0|  0.00%|        axis = (axis,)
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|    if len(axis) == 1:
  2500|         0|            0|            0|  0.00%|        if ord == Inf:
  2501|         0|            0|            0|  0.00%|            return abs(x).max(axis=axis, keepdims=keepdims)
  2502|         0|            0|            0|  0.00%|        elif ord == -Inf:
  2503|         0|            0|            0|  0.00%|            return abs(x).min(axis=axis, keepdims=keepdims)
  2504|         0|            0|            0|  0.00%|        elif ord == 0:
  2505|         0|            0|            0|  0.00%|            # Zero norm
  2506|         0|            0|            0|  0.00%|            return (x != 0).astype(x.real.dtype).sum(axis=axis, keepdims=keepdims)
  2507|         0|            0|            0|  0.00%|        elif ord == 1:
  2508|         0|            0|            0|  0.00%|            # special case for speedup
  2509|         0|            0|            0|  0.00%|            return add.reduce(abs(x), axis=axis, keepdims=keepdims)
  2510|         0|            0|            0|  0.00%|        elif ord is None or ord == 2:
  2511|         0|            0|            0|  0.00%|            # special case for speedup
  2512|         0|            0|            0|  0.00%|            s = (x.conj() * x).real
  2513|         0|            0|            0|  0.00%|            return sqrt(add.reduce(s, axis=axis, keepdims=keepdims))
  2514|         0|            0|            0|  0.00%|        else:
  2515|         0|            0|            0|  0.00%|            try:
  2516|         0|            0|            0|  0.00%|                ord + 1
  2517|         0|            0|            0|  0.00%|            except TypeError:
  2518|         0|            0|            0|  0.00%|                raise ValueError("Invalid norm order for vectors.")
  2519|         0|            0|            0|  0.00%|            absx = abs(x)
  2520|         0|            0|            0|  0.00%|            absx **= ord
  2521|         0|            0|            0|  0.00%|            ret = add.reduce(absx, axis=axis, keepdims=keepdims)
  2522|         0|            0|            0|  0.00%|            ret **= (1 / ord)
  2523|         0|            0|            0|  0.00%|            return ret
  2524|         0|            0|            0|  0.00%|    elif len(axis) == 2:
  2525|         0|            0|            0|  0.00%|        row_axis, col_axis = axis
  2526|         0|            0|            0|  0.00%|        row_axis = normalize_axis_index(row_axis, nd)
  2527|         0|            0|            0|  0.00%|        col_axis = normalize_axis_index(col_axis, nd)
  2528|         0|            0|            0|  0.00%|        if row_axis == col_axis:
  2529|         0|            0|            0|  0.00%|            raise ValueError('Duplicate axes given.')
  2530|         0|            0|            0|  0.00%|        if ord == 2:
  2531|         0|            0|            0|  0.00%|            ret =  _multi_svd_norm(x, row_axis, col_axis, amax)
  2532|         0|            0|            0|  0.00%|        elif ord == -2:
  2533|         0|            0|            0|  0.00%|            ret = _multi_svd_norm(x, row_axis, col_axis, amin)
  2534|         0|            0|            0|  0.00%|        elif ord == 1:
  2535|         0|            0|            0|  0.00%|            if col_axis > row_axis:
  2536|         0|            0|            0|  0.00%|                col_axis -= 1
  2537|         0|            0|            0|  0.00%|            ret = add.reduce(abs(x), axis=row_axis).max(axis=col_axis)
  2538|         0|            0|            0|  0.00%|        elif ord == Inf:
  2539|         0|            0|            0|  0.00%|            if row_axis > col_axis:
  2540|         0|            0|            0|  0.00%|                row_axis -= 1
  2541|         0|            0|            0|  0.00%|            ret = add.reduce(abs(x), axis=col_axis).max(axis=row_axis)
  2542|         0|            0|            0|  0.00%|        elif ord == -1:
  2543|         0|            0|            0|  0.00%|            if col_axis > row_axis:
  2544|         0|            0|            0|  0.00%|                col_axis -= 1
  2545|         0|            0|            0|  0.00%|            ret = add.reduce(abs(x), axis=row_axis).min(axis=col_axis)
  2546|         0|            0|            0|  0.00%|        elif ord == -Inf:
  2547|         0|            0|            0|  0.00%|            if row_axis > col_axis:
  2548|         0|            0|            0|  0.00%|                row_axis -= 1
  2549|         0|            0|            0|  0.00%|            ret = add.reduce(abs(x), axis=col_axis).min(axis=row_axis)
  2550|         0|            0|            0|  0.00%|        elif ord in [None, 'fro', 'f']:
  2551|         0|            0|            0|  0.00%|            ret = sqrt(add.reduce((x.conj() * x).real, axis=axis))
  2552|         0|            0|            0|  0.00%|        elif ord == 'nuc':
  2553|         0|            0|            0|  0.00%|            ret = _multi_svd_norm(x, row_axis, col_axis, sum)
  2554|         0|            0|            0|  0.00%|        else:
  2555|         0|            0|            0|  0.00%|            raise ValueError("Invalid norm order for matrices.")
  2556|         0|            0|            0|  0.00%|        if keepdims:
  2557|         0|            0|            0|  0.00%|            ret_shape = list(x.shape)
  2558|         0|            0|            0|  0.00%|            ret_shape[axis[0]] = 1
  2559|         0|            0|            0|  0.00%|            ret_shape[axis[1]] = 1
  2560|         0|            0|            0|  0.00%|            ret = ret.reshape(ret_shape)
  2561|         0|            0|            0|  0.00%|        return ret
  2562|         0|            0|            0|  0.00%|    else:
  2563|         0|            0|            0|  0.00%|        raise ValueError("Improper number of dimensions to norm.")
  2564|         0|            0|            0|  0.00%|
  2565|         0|            0|            0|  0.00%|
  2566|         0|            0|            0|  0.00%|# multi_dot
  2567|         0|            0|            0|  0.00%|
  2568|         0|            0|            0|  0.00%|def _multidot_dispatcher(arrays):
  2569|         0|            0|            0|  0.00%|    return arrays
  2570|         0|            0|            0|  0.00%|
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|@array_function_dispatch(_multidot_dispatcher)
  2573|         0|            0|            0|  0.00%|def multi_dot(arrays):
  2574|         0|            0|            0|  0.00%|    """
  2575|         0|            0|            0|  0.00%|    Compute the dot product of two or more arrays in a single function call,
  2576|         0|            0|            0|  0.00%|    while automatically selecting the fastest evaluation order.
  2577|         0|            0|            0|  0.00%|
  2578|         0|            0|            0|  0.00%|    `multi_dot` chains `numpy.dot` and uses optimal parenthesization
  2579|         0|            0|            0|  0.00%|    of the matrices [1]_ [2]_. Depending on the shapes of the matrices,
  2580|         0|            0|            0|  0.00%|    this can speed up the multiplication a lot.
  2581|         0|            0|            0|  0.00%|
  2582|         0|            0|            0|  0.00%|    If the first argument is 1-D it is treated as a row vector.
  2583|         0|            0|            0|  0.00%|    If the last argument is 1-D it is treated as a column vector.
  2584|         0|            0|            0|  0.00%|    The other arguments must be 2-D.
  2585|         0|            0|            0|  0.00%|
  2586|         0|            0|            0|  0.00%|    Think of `multi_dot` as::
  2587|         0|            0|            0|  0.00%|
  2588|         0|            0|            0|  0.00%|        def multi_dot(arrays): return functools.reduce(np.dot, arrays)
  2589|         0|            0|            0|  0.00%|
  2590|         0|            0|            0|  0.00%|
  2591|         0|            0|            0|  0.00%|    Parameters
  2592|         0|            0|            0|  0.00%|    ----------
  2593|         0|            0|            0|  0.00%|    arrays : sequence of array_like
  2594|         0|            0|            0|  0.00%|        If the first argument is 1-D it is treated as row vector.
  2595|         0|            0|            0|  0.00%|        If the last argument is 1-D it is treated as column vector.
  2596|         0|            0|            0|  0.00%|        The other arguments must be 2-D.
  2597|         0|            0|            0|  0.00%|
  2598|         0|            0|            0|  0.00%|    Returns
  2599|         0|            0|            0|  0.00%|    -------
  2600|         0|            0|            0|  0.00%|    output : ndarray
  2601|         0|            0|            0|  0.00%|        Returns the dot product of the supplied arrays.
  2602|         0|            0|            0|  0.00%|
  2603|         0|            0|            0|  0.00%|    See Also
  2604|         0|            0|            0|  0.00%|    --------
  2605|         0|            0|            0|  0.00%|    dot : dot multiplication with two arguments.
  2606|         0|            0|            0|  0.00%|
  2607|         0|            0|            0|  0.00%|    References
  2608|         0|            0|            0|  0.00%|    ----------
  2609|         0|            0|            0|  0.00%|
  2610|         0|            0|            0|  0.00%|    .. [1] Cormen, "Introduction to Algorithms", Chapter 15.2, p. 370-378
  2611|         0|            0|            0|  0.00%|    .. [2] https://en.wikipedia.org/wiki/Matrix_chain_multiplication
  2612|         0|            0|            0|  0.00%|
  2613|         0|            0|            0|  0.00%|    Examples
  2614|         0|            0|            0|  0.00%|    --------
  2615|         0|            0|            0|  0.00%|    `multi_dot` allows you to write::
  2616|         0|            0|            0|  0.00%|
  2617|         0|            0|            0|  0.00%|    >>> from numpy.linalg import multi_dot
  2618|         0|            0|            0|  0.00%|    >>> # Prepare some data
  2619|         0|            0|            0|  0.00%|    >>> A = np.random.random((10000, 100))
  2620|         0|            0|            0|  0.00%|    >>> B = np.random.random((100, 1000))
  2621|         0|            0|            0|  0.00%|    >>> C = np.random.random((1000, 5))
  2622|         0|            0|            0|  0.00%|    >>> D = np.random.random((5, 333))
  2623|         0|            0|            0|  0.00%|    >>> # the actual dot multiplication
  2624|         0|            0|            0|  0.00%|    >>> _ = multi_dot([A, B, C, D])
  2625|         0|            0|            0|  0.00%|
  2626|         0|            0|            0|  0.00%|    instead of::
  2627|         0|            0|            0|  0.00%|
  2628|         0|            0|            0|  0.00%|    >>> _ = np.dot(np.dot(np.dot(A, B), C), D)
  2629|         0|            0|            0|  0.00%|    >>> # or
  2630|         0|            0|            0|  0.00%|    >>> _ = A.dot(B).dot(C).dot(D)
  2631|         0|            0|            0|  0.00%|
  2632|         0|            0|            0|  0.00%|    Notes
  2633|         0|            0|            0|  0.00%|    -----
  2634|         0|            0|            0|  0.00%|    The cost for a matrix multiplication can be calculated with the
  2635|         0|            0|            0|  0.00%|    following function::
  2636|         0|            0|            0|  0.00%|
  2637|         0|            0|            0|  0.00%|        def cost(A, B):
  2638|         0|            0|            0|  0.00%|            return A.shape[0] * A.shape[1] * B.shape[1]
  2639|         0|            0|            0|  0.00%|
  2640|         0|            0|            0|  0.00%|    Assume we have three matrices
  2641|         0|            0|            0|  0.00%|    :math:`A_{10x100}, B_{100x5}, C_{5x50}`.
  2642|         0|            0|            0|  0.00%|
  2643|         0|            0|            0|  0.00%|    The costs for the two different parenthesizations are as follows::
  2644|         0|            0|            0|  0.00%|
  2645|         0|            0|            0|  0.00%|        cost((AB)C) = 10*100*5 + 10*5*50   = 5000 + 2500   = 7500
  2646|         0|            0|            0|  0.00%|        cost(A(BC)) = 10*100*50 + 100*5*50 = 50000 + 25000 = 75000
  2647|         0|            0|            0|  0.00%|
  2648|         0|            0|            0|  0.00%|    """
  2649|         0|            0|            0|  0.00%|    n = len(arrays)
  2650|         0|            0|            0|  0.00%|    # optimization only makes sense for len(arrays) > 2
  2651|         0|            0|            0|  0.00%|    if n < 2:
  2652|         0|            0|            0|  0.00%|        raise ValueError("Expecting at least two arrays.")
  2653|         0|            0|            0|  0.00%|    elif n == 2:
  2654|         0|            0|            0|  0.00%|        return dot(arrays[0], arrays[1])
  2655|         0|            0|            0|  0.00%|
  2656|         0|            0|            0|  0.00%|    arrays = [asanyarray(a) for a in arrays]
  2657|         0|            0|            0|  0.00%|
  2658|         0|            0|            0|  0.00%|    # save original ndim to reshape the result array into the proper form later
  2659|         0|            0|            0|  0.00%|    ndim_first, ndim_last = arrays[0].ndim, arrays[-1].ndim
  2660|         0|            0|            0|  0.00%|    # Explicitly convert vectors to 2D arrays to keep the logic of the internal
  2661|         0|            0|            0|  0.00%|    # _multi_dot_* functions as simple as possible.
  2662|         0|            0|            0|  0.00%|    if arrays[0].ndim == 1:
  2663|         0|            0|            0|  0.00%|        arrays[0] = atleast_2d(arrays[0])
  2664|         0|            0|            0|  0.00%|    if arrays[-1].ndim == 1:
  2665|         0|            0|            0|  0.00%|        arrays[-1] = atleast_2d(arrays[-1]).T
  2666|         0|            0|            0|  0.00%|    _assertRank2(*arrays)
  2667|         0|            0|            0|  0.00%|
  2668|         0|            0|            0|  0.00%|    # _multi_dot_three is much faster than _multi_dot_matrix_chain_order
  2669|         0|            0|            0|  0.00%|    if n == 3:
  2670|         0|            0|            0|  0.00%|        result = _multi_dot_three(arrays[0], arrays[1], arrays[2])
  2671|         0|            0|            0|  0.00%|    else:
  2672|         0|            0|            0|  0.00%|        order = _multi_dot_matrix_chain_order(arrays)
  2673|         0|            0|            0|  0.00%|        result = _multi_dot(arrays, order, 0, n - 1)
  2674|         0|            0|            0|  0.00%|
  2675|         0|            0|            0|  0.00%|    # return proper shape
  2676|         0|            0|            0|  0.00%|    if ndim_first == 1 and ndim_last == 1:
  2677|         0|            0|            0|  0.00%|        return result[0, 0]  # scalar
  2678|         0|            0|            0|  0.00%|    elif ndim_first == 1 or ndim_last == 1:
  2679|         0|            0|            0|  0.00%|        return result.ravel()  # 1-D
  2680|         0|            0|            0|  0.00%|    else:
  2681|         0|            0|            0|  0.00%|        return result
  2682|         0|            0|            0|  0.00%|
  2683|         0|            0|            0|  0.00%|
  2684|         0|            0|            0|  0.00%|def _multi_dot_three(A, B, C):
  2685|         0|            0|            0|  0.00%|    """
  2686|         0|            0|            0|  0.00%|    Find the best order for three arrays and do the multiplication.
  2687|         0|            0|            0|  0.00%|
  2688|         0|            0|            0|  0.00%|    For three arguments `_multi_dot_three` is approximately 15 times faster
  2689|         0|            0|            0|  0.00%|    than `_multi_dot_matrix_chain_order`
  2690|         0|            0|            0|  0.00%|
  2691|         0|            0|            0|  0.00%|    """
  2692|         0|            0|            0|  0.00%|    a0, a1b0 = A.shape
  2693|         0|            0|            0|  0.00%|    b1c0, c1 = C.shape
  2694|         0|            0|            0|  0.00%|    # cost1 = cost((AB)C) = a0*a1b0*b1c0 + a0*b1c0*c1
  2695|         0|            0|            0|  0.00%|    cost1 = a0 * b1c0 * (a1b0 + c1)
  2696|         0|            0|            0|  0.00%|    # cost2 = cost(A(BC)) = a1b0*b1c0*c1 + a0*a1b0*c1
  2697|         0|            0|            0|  0.00%|    cost2 = a1b0 * c1 * (a0 + b1c0)
  2698|         0|            0|            0|  0.00%|
  2699|         0|            0|            0|  0.00%|    if cost1 < cost2:
  2700|         0|            0|            0|  0.00%|        return dot(dot(A, B), C)
  2701|         0|            0|            0|  0.00%|    else:
  2702|         0|            0|            0|  0.00%|        return dot(A, dot(B, C))
  2703|         0|            0|            0|  0.00%|
  2704|         0|            0|            0|  0.00%|
  2705|         0|            0|            0|  0.00%|def _multi_dot_matrix_chain_order(arrays, return_costs=False):
  2706|         0|            0|            0|  0.00%|    """
  2707|         0|            0|            0|  0.00%|    Return a np.array that encodes the optimal order of mutiplications.
  2708|         0|            0|            0|  0.00%|
  2709|         0|            0|            0|  0.00%|    The optimal order array is then used by `_multi_dot()` to do the
  2710|         0|            0|            0|  0.00%|    multiplication.
  2711|         0|            0|            0|  0.00%|
  2712|         0|            0|            0|  0.00%|    Also return the cost matrix if `return_costs` is `True`
  2713|         0|            0|            0|  0.00%|
  2714|         0|            0|            0|  0.00%|    The implementation CLOSELY follows Cormen, "Introduction to Algorithms",
  2715|         0|            0|            0|  0.00%|    Chapter 15.2, p. 370-378.  Note that Cormen uses 1-based indices.
  2716|         0|            0|            0|  0.00%|
  2717|         0|            0|            0|  0.00%|        cost[i, j] = min([
  2718|         0|            0|            0|  0.00%|            cost[prefix] + cost[suffix] + cost_mult(prefix, suffix)
  2719|         0|            0|            0|  0.00%|            for k in range(i, j)])
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|    """
  2722|         0|            0|            0|  0.00%|    n = len(arrays)
  2723|         0|            0|            0|  0.00%|    # p stores the dimensions of the matrices
  2724|         0|            0|            0|  0.00%|    # Example for p: A_{10x100}, B_{100x5}, C_{5x50} --> p = [10, 100, 5, 50]
  2725|         0|            0|            0|  0.00%|    p = [a.shape[0] for a in arrays] + [arrays[-1].shape[1]]
  2726|         0|            0|            0|  0.00%|    # m is a matrix of costs of the subproblems
  2727|         0|            0|            0|  0.00%|    # m[i,j]: min number of scalar multiplications needed to compute A_{i..j}
  2728|         0|            0|            0|  0.00%|    m = zeros((n, n), dtype=double)
  2729|         0|            0|            0|  0.00%|    # s is the actual ordering
  2730|         0|            0|            0|  0.00%|    # s[i, j] is the value of k at which we split the product A_i..A_j
  2731|         0|            0|            0|  0.00%|    s = empty((n, n), dtype=intp)
  2732|         0|            0|            0|  0.00%|
  2733|         0|            0|            0|  0.00%|    for l in range(1, n):
  2734|         0|            0|            0|  0.00%|        for i in range(n - l):
  2735|         0|            0|            0|  0.00%|            j = i + l
  2736|         0|            0|            0|  0.00%|            m[i, j] = Inf
  2737|         0|            0|            0|  0.00%|            for k in range(i, j):
  2738|         0|            0|            0|  0.00%|                q = m[i, k] + m[k+1, j] + p[i]*p[k+1]*p[j+1]
  2739|         0|            0|            0|  0.00%|                if q < m[i, j]:
  2740|         0|            0|            0|  0.00%|                    m[i, j] = q
  2741|         0|            0|            0|  0.00%|                    s[i, j] = k  # Note that Cormen uses 1-based index
  2742|         0|            0|            0|  0.00%|
  2743|         0|            0|            0|  0.00%|    return (s, m) if return_costs else s
  2744|         0|            0|            0|  0.00%|
  2745|         0|            0|            0|  0.00%|
  2746|         0|            0|            0|  0.00%|def _multi_dot(arrays, order, i, j):
  2747|         0|            0|            0|  0.00%|    """Actually do the multiplication with the given order."""
  2748|         0|            0|            0|  0.00%|    if i == j:
  2749|         0|            0|            0|  0.00%|        return arrays[i]
  2750|         0|            0|            0|  0.00%|    else:
  2751|         0|            0|            0|  0.00%|        return dot(_multi_dot(arrays, order, i, order[i, j]),
  2752|         0|            0|            0|  0.00%|                   _multi_dot(arrays, order, order[i, j] + 1, j))
File: <__array_function__ internals>_10
File duration: 0.0996158s (1.84%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|      4000|    0.0242755|  6.06889e-06|  0.45%|
     3|         0|            0|            0|  0.00%|
     4|      4000|    0.0336478|  8.41194e-06|  0.62%|
(call)|      4000|    0.0168669|  4.21673e-06|  0.31%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:482 _unary_dispatcher
     5|      4000|    0.0088923|  2.22307e-06|  0.16%|
     6|      4000|    0.0328002|  8.20005e-06|  0.61%|
(call)|      4000|      0.57507|  0.000143768| 10.64%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:2072 det
File: <__array_function__ internals>_11
File duration: 0.0865586s (1.60%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|      4000|    0.0159874|  3.99685e-06|  0.30%|
     3|         0|            0|            0|  0.00%|
     4|      4000|    0.0278873|  6.97184e-06|  0.52%|
(call)|      4000|    0.0157821|  3.94553e-06|  0.29%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:482 _unary_dispatcher
     5|      4000|   0.00862503|  2.15626e-06|  0.16%|
     6|      4000|    0.0340588|   8.5147e-06|  0.63%|
(call)|      4000|     0.671573|  0.000167893| 12.42%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/linalg/linalg.py:486 inv
File: <__array_function__ internals>_12
File duration: 0.0778289s (1.44%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|      4000|       0.0177|  4.42499e-06|  0.33%|
     3|         0|            0|            0|  0.00%|
     4|      4000|    0.0303886|  7.59715e-06|  0.56%|
(call)|      4000|    0.0170858|  4.27145e-06|  0.32%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/multiarray.py:707 dot
     5|      4000|   0.00891948|  2.22987e-06|  0.16%|
     6|      4000|    0.0208209|  5.20521e-06|  0.39%|
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py
File duration: 0.03723s (0.69%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Functions in the ``as*array`` family that promote array-likes into arrays.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|`require` fits this category despite its name not matching this pattern.
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|from .overrides import set_module
     9|         0|            0|            0|  0.00%|from .multiarray import array
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|__all__ = [
    13|         0|            0|            0|  0.00%|    "asarray", "asanyarray", "ascontiguousarray", "asfortranarray", "require",
    14|         0|            0|            0|  0.00%|]
    15|         0|            0|            0|  0.00%|
    16|      8002|    0.0141661|  1.77032e-06|  0.26%|@set_module('numpy')
    17|         0|            0|            0|  0.00%|def asarray(a, dtype=None, order=None):
    18|         0|            0|            0|  0.00%|    """Convert the input to an array.
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|    Parameters
    21|         0|            0|            0|  0.00%|    ----------
    22|         0|            0|            0|  0.00%|    a : array_like
    23|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to an array.  This
    24|         0|            0|            0|  0.00%|        includes lists, lists of tuples, tuples, tuples of tuples, tuples
    25|         0|            0|            0|  0.00%|        of lists and ndarrays.
    26|         0|            0|            0|  0.00%|    dtype : data-type, optional
    27|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
    28|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
    29|         0|            0|            0|  0.00%|        Whether to use row-major (C-style) or
    30|         0|            0|            0|  0.00%|        column-major (Fortran-style) memory representation.
    31|         0|            0|            0|  0.00%|        Defaults to 'C'.
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|    Returns
    34|         0|            0|            0|  0.00%|    -------
    35|         0|            0|            0|  0.00%|    out : ndarray
    36|         0|            0|            0|  0.00%|        Array interpretation of `a`.  No copy is performed if the input
    37|         0|            0|            0|  0.00%|        is already an ndarray with matching dtype and order.  If `a` is a
    38|         0|            0|            0|  0.00%|        subclass of ndarray, a base class ndarray is returned.
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|    See Also
    41|         0|            0|            0|  0.00%|    --------
    42|         0|            0|            0|  0.00%|    asanyarray : Similar function which passes through subclasses.
    43|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous array.
    44|         0|            0|            0|  0.00%|    asfarray : Convert input to a floating point ndarray.
    45|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
    46|         0|            0|            0|  0.00%|                     memory order.
    47|         0|            0|            0|  0.00%|    asarray_chkfinite : Similar function which checks input for NaNs and Infs.
    48|         0|            0|            0|  0.00%|    fromiter : Create an array from an iterator.
    49|         0|            0|            0|  0.00%|    fromfunction : Construct an array by executing a function on grid
    50|         0|            0|            0|  0.00%|                   positions.
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|    Examples
    53|         0|            0|            0|  0.00%|    --------
    54|         0|            0|            0|  0.00%|    Convert a list into an array:
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|    >>> a = [1, 2]
    57|         0|            0|            0|  0.00%|    >>> np.asarray(a)
    58|         0|            0|            0|  0.00%|    array([1, 2])
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    Existing arrays are not copied:
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2])
    63|         0|            0|            0|  0.00%|    >>> np.asarray(a) is a
    64|         0|            0|            0|  0.00%|    True
    65|         0|            0|            0|  0.00%|
    66|         0|            0|            0|  0.00%|    If `dtype` is set, array is copied only if dtype does not match:
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2], dtype=np.float32)
    69|         0|            0|            0|  0.00%|    >>> np.asarray(a, dtype=np.float32) is a
    70|         0|            0|            0|  0.00%|    True
    71|         0|            0|            0|  0.00%|    >>> np.asarray(a, dtype=np.float64) is a
    72|         0|            0|            0|  0.00%|    False
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    Contrary to `asanyarray`, ndarray subclasses are not passed through:
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|    >>> issubclass(np.recarray, np.ndarray)
    77|         0|            0|            0|  0.00%|    True
    78|         0|            0|            0|  0.00%|    >>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
    79|         0|            0|            0|  0.00%|    >>> np.asarray(a) is a
    80|         0|            0|            0|  0.00%|    False
    81|         0|            0|            0|  0.00%|    >>> np.asanyarray(a) is a
    82|         0|            0|            0|  0.00%|    True
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    """
    85|      8002|    0.0229986|   2.8741e-06|  0.43%|    return array(a, dtype, copy=False, order=order)
    86|         0|            0|            0|  0.00%|
    87|         0|            0|            0|  0.00%|
    88|         7|  2.43187e-05|   3.4741e-06|  0.00%|@set_module('numpy')
    89|         0|            0|            0|  0.00%|def asanyarray(a, dtype=None, order=None):
    90|         0|            0|            0|  0.00%|    """Convert the input to an ndarray, but pass ndarray subclasses through.
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    Parameters
    93|         0|            0|            0|  0.00%|    ----------
    94|         0|            0|            0|  0.00%|    a : array_like
    95|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to an array.  This
    96|         0|            0|            0|  0.00%|        includes scalars, lists, lists of tuples, tuples, tuples of tuples,
    97|         0|            0|            0|  0.00%|        tuples of lists, and ndarrays.
    98|         0|            0|            0|  0.00%|    dtype : data-type, optional
    99|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
   100|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   101|         0|            0|            0|  0.00%|        Whether to use row-major (C-style) or column-major
   102|         0|            0|            0|  0.00%|        (Fortran-style) memory representation.  Defaults to 'C'.
   103|         0|            0|            0|  0.00%|
   104|         0|            0|            0|  0.00%|    Returns
   105|         0|            0|            0|  0.00%|    -------
   106|         0|            0|            0|  0.00%|    out : ndarray or an ndarray subclass
   107|         0|            0|            0|  0.00%|        Array interpretation of `a`.  If `a` is an ndarray or a subclass
   108|         0|            0|            0|  0.00%|        of ndarray, it is returned as-is and no copy is performed.
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|    See Also
   111|         0|            0|            0|  0.00%|    --------
   112|         0|            0|            0|  0.00%|    asarray : Similar function which always returns ndarrays.
   113|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous array.
   114|         0|            0|            0|  0.00%|    asfarray : Convert input to a floating point ndarray.
   115|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
   116|         0|            0|            0|  0.00%|                     memory order.
   117|         0|            0|            0|  0.00%|    asarray_chkfinite : Similar function which checks input for NaNs and
   118|         0|            0|            0|  0.00%|                        Infs.
   119|         0|            0|            0|  0.00%|    fromiter : Create an array from an iterator.
   120|         0|            0|            0|  0.00%|    fromfunction : Construct an array by executing a function on grid
   121|         0|            0|            0|  0.00%|                   positions.
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|    Examples
   124|         0|            0|            0|  0.00%|    --------
   125|         0|            0|            0|  0.00%|    Convert a list into an array:
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|    >>> a = [1, 2]
   128|         0|            0|            0|  0.00%|    >>> np.asanyarray(a)
   129|         0|            0|            0|  0.00%|    array([1, 2])
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    Instances of `ndarray` subclasses are passed through as-is:
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    >>> a = np.array([(1.0, 2), (3.0, 4)], dtype='f4,i4').view(np.recarray)
   134|         0|            0|            0|  0.00%|    >>> np.asanyarray(a) is a
   135|         0|            0|            0|  0.00%|    True
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    """
   138|         7|   4.1008e-05|  5.85829e-06|  0.00%|    return array(a, dtype, copy=False, order=order, subok=True)
   139|         0|            0|            0|  0.00%|
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|@set_module('numpy')
   142|         0|            0|            0|  0.00%|def ascontiguousarray(a, dtype=None):
   143|         0|            0|            0|  0.00%|    """
   144|         0|            0|            0|  0.00%|    Return a contiguous array (ndim >= 1) in memory (C order).
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|    Parameters
   147|         0|            0|            0|  0.00%|    ----------
   148|         0|            0|            0|  0.00%|    a : array_like
   149|         0|            0|            0|  0.00%|        Input array.
   150|         0|            0|            0|  0.00%|    dtype : str or dtype object, optional
   151|         0|            0|            0|  0.00%|        Data-type of returned array.
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    Returns
   154|         0|            0|            0|  0.00%|    -------
   155|         0|            0|            0|  0.00%|    out : ndarray
   156|         0|            0|            0|  0.00%|        Contiguous array of same shape and content as `a`, with type `dtype`
   157|         0|            0|            0|  0.00%|        if specified.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|    See Also
   160|         0|            0|            0|  0.00%|    --------
   161|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
   162|         0|            0|            0|  0.00%|                     memory order.
   163|         0|            0|            0|  0.00%|    require : Return an ndarray that satisfies requirements.
   164|         0|            0|            0|  0.00%|    ndarray.flags : Information about the memory layout of the array.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    Examples
   167|         0|            0|            0|  0.00%|    --------
   168|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2,3)
   169|         0|            0|            0|  0.00%|    >>> np.ascontiguousarray(x, dtype=np.float32)
   170|         0|            0|            0|  0.00%|    array([[0., 1., 2.],
   171|         0|            0|            0|  0.00%|           [3., 4., 5.]], dtype=float32)
   172|         0|            0|            0|  0.00%|    >>> x.flags['C_CONTIGUOUS']
   173|         0|            0|            0|  0.00%|    True
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    Note: This function returns an array with at least one-dimension (1-d)
   176|         0|            0|            0|  0.00%|    so it will not preserve 0-d arrays.
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|    """
   179|         0|            0|            0|  0.00%|    return array(a, dtype, copy=False, order='C', ndmin=1)
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|@set_module('numpy')
   183|         0|            0|            0|  0.00%|def asfortranarray(a, dtype=None):
   184|         0|            0|            0|  0.00%|    """
   185|         0|            0|            0|  0.00%|    Return an array (ndim >= 1) laid out in Fortran order in memory.
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    Parameters
   188|         0|            0|            0|  0.00%|    ----------
   189|         0|            0|            0|  0.00%|    a : array_like
   190|         0|            0|            0|  0.00%|        Input array.
   191|         0|            0|            0|  0.00%|    dtype : str or dtype object, optional
   192|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
   193|         0|            0|            0|  0.00%|
   194|         0|            0|            0|  0.00%|    Returns
   195|         0|            0|            0|  0.00%|    -------
   196|         0|            0|            0|  0.00%|    out : ndarray
   197|         0|            0|            0|  0.00%|        The input `a` in Fortran, or column-major, order.
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    See Also
   200|         0|            0|            0|  0.00%|    --------
   201|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous (C order) array.
   202|         0|            0|            0|  0.00%|    asanyarray : Convert input to an ndarray with either row or
   203|         0|            0|            0|  0.00%|        column-major memory order.
   204|         0|            0|            0|  0.00%|    require : Return an ndarray that satisfies requirements.
   205|         0|            0|            0|  0.00%|    ndarray.flags : Information about the memory layout of the array.
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    Examples
   208|         0|            0|            0|  0.00%|    --------
   209|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2,3)
   210|         0|            0|            0|  0.00%|    >>> y = np.asfortranarray(x)
   211|         0|            0|            0|  0.00%|    >>> x.flags['F_CONTIGUOUS']
   212|         0|            0|            0|  0.00%|    False
   213|         0|            0|            0|  0.00%|    >>> y.flags['F_CONTIGUOUS']
   214|         0|            0|            0|  0.00%|    True
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    Note: This function returns an array with at least one-dimension (1-d)
   217|         0|            0|            0|  0.00%|    so it will not preserve 0-d arrays.
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|    """
   220|         0|            0|            0|  0.00%|    return array(a, dtype, copy=False, order='F', ndmin=1)
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|@set_module('numpy')
   224|         0|            0|            0|  0.00%|def require(a, dtype=None, requirements=None):
   225|         0|            0|            0|  0.00%|    """
   226|         0|            0|            0|  0.00%|    Return an ndarray of the provided type that satisfies requirements.
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|    This function is useful to be sure that an array with the correct flags
   229|         0|            0|            0|  0.00%|    is returned for passing to compiled code (perhaps through ctypes).
   230|         0|            0|            0|  0.00%|
   231|         0|            0|            0|  0.00%|    Parameters
   232|         0|            0|            0|  0.00%|    ----------
   233|         0|            0|            0|  0.00%|    a : array_like
   234|         0|            0|            0|  0.00%|       The object to be converted to a type-and-requirement-satisfying array.
   235|         0|            0|            0|  0.00%|    dtype : data-type
   236|         0|            0|            0|  0.00%|       The required data-type. If None preserve the current dtype. If your
   237|         0|            0|            0|  0.00%|       application requires the data to be in native byteorder, include
   238|         0|            0|            0|  0.00%|       a byteorder specification as a part of the dtype specification.
   239|         0|            0|            0|  0.00%|    requirements : str or list of str
   240|         0|            0|            0|  0.00%|       The requirements list can be any of the following
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|       * 'F_CONTIGUOUS' ('F') - ensure a Fortran-contiguous array
   243|         0|            0|            0|  0.00%|       * 'C_CONTIGUOUS' ('C') - ensure a C-contiguous array
   244|         0|            0|            0|  0.00%|       * 'ALIGNED' ('A')      - ensure a data-type aligned array
   245|         0|            0|            0|  0.00%|       * 'WRITEABLE' ('W')    - ensure a writable array
   246|         0|            0|            0|  0.00%|       * 'OWNDATA' ('O')      - ensure an array that owns its own data
   247|         0|            0|            0|  0.00%|       * 'ENSUREARRAY', ('E') - ensure a base array, instead of a subclass
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|    Returns
   250|         0|            0|            0|  0.00%|    -------
   251|         0|            0|            0|  0.00%|    out : ndarray
   252|         0|            0|            0|  0.00%|        Array with specified requirements and type if given.
   253|         0|            0|            0|  0.00%|
   254|         0|            0|            0|  0.00%|    See Also
   255|         0|            0|            0|  0.00%|    --------
   256|         0|            0|            0|  0.00%|    asarray : Convert input to an ndarray.
   257|         0|            0|            0|  0.00%|    asanyarray : Convert to an ndarray, but pass through ndarray subclasses.
   258|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous array.
   259|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
   260|         0|            0|            0|  0.00%|                     memory order.
   261|         0|            0|            0|  0.00%|    ndarray.flags : Information about the memory layout of the array.
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    Notes
   264|         0|            0|            0|  0.00%|    -----
   265|         0|            0|            0|  0.00%|    The returned array will be guaranteed to have the listed requirements
   266|         0|            0|            0|  0.00%|    by making a copy if needed.
   267|         0|            0|            0|  0.00%|
   268|         0|            0|            0|  0.00%|    Examples
   269|         0|            0|            0|  0.00%|    --------
   270|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2,3)
   271|         0|            0|            0|  0.00%|    >>> x.flags
   272|         0|            0|            0|  0.00%|      C_CONTIGUOUS : True
   273|         0|            0|            0|  0.00%|      F_CONTIGUOUS : False
   274|         0|            0|            0|  0.00%|      OWNDATA : False
   275|         0|            0|            0|  0.00%|      WRITEABLE : True
   276|         0|            0|            0|  0.00%|      ALIGNED : True
   277|         0|            0|            0|  0.00%|      WRITEBACKIFCOPY : False
   278|         0|            0|            0|  0.00%|      UPDATEIFCOPY : False
   279|         0|            0|            0|  0.00%|
   280|         0|            0|            0|  0.00%|    >>> y = np.require(x, dtype=np.float32, requirements=['A', 'O', 'W', 'F'])
   281|         0|            0|            0|  0.00%|    >>> y.flags
   282|         0|            0|            0|  0.00%|      C_CONTIGUOUS : False
   283|         0|            0|            0|  0.00%|      F_CONTIGUOUS : True
   284|         0|            0|            0|  0.00%|      OWNDATA : True
   285|         0|            0|            0|  0.00%|      WRITEABLE : True
   286|         0|            0|            0|  0.00%|      ALIGNED : True
   287|         0|            0|            0|  0.00%|      WRITEBACKIFCOPY : False
   288|         0|            0|            0|  0.00%|      UPDATEIFCOPY : False
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|    """
   291|         0|            0|            0|  0.00%|    possible_flags = {'C': 'C', 'C_CONTIGUOUS': 'C', 'CONTIGUOUS': 'C',
   292|         0|            0|            0|  0.00%|                      'F': 'F', 'F_CONTIGUOUS': 'F', 'FORTRAN': 'F',
   293|         0|            0|            0|  0.00%|                      'A': 'A', 'ALIGNED': 'A',
   294|         0|            0|            0|  0.00%|                      'W': 'W', 'WRITEABLE': 'W',
   295|         0|            0|            0|  0.00%|                      'O': 'O', 'OWNDATA': 'O',
   296|         0|            0|            0|  0.00%|                      'E': 'E', 'ENSUREARRAY': 'E'}
   297|         0|            0|            0|  0.00%|    if not requirements:
   298|         0|            0|            0|  0.00%|        return asanyarray(a, dtype=dtype)
   299|         0|            0|            0|  0.00%|    else:
   300|         0|            0|            0|  0.00%|        requirements = {possible_flags[x.upper()] for x in requirements}
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    if 'E' in requirements:
   303|         0|            0|            0|  0.00%|        requirements.remove('E')
   304|         0|            0|            0|  0.00%|        subok = False
   305|         0|            0|            0|  0.00%|    else:
   306|         0|            0|            0|  0.00%|        subok = True
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    order = 'A'
   309|         0|            0|            0|  0.00%|    if requirements >= {'C', 'F'}:
   310|         0|            0|            0|  0.00%|        raise ValueError('Cannot specify both "C" and "F" order')
   311|         0|            0|            0|  0.00%|    elif 'F' in requirements:
   312|         0|            0|            0|  0.00%|        order = 'F'
   313|         0|            0|            0|  0.00%|        requirements.remove('F')
   314|         0|            0|            0|  0.00%|    elif 'C' in requirements:
   315|         0|            0|            0|  0.00%|        order = 'C'
   316|         0|            0|            0|  0.00%|        requirements.remove('C')
   317|         0|            0|            0|  0.00%|
   318|         0|            0|            0|  0.00%|    arr = array(a, dtype=dtype, order=order, copy=False, subok=subok)
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    for prop in requirements:
   321|         0|            0|            0|  0.00%|        if not arr.flags[prop]:
   322|         0|            0|            0|  0.00%|            arr = arr.copy(order)
   323|         0|            0|            0|  0.00%|            break
   324|         0|            0|            0|  0.00%|    return arr
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/multiarray.py
File duration: 0.0171008s (0.32%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Create the numpy.core.multiarray namespace for backward compatibility. In v1.16
     3|         0|            0|            0|  0.00%|the multiarray and umath c-extension modules were merged into a single
     4|         0|            0|            0|  0.00%|_multiarray_umath extension module. So we replicate the old namespace
     5|         0|            0|            0|  0.00%|by importing from the extension module.
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|"""
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|import functools
    10|         0|            0|            0|  0.00%|import sys
    11|         0|            0|            0|  0.00%|import warnings
    12|         0|            0|            0|  0.00%|import sys
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|from . import overrides
    15|         0|            0|            0|  0.00%|from . import _multiarray_umath
    16|         0|            0|            0|  0.00%|import numpy as np
    17|         0|            0|            0|  0.00%|from numpy.core._multiarray_umath import *
    18|         0|            0|            0|  0.00%|from numpy.core._multiarray_umath import (
    19|         0|            0|            0|  0.00%|    _fastCopyAndTranspose, _flagdict, _insert, _reconstruct, _vec_string,
    20|         0|            0|            0|  0.00%|    _ARRAY_API, _monotonicity, _get_ndarray_c_version
    21|         0|            0|            0|  0.00%|    )
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|__all__ = [
    24|         0|            0|            0|  0.00%|    '_ARRAY_API', 'ALLOW_THREADS', 'BUFSIZE', 'CLIP', 'DATETIMEUNITS',
    25|         0|            0|            0|  0.00%|    'ITEM_HASOBJECT', 'ITEM_IS_POINTER', 'LIST_PICKLE', 'MAXDIMS',
    26|         0|            0|            0|  0.00%|    'MAY_SHARE_BOUNDS', 'MAY_SHARE_EXACT', 'NEEDS_INIT', 'NEEDS_PYAPI',
    27|         0|            0|            0|  0.00%|    'RAISE', 'USE_GETITEM', 'USE_SETITEM', 'WRAP', '_fastCopyAndTranspose',
    28|         0|            0|            0|  0.00%|    '_flagdict', '_insert', '_reconstruct', '_vec_string', '_monotonicity',
    29|         0|            0|            0|  0.00%|    'add_docstring', 'arange', 'array', 'bincount', 'broadcast',
    30|         0|            0|            0|  0.00%|    'busday_count', 'busday_offset', 'busdaycalendar', 'can_cast',
    31|         0|            0|            0|  0.00%|    'compare_chararrays', 'concatenate', 'copyto', 'correlate', 'correlate2',
    32|         0|            0|            0|  0.00%|    'count_nonzero', 'c_einsum', 'datetime_as_string', 'datetime_data',
    33|         0|            0|            0|  0.00%|    'digitize', 'dot', 'dragon4_positional', 'dragon4_scientific', 'dtype',
    34|         0|            0|            0|  0.00%|    'empty', 'empty_like', 'error', 'flagsobj', 'flatiter', 'format_longfloat',
    35|         0|            0|            0|  0.00%|    'frombuffer', 'fromfile', 'fromiter', 'fromstring', 'inner',
    36|         0|            0|            0|  0.00%|    'int_asbuffer', 'interp', 'interp_complex', 'is_busday', 'lexsort',
    37|         0|            0|            0|  0.00%|    'matmul', 'may_share_memory', 'min_scalar_type', 'ndarray', 'nditer',
    38|         0|            0|            0|  0.00%|    'nested_iters', 'normalize_axis_index', 'packbits',
    39|         0|            0|            0|  0.00%|    'promote_types', 'putmask', 'ravel_multi_index', 'result_type', 'scalar',
    40|         0|            0|            0|  0.00%|    'set_datetimeparse_function', 'set_legacy_print_mode', 'set_numeric_ops',
    41|         0|            0|            0|  0.00%|    'set_string_function', 'set_typeDict', 'shares_memory', 'test_interrupt',
    42|         0|            0|            0|  0.00%|    'tracemalloc_domain', 'typeinfo', 'unpackbits', 'unravel_index', 'vdot',
    43|         0|            0|            0|  0.00%|    'where', 'zeros']
    44|         0|            0|            0|  0.00%|if sys.version_info.major < 3:
    45|         0|            0|            0|  0.00%|    __all__ += ['newbuffer', 'getbuffer']
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|# For backward compatibility, make sure pickle imports these functions from here
    48|         0|            0|            0|  0.00%|_reconstruct.__module__ = 'numpy.core.multiarray'
    49|         0|            0|            0|  0.00%|scalar.__module__ = 'numpy.core.multiarray'
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|arange.__module__ = 'numpy'
    53|         0|            0|            0|  0.00%|array.__module__ = 'numpy'
    54|         0|            0|            0|  0.00%|datetime_data.__module__ = 'numpy'
    55|         0|            0|            0|  0.00%|empty.__module__ = 'numpy'
    56|         0|            0|            0|  0.00%|frombuffer.__module__ = 'numpy'
    57|         0|            0|            0|  0.00%|fromfile.__module__ = 'numpy'
    58|         0|            0|            0|  0.00%|fromiter.__module__ = 'numpy'
    59|         0|            0|            0|  0.00%|frompyfunc.__module__ = 'numpy'
    60|         0|            0|            0|  0.00%|fromstring.__module__ = 'numpy'
    61|         0|            0|            0|  0.00%|geterrobj.__module__ = 'numpy'
    62|         0|            0|            0|  0.00%|may_share_memory.__module__ = 'numpy'
    63|         0|            0|            0|  0.00%|nested_iters.__module__ = 'numpy'
    64|         0|            0|            0|  0.00%|promote_types.__module__ = 'numpy'
    65|         0|            0|            0|  0.00%|set_numeric_ops.__module__ = 'numpy'
    66|         0|            0|            0|  0.00%|seterrobj.__module__ = 'numpy'
    67|         0|            0|            0|  0.00%|zeros.__module__ = 'numpy'
    68|         0|            0|            0|  0.00%|
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|# We can't verify dispatcher signatures because NumPy's C functions don't
    71|         0|            0|            0|  0.00%|# support introspection.
    72|         0|            0|            0|  0.00%|array_function_from_c_func_and_dispatcher = functools.partial(
    73|         0|            0|            0|  0.00%|    overrides.array_function_from_dispatcher,
    74|         0|            0|            0|  0.00%|    module='numpy', docs_from_dispatcher=True, verify=False)
    75|         0|            0|            0|  0.00%|
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.empty_like)
    78|         0|            0|            0|  0.00%|def empty_like(prototype, dtype=None, order=None, subok=None, shape=None):
    79|         0|            0|            0|  0.00%|    """
    80|         0|            0|            0|  0.00%|    empty_like(prototype, dtype=None, order='K', subok=True, shape=None)
    81|         0|            0|            0|  0.00%|
    82|         0|            0|            0|  0.00%|    Return a new array with the same shape and type as a given array.
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|    Parameters
    85|         0|            0|            0|  0.00%|    ----------
    86|         0|            0|            0|  0.00%|    prototype : array_like
    87|         0|            0|            0|  0.00%|        The shape and data-type of `prototype` define these same attributes
    88|         0|            0|            0|  0.00%|        of the returned array.
    89|         0|            0|            0|  0.00%|    dtype : data-type, optional
    90|         0|            0|            0|  0.00%|        Overrides the data type of the result.
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
    93|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
    94|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
    95|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if ``prototype`` is Fortran
    96|         0|            0|            0|  0.00%|        contiguous, 'C' otherwise. 'K' means match the layout of ``prototype``
    97|         0|            0|            0|  0.00%|        as closely as possible.
    98|         0|            0|            0|  0.00%|
    99|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   100|         0|            0|            0|  0.00%|    subok : bool, optional.
   101|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   102|         0|            0|            0|  0.00%|        type of 'a', otherwise it will be a base-class array. Defaults
   103|         0|            0|            0|  0.00%|        to True.
   104|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   105|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   106|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   107|         0|            0|            0|  0.00%|        order='C' is implied.
   108|         0|            0|            0|  0.00%|
   109|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    Returns
   112|         0|            0|            0|  0.00%|    -------
   113|         0|            0|            0|  0.00%|    out : ndarray
   114|         0|            0|            0|  0.00%|        Array of uninitialized (arbitrary) data with the same
   115|         0|            0|            0|  0.00%|        shape and type as `prototype`.
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|    See Also
   118|         0|            0|            0|  0.00%|    --------
   119|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   120|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   121|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   122|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    Notes
   125|         0|            0|            0|  0.00%|    -----
   126|         0|            0|            0|  0.00%|    This function does *not* initialize the returned array; to do that use
   127|         0|            0|            0|  0.00%|    `zeros_like` or `ones_like` instead.  It may be marginally faster than
   128|         0|            0|            0|  0.00%|    the functions that do set the array values.
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|    Examples
   131|         0|            0|            0|  0.00%|    --------
   132|         0|            0|            0|  0.00%|    >>> a = ([1,2,3], [4,5,6])                         # a is array-like
   133|         0|            0|            0|  0.00%|    >>> np.empty_like(a)
   134|         0|            0|            0|  0.00%|    array([[-1073741821, -1073741821,           3],    # uninitialized
   135|         0|            0|            0|  0.00%|           [          0,           0, -1073741821]])
   136|         0|            0|            0|  0.00%|    >>> a = np.array([[1., 2., 3.],[4.,5.,6.]])
   137|         0|            0|            0|  0.00%|    >>> np.empty_like(a)
   138|         0|            0|            0|  0.00%|    array([[ -2.00000715e+000,   1.48219694e-323,  -2.00000572e+000], # uninitialized
   139|         0|            0|            0|  0.00%|           [  4.38791518e-305,  -2.00000715e+000,   4.17269252e-309]])
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    """
   142|         0|            0|            0|  0.00%|    return (prototype,)
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.concatenate)
   146|         0|            0|            0|  0.00%|def concatenate(arrays, axis=None, out=None):
   147|         0|            0|            0|  0.00%|    """
   148|         0|            0|            0|  0.00%|    concatenate((a1, a2, ...), axis=0, out=None)
   149|         0|            0|            0|  0.00%|
   150|         0|            0|            0|  0.00%|    Join a sequence of arrays along an existing axis.
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    Parameters
   153|         0|            0|            0|  0.00%|    ----------
   154|         0|            0|            0|  0.00%|    a1, a2, ... : sequence of array_like
   155|         0|            0|            0|  0.00%|        The arrays must have the same shape, except in the dimension
   156|         0|            0|            0|  0.00%|        corresponding to `axis` (the first, by default).
   157|         0|            0|            0|  0.00%|    axis : int, optional
   158|         0|            0|            0|  0.00%|        The axis along which the arrays will be joined.  If axis is None,
   159|         0|            0|            0|  0.00%|        arrays are flattened before use.  Default is 0.
   160|         0|            0|            0|  0.00%|    out : ndarray, optional
   161|         0|            0|            0|  0.00%|        If provided, the destination to place the result. The shape must be
   162|         0|            0|            0|  0.00%|        correct, matching that of what concatenate would have returned if no
   163|         0|            0|            0|  0.00%|        out argument were specified.
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|    Returns
   166|         0|            0|            0|  0.00%|    -------
   167|         0|            0|            0|  0.00%|    res : ndarray
   168|         0|            0|            0|  0.00%|        The concatenated array.
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    See Also
   171|         0|            0|            0|  0.00%|    --------
   172|         0|            0|            0|  0.00%|    ma.concatenate : Concatenate function that preserves input masks.
   173|         0|            0|            0|  0.00%|    array_split : Split an array into multiple sub-arrays of equal or
   174|         0|            0|            0|  0.00%|                  near-equal size.
   175|         0|            0|            0|  0.00%|    split : Split array into a list of multiple sub-arrays of equal size.
   176|         0|            0|            0|  0.00%|    hsplit : Split array into multiple sub-arrays horizontally (column wise)
   177|         0|            0|            0|  0.00%|    vsplit : Split array into multiple sub-arrays vertically (row wise)
   178|         0|            0|            0|  0.00%|    dsplit : Split array into multiple sub-arrays along the 3rd axis (depth).
   179|         0|            0|            0|  0.00%|    stack : Stack a sequence of arrays along a new axis.
   180|         0|            0|            0|  0.00%|    hstack : Stack arrays in sequence horizontally (column wise)
   181|         0|            0|            0|  0.00%|    vstack : Stack arrays in sequence vertically (row wise)
   182|         0|            0|            0|  0.00%|    dstack : Stack arrays in sequence depth wise (along third dimension)
   183|         0|            0|            0|  0.00%|    block : Assemble arrays from blocks.
   184|         0|            0|            0|  0.00%|
   185|         0|            0|            0|  0.00%|    Notes
   186|         0|            0|            0|  0.00%|    -----
   187|         0|            0|            0|  0.00%|    When one or more of the arrays to be concatenated is a MaskedArray,
   188|         0|            0|            0|  0.00%|    this function will return a MaskedArray object instead of an ndarray,
   189|         0|            0|            0|  0.00%|    but the input masks are *not* preserved. In cases where a MaskedArray
   190|         0|            0|            0|  0.00%|    is expected as input, use the ma.concatenate function from the masked
   191|         0|            0|            0|  0.00%|    array module instead.
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    Examples
   194|         0|            0|            0|  0.00%|    --------
   195|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
   196|         0|            0|            0|  0.00%|    >>> b = np.array([[5, 6]])
   197|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b), axis=0)
   198|         0|            0|            0|  0.00%|    array([[1, 2],
   199|         0|            0|            0|  0.00%|           [3, 4],
   200|         0|            0|            0|  0.00%|           [5, 6]])
   201|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b.T), axis=1)
   202|         0|            0|            0|  0.00%|    array([[1, 2, 5],
   203|         0|            0|            0|  0.00%|           [3, 4, 6]])
   204|         0|            0|            0|  0.00%|    >>> np.concatenate((a, b), axis=None)
   205|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    This function will not preserve masking of MaskedArray inputs.
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    >>> a = np.ma.arange(3)
   210|         0|            0|            0|  0.00%|    >>> a[1] = np.ma.masked
   211|         0|            0|            0|  0.00%|    >>> b = np.arange(2, 5)
   212|         0|            0|            0|  0.00%|    >>> a
   213|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2],
   214|         0|            0|            0|  0.00%|                 mask=[False,  True, False],
   215|         0|            0|            0|  0.00%|           fill_value=999999)
   216|         0|            0|            0|  0.00%|    >>> b
   217|         0|            0|            0|  0.00%|    array([2, 3, 4])
   218|         0|            0|            0|  0.00%|    >>> np.concatenate([a, b])
   219|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, 2, 2, 3, 4],
   220|         0|            0|            0|  0.00%|                 mask=False,
   221|         0|            0|            0|  0.00%|           fill_value=999999)
   222|         0|            0|            0|  0.00%|    >>> np.ma.concatenate([a, b])
   223|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2, 2, 3, 4],
   224|         0|            0|            0|  0.00%|                 mask=[False,  True, False, False, False, False],
   225|         0|            0|            0|  0.00%|           fill_value=999999)
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    """
   228|         0|            0|            0|  0.00%|    if out is not None:
   229|         0|            0|            0|  0.00%|        # optimize for the typical case where only arrays is provided
   230|         0|            0|            0|  0.00%|        arrays = list(arrays)
   231|         0|            0|            0|  0.00%|        arrays.append(out)
   232|         0|            0|            0|  0.00%|    return arrays
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.inner)
   236|         0|            0|            0|  0.00%|def inner(a, b):
   237|         0|            0|            0|  0.00%|    """
   238|         0|            0|            0|  0.00%|    inner(a, b)
   239|         0|            0|            0|  0.00%|
   240|         0|            0|            0|  0.00%|    Inner product of two arrays.
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|    Ordinary inner product of vectors for 1-D arrays (without complex
   243|         0|            0|            0|  0.00%|    conjugation), in higher dimensions a sum product over the last axes.
   244|         0|            0|            0|  0.00%|
   245|         0|            0|            0|  0.00%|    Parameters
   246|         0|            0|            0|  0.00%|    ----------
   247|         0|            0|            0|  0.00%|    a, b : array_like
   248|         0|            0|            0|  0.00%|        If `a` and `b` are nonscalar, their last dimensions must match.
   249|         0|            0|            0|  0.00%|
   250|         0|            0|            0|  0.00%|    Returns
   251|         0|            0|            0|  0.00%|    -------
   252|         0|            0|            0|  0.00%|    out : ndarray
   253|         0|            0|            0|  0.00%|        `out.shape = a.shape[:-1] + b.shape[:-1]`
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    Raises
   256|         0|            0|            0|  0.00%|    ------
   257|         0|            0|            0|  0.00%|    ValueError
   258|         0|            0|            0|  0.00%|        If the last dimension of `a` and `b` has different size.
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    See Also
   261|         0|            0|            0|  0.00%|    --------
   262|         0|            0|            0|  0.00%|    tensordot : Sum products over arbitrary axes.
   263|         0|            0|            0|  0.00%|    dot : Generalised matrix product, using second last dimension of `b`.
   264|         0|            0|            0|  0.00%|    einsum : Einstein summation convention.
   265|         0|            0|            0|  0.00%|
   266|         0|            0|            0|  0.00%|    Notes
   267|         0|            0|            0|  0.00%|    -----
   268|         0|            0|            0|  0.00%|    For vectors (1-D arrays) it computes the ordinary inner-product::
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|        np.inner(a, b) = sum(a[:]*b[:])
   271|         0|            0|            0|  0.00%|
   272|         0|            0|            0|  0.00%|    More generally, if `ndim(a) = r > 0` and `ndim(b) = s > 0`::
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|        np.inner(a, b) = np.tensordot(a, b, axes=(-1,-1))
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    or explicitly::
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|        np.inner(a, b)[i0,...,ir-1,j0,...,js-1]
   279|         0|            0|            0|  0.00%|             = sum(a[i0,...,ir-1,:]*b[j0,...,js-1,:])
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    In addition `a` or `b` may be scalars, in which case::
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|       np.inner(a,b) = a*b
   284|         0|            0|            0|  0.00%|
   285|         0|            0|            0|  0.00%|    Examples
   286|         0|            0|            0|  0.00%|    --------
   287|         0|            0|            0|  0.00%|    Ordinary inner product for vectors:
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|    >>> a = np.array([1,2,3])
   290|         0|            0|            0|  0.00%|    >>> b = np.array([0,1,0])
   291|         0|            0|            0|  0.00%|    >>> np.inner(a, b)
   292|         0|            0|            0|  0.00%|    2
   293|         0|            0|            0|  0.00%|
   294|         0|            0|            0|  0.00%|    A multidimensional example:
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    >>> a = np.arange(24).reshape((2,3,4))
   297|         0|            0|            0|  0.00%|    >>> b = np.arange(4)
   298|         0|            0|            0|  0.00%|    >>> np.inner(a, b)
   299|         0|            0|            0|  0.00%|    array([[ 14,  38,  62],
   300|         0|            0|            0|  0.00%|           [ 86, 110, 134]])
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    An example where `b` is a scalar:
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|    >>> np.inner(np.eye(2), 7)
   305|         0|            0|            0|  0.00%|    array([[7., 0.],
   306|         0|            0|            0|  0.00%|           [0., 7.]])
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    """
   309|         0|            0|            0|  0.00%|    return (a, b)
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.where)
   313|         0|            0|            0|  0.00%|def where(condition, x=None, y=None):
   314|         0|            0|            0|  0.00%|    """
   315|         0|            0|            0|  0.00%|    where(condition, [x, y])
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    Return elements chosen from `x` or `y` depending on `condition`.
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    .. note::
   320|         0|            0|            0|  0.00%|        When only `condition` is provided, this function is a shorthand for
   321|         0|            0|            0|  0.00%|        ``np.asarray(condition).nonzero()``. Using `nonzero` directly should be
   322|         0|            0|            0|  0.00%|        preferred, as it behaves correctly for subclasses. The rest of this
   323|         0|            0|            0|  0.00%|        documentation covers only the case where all three arguments are
   324|         0|            0|            0|  0.00%|        provided.
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    Parameters
   327|         0|            0|            0|  0.00%|    ----------
   328|         0|            0|            0|  0.00%|    condition : array_like, bool
   329|         0|            0|            0|  0.00%|        Where True, yield `x`, otherwise yield `y`.
   330|         0|            0|            0|  0.00%|    x, y : array_like
   331|         0|            0|            0|  0.00%|        Values from which to choose. `x`, `y` and `condition` need to be
   332|         0|            0|            0|  0.00%|        broadcastable to some shape.
   333|         0|            0|            0|  0.00%|
   334|         0|            0|            0|  0.00%|    Returns
   335|         0|            0|            0|  0.00%|    -------
   336|         0|            0|            0|  0.00%|    out : ndarray
   337|         0|            0|            0|  0.00%|        An array with elements from `x` where `condition` is True, and elements
   338|         0|            0|            0|  0.00%|        from `y` elsewhere.
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|    See Also
   341|         0|            0|            0|  0.00%|    --------
   342|         0|            0|            0|  0.00%|    choose
   343|         0|            0|            0|  0.00%|    nonzero : The function that is called when x and y are omitted
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    Notes
   346|         0|            0|            0|  0.00%|    -----
   347|         0|            0|            0|  0.00%|    If all the arrays are 1-D, `where` is equivalent to::
   348|         0|            0|            0|  0.00%|
   349|         0|            0|            0|  0.00%|        [xv if c else yv
   350|         0|            0|            0|  0.00%|         for c, xv, yv in zip(condition, x, y)]
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    Examples
   353|         0|            0|            0|  0.00%|    --------
   354|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
   355|         0|            0|            0|  0.00%|    >>> a
   356|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
   357|         0|            0|            0|  0.00%|    >>> np.where(a < 5, a, 10*a)
   358|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|    This can be used on multidimensional arrays too:
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|    >>> np.where([[True, False], [True, True]],
   363|         0|            0|            0|  0.00%|    ...          [[1, 2], [3, 4]],
   364|         0|            0|            0|  0.00%|    ...          [[9, 8], [7, 6]])
   365|         0|            0|            0|  0.00%|    array([[1, 8],
   366|         0|            0|            0|  0.00%|           [3, 4]])
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    The shapes of x, y, and the condition are broadcast together:
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    >>> x, y = np.ogrid[:3, :4]
   371|         0|            0|            0|  0.00%|    >>> np.where(x < y, x, 10 + y)  # both x and 10+y are broadcast
   372|         0|            0|            0|  0.00%|    array([[10,  0,  0,  0],
   373|         0|            0|            0|  0.00%|           [10, 11,  1,  1],
   374|         0|            0|            0|  0.00%|           [10, 11, 12,  2]])
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    >>> a = np.array([[0, 1, 2],
   377|         0|            0|            0|  0.00%|    ...               [0, 2, 4],
   378|         0|            0|            0|  0.00%|    ...               [0, 3, 6]])
   379|         0|            0|            0|  0.00%|    >>> np.where(a < 4, a, -1)  # -1 is broadcast
   380|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
   381|         0|            0|            0|  0.00%|           [ 0,  2, -1],
   382|         0|            0|            0|  0.00%|           [ 0,  3, -1]])
   383|         0|            0|            0|  0.00%|    """
   384|         0|            0|            0|  0.00%|    return (condition, x, y)
   385|         0|            0|            0|  0.00%|
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.lexsort)
   388|         0|            0|            0|  0.00%|def lexsort(keys, axis=None):
   389|         0|            0|            0|  0.00%|    """
   390|         0|            0|            0|  0.00%|    lexsort(keys, axis=-1)
   391|         0|            0|            0|  0.00%|
   392|         0|            0|            0|  0.00%|    Perform an indirect stable sort using a sequence of keys.
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    Given multiple sorting keys, which can be interpreted as columns in a
   395|         0|            0|            0|  0.00%|    spreadsheet, lexsort returns an array of integer indices that describes
   396|         0|            0|            0|  0.00%|    the sort order by multiple columns. The last key in the sequence is used
   397|         0|            0|            0|  0.00%|    for the primary sort order, the second-to-last key for the secondary sort
   398|         0|            0|            0|  0.00%|    order, and so on. The keys argument must be a sequence of objects that
   399|         0|            0|            0|  0.00%|    can be converted to arrays of the same shape. If a 2D array is provided
   400|         0|            0|            0|  0.00%|    for the keys argument, it's rows are interpreted as the sorting keys and
   401|         0|            0|            0|  0.00%|    sorting is according to the last row, second last row etc.
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    Parameters
   404|         0|            0|            0|  0.00%|    ----------
   405|         0|            0|            0|  0.00%|    keys : (k, N) array or tuple containing k (N,)-shaped sequences
   406|         0|            0|            0|  0.00%|        The `k` different "columns" to be sorted.  The last column (or row if
   407|         0|            0|            0|  0.00%|        `keys` is a 2D array) is the primary sort key.
   408|         0|            0|            0|  0.00%|    axis : int, optional
   409|         0|            0|            0|  0.00%|        Axis to be indirectly sorted.  By default, sort over the last axis.
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    Returns
   412|         0|            0|            0|  0.00%|    -------
   413|         0|            0|            0|  0.00%|    indices : (N,) ndarray of ints
   414|         0|            0|            0|  0.00%|        Array of indices that sort the keys along the specified axis.
   415|         0|            0|            0|  0.00%|
   416|         0|            0|            0|  0.00%|    See Also
   417|         0|            0|            0|  0.00%|    --------
   418|         0|            0|            0|  0.00%|    argsort : Indirect sort.
   419|         0|            0|            0|  0.00%|    ndarray.sort : In-place sort.
   420|         0|            0|            0|  0.00%|    sort : Return a sorted copy of an array.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    Examples
   423|         0|            0|            0|  0.00%|    --------
   424|         0|            0|            0|  0.00%|    Sort names: first by surname, then by name.
   425|         0|            0|            0|  0.00%|
   426|         0|            0|            0|  0.00%|    >>> surnames =    ('Hertz',    'Galilei', 'Hertz')
   427|         0|            0|            0|  0.00%|    >>> first_names = ('Heinrich', 'Galileo', 'Gustav')
   428|         0|            0|            0|  0.00%|    >>> ind = np.lexsort((first_names, surnames))
   429|         0|            0|            0|  0.00%|    >>> ind
   430|         0|            0|            0|  0.00%|    array([1, 2, 0])
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|    >>> [surnames[i] + ", " + first_names[i] for i in ind]
   433|         0|            0|            0|  0.00%|    ['Galilei, Galileo', 'Hertz, Gustav', 'Hertz, Heinrich']
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    Sort two columns of numbers:
   436|         0|            0|            0|  0.00%|
   437|         0|            0|            0|  0.00%|    >>> a = [1,5,1,4,3,4,4] # First column
   438|         0|            0|            0|  0.00%|    >>> b = [9,4,0,4,0,2,1] # Second column
   439|         0|            0|            0|  0.00%|    >>> ind = np.lexsort((b,a)) # Sort by a, then by b
   440|         0|            0|            0|  0.00%|    >>> ind
   441|         0|            0|            0|  0.00%|    array([2, 0, 4, 6, 5, 3, 1])
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    >>> [(a[i],b[i]) for i in ind]
   444|         0|            0|            0|  0.00%|    [(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)]
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    Note that sorting is first according to the elements of ``a``.
   447|         0|            0|            0|  0.00%|    Secondary sorting is according to the elements of ``b``.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    A normal ``argsort`` would have yielded:
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    >>> [(a[i],b[i]) for i in np.argsort(a)]
   452|         0|            0|            0|  0.00%|    [(1, 9), (1, 0), (3, 0), (4, 4), (4, 2), (4, 1), (5, 4)]
   453|         0|            0|            0|  0.00%|
   454|         0|            0|            0|  0.00%|    Structured arrays are sorted lexically by ``argsort``:
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    >>> x = np.array([(1,9), (5,4), (1,0), (4,4), (3,0), (4,2), (4,1)],
   457|         0|            0|            0|  0.00%|    ...              dtype=np.dtype([('x', int), ('y', int)]))
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|    >>> np.argsort(x) # or np.argsort(x, order=('x', 'y'))
   460|         0|            0|            0|  0.00%|    array([2, 0, 4, 6, 5, 3, 1])
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|    """
   463|         0|            0|            0|  0.00%|    if isinstance(keys, tuple):
   464|         0|            0|            0|  0.00%|        return keys
   465|         0|            0|            0|  0.00%|    else:
   466|         0|            0|            0|  0.00%|        return (keys,)
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.can_cast)
   470|         0|            0|            0|  0.00%|def can_cast(from_, to, casting=None):
   471|         0|            0|            0|  0.00%|    """
   472|         0|            0|            0|  0.00%|    can_cast(from_, to, casting='safe')
   473|         0|            0|            0|  0.00%|
   474|         0|            0|            0|  0.00%|    Returns True if cast between data types can occur according to the
   475|         0|            0|            0|  0.00%|    casting rule.  If from is a scalar or array scalar, also returns
   476|         0|            0|            0|  0.00%|    True if the scalar value can be cast without overflow or truncation
   477|         0|            0|            0|  0.00%|    to an integer.
   478|         0|            0|            0|  0.00%|
   479|         0|            0|            0|  0.00%|    Parameters
   480|         0|            0|            0|  0.00%|    ----------
   481|         0|            0|            0|  0.00%|    from_ : dtype, dtype specifier, scalar, or array
   482|         0|            0|            0|  0.00%|        Data type, scalar, or array to cast from.
   483|         0|            0|            0|  0.00%|    to : dtype or dtype specifier
   484|         0|            0|            0|  0.00%|        Data type to cast to.
   485|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
   486|         0|            0|            0|  0.00%|        Controls what kind of data casting may occur.
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|          * 'no' means the data types should not be cast at all.
   489|         0|            0|            0|  0.00%|          * 'equiv' means only byte-order changes are allowed.
   490|         0|            0|            0|  0.00%|          * 'safe' means only casts which can preserve values are allowed.
   491|         0|            0|            0|  0.00%|          * 'same_kind' means only safe casts or casts within a kind,
   492|         0|            0|            0|  0.00%|            like float64 to float32, are allowed.
   493|         0|            0|            0|  0.00%|          * 'unsafe' means any data conversions may be done.
   494|         0|            0|            0|  0.00%|
   495|         0|            0|            0|  0.00%|    Returns
   496|         0|            0|            0|  0.00%|    -------
   497|         0|            0|            0|  0.00%|    out : bool
   498|         0|            0|            0|  0.00%|        True if cast can occur according to the casting rule.
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|    Notes
   501|         0|            0|            0|  0.00%|    -----
   502|         0|            0|            0|  0.00%|    .. versionchanged:: 1.17.0
   503|         0|            0|            0|  0.00%|       Casting between a simple data type and a structured one is possible only
   504|         0|            0|            0|  0.00%|       for "unsafe" casting.  Casting to multiple fields is allowed, but
   505|         0|            0|            0|  0.00%|       casting from multiple fields is not.
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|    .. versionchanged:: 1.9.0
   508|         0|            0|            0|  0.00%|       Casting from numeric to string types in 'safe' casting mode requires
   509|         0|            0|            0|  0.00%|       that the string dtype length is long enough to store the maximum
   510|         0|            0|            0|  0.00%|       integer/float value converted.
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    See also
   513|         0|            0|            0|  0.00%|    --------
   514|         0|            0|            0|  0.00%|    dtype, result_type
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    Examples
   517|         0|            0|            0|  0.00%|    --------
   518|         0|            0|            0|  0.00%|    Basic examples
   519|         0|            0|            0|  0.00%|
   520|         0|            0|            0|  0.00%|    >>> np.can_cast(np.int32, np.int64)
   521|         0|            0|            0|  0.00%|    True
   522|         0|            0|            0|  0.00%|    >>> np.can_cast(np.float64, complex)
   523|         0|            0|            0|  0.00%|    True
   524|         0|            0|            0|  0.00%|    >>> np.can_cast(complex, float)
   525|         0|            0|            0|  0.00%|    False
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'f8')
   528|         0|            0|            0|  0.00%|    True
   529|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'f4')
   530|         0|            0|            0|  0.00%|    False
   531|         0|            0|            0|  0.00%|    >>> np.can_cast('i4', 'S4')
   532|         0|            0|            0|  0.00%|    False
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|    Casting scalars
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    >>> np.can_cast(100, 'i1')
   537|         0|            0|            0|  0.00%|    True
   538|         0|            0|            0|  0.00%|    >>> np.can_cast(150, 'i1')
   539|         0|            0|            0|  0.00%|    False
   540|         0|            0|            0|  0.00%|    >>> np.can_cast(150, 'u1')
   541|         0|            0|            0|  0.00%|    True
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|    >>> np.can_cast(3.5e100, np.float32)
   544|         0|            0|            0|  0.00%|    False
   545|         0|            0|            0|  0.00%|    >>> np.can_cast(1000.0, np.float32)
   546|         0|            0|            0|  0.00%|    True
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|    Array scalar checks the value, array does not
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|    >>> np.can_cast(np.array(1000.0), np.float32)
   551|         0|            0|            0|  0.00%|    True
   552|         0|            0|            0|  0.00%|    >>> np.can_cast(np.array([1000.0]), np.float32)
   553|         0|            0|            0|  0.00%|    False
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|    Using the casting rules
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    >>> np.can_cast('i8', 'i8', 'no')
   558|         0|            0|            0|  0.00%|    True
   559|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i8', 'no')
   560|         0|            0|            0|  0.00%|    False
   561|         0|            0|            0|  0.00%|
   562|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i8', 'equiv')
   563|         0|            0|            0|  0.00%|    True
   564|         0|            0|            0|  0.00%|    >>> np.can_cast('<i4', '>i8', 'equiv')
   565|         0|            0|            0|  0.00%|    False
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|    >>> np.can_cast('<i4', '>i8', 'safe')
   568|         0|            0|            0|  0.00%|    True
   569|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i4', 'safe')
   570|         0|            0|            0|  0.00%|    False
   571|         0|            0|            0|  0.00%|
   572|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>i4', 'same_kind')
   573|         0|            0|            0|  0.00%|    True
   574|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>u4', 'same_kind')
   575|         0|            0|            0|  0.00%|    False
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|    >>> np.can_cast('<i8', '>u4', 'unsafe')
   578|         0|            0|            0|  0.00%|    True
   579|         0|            0|            0|  0.00%|
   580|         0|            0|            0|  0.00%|    """
   581|         0|            0|            0|  0.00%|    return (from_,)
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.min_scalar_type)
   585|         0|            0|            0|  0.00%|def min_scalar_type(a):
   586|         0|            0|            0|  0.00%|    """
   587|         0|            0|            0|  0.00%|    min_scalar_type(a)
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    For scalar ``a``, returns the data type with the smallest size
   590|         0|            0|            0|  0.00%|    and smallest scalar kind which can hold its value.  For non-scalar
   591|         0|            0|            0|  0.00%|    array ``a``, returns the vector's dtype unmodified.
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|    Floating point values are not demoted to integers,
   594|         0|            0|            0|  0.00%|    and complex values are not demoted to floats.
   595|         0|            0|            0|  0.00%|
   596|         0|            0|            0|  0.00%|    Parameters
   597|         0|            0|            0|  0.00%|    ----------
   598|         0|            0|            0|  0.00%|    a : scalar or array_like
   599|         0|            0|            0|  0.00%|        The value whose minimal data type is to be found.
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    Returns
   602|         0|            0|            0|  0.00%|    -------
   603|         0|            0|            0|  0.00%|    out : dtype
   604|         0|            0|            0|  0.00%|        The minimal data type.
   605|         0|            0|            0|  0.00%|
   606|         0|            0|            0|  0.00%|    Notes
   607|         0|            0|            0|  0.00%|    -----
   608|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    See Also
   611|         0|            0|            0|  0.00%|    --------
   612|         0|            0|            0|  0.00%|    result_type, promote_types, dtype, can_cast
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    Examples
   615|         0|            0|            0|  0.00%|    --------
   616|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(10)
   617|         0|            0|            0|  0.00%|    dtype('uint8')
   618|         0|            0|            0|  0.00%|
   619|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(-260)
   620|         0|            0|            0|  0.00%|    dtype('int16')
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(3.1)
   623|         0|            0|            0|  0.00%|    dtype('float16')
   624|         0|            0|            0|  0.00%|
   625|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(1e50)
   626|         0|            0|            0|  0.00%|    dtype('float64')
   627|         0|            0|            0|  0.00%|
   628|         0|            0|            0|  0.00%|    >>> np.min_scalar_type(np.arange(4,dtype='f8'))
   629|         0|            0|            0|  0.00%|    dtype('float64')
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|    """
   632|         0|            0|            0|  0.00%|    return (a,)
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|
   635|         1|  6.91414e-06|  6.91414e-06|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.result_type)
   636|         0|            0|            0|  0.00%|def result_type(*arrays_and_dtypes):
   637|         0|            0|            0|  0.00%|    """
   638|         0|            0|            0|  0.00%|    result_type(*arrays_and_dtypes)
   639|         0|            0|            0|  0.00%|
   640|         0|            0|            0|  0.00%|    Returns the type that results from applying the NumPy
   641|         0|            0|            0|  0.00%|    type promotion rules to the arguments.
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    Type promotion in NumPy works similarly to the rules in languages
   644|         0|            0|            0|  0.00%|    like C++, with some slight differences.  When both scalars and
   645|         0|            0|            0|  0.00%|    arrays are used, the array's type takes precedence and the actual value
   646|         0|            0|            0|  0.00%|    of the scalar is taken into account.
   647|         0|            0|            0|  0.00%|
   648|         0|            0|            0|  0.00%|    For example, calculating 3*a, where a is an array of 32-bit floats,
   649|         0|            0|            0|  0.00%|    intuitively should result in a 32-bit float output.  If the 3 is a
   650|         0|            0|            0|  0.00%|    32-bit integer, the NumPy rules indicate it can't convert losslessly
   651|         0|            0|            0|  0.00%|    into a 32-bit float, so a 64-bit float should be the result type.
   652|         0|            0|            0|  0.00%|    By examining the value of the constant, '3', we see that it fits in
   653|         0|            0|            0|  0.00%|    an 8-bit integer, which can be cast losslessly into the 32-bit float.
   654|         0|            0|            0|  0.00%|
   655|         0|            0|            0|  0.00%|    Parameters
   656|         0|            0|            0|  0.00%|    ----------
   657|         0|            0|            0|  0.00%|    arrays_and_dtypes : list of arrays and dtypes
   658|         0|            0|            0|  0.00%|        The operands of some operation whose result type is needed.
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    Returns
   661|         0|            0|            0|  0.00%|    -------
   662|         0|            0|            0|  0.00%|    out : dtype
   663|         0|            0|            0|  0.00%|        The result type.
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|    See also
   666|         0|            0|            0|  0.00%|    --------
   667|         0|            0|            0|  0.00%|    dtype, promote_types, min_scalar_type, can_cast
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|    Notes
   670|         0|            0|            0|  0.00%|    -----
   671|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|    The specific algorithm used is as follows.
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|    Categories are determined by first checking which of boolean,
   676|         0|            0|            0|  0.00%|    integer (int/uint), or floating point (float/complex) the maximum
   677|         0|            0|            0|  0.00%|    kind of all the arrays and the scalars are.
   678|         0|            0|            0|  0.00%|
   679|         0|            0|            0|  0.00%|    If there are only scalars or the maximum category of the scalars
   680|         0|            0|            0|  0.00%|    is higher than the maximum category of the arrays,
   681|         0|            0|            0|  0.00%|    the data types are combined with :func:`promote_types`
   682|         0|            0|            0|  0.00%|    to produce the return value.
   683|         0|            0|            0|  0.00%|
   684|         0|            0|            0|  0.00%|    Otherwise, `min_scalar_type` is called on each array, and
   685|         0|            0|            0|  0.00%|    the resulting data types are all combined with :func:`promote_types`
   686|         0|            0|            0|  0.00%|    to produce the return value.
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|    The set of int values is not a subset of the uint values for types
   689|         0|            0|            0|  0.00%|    with the same number of bits, something not reflected in
   690|         0|            0|            0|  0.00%|    :func:`min_scalar_type`, but handled as a special case in `result_type`.
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    Examples
   693|         0|            0|            0|  0.00%|    --------
   694|         0|            0|            0|  0.00%|    >>> np.result_type(3, np.arange(7, dtype='i1'))
   695|         0|            0|            0|  0.00%|    dtype('int8')
   696|         0|            0|            0|  0.00%|
   697|         0|            0|            0|  0.00%|    >>> np.result_type('i4', 'c8')
   698|         0|            0|            0|  0.00%|    dtype('complex128')
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    >>> np.result_type(3.0, -2)
   701|         0|            0|            0|  0.00%|    dtype('float64')
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    """
   704|         1|  8.10623e-06|  8.10623e-06|  0.00%|    return arrays_and_dtypes
   705|         0|            0|            0|  0.00%|
   706|         0|            0|            0|  0.00%|
   707|      4000|   0.00724411|  1.81103e-06|  0.13%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.dot)
   708|         0|            0|            0|  0.00%|def dot(a, b, out=None):
   709|         0|            0|            0|  0.00%|    """
   710|         0|            0|            0|  0.00%|    dot(a, b, out=None)
   711|         0|            0|            0|  0.00%|
   712|         0|            0|            0|  0.00%|    Dot product of two arrays. Specifically,
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|    - If both `a` and `b` are 1-D arrays, it is inner product of vectors
   715|         0|            0|            0|  0.00%|      (without complex conjugation).
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|    - If both `a` and `b` are 2-D arrays, it is matrix multiplication,
   718|         0|            0|            0|  0.00%|      but using :func:`matmul` or ``a @ b`` is preferred.
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|    - If either `a` or `b` is 0-D (scalar), it is equivalent to :func:`multiply`
   721|         0|            0|            0|  0.00%|      and using ``numpy.multiply(a, b)`` or ``a * b`` is preferred.
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|    - If `a` is an N-D array and `b` is a 1-D array, it is a sum product over
   724|         0|            0|            0|  0.00%|      the last axis of `a` and `b`.
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|    - If `a` is an N-D array and `b` is an M-D array (where ``M>=2``), it is a
   727|         0|            0|            0|  0.00%|      sum product over the last axis of `a` and the second-to-last axis of `b`::
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|        dot(a, b)[i,j,k,m] = sum(a[i,j,:] * b[k,:,m])
   730|         0|            0|            0|  0.00%|
   731|         0|            0|            0|  0.00%|    Parameters
   732|         0|            0|            0|  0.00%|    ----------
   733|         0|            0|            0|  0.00%|    a : array_like
   734|         0|            0|            0|  0.00%|        First argument.
   735|         0|            0|            0|  0.00%|    b : array_like
   736|         0|            0|            0|  0.00%|        Second argument.
   737|         0|            0|            0|  0.00%|    out : ndarray, optional
   738|         0|            0|            0|  0.00%|        Output argument. This must have the exact kind that would be returned
   739|         0|            0|            0|  0.00%|        if it was not used. In particular, it must have the right type, must be
   740|         0|            0|            0|  0.00%|        C-contiguous, and its dtype must be the dtype that would be returned
   741|         0|            0|            0|  0.00%|        for `dot(a,b)`. This is a performance feature. Therefore, if these
   742|         0|            0|            0|  0.00%|        conditions are not met, an exception is raised, instead of attempting
   743|         0|            0|            0|  0.00%|        to be flexible.
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|    Returns
   746|         0|            0|            0|  0.00%|    -------
   747|         0|            0|            0|  0.00%|    output : ndarray
   748|         0|            0|            0|  0.00%|        Returns the dot product of `a` and `b`.  If `a` and `b` are both
   749|         0|            0|            0|  0.00%|        scalars or both 1-D arrays then a scalar is returned; otherwise
   750|         0|            0|            0|  0.00%|        an array is returned.
   751|         0|            0|            0|  0.00%|        If `out` is given, then it is returned.
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|    Raises
   754|         0|            0|            0|  0.00%|    ------
   755|         0|            0|            0|  0.00%|    ValueError
   756|         0|            0|            0|  0.00%|        If the last dimension of `a` is not the same size as
   757|         0|            0|            0|  0.00%|        the second-to-last dimension of `b`.
   758|         0|            0|            0|  0.00%|
   759|         0|            0|            0|  0.00%|    See Also
   760|         0|            0|            0|  0.00%|    --------
   761|         0|            0|            0|  0.00%|    vdot : Complex-conjugating dot product.
   762|         0|            0|            0|  0.00%|    tensordot : Sum products over arbitrary axes.
   763|         0|            0|            0|  0.00%|    einsum : Einstein summation convention.
   764|         0|            0|            0|  0.00%|    matmul : '@' operator as method with out parameter.
   765|         0|            0|            0|  0.00%|
   766|         0|            0|            0|  0.00%|    Examples
   767|         0|            0|            0|  0.00%|    --------
   768|         0|            0|            0|  0.00%|    >>> np.dot(3, 4)
   769|         0|            0|            0|  0.00%|    12
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|    Neither argument is complex-conjugated:
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    >>> np.dot([2j, 3j], [2j, 3j])
   774|         0|            0|            0|  0.00%|    (-13+0j)
   775|         0|            0|            0|  0.00%|
   776|         0|            0|            0|  0.00%|    For 2-D arrays it is the matrix product:
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|    >>> a = [[1, 0], [0, 1]]
   779|         0|            0|            0|  0.00%|    >>> b = [[4, 1], [2, 2]]
   780|         0|            0|            0|  0.00%|    >>> np.dot(a, b)
   781|         0|            0|            0|  0.00%|    array([[4, 1],
   782|         0|            0|            0|  0.00%|           [2, 2]])
   783|         0|            0|            0|  0.00%|
   784|         0|            0|            0|  0.00%|    >>> a = np.arange(3*4*5*6).reshape((3,4,5,6))
   785|         0|            0|            0|  0.00%|    >>> b = np.arange(3*4*5*6)[::-1].reshape((5,4,6,3))
   786|         0|            0|            0|  0.00%|    >>> np.dot(a, b)[2,3,2,1,2,2]
   787|         0|            0|            0|  0.00%|    499128
   788|         0|            0|            0|  0.00%|    >>> sum(a[2,3,2,:] * b[1,2,:,2])
   789|         0|            0|            0|  0.00%|    499128
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|    """
   792|      4000|   0.00984168|  2.46042e-06|  0.18%|    return (a, b, out)
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.vdot)
   796|         0|            0|            0|  0.00%|def vdot(a, b):
   797|         0|            0|            0|  0.00%|    """
   798|         0|            0|            0|  0.00%|    vdot(a, b)
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    Return the dot product of two vectors.
   801|         0|            0|            0|  0.00%|
   802|         0|            0|            0|  0.00%|    The vdot(`a`, `b`) function handles complex numbers differently than
   803|         0|            0|            0|  0.00%|    dot(`a`, `b`).  If the first argument is complex the complex conjugate
   804|         0|            0|            0|  0.00%|    of the first argument is used for the calculation of the dot product.
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    Note that `vdot` handles multidimensional arrays differently than `dot`:
   807|         0|            0|            0|  0.00%|    it does *not* perform a matrix product, but flattens input arguments
   808|         0|            0|            0|  0.00%|    to 1-D vectors first. Consequently, it should only be used for vectors.
   809|         0|            0|            0|  0.00%|
   810|         0|            0|            0|  0.00%|    Parameters
   811|         0|            0|            0|  0.00%|    ----------
   812|         0|            0|            0|  0.00%|    a : array_like
   813|         0|            0|            0|  0.00%|        If `a` is complex the complex conjugate is taken before calculation
   814|         0|            0|            0|  0.00%|        of the dot product.
   815|         0|            0|            0|  0.00%|    b : array_like
   816|         0|            0|            0|  0.00%|        Second argument to the dot product.
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    Returns
   819|         0|            0|            0|  0.00%|    -------
   820|         0|            0|            0|  0.00%|    output : ndarray
   821|         0|            0|            0|  0.00%|        Dot product of `a` and `b`.  Can be an int, float, or
   822|         0|            0|            0|  0.00%|        complex depending on the types of `a` and `b`.
   823|         0|            0|            0|  0.00%|
   824|         0|            0|            0|  0.00%|    See Also
   825|         0|            0|            0|  0.00%|    --------
   826|         0|            0|            0|  0.00%|    dot : Return the dot product without using the complex conjugate of the
   827|         0|            0|            0|  0.00%|          first argument.
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    Examples
   830|         0|            0|            0|  0.00%|    --------
   831|         0|            0|            0|  0.00%|    >>> a = np.array([1+2j,3+4j])
   832|         0|            0|            0|  0.00%|    >>> b = np.array([5+6j,7+8j])
   833|         0|            0|            0|  0.00%|    >>> np.vdot(a, b)
   834|         0|            0|            0|  0.00%|    (70-8j)
   835|         0|            0|            0|  0.00%|    >>> np.vdot(b, a)
   836|         0|            0|            0|  0.00%|    (70+8j)
   837|         0|            0|            0|  0.00%|
   838|         0|            0|            0|  0.00%|    Note that higher-dimensional arrays are flattened!
   839|         0|            0|            0|  0.00%|
   840|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 4], [5, 6]])
   841|         0|            0|            0|  0.00%|    >>> b = np.array([[4, 1], [2, 2]])
   842|         0|            0|            0|  0.00%|    >>> np.vdot(a, b)
   843|         0|            0|            0|  0.00%|    30
   844|         0|            0|            0|  0.00%|    >>> np.vdot(b, a)
   845|         0|            0|            0|  0.00%|    30
   846|         0|            0|            0|  0.00%|    >>> 1*4 + 4*1 + 5*2 + 6*2
   847|         0|            0|            0|  0.00%|    30
   848|         0|            0|            0|  0.00%|
   849|         0|            0|            0|  0.00%|    """
   850|         0|            0|            0|  0.00%|    return (a, b)
   851|         0|            0|            0|  0.00%|
   852|         0|            0|            0|  0.00%|
   853|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.bincount)
   854|         0|            0|            0|  0.00%|def bincount(x, weights=None, minlength=None):
   855|         0|            0|            0|  0.00%|    """
   856|         0|            0|            0|  0.00%|    bincount(x, weights=None, minlength=0)
   857|         0|            0|            0|  0.00%|
   858|         0|            0|            0|  0.00%|    Count number of occurrences of each value in array of non-negative ints.
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|    The number of bins (of size 1) is one larger than the largest value in
   861|         0|            0|            0|  0.00%|    `x`. If `minlength` is specified, there will be at least this number
   862|         0|            0|            0|  0.00%|    of bins in the output array (though it will be longer if necessary,
   863|         0|            0|            0|  0.00%|    depending on the contents of `x`).
   864|         0|            0|            0|  0.00%|    Each bin gives the number of occurrences of its index value in `x`.
   865|         0|            0|            0|  0.00%|    If `weights` is specified the input array is weighted by it, i.e. if a
   866|         0|            0|            0|  0.00%|    value ``n`` is found at position ``i``, ``out[n] += weight[i]`` instead
   867|         0|            0|            0|  0.00%|    of ``out[n] += 1``.
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|    Parameters
   870|         0|            0|            0|  0.00%|    ----------
   871|         0|            0|            0|  0.00%|    x : array_like, 1 dimension, nonnegative ints
   872|         0|            0|            0|  0.00%|        Input array.
   873|         0|            0|            0|  0.00%|    weights : array_like, optional
   874|         0|            0|            0|  0.00%|        Weights, array of the same shape as `x`.
   875|         0|            0|            0|  0.00%|    minlength : int, optional
   876|         0|            0|            0|  0.00%|        A minimum number of bins for the output array.
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   879|         0|            0|            0|  0.00%|
   880|         0|            0|            0|  0.00%|    Returns
   881|         0|            0|            0|  0.00%|    -------
   882|         0|            0|            0|  0.00%|    out : ndarray of ints
   883|         0|            0|            0|  0.00%|        The result of binning the input array.
   884|         0|            0|            0|  0.00%|        The length of `out` is equal to ``np.amax(x)+1``.
   885|         0|            0|            0|  0.00%|
   886|         0|            0|            0|  0.00%|    Raises
   887|         0|            0|            0|  0.00%|    ------
   888|         0|            0|            0|  0.00%|    ValueError
   889|         0|            0|            0|  0.00%|        If the input is not 1-dimensional, or contains elements with negative
   890|         0|            0|            0|  0.00%|        values, or if `minlength` is negative.
   891|         0|            0|            0|  0.00%|    TypeError
   892|         0|            0|            0|  0.00%|        If the type of the input is float or complex.
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    See Also
   895|         0|            0|            0|  0.00%|    --------
   896|         0|            0|            0|  0.00%|    histogram, digitize, unique
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|    Examples
   899|         0|            0|            0|  0.00%|    --------
   900|         0|            0|            0|  0.00%|    >>> np.bincount(np.arange(5))
   901|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1])
   902|         0|            0|            0|  0.00%|    >>> np.bincount(np.array([0, 1, 1, 3, 2, 1, 7]))
   903|         0|            0|            0|  0.00%|    array([1, 3, 1, 1, 0, 0, 0, 1])
   904|         0|            0|            0|  0.00%|
   905|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 1, 3, 2, 1, 7, 23])
   906|         0|            0|            0|  0.00%|    >>> np.bincount(x).size == np.amax(x)+1
   907|         0|            0|            0|  0.00%|    True
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    The input array needs to be of integer dtype, otherwise a
   910|         0|            0|            0|  0.00%|    TypeError is raised:
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|    >>> np.bincount(np.arange(5, dtype=float))
   913|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   914|         0|            0|            0|  0.00%|      File "<stdin>", line 1, in <module>
   915|         0|            0|            0|  0.00%|    TypeError: array cannot be safely cast to required type
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|    A possible use of ``bincount`` is to perform sums over
   918|         0|            0|            0|  0.00%|    variable-size chunks of an array, using the ``weights`` keyword.
   919|         0|            0|            0|  0.00%|
   920|         0|            0|            0|  0.00%|    >>> w = np.array([0.3, 0.5, 0.2, 0.7, 1., -0.6]) # weights
   921|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 1, 2, 2, 2])
   922|         0|            0|            0|  0.00%|    >>> np.bincount(x,  weights=w)
   923|         0|            0|            0|  0.00%|    array([ 0.3,  0.7,  1.1])
   924|         0|            0|            0|  0.00%|
   925|         0|            0|            0|  0.00%|    """
   926|         0|            0|            0|  0.00%|    return (x, weights)
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.ravel_multi_index)
   930|         0|            0|            0|  0.00%|def ravel_multi_index(multi_index, dims, mode=None, order=None):
   931|         0|            0|            0|  0.00%|    """
   932|         0|            0|            0|  0.00%|    ravel_multi_index(multi_index, dims, mode='raise', order='C')
   933|         0|            0|            0|  0.00%|
   934|         0|            0|            0|  0.00%|    Converts a tuple of index arrays into an array of flat
   935|         0|            0|            0|  0.00%|    indices, applying boundary modes to the multi-index.
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    Parameters
   938|         0|            0|            0|  0.00%|    ----------
   939|         0|            0|            0|  0.00%|    multi_index : tuple of array_like
   940|         0|            0|            0|  0.00%|        A tuple of integer arrays, one array for each dimension.
   941|         0|            0|            0|  0.00%|    dims : tuple of ints
   942|         0|            0|            0|  0.00%|        The shape of array into which the indices from ``multi_index`` apply.
   943|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   944|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices are handled.  Can specify
   945|         0|            0|            0|  0.00%|        either one mode or a tuple of modes, one mode per index.
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   948|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   949|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|        In 'clip' mode, a negative index which would normally
   952|         0|            0|            0|  0.00%|        wrap will clip to 0 instead.
   953|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   954|         0|            0|            0|  0.00%|        Determines whether the multi-index should be viewed as
   955|         0|            0|            0|  0.00%|        indexing in row-major (C-style) or column-major
   956|         0|            0|            0|  0.00%|        (Fortran-style) order.
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|    Returns
   959|         0|            0|            0|  0.00%|    -------
   960|         0|            0|            0|  0.00%|    raveled_indices : ndarray
   961|         0|            0|            0|  0.00%|        An array of indices into the flattened version of an array
   962|         0|            0|            0|  0.00%|        of dimensions ``dims``.
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|    See Also
   965|         0|            0|            0|  0.00%|    --------
   966|         0|            0|            0|  0.00%|    unravel_index
   967|         0|            0|            0|  0.00%|
   968|         0|            0|            0|  0.00%|    Notes
   969|         0|            0|            0|  0.00%|    -----
   970|         0|            0|            0|  0.00%|    .. versionadded:: 1.6.0
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|    Examples
   973|         0|            0|            0|  0.00%|    --------
   974|         0|            0|            0|  0.00%|    >>> arr = np.array([[3,6,6],[4,5,1]])
   975|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (7,6))
   976|         0|            0|            0|  0.00%|    array([22, 41, 37])
   977|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (7,6), order='F')
   978|         0|            0|            0|  0.00%|    array([31, 41, 13])
   979|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (4,6), mode='clip')
   980|         0|            0|            0|  0.00%|    array([22, 23, 19])
   981|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index(arr, (4,4), mode=('clip','wrap'))
   982|         0|            0|            0|  0.00%|    array([12, 13, 13])
   983|         0|            0|            0|  0.00%|
   984|         0|            0|            0|  0.00%|    >>> np.ravel_multi_index((3,1,4,1), (6,7,8,9))
   985|         0|            0|            0|  0.00%|    1621
   986|         0|            0|            0|  0.00%|    """
   987|         0|            0|            0|  0.00%|    return multi_index
   988|         0|            0|            0|  0.00%|
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.unravel_index)
   991|         0|            0|            0|  0.00%|def unravel_index(indices, shape=None, order=None, dims=None):
   992|         0|            0|            0|  0.00%|    """
   993|         0|            0|            0|  0.00%|    unravel_index(indices, shape, order='C')
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    Converts a flat index or array of flat indices into a tuple
   996|         0|            0|            0|  0.00%|    of coordinate arrays.
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|    Parameters
   999|         0|            0|            0|  0.00%|    ----------
  1000|         0|            0|            0|  0.00%|    indices : array_like
  1001|         0|            0|            0|  0.00%|        An integer array whose elements are indices into the flattened
  1002|         0|            0|            0|  0.00%|        version of an array of dimensions ``shape``. Before version 1.6.0,
  1003|         0|            0|            0|  0.00%|        this function accepted just one index value.
  1004|         0|            0|            0|  0.00%|    shape : tuple of ints
  1005|         0|            0|            0|  0.00%|        The shape of the array to use for unraveling ``indices``.
  1006|         0|            0|            0|  0.00%|
  1007|         0|            0|            0|  0.00%|        .. versionchanged:: 1.16.0
  1008|         0|            0|            0|  0.00%|            Renamed from ``dims`` to ``shape``.
  1009|         0|            0|            0|  0.00%|
  1010|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
  1011|         0|            0|            0|  0.00%|        Determines whether the indices should be viewed as indexing in
  1012|         0|            0|            0|  0.00%|        row-major (C-style) or column-major (Fortran-style) order.
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|    Returns
  1017|         0|            0|            0|  0.00%|    -------
  1018|         0|            0|            0|  0.00%|    unraveled_coords : tuple of ndarray
  1019|         0|            0|            0|  0.00%|        Each array in the tuple has the same shape as the ``indices``
  1020|         0|            0|            0|  0.00%|        array.
  1021|         0|            0|            0|  0.00%|
  1022|         0|            0|            0|  0.00%|    See Also
  1023|         0|            0|            0|  0.00%|    --------
  1024|         0|            0|            0|  0.00%|    ravel_multi_index
  1025|         0|            0|            0|  0.00%|
  1026|         0|            0|            0|  0.00%|    Examples
  1027|         0|            0|            0|  0.00%|    --------
  1028|         0|            0|            0|  0.00%|    >>> np.unravel_index([22, 41, 37], (7,6))
  1029|         0|            0|            0|  0.00%|    (array([3, 6, 6]), array([4, 5, 1]))
  1030|         0|            0|            0|  0.00%|    >>> np.unravel_index([31, 41, 13], (7,6), order='F')
  1031|         0|            0|            0|  0.00%|    (array([3, 6, 6]), array([4, 5, 1]))
  1032|         0|            0|            0|  0.00%|
  1033|         0|            0|            0|  0.00%|    >>> np.unravel_index(1621, (6,7,8,9))
  1034|         0|            0|            0|  0.00%|    (3, 1, 4, 1)
  1035|         0|            0|            0|  0.00%|
  1036|         0|            0|            0|  0.00%|    """
  1037|         0|            0|            0|  0.00%|    if dims is not None:
  1038|         0|            0|            0|  0.00%|        warnings.warn("'shape' argument should be used instead of 'dims'",
  1039|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=3)
  1040|         0|            0|            0|  0.00%|    return (indices,)
  1041|         0|            0|            0|  0.00%|
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.copyto)
  1044|         0|            0|            0|  0.00%|def copyto(dst, src, casting=None, where=None):
  1045|         0|            0|            0|  0.00%|    """
  1046|         0|            0|            0|  0.00%|    copyto(dst, src, casting='same_kind', where=True)
  1047|         0|            0|            0|  0.00%|
  1048|         0|            0|            0|  0.00%|    Copies values from one array to another, broadcasting as necessary.
  1049|         0|            0|            0|  0.00%|
  1050|         0|            0|            0|  0.00%|    Raises a TypeError if the `casting` rule is violated, and if
  1051|         0|            0|            0|  0.00%|    `where` is provided, it selects which elements to copy.
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|    Parameters
  1056|         0|            0|            0|  0.00%|    ----------
  1057|         0|            0|            0|  0.00%|    dst : ndarray
  1058|         0|            0|            0|  0.00%|        The array into which values are copied.
  1059|         0|            0|            0|  0.00%|    src : array_like
  1060|         0|            0|            0|  0.00%|        The array from which values are copied.
  1061|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}, optional
  1062|         0|            0|            0|  0.00%|        Controls what kind of data casting may occur when copying.
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|          * 'no' means the data types should not be cast at all.
  1065|         0|            0|            0|  0.00%|          * 'equiv' means only byte-order changes are allowed.
  1066|         0|            0|            0|  0.00%|          * 'safe' means only casts which can preserve values are allowed.
  1067|         0|            0|            0|  0.00%|          * 'same_kind' means only safe casts or casts within a kind,
  1068|         0|            0|            0|  0.00%|            like float64 to float32, are allowed.
  1069|         0|            0|            0|  0.00%|          * 'unsafe' means any data conversions may be done.
  1070|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  1071|         0|            0|            0|  0.00%|        A boolean array which is broadcasted to match the dimensions
  1072|         0|            0|            0|  0.00%|        of `dst`, and selects elements to copy from `src` to `dst`
  1073|         0|            0|            0|  0.00%|        wherever it contains the value True.
  1074|         0|            0|            0|  0.00%|    """
  1075|         0|            0|            0|  0.00%|    return (dst, src, where)
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.putmask)
  1079|         0|            0|            0|  0.00%|def putmask(a, mask, values):
  1080|         0|            0|            0|  0.00%|    """
  1081|         0|            0|            0|  0.00%|    putmask(a, mask, values)
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    Changes elements of an array based on conditional and input values.
  1084|         0|            0|            0|  0.00%|
  1085|         0|            0|            0|  0.00%|    Sets ``a.flat[n] = values[n]`` for each n where ``mask.flat[n]==True``.
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|    If `values` is not the same size as `a` and `mask` then it will repeat.
  1088|         0|            0|            0|  0.00%|    This gives behavior different from ``a[mask] = values``.
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|    Parameters
  1091|         0|            0|            0|  0.00%|    ----------
  1092|         0|            0|            0|  0.00%|    a : array_like
  1093|         0|            0|            0|  0.00%|        Target array.
  1094|         0|            0|            0|  0.00%|    mask : array_like
  1095|         0|            0|            0|  0.00%|        Boolean mask array. It has to be the same shape as `a`.
  1096|         0|            0|            0|  0.00%|    values : array_like
  1097|         0|            0|            0|  0.00%|        Values to put into `a` where `mask` is True. If `values` is smaller
  1098|         0|            0|            0|  0.00%|        than `a` it will be repeated.
  1099|         0|            0|            0|  0.00%|
  1100|         0|            0|            0|  0.00%|    See Also
  1101|         0|            0|            0|  0.00%|    --------
  1102|         0|            0|            0|  0.00%|    place, put, take, copyto
  1103|         0|            0|            0|  0.00%|
  1104|         0|            0|            0|  0.00%|    Examples
  1105|         0|            0|            0|  0.00%|    --------
  1106|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2, 3)
  1107|         0|            0|            0|  0.00%|    >>> np.putmask(x, x>2, x**2)
  1108|         0|            0|            0|  0.00%|    >>> x
  1109|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
  1110|         0|            0|            0|  0.00%|           [ 9, 16, 25]])
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|    If `values` is smaller than `a` it is repeated:
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|    >>> x = np.arange(5)
  1115|         0|            0|            0|  0.00%|    >>> np.putmask(x, x>1, [-33, -44])
  1116|         0|            0|            0|  0.00%|    >>> x
  1117|         0|            0|            0|  0.00%|    array([  0,   1, -33, -44, -33])
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    """
  1120|         0|            0|            0|  0.00%|    return (a, mask, values)
  1121|         0|            0|            0|  0.00%|
  1122|         0|            0|            0|  0.00%|
  1123|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.packbits)
  1124|         0|            0|            0|  0.00%|def packbits(a, axis=None, bitorder='big'):
  1125|         0|            0|            0|  0.00%|    """
  1126|         0|            0|            0|  0.00%|    packbits(a, axis=None, bitorder='big')
  1127|         0|            0|            0|  0.00%|
  1128|         0|            0|            0|  0.00%|    Packs the elements of a binary-valued array into bits in a uint8 array.
  1129|         0|            0|            0|  0.00%|
  1130|         0|            0|            0|  0.00%|    The result is padded to full bytes by inserting zero bits at the end.
  1131|         0|            0|            0|  0.00%|
  1132|         0|            0|            0|  0.00%|    Parameters
  1133|         0|            0|            0|  0.00%|    ----------
  1134|         0|            0|            0|  0.00%|    a : array_like
  1135|         0|            0|            0|  0.00%|        An array of integers or booleans whose elements should be packed to
  1136|         0|            0|            0|  0.00%|        bits.
  1137|         0|            0|            0|  0.00%|    axis : int, optional
  1138|         0|            0|            0|  0.00%|        The dimension over which bit-packing is done.
  1139|         0|            0|            0|  0.00%|        ``None`` implies packing the flattened array.
  1140|         0|            0|            0|  0.00%|    bitorder : {'big', 'little'}, optional
  1141|         0|            0|            0|  0.00%|        The order of the input bits. 'big' will mimic bin(val),
  1142|         0|            0|            0|  0.00%|        ``[0, 0, 0, 0, 0, 0, 1, 1] => 3 = 0b00000011 => ``, 'little' will
  1143|         0|            0|            0|  0.00%|        reverse the order so ``[1, 1, 0, 0, 0, 0, 0, 0] => 3``.
  1144|         0|            0|            0|  0.00%|        Defaults to 'big'.
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1147|         0|            0|            0|  0.00%|
  1148|         0|            0|            0|  0.00%|    Returns
  1149|         0|            0|            0|  0.00%|    -------
  1150|         0|            0|            0|  0.00%|    packed : ndarray
  1151|         0|            0|            0|  0.00%|        Array of type uint8 whose elements represent bits corresponding to the
  1152|         0|            0|            0|  0.00%|        logical (0 or nonzero) value of the input elements. The shape of
  1153|         0|            0|            0|  0.00%|        `packed` has the same number of dimensions as the input (unless `axis`
  1154|         0|            0|            0|  0.00%|        is None, in which case the output is 1-D).
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    See Also
  1157|         0|            0|            0|  0.00%|    --------
  1158|         0|            0|            0|  0.00%|    unpackbits: Unpacks elements of a uint8 array into a binary-valued output
  1159|         0|            0|            0|  0.00%|                array.
  1160|         0|            0|            0|  0.00%|
  1161|         0|            0|            0|  0.00%|    Examples
  1162|         0|            0|            0|  0.00%|    --------
  1163|         0|            0|            0|  0.00%|    >>> a = np.array([[[1,0,1],
  1164|         0|            0|            0|  0.00%|    ...                [0,1,0]],
  1165|         0|            0|            0|  0.00%|    ...               [[1,1,0],
  1166|         0|            0|            0|  0.00%|    ...                [0,0,1]]])
  1167|         0|            0|            0|  0.00%|    >>> b = np.packbits(a, axis=-1)
  1168|         0|            0|            0|  0.00%|    >>> b
  1169|         0|            0|            0|  0.00%|    array([[[160],
  1170|         0|            0|            0|  0.00%|            [ 64]],
  1171|         0|            0|            0|  0.00%|           [[192],
  1172|         0|            0|            0|  0.00%|            [ 32]]], dtype=uint8)
  1173|         0|            0|            0|  0.00%|
  1174|         0|            0|            0|  0.00%|    Note that in binary 160 = 1010 0000, 64 = 0100 0000, 192 = 1100 0000,
  1175|         0|            0|            0|  0.00%|    and 32 = 0010 0000.
  1176|         0|            0|            0|  0.00%|
  1177|         0|            0|            0|  0.00%|    """
  1178|         0|            0|            0|  0.00%|    return (a,)
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.unpackbits)
  1182|         0|            0|            0|  0.00%|def unpackbits(a, axis=None, count=None, bitorder='big'):
  1183|         0|            0|            0|  0.00%|    """
  1184|         0|            0|            0|  0.00%|    unpackbits(a, axis=None, count=None, bitorder='big')
  1185|         0|            0|            0|  0.00%|
  1186|         0|            0|            0|  0.00%|    Unpacks elements of a uint8 array into a binary-valued output array.
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|    Each element of `a` represents a bit-field that should be unpacked
  1189|         0|            0|            0|  0.00%|    into a binary-valued output array. The shape of the output array is
  1190|         0|            0|            0|  0.00%|    either 1-D (if `axis` is ``None``) or the same shape as the input
  1191|         0|            0|            0|  0.00%|    array with unpacking done along the axis specified.
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    Parameters
  1194|         0|            0|            0|  0.00%|    ----------
  1195|         0|            0|            0|  0.00%|    a : ndarray, uint8 type
  1196|         0|            0|            0|  0.00%|       Input array.
  1197|         0|            0|            0|  0.00%|    axis : int, optional
  1198|         0|            0|            0|  0.00%|        The dimension over which bit-unpacking is done.
  1199|         0|            0|            0|  0.00%|        ``None`` implies unpacking the flattened array.
  1200|         0|            0|            0|  0.00%|    count : int or None, optional
  1201|         0|            0|            0|  0.00%|        The number of elements to unpack along `axis`, provided as a way
  1202|         0|            0|            0|  0.00%|        of undoing the effect of packing a size that is not a multiple
  1203|         0|            0|            0|  0.00%|        of eight. A non-negative number means to only unpack `count`
  1204|         0|            0|            0|  0.00%|        bits. A negative number means to trim off that many bits from
  1205|         0|            0|            0|  0.00%|        the end. ``None`` means to unpack the entire array (the
  1206|         0|            0|            0|  0.00%|        default). Counts larger than the available number of bits will
  1207|         0|            0|            0|  0.00%|        add zero padding to the output. Negative counts must not
  1208|         0|            0|            0|  0.00%|        exceed the available number of bits.
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1211|         0|            0|            0|  0.00%|
  1212|         0|            0|            0|  0.00%|    bitorder : {'big', 'little'}, optional
  1213|         0|            0|            0|  0.00%|        The order of the returned bits. 'big' will mimic bin(val),
  1214|         0|            0|            0|  0.00%|        ``3 = 0b00000011 => [0, 0, 0, 0, 0, 0, 1, 1]``, 'little' will reverse
  1215|         0|            0|            0|  0.00%|        the order to ``[1, 1, 0, 0, 0, 0, 0, 0]``.
  1216|         0|            0|            0|  0.00%|        Defaults to 'big'.
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|    Returns
  1221|         0|            0|            0|  0.00%|    -------
  1222|         0|            0|            0|  0.00%|    unpacked : ndarray, uint8 type
  1223|         0|            0|            0|  0.00%|       The elements are binary-valued (0 or 1).
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|    See Also
  1226|         0|            0|            0|  0.00%|    --------
  1227|         0|            0|            0|  0.00%|    packbits : Packs the elements of a binary-valued array into bits in
  1228|         0|            0|            0|  0.00%|               a uint8 array.
  1229|         0|            0|            0|  0.00%|
  1230|         0|            0|            0|  0.00%|    Examples
  1231|         0|            0|            0|  0.00%|    --------
  1232|         0|            0|            0|  0.00%|    >>> a = np.array([[2], [7], [23]], dtype=np.uint8)
  1233|         0|            0|            0|  0.00%|    >>> a
  1234|         0|            0|            0|  0.00%|    array([[ 2],
  1235|         0|            0|            0|  0.00%|           [ 7],
  1236|         0|            0|            0|  0.00%|           [23]], dtype=uint8)
  1237|         0|            0|            0|  0.00%|    >>> b = np.unpackbits(a, axis=1)
  1238|         0|            0|            0|  0.00%|    >>> b
  1239|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0, 0, 1, 0],
  1240|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 1, 1, 1],
  1241|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0, 1, 1, 1]], dtype=uint8)
  1242|         0|            0|            0|  0.00%|    >>> c = np.unpackbits(a, axis=1, count=-3)
  1243|         0|            0|            0|  0.00%|    >>> c
  1244|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0],
  1245|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0],
  1246|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0]], dtype=uint8)
  1247|         0|            0|            0|  0.00%|
  1248|         0|            0|            0|  0.00%|    >>> p = np.packbits(b, axis=0)
  1249|         0|            0|            0|  0.00%|    >>> np.unpackbits(p, axis=0)
  1250|         0|            0|            0|  0.00%|    array([[0, 0, 0, 0, 0, 0, 1, 0],
  1251|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 1, 1, 1],
  1252|         0|            0|            0|  0.00%|           [0, 0, 0, 1, 0, 1, 1, 1],
  1253|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1254|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1255|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1256|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0],
  1257|         0|            0|            0|  0.00%|           [0, 0, 0, 0, 0, 0, 0, 0]], dtype=uint8)
  1258|         0|            0|            0|  0.00%|    >>> np.array_equal(b, np.unpackbits(p, axis=0, count=b.shape[0]))
  1259|         0|            0|            0|  0.00%|    True
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|    """
  1262|         0|            0|            0|  0.00%|    return (a,)
  1263|         0|            0|            0|  0.00%|
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.shares_memory)
  1266|         0|            0|            0|  0.00%|def shares_memory(a, b, max_work=None):
  1267|         0|            0|            0|  0.00%|    """
  1268|         0|            0|            0|  0.00%|    shares_memory(a, b, max_work=None)
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|    Determine if two arrays share memory
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|    Parameters
  1273|         0|            0|            0|  0.00%|    ----------
  1274|         0|            0|            0|  0.00%|    a, b : ndarray
  1275|         0|            0|            0|  0.00%|        Input arrays
  1276|         0|            0|            0|  0.00%|    max_work : int, optional
  1277|         0|            0|            0|  0.00%|        Effort to spend on solving the overlap problem (maximum number
  1278|         0|            0|            0|  0.00%|        of candidate solutions to consider). The following special
  1279|         0|            0|            0|  0.00%|        values are recognized:
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|        max_work=MAY_SHARE_EXACT  (default)
  1282|         0|            0|            0|  0.00%|            The problem is solved exactly. In this case, the function returns
  1283|         0|            0|            0|  0.00%|            True only if there is an element shared between the arrays.
  1284|         0|            0|            0|  0.00%|        max_work=MAY_SHARE_BOUNDS
  1285|         0|            0|            0|  0.00%|            Only the memory bounds of a and b are checked.
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    Raises
  1288|         0|            0|            0|  0.00%|    ------
  1289|         0|            0|            0|  0.00%|    numpy.TooHardError
  1290|         0|            0|            0|  0.00%|        Exceeded max_work.
  1291|         0|            0|            0|  0.00%|
  1292|         0|            0|            0|  0.00%|    Returns
  1293|         0|            0|            0|  0.00%|    -------
  1294|         0|            0|            0|  0.00%|    out : bool
  1295|         0|            0|            0|  0.00%|
  1296|         0|            0|            0|  0.00%|    See Also
  1297|         0|            0|            0|  0.00%|    --------
  1298|         0|            0|            0|  0.00%|    may_share_memory
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    Examples
  1301|         0|            0|            0|  0.00%|    --------
  1302|         0|            0|            0|  0.00%|    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
  1303|         0|            0|            0|  0.00%|    False
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|    """
  1306|         0|            0|            0|  0.00%|    return (a, b)
  1307|         0|            0|            0|  0.00%|
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.may_share_memory)
  1310|         0|            0|            0|  0.00%|def may_share_memory(a, b, max_work=None):
  1311|         0|            0|            0|  0.00%|    """
  1312|         0|            0|            0|  0.00%|    may_share_memory(a, b, max_work=None)
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|    Determine if two arrays might share memory
  1315|         0|            0|            0|  0.00%|
  1316|         0|            0|            0|  0.00%|    A return of True does not necessarily mean that the two arrays
  1317|         0|            0|            0|  0.00%|    share any element.  It just means that they *might*.
  1318|         0|            0|            0|  0.00%|
  1319|         0|            0|            0|  0.00%|    Only the memory bounds of a and b are checked by default.
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|    Parameters
  1322|         0|            0|            0|  0.00%|    ----------
  1323|         0|            0|            0|  0.00%|    a, b : ndarray
  1324|         0|            0|            0|  0.00%|        Input arrays
  1325|         0|            0|            0|  0.00%|    max_work : int, optional
  1326|         0|            0|            0|  0.00%|        Effort to spend on solving the overlap problem.  See
  1327|         0|            0|            0|  0.00%|        `shares_memory` for details.  Default for ``may_share_memory``
  1328|         0|            0|            0|  0.00%|        is to do a bounds check.
  1329|         0|            0|            0|  0.00%|
  1330|         0|            0|            0|  0.00%|    Returns
  1331|         0|            0|            0|  0.00%|    -------
  1332|         0|            0|            0|  0.00%|    out : bool
  1333|         0|            0|            0|  0.00%|
  1334|         0|            0|            0|  0.00%|    See Also
  1335|         0|            0|            0|  0.00%|    --------
  1336|         0|            0|            0|  0.00%|    shares_memory
  1337|         0|            0|            0|  0.00%|
  1338|         0|            0|            0|  0.00%|    Examples
  1339|         0|            0|            0|  0.00%|    --------
  1340|         0|            0|            0|  0.00%|    >>> np.may_share_memory(np.array([1,2]), np.array([5,8,9]))
  1341|         0|            0|            0|  0.00%|    False
  1342|         0|            0|            0|  0.00%|    >>> x = np.zeros([3, 4])
  1343|         0|            0|            0|  0.00%|    >>> np.may_share_memory(x[:,0], x[:,1])
  1344|         0|            0|            0|  0.00%|    True
  1345|         0|            0|            0|  0.00%|
  1346|         0|            0|            0|  0.00%|    """
  1347|         0|            0|            0|  0.00%|    return (a, b)
  1348|         0|            0|            0|  0.00%|
  1349|         0|            0|            0|  0.00%|
  1350|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.is_busday)
  1351|         0|            0|            0|  0.00%|def is_busday(dates, weekmask=None, holidays=None, busdaycal=None, out=None):
  1352|         0|            0|            0|  0.00%|    """
  1353|         0|            0|            0|  0.00%|    is_busday(dates, weekmask='1111100', holidays=None, busdaycal=None, out=None)
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|    Calculates which of the given dates are valid days, and which are not.
  1356|         0|            0|            0|  0.00%|
  1357|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1358|         0|            0|            0|  0.00%|
  1359|         0|            0|            0|  0.00%|    Parameters
  1360|         0|            0|            0|  0.00%|    ----------
  1361|         0|            0|            0|  0.00%|    dates : array_like of datetime64[D]
  1362|         0|            0|            0|  0.00%|        The array of dates to process.
  1363|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1364|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1365|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1366|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1367|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1368|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1369|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1370|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1371|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1372|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1373|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1374|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1375|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1376|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1377|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1378|         0|            0|            0|  0.00%|        provided.
  1379|         0|            0|            0|  0.00%|    out : array of bool, optional
  1380|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1381|         0|            0|            0|  0.00%|
  1382|         0|            0|            0|  0.00%|    Returns
  1383|         0|            0|            0|  0.00%|    -------
  1384|         0|            0|            0|  0.00%|    out : array of bool
  1385|         0|            0|            0|  0.00%|        An array with the same shape as ``dates``, containing True for
  1386|         0|            0|            0|  0.00%|        each valid day, and False for each invalid day.
  1387|         0|            0|            0|  0.00%|
  1388|         0|            0|            0|  0.00%|    See Also
  1389|         0|            0|            0|  0.00%|    --------
  1390|         0|            0|            0|  0.00%|    busdaycalendar: An object that specifies a custom set of valid days.
  1391|         0|            0|            0|  0.00%|    busday_offset : Applies an offset counted in valid days.
  1392|         0|            0|            0|  0.00%|    busday_count : Counts how many valid days are in a half-open date range.
  1393|         0|            0|            0|  0.00%|
  1394|         0|            0|            0|  0.00%|    Examples
  1395|         0|            0|            0|  0.00%|    --------
  1396|         0|            0|            0|  0.00%|    >>> # The weekdays are Friday, Saturday, and Monday
  1397|         0|            0|            0|  0.00%|    ... np.is_busday(['2011-07-01', '2011-07-02', '2011-07-18'],
  1398|         0|            0|            0|  0.00%|    ...                 holidays=['2011-07-01', '2011-07-04', '2011-07-17'])
  1399|         0|            0|            0|  0.00%|    array([False, False,  True])
  1400|         0|            0|            0|  0.00%|    """
  1401|         0|            0|            0|  0.00%|    return (dates, weekmask, holidays, out)
  1402|         0|            0|            0|  0.00%|
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_offset)
  1405|         0|            0|            0|  0.00%|def busday_offset(dates, offsets, roll=None, weekmask=None, holidays=None,
  1406|         0|            0|            0|  0.00%|                  busdaycal=None, out=None):
  1407|         0|            0|            0|  0.00%|    """
  1408|         0|            0|            0|  0.00%|    busday_offset(dates, offsets, roll='raise', weekmask='1111100', holidays=None, busdaycal=None, out=None)
  1409|         0|            0|            0|  0.00%|
  1410|         0|            0|            0|  0.00%|    First adjusts the date to fall on a valid day according to
  1411|         0|            0|            0|  0.00%|    the ``roll`` rule, then applies offsets to the given dates
  1412|         0|            0|            0|  0.00%|    counted in valid days.
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|    Parameters
  1417|         0|            0|            0|  0.00%|    ----------
  1418|         0|            0|            0|  0.00%|    dates : array_like of datetime64[D]
  1419|         0|            0|            0|  0.00%|        The array of dates to process.
  1420|         0|            0|            0|  0.00%|    offsets : array_like of int
  1421|         0|            0|            0|  0.00%|        The array of offsets, which is broadcast with ``dates``.
  1422|         0|            0|            0|  0.00%|    roll : {'raise', 'nat', 'forward', 'following', 'backward', 'preceding', 'modifiedfollowing', 'modifiedpreceding'}, optional
  1423|         0|            0|            0|  0.00%|        How to treat dates that do not fall on a valid day. The default
  1424|         0|            0|            0|  0.00%|        is 'raise'.
  1425|         0|            0|            0|  0.00%|
  1426|         0|            0|            0|  0.00%|          * 'raise' means to raise an exception for an invalid day.
  1427|         0|            0|            0|  0.00%|          * 'nat' means to return a NaT (not-a-time) for an invalid day.
  1428|         0|            0|            0|  0.00%|          * 'forward' and 'following' mean to take the first valid day
  1429|         0|            0|            0|  0.00%|            later in time.
  1430|         0|            0|            0|  0.00%|          * 'backward' and 'preceding' mean to take the first valid day
  1431|         0|            0|            0|  0.00%|            earlier in time.
  1432|         0|            0|            0|  0.00%|          * 'modifiedfollowing' means to take the first valid day
  1433|         0|            0|            0|  0.00%|            later in time unless it is across a Month boundary, in which
  1434|         0|            0|            0|  0.00%|            case to take the first valid day earlier in time.
  1435|         0|            0|            0|  0.00%|          * 'modifiedpreceding' means to take the first valid day
  1436|         0|            0|            0|  0.00%|            earlier in time unless it is across a Month boundary, in which
  1437|         0|            0|            0|  0.00%|            case to take the first valid day later in time.
  1438|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1439|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1440|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1441|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1442|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1443|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1444|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1445|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1446|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1447|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1448|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1449|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1450|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1451|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1452|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1453|         0|            0|            0|  0.00%|        provided.
  1454|         0|            0|            0|  0.00%|    out : array of datetime64[D], optional
  1455|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1456|         0|            0|            0|  0.00%|
  1457|         0|            0|            0|  0.00%|    Returns
  1458|         0|            0|            0|  0.00%|    -------
  1459|         0|            0|            0|  0.00%|    out : array of datetime64[D]
  1460|         0|            0|            0|  0.00%|        An array with a shape from broadcasting ``dates`` and ``offsets``
  1461|         0|            0|            0|  0.00%|        together, containing the dates with offsets applied.
  1462|         0|            0|            0|  0.00%|
  1463|         0|            0|            0|  0.00%|    See Also
  1464|         0|            0|            0|  0.00%|    --------
  1465|         0|            0|            0|  0.00%|    busdaycalendar: An object that specifies a custom set of valid days.
  1466|         0|            0|            0|  0.00%|    is_busday : Returns a boolean array indicating valid days.
  1467|         0|            0|            0|  0.00%|    busday_count : Counts how many valid days are in a half-open date range.
  1468|         0|            0|            0|  0.00%|
  1469|         0|            0|            0|  0.00%|    Examples
  1470|         0|            0|            0|  0.00%|    --------
  1471|         0|            0|            0|  0.00%|    >>> # First business day in October 2011 (not accounting for holidays)
  1472|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-10', 0, roll='forward')
  1473|         0|            0|            0|  0.00%|    numpy.datetime64('2011-10-03')
  1474|         0|            0|            0|  0.00%|    >>> # Last business day in February 2012 (not accounting for holidays)
  1475|         0|            0|            0|  0.00%|    ... np.busday_offset('2012-03', -1, roll='forward')
  1476|         0|            0|            0|  0.00%|    numpy.datetime64('2012-02-29')
  1477|         0|            0|            0|  0.00%|    >>> # Third Wednesday in January 2011
  1478|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-01', 2, roll='forward', weekmask='Wed')
  1479|         0|            0|            0|  0.00%|    numpy.datetime64('2011-01-19')
  1480|         0|            0|            0|  0.00%|    >>> # 2012 Mother's Day in Canada and the U.S.
  1481|         0|            0|            0|  0.00%|    ... np.busday_offset('2012-05', 1, roll='forward', weekmask='Sun')
  1482|         0|            0|            0|  0.00%|    numpy.datetime64('2012-05-13')
  1483|         0|            0|            0|  0.00%|
  1484|         0|            0|            0|  0.00%|    >>> # First business day on or after a date
  1485|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-03-20', 0, roll='forward')
  1486|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-21')
  1487|         0|            0|            0|  0.00%|    >>> np.busday_offset('2011-03-22', 0, roll='forward')
  1488|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-22')
  1489|         0|            0|            0|  0.00%|    >>> # First business day after a date
  1490|         0|            0|            0|  0.00%|    ... np.busday_offset('2011-03-20', 1, roll='backward')
  1491|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-21')
  1492|         0|            0|            0|  0.00%|    >>> np.busday_offset('2011-03-22', 1, roll='backward')
  1493|         0|            0|            0|  0.00%|    numpy.datetime64('2011-03-23')
  1494|         0|            0|            0|  0.00%|    """
  1495|         0|            0|            0|  0.00%|    return (dates, offsets, weekmask, holidays, out)
  1496|         0|            0|            0|  0.00%|
  1497|         0|            0|            0|  0.00%|
  1498|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(_multiarray_umath.busday_count)
  1499|         0|            0|            0|  0.00%|def busday_count(begindates, enddates, weekmask=None, holidays=None,
  1500|         0|            0|            0|  0.00%|                 busdaycal=None, out=None):
  1501|         0|            0|            0|  0.00%|    """
  1502|         0|            0|            0|  0.00%|    busday_count(begindates, enddates, weekmask='1111100', holidays=[], busdaycal=None, out=None)
  1503|         0|            0|            0|  0.00%|
  1504|         0|            0|            0|  0.00%|    Counts the number of valid days between `begindates` and
  1505|         0|            0|            0|  0.00%|    `enddates`, not including the day of `enddates`.
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|    If ``enddates`` specifies a date value that is earlier than the
  1508|         0|            0|            0|  0.00%|    corresponding ``begindates`` date value, the count will be negative.
  1509|         0|            0|            0|  0.00%|
  1510|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  1511|         0|            0|            0|  0.00%|
  1512|         0|            0|            0|  0.00%|    Parameters
  1513|         0|            0|            0|  0.00%|    ----------
  1514|         0|            0|            0|  0.00%|    begindates : array_like of datetime64[D]
  1515|         0|            0|            0|  0.00%|        The array of the first dates for counting.
  1516|         0|            0|            0|  0.00%|    enddates : array_like of datetime64[D]
  1517|         0|            0|            0|  0.00%|        The array of the end dates for counting, which are excluded
  1518|         0|            0|            0|  0.00%|        from the count themselves.
  1519|         0|            0|            0|  0.00%|    weekmask : str or array_like of bool, optional
  1520|         0|            0|            0|  0.00%|        A seven-element array indicating which of Monday through Sunday are
  1521|         0|            0|            0|  0.00%|        valid days. May be specified as a length-seven list or array, like
  1522|         0|            0|            0|  0.00%|        [1,1,1,1,1,0,0]; a length-seven string, like '1111100'; or a string
  1523|         0|            0|            0|  0.00%|        like "Mon Tue Wed Thu Fri", made up of 3-character abbreviations for
  1524|         0|            0|            0|  0.00%|        weekdays, optionally separated by white space. Valid abbreviations
  1525|         0|            0|            0|  0.00%|        are: Mon Tue Wed Thu Fri Sat Sun
  1526|         0|            0|            0|  0.00%|    holidays : array_like of datetime64[D], optional
  1527|         0|            0|            0|  0.00%|        An array of dates to consider as invalid dates.  They may be
  1528|         0|            0|            0|  0.00%|        specified in any order, and NaT (not-a-time) dates are ignored.
  1529|         0|            0|            0|  0.00%|        This list is saved in a normalized form that is suited for
  1530|         0|            0|            0|  0.00%|        fast calculations of valid days.
  1531|         0|            0|            0|  0.00%|    busdaycal : busdaycalendar, optional
  1532|         0|            0|            0|  0.00%|        A `busdaycalendar` object which specifies the valid days. If this
  1533|         0|            0|            0|  0.00%|        parameter is provided, neither weekmask nor holidays may be
  1534|         0|            0|            0|  0.00%|        provided.
  1535|         0|            0|            0|  0.00%|    out : array of int, optional
  1536|         0|            0|            0|  0.00%|        If provided, this array is filled with the result.
  1537|         0|            0|            0|  0.00%|
  1538|         0|            0|            0|  0.00%|    Returns
  1539|         0|            0|            0|  0.00%|    -------
  1540|         0|            0|            0|  0.00%|    out : array of int
  1541|         0|            0|            0|  0.00%|        An array with a shape from broadcasting ``begindates`` and ``enddates``
  1542|         0|            0|            0|  0.00%|        together, containing the number of valid days between
  1543|         0|            0|            0|  0.00%|        the begin and end dates.
  1544|         0|            0|            0|  0.00%|
  1545|         0|            0|            0|  0.00%|    See Also
  1546|         0|            0|            0|  0.00%|    --------
  1547|         0|            0|            0|  0.00%|    busdaycalendar: An object that specifies a custom set of valid days.
  1548|         0|            0|            0|  0.00%|    is_busday : Returns a boolean array indicating valid days.
  1549|         0|            0|            0|  0.00%|    busday_offset : Applies an offset counted in valid days.
  1550|         0|            0|            0|  0.00%|
  1551|         0|            0|            0|  0.00%|    Examples
  1552|         0|            0|            0|  0.00%|    --------
  1553|         0|            0|            0|  0.00%|    >>> # Number of weekdays in January 2011
  1554|         0|            0|            0|  0.00%|    ... np.busday_count('2011-01', '2011-02')
  1555|         0|            0|            0|  0.00%|    21
  1556|         0|            0|            0|  0.00%|    >>> # Number of weekdays in 2011
  1557|         0|            0|            0|  0.00%|    >>> np.busday_count('2011', '2012')
  1558|         0|            0|            0|  0.00%|    260
  1559|         0|            0|            0|  0.00%|    >>> # Number of Saturdays in 2011
  1560|         0|            0|            0|  0.00%|    ... np.busday_count('2011', '2012', weekmask='Sat')
  1561|         0|            0|            0|  0.00%|    53
  1562|         0|            0|            0|  0.00%|    """
  1563|         0|            0|            0|  0.00%|    return (begindates, enddates, weekmask, holidays, out)
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|
  1566|         0|            0|            0|  0.00%|@array_function_from_c_func_and_dispatcher(
  1567|         0|            0|            0|  0.00%|    _multiarray_umath.datetime_as_string)
  1568|         0|            0|            0|  0.00%|def datetime_as_string(arr, unit=None, timezone=None, casting=None):
  1569|         0|            0|            0|  0.00%|    """
  1570|         0|            0|            0|  0.00%|    datetime_as_string(arr, unit=None, timezone='naive', casting='same_kind')
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|    Convert an array of datetimes into an array of strings.
  1573|         0|            0|            0|  0.00%|
  1574|         0|            0|            0|  0.00%|    Parameters
  1575|         0|            0|            0|  0.00%|    ----------
  1576|         0|            0|            0|  0.00%|    arr : array_like of datetime64
  1577|         0|            0|            0|  0.00%|        The array of UTC timestamps to format.
  1578|         0|            0|            0|  0.00%|    unit : str
  1579|         0|            0|            0|  0.00%|        One of None, 'auto', or a :ref:`datetime unit <arrays.dtypes.dateunits>`.
  1580|         0|            0|            0|  0.00%|    timezone : {'naive', 'UTC', 'local'} or tzinfo
  1581|         0|            0|            0|  0.00%|        Timezone information to use when displaying the datetime. If 'UTC', end
  1582|         0|            0|            0|  0.00%|        with a Z to indicate UTC time. If 'local', convert to the local timezone
  1583|         0|            0|            0|  0.00%|        first, and suffix with a +-#### timezone offset. If a tzinfo object,
  1584|         0|            0|            0|  0.00%|        then do as with 'local', but use the specified timezone.
  1585|         0|            0|            0|  0.00%|    casting : {'no', 'equiv', 'safe', 'same_kind', 'unsafe'}
  1586|         0|            0|            0|  0.00%|        Casting to allow when changing between datetime units.
  1587|         0|            0|            0|  0.00%|
  1588|         0|            0|            0|  0.00%|    Returns
  1589|         0|            0|            0|  0.00%|    -------
  1590|         0|            0|            0|  0.00%|    str_arr : ndarray
  1591|         0|            0|            0|  0.00%|        An array of strings the same shape as `arr`.
  1592|         0|            0|            0|  0.00%|
  1593|         0|            0|            0|  0.00%|    Examples
  1594|         0|            0|            0|  0.00%|    --------
  1595|         0|            0|            0|  0.00%|    >>> import pytz
  1596|         0|            0|            0|  0.00%|    >>> d = np.arange('2002-10-27T04:30', 4*60, 60, dtype='M8[m]')
  1597|         0|            0|            0|  0.00%|    >>> d
  1598|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30', '2002-10-27T05:30', '2002-10-27T06:30',
  1599|         0|            0|            0|  0.00%|           '2002-10-27T07:30'], dtype='datetime64[m]')
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|    Setting the timezone to UTC shows the same information, but with a Z suffix
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, timezone='UTC')
  1604|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30Z', '2002-10-27T05:30Z', '2002-10-27T06:30Z',
  1605|         0|            0|            0|  0.00%|           '2002-10-27T07:30Z'], dtype='<U35')
  1606|         0|            0|            0|  0.00%|
  1607|         0|            0|            0|  0.00%|    Note that we picked datetimes that cross a DST boundary. Passing in a
  1608|         0|            0|            0|  0.00%|    ``pytz`` timezone object will print the appropriate offset
  1609|         0|            0|            0|  0.00%|
  1610|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, timezone=pytz.timezone('US/Eastern'))
  1611|         0|            0|            0|  0.00%|    array(['2002-10-27T00:30-0400', '2002-10-27T01:30-0400',
  1612|         0|            0|            0|  0.00%|           '2002-10-27T01:30-0500', '2002-10-27T02:30-0500'], dtype='<U39')
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|    Passing in a unit will change the precision
  1615|         0|            0|            0|  0.00%|
  1616|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='h')
  1617|         0|            0|            0|  0.00%|    array(['2002-10-27T04', '2002-10-27T05', '2002-10-27T06', '2002-10-27T07'],
  1618|         0|            0|            0|  0.00%|          dtype='<U32')
  1619|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='s')
  1620|         0|            0|            0|  0.00%|    array(['2002-10-27T04:30:00', '2002-10-27T05:30:00', '2002-10-27T06:30:00',
  1621|         0|            0|            0|  0.00%|           '2002-10-27T07:30:00'], dtype='<U38')
  1622|         0|            0|            0|  0.00%|
  1623|         0|            0|            0|  0.00%|    'casting' can be used to specify whether precision can be changed
  1624|         0|            0|            0|  0.00%|
  1625|         0|            0|            0|  0.00%|    >>> np.datetime_as_string(d, unit='h', casting='safe')
  1626|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1627|         0|            0|            0|  0.00%|        ...
  1628|         0|            0|            0|  0.00%|    TypeError: Cannot create a datetime string as units 'h' from a NumPy
  1629|         0|            0|            0|  0.00%|    datetime with units 'm' according to the rule 'safe'
  1630|         0|            0|            0|  0.00%|    """
  1631|         0|            0|            0|  0.00%|    return (arr,)
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py
File duration: 0.000485659s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""Module containing non-deprecated functions borrowed from Numeric.
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|"""
     4|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     5|         0|            0|            0|  0.00%|
     6|         0|            0|            0|  0.00%|import functools
     7|         0|            0|            0|  0.00%|import types
     8|         0|            0|            0|  0.00%|import warnings
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|import numpy as np
    11|         0|            0|            0|  0.00%|from .. import VisibleDeprecationWarning
    12|         0|            0|            0|  0.00%|from . import multiarray as mu
    13|         0|            0|            0|  0.00%|from . import overrides
    14|         0|            0|            0|  0.00%|from . import umath as um
    15|         0|            0|            0|  0.00%|from . import numerictypes as nt
    16|         0|            0|            0|  0.00%|from ._asarray import asarray, array, asanyarray
    17|         0|            0|            0|  0.00%|from .multiarray import concatenate
    18|         0|            0|            0|  0.00%|from . import _methods
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|_dt_ = nt.sctype2char
    21|         0|            0|            0|  0.00%|
    22|         0|            0|            0|  0.00%|# functions that are methods
    23|         0|            0|            0|  0.00%|__all__ = [
    24|         0|            0|            0|  0.00%|    'alen', 'all', 'alltrue', 'amax', 'amin', 'any', 'argmax',
    25|         0|            0|            0|  0.00%|    'argmin', 'argpartition', 'argsort', 'around', 'choose', 'clip',
    26|         0|            0|            0|  0.00%|    'compress', 'cumprod', 'cumproduct', 'cumsum', 'diagonal', 'mean',
    27|         0|            0|            0|  0.00%|    'ndim', 'nonzero', 'partition', 'prod', 'product', 'ptp', 'put',
    28|         0|            0|            0|  0.00%|    'rank', 'ravel', 'repeat', 'reshape', 'resize', 'round_',
    29|         0|            0|            0|  0.00%|    'searchsorted', 'shape', 'size', 'sometrue', 'sort', 'squeeze',
    30|         0|            0|            0|  0.00%|    'std', 'sum', 'swapaxes', 'take', 'trace', 'transpose', 'var',
    31|         0|            0|            0|  0.00%|]
    32|         0|            0|            0|  0.00%|
    33|         0|            0|            0|  0.00%|_gentype = types.GeneratorType
    34|         0|            0|            0|  0.00%|# save away Python sum
    35|         0|            0|            0|  0.00%|_sum_ = sum
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    38|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|# functions that are now methods
    42|         2|  5.00679e-06|   2.5034e-06|  0.00%|def _wrapit(obj, method, *args, **kwds):
    43|         2|   6.4373e-06|  3.21865e-06|  0.00%|    try:
    44|         2|  1.35899e-05|  6.79493e-06|  0.00%|        wrap = obj.__array_wrap__
    45|         2|  9.05991e-06|  4.52995e-06|  0.00%|    except AttributeError:
    46|         2|  8.58307e-06|  4.29153e-06|  0.00%|        wrap = None
    47|         2|  5.19753e-05|  2.59876e-05|  0.00%|    result = getattr(asarray(obj), method)(*args, **kwds)
(call)|         2|  1.85966e-05|  9.29832e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:16 asarray
    48|         2|  8.34465e-06|  4.17233e-06|  0.00%|    if wrap:
    49|         0|            0|            0|  0.00%|        if not isinstance(result, mu.ndarray):
    50|         0|            0|            0|  0.00%|            result = asarray(result)
    51|         0|            0|            0|  0.00%|        result = wrap(result)
    52|         2|  5.96046e-06|  2.98023e-06|  0.00%|    return result
    53|         0|            0|            0|  0.00%|
    54|         0|            0|            0|  0.00%|
    55|         2|  5.00679e-06|   2.5034e-06|  0.00%|def _wrapfunc(obj, method, *args, **kwds):
    56|         2|  6.91414e-06|  3.45707e-06|  0.00%|    bound = getattr(obj, method, None)
    57|         2|  5.96046e-06|  2.98023e-06|  0.00%|    if bound is None:
    58|         2|  2.21729e-05|  1.10865e-05|  0.00%|        return _wrapit(obj, method, *args, **kwds)
(call)|         2|  0.000127554|   6.3777e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:42 _wrapit
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|    try:
    61|         0|            0|            0|  0.00%|        return bound(*args, **kwds)
    62|         0|            0|            0|  0.00%|    except TypeError:
    63|         0|            0|            0|  0.00%|        # A TypeError occurs if the object does have such a method in its
    64|         0|            0|            0|  0.00%|        # class, but its signature is not identical to that of NumPy's. This
    65|         0|            0|            0|  0.00%|        # situation has occurred in the case of a downstream library like
    66|         0|            0|            0|  0.00%|        # 'pandas'.
    67|         0|            0|            0|  0.00%|        #
    68|         0|            0|            0|  0.00%|        # Call _wrapit from within the except clause to ensure a potential
    69|         0|            0|            0|  0.00%|        # exception has a traceback chain.
    70|         0|            0|            0|  0.00%|        return _wrapit(obj, method, *args, **kwds)
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|
    73|         1|  5.48363e-06|  5.48363e-06|  0.00%|def _wrapreduction(obj, ufunc, method, axis, dtype, out, **kwargs):
    74|         4|  2.19345e-05|  5.48363e-06|  0.00%|    passkwargs = {k: v for k, v in kwargs.items()
(call)|         1|   1.3113e-05|   1.3113e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:74 <dictcomp>
    75|         1|   2.6226e-06|   2.6226e-06|  0.00%|                  if v is not np._NoValue}
    76|         0|            0|            0|  0.00%|
    77|         1|  4.76837e-06|  4.76837e-06|  0.00%|    if type(obj) is not mu.ndarray:
    78|         1|  4.05312e-06|  4.05312e-06|  0.00%|        try:
    79|         1|  4.52995e-06|  4.52995e-06|  0.00%|            reduction = getattr(obj, method)
    80|         0|            0|            0|  0.00%|        except AttributeError:
    81|         0|            0|            0|  0.00%|            pass
    82|         0|            0|            0|  0.00%|        else:
    83|         0|            0|            0|  0.00%|            # This branch is needed for reductions like any which don't
    84|         0|            0|            0|  0.00%|            # support a dtype.
    85|         1|   3.8147e-06|   3.8147e-06|  0.00%|            if dtype is not None:
    86|         0|            0|            0|  0.00%|                return reduction(axis=axis, dtype=dtype, out=out, **passkwargs)
    87|         0|            0|            0|  0.00%|            else:
    88|         1|  2.47955e-05|  2.47955e-05|  0.00%|                return reduction(axis=axis, out=out, **passkwargs)
(call)|         1|  2.95639e-05|  2.95639e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_methods.py:44 _any
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|    return ufunc.reduce(obj, axis, dtype, out, **passkwargs)
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|def _take_dispatcher(a, indices, axis=None, out=None, mode=None):
    94|         0|            0|            0|  0.00%|    return (a, out)
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|@array_function_dispatch(_take_dispatcher)
    98|         0|            0|            0|  0.00%|def take(a, indices, axis=None, out=None, mode='raise'):
    99|         0|            0|            0|  0.00%|    """
   100|         0|            0|            0|  0.00%|    Take elements from an array along an axis.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    When axis is not None, this function does the same thing as "fancy"
   103|         0|            0|            0|  0.00%|    indexing (indexing arrays using arrays); however, it can be easier to use
   104|         0|            0|            0|  0.00%|    if you need elements along a given axis. A call such as
   105|         0|            0|            0|  0.00%|    ``np.take(arr, indices, axis=3)`` is equivalent to
   106|         0|            0|            0|  0.00%|    ``arr[:,:,:,indices,...]``.
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    Explained without fancy indexing, this is equivalent to the following use
   109|         0|            0|            0|  0.00%|    of `ndindex`, which sets each of ``ii``, ``jj``, and ``kk`` to a tuple of
   110|         0|            0|            0|  0.00%|    indices::
   111|         0|            0|            0|  0.00%|
   112|         0|            0|            0|  0.00%|        Ni, Nk = a.shape[:axis], a.shape[axis+1:]
   113|         0|            0|            0|  0.00%|        Nj = indices.shape
   114|         0|            0|            0|  0.00%|        for ii in ndindex(Ni):
   115|         0|            0|            0|  0.00%|            for jj in ndindex(Nj):
   116|         0|            0|            0|  0.00%|                for kk in ndindex(Nk):
   117|         0|            0|            0|  0.00%|                    out[ii + jj + kk] = a[ii + (indices[jj],) + kk]
   118|         0|            0|            0|  0.00%|
   119|         0|            0|            0|  0.00%|    Parameters
   120|         0|            0|            0|  0.00%|    ----------
   121|         0|            0|            0|  0.00%|    a : array_like (Ni..., M, Nk...)
   122|         0|            0|            0|  0.00%|        The source array.
   123|         0|            0|            0|  0.00%|    indices : array_like (Nj...)
   124|         0|            0|            0|  0.00%|        The indices of the values to extract.
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
   127|         0|            0|            0|  0.00%|
   128|         0|            0|            0|  0.00%|        Also allow scalars for indices.
   129|         0|            0|            0|  0.00%|    axis : int, optional
   130|         0|            0|            0|  0.00%|        The axis over which to select values. By default, the flattened
   131|         0|            0|            0|  0.00%|        input array is used.
   132|         0|            0|            0|  0.00%|    out : ndarray, optional (Ni..., Nj..., Nk...)
   133|         0|            0|            0|  0.00%|        If provided, the result will be placed in this array. It should
   134|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype. Note that `out` is always
   135|         0|            0|            0|  0.00%|        buffered if `mode='raise'`; use other modes for better performance.
   136|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   137|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices will behave.
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   140|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   141|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|        'clip' mode means that all indices that are too large are replaced
   144|         0|            0|            0|  0.00%|        by the index that addresses the last element along that axis. Note
   145|         0|            0|            0|  0.00%|        that this disables indexing with negative numbers.
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|    Returns
   148|         0|            0|            0|  0.00%|    -------
   149|         0|            0|            0|  0.00%|    out : ndarray (Ni..., Nj..., Nk...)
   150|         0|            0|            0|  0.00%|        The returned array has the same type as `a`.
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    See Also
   153|         0|            0|            0|  0.00%|    --------
   154|         0|            0|            0|  0.00%|    compress : Take elements using a boolean mask
   155|         0|            0|            0|  0.00%|    ndarray.take : equivalent method
   156|         0|            0|            0|  0.00%|    take_along_axis : Take elements by matching the array and the index arrays
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    Notes
   159|         0|            0|            0|  0.00%|    -----
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|    By eliminating the inner loop in the description above, and using `s_` to
   162|         0|            0|            0|  0.00%|    build simple slice objects, `take` can be expressed  in terms of applying
   163|         0|            0|            0|  0.00%|    fancy indexing to each 1-d slice::
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|        Ni, Nk = a.shape[:axis], a.shape[axis+1:]
   166|         0|            0|            0|  0.00%|        for ii in ndindex(Ni):
   167|         0|            0|            0|  0.00%|            for kk in ndindex(Nj):
   168|         0|            0|            0|  0.00%|                out[ii + s_[...,] + kk] = a[ii + s_[:,] + kk][indices]
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    For this reason, it is equivalent to (but faster than) the following use
   171|         0|            0|            0|  0.00%|    of `apply_along_axis`::
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|        out = np.apply_along_axis(lambda a_1d: a_1d[indices], axis, a)
   174|         0|            0|            0|  0.00%|
   175|         0|            0|            0|  0.00%|    Examples
   176|         0|            0|            0|  0.00%|    --------
   177|         0|            0|            0|  0.00%|    >>> a = [4, 3, 5, 7, 6, 8]
   178|         0|            0|            0|  0.00%|    >>> indices = [0, 1, 4]
   179|         0|            0|            0|  0.00%|    >>> np.take(a, indices)
   180|         0|            0|            0|  0.00%|    array([4, 3, 6])
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|    In this example if `a` is an ndarray, "fancy" indexing can be used.
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|    >>> a = np.array(a)
   185|         0|            0|            0|  0.00%|    >>> a[indices]
   186|         0|            0|            0|  0.00%|    array([4, 3, 6])
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    If `indices` is not one dimensional, the output also has these dimensions.
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    >>> np.take(a, [[0, 1], [2, 3]])
   191|         0|            0|            0|  0.00%|    array([[4, 3],
   192|         0|            0|            0|  0.00%|           [5, 7]])
   193|         0|            0|            0|  0.00%|    """
   194|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'take', indices, axis=axis, out=out, mode=mode)
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|def _reshape_dispatcher(a, newshape, order=None):
   198|         0|            0|            0|  0.00%|    return (a,)
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|# not deprecated --- copy if necessary, view otherwise
   202|         0|            0|            0|  0.00%|@array_function_dispatch(_reshape_dispatcher)
   203|         0|            0|            0|  0.00%|def reshape(a, newshape, order='C'):
   204|         0|            0|            0|  0.00%|    """
   205|         0|            0|            0|  0.00%|    Gives a new shape to an array without changing its data.
   206|         0|            0|            0|  0.00%|
   207|         0|            0|            0|  0.00%|    Parameters
   208|         0|            0|            0|  0.00%|    ----------
   209|         0|            0|            0|  0.00%|    a : array_like
   210|         0|            0|            0|  0.00%|        Array to be reshaped.
   211|         0|            0|            0|  0.00%|    newshape : int or tuple of ints
   212|         0|            0|            0|  0.00%|        The new shape should be compatible with the original shape. If
   213|         0|            0|            0|  0.00%|        an integer, then the result will be a 1-D array of that length.
   214|         0|            0|            0|  0.00%|        One shape dimension can be -1. In this case, the value is
   215|         0|            0|            0|  0.00%|        inferred from the length of the array and remaining dimensions.
   216|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A'}, optional
   217|         0|            0|            0|  0.00%|        Read the elements of `a` using this index order, and place the
   218|         0|            0|            0|  0.00%|        elements into the reshaped array using this index order.  'C'
   219|         0|            0|            0|  0.00%|        means to read / write the elements using C-like index order,
   220|         0|            0|            0|  0.00%|        with the last axis index changing fastest, back to the first
   221|         0|            0|            0|  0.00%|        axis index changing slowest. 'F' means to read / write the
   222|         0|            0|            0|  0.00%|        elements using Fortran-like index order, with the first index
   223|         0|            0|            0|  0.00%|        changing fastest, and the last index changing slowest. Note that
   224|         0|            0|            0|  0.00%|        the 'C' and 'F' options take no account of the memory layout of
   225|         0|            0|            0|  0.00%|        the underlying array, and only refer to the order of indexing.
   226|         0|            0|            0|  0.00%|        'A' means to read / write the elements in Fortran-like index
   227|         0|            0|            0|  0.00%|        order if `a` is Fortran *contiguous* in memory, C-like order
   228|         0|            0|            0|  0.00%|        otherwise.
   229|         0|            0|            0|  0.00%|
   230|         0|            0|            0|  0.00%|    Returns
   231|         0|            0|            0|  0.00%|    -------
   232|         0|            0|            0|  0.00%|    reshaped_array : ndarray
   233|         0|            0|            0|  0.00%|        This will be a new view object if possible; otherwise, it will
   234|         0|            0|            0|  0.00%|        be a copy.  Note there is no guarantee of the *memory layout* (C- or
   235|         0|            0|            0|  0.00%|        Fortran- contiguous) of the returned array.
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    See Also
   238|         0|            0|            0|  0.00%|    --------
   239|         0|            0|            0|  0.00%|    ndarray.reshape : Equivalent method.
   240|         0|            0|            0|  0.00%|
   241|         0|            0|            0|  0.00%|    Notes
   242|         0|            0|            0|  0.00%|    -----
   243|         0|            0|            0|  0.00%|    It is not always possible to change the shape of an array without
   244|         0|            0|            0|  0.00%|    copying the data. If you want an error to be raised when the data is copied,
   245|         0|            0|            0|  0.00%|    you should assign the new shape to the shape attribute of the array::
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|     >>> a = np.zeros((10, 2))
   248|         0|            0|            0|  0.00%|
   249|         0|            0|            0|  0.00%|     # A transpose makes the array non-contiguous
   250|         0|            0|            0|  0.00%|     >>> b = a.T
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|     # Taking a view makes it possible to modify the shape without modifying
   253|         0|            0|            0|  0.00%|     # the initial object.
   254|         0|            0|            0|  0.00%|     >>> c = b.view()
   255|         0|            0|            0|  0.00%|     >>> c.shape = (20)
   256|         0|            0|            0|  0.00%|     Traceback (most recent call last):
   257|         0|            0|            0|  0.00%|        ...
   258|         0|            0|            0|  0.00%|     AttributeError: incompatible shape for a non-contiguous array
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    The `order` keyword gives the index ordering both for *fetching* the values
   261|         0|            0|            0|  0.00%|    from `a`, and then *placing* the values into the output array.
   262|         0|            0|            0|  0.00%|    For example, let's say you have an array:
   263|         0|            0|            0|  0.00%|
   264|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape((3, 2))
   265|         0|            0|            0|  0.00%|    >>> a
   266|         0|            0|            0|  0.00%|    array([[0, 1],
   267|         0|            0|            0|  0.00%|           [2, 3],
   268|         0|            0|            0|  0.00%|           [4, 5]])
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    You can think of reshaping as first raveling the array (using the given
   271|         0|            0|            0|  0.00%|    index order), then inserting the elements from the raveled array into the
   272|         0|            0|            0|  0.00%|    new array using the same kind of index ordering as was used for the
   273|         0|            0|            0|  0.00%|    raveling.
   274|         0|            0|            0|  0.00%|
   275|         0|            0|            0|  0.00%|    >>> np.reshape(a, (2, 3)) # C-like index ordering
   276|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   277|         0|            0|            0|  0.00%|           [3, 4, 5]])
   278|         0|            0|            0|  0.00%|    >>> np.reshape(np.ravel(a), (2, 3)) # equivalent to C ravel then C reshape
   279|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   280|         0|            0|            0|  0.00%|           [3, 4, 5]])
   281|         0|            0|            0|  0.00%|    >>> np.reshape(a, (2, 3), order='F') # Fortran-like index ordering
   282|         0|            0|            0|  0.00%|    array([[0, 4, 3],
   283|         0|            0|            0|  0.00%|           [2, 1, 5]])
   284|         0|            0|            0|  0.00%|    >>> np.reshape(np.ravel(a, order='F'), (2, 3), order='F')
   285|         0|            0|            0|  0.00%|    array([[0, 4, 3],
   286|         0|            0|            0|  0.00%|           [2, 1, 5]])
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|    Examples
   289|         0|            0|            0|  0.00%|    --------
   290|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3], [4,5,6]])
   291|         0|            0|            0|  0.00%|    >>> np.reshape(a, 6)
   292|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
   293|         0|            0|            0|  0.00%|    >>> np.reshape(a, 6, order='F')
   294|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    >>> np.reshape(a, (3,-1))       # the unspecified value is inferred to be 2
   297|         0|            0|            0|  0.00%|    array([[1, 2],
   298|         0|            0|            0|  0.00%|           [3, 4],
   299|         0|            0|            0|  0.00%|           [5, 6]])
   300|         0|            0|            0|  0.00%|    """
   301|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'reshape', newshape, order=order)
   302|         0|            0|            0|  0.00%|
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|def _choose_dispatcher(a, choices, out=None, mode=None):
   305|         0|            0|            0|  0.00%|    yield a
   306|         0|            0|            0|  0.00%|    for c in choices:
   307|         0|            0|            0|  0.00%|        yield c
   308|         0|            0|            0|  0.00%|    yield out
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|
   311|         0|            0|            0|  0.00%|@array_function_dispatch(_choose_dispatcher)
   312|         0|            0|            0|  0.00%|def choose(a, choices, out=None, mode='raise'):
   313|         0|            0|            0|  0.00%|    """
   314|         0|            0|            0|  0.00%|    Construct an array from an index array and a set of arrays to choose from.
   315|         0|            0|            0|  0.00%|
   316|         0|            0|            0|  0.00%|    First of all, if confused or uncertain, definitely look at the Examples -
   317|         0|            0|            0|  0.00%|    in its full generality, this function is less simple than it might
   318|         0|            0|            0|  0.00%|    seem from the following code description (below ndi =
   319|         0|            0|            0|  0.00%|    `numpy.lib.index_tricks`):
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|    ``np.choose(a,c) == np.array([c[a[I]][I] for I in ndi.ndindex(a.shape)])``.
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    But this omits some subtleties.  Here is a fully general summary:
   324|         0|            0|            0|  0.00%|
   325|         0|            0|            0|  0.00%|    Given an "index" array (`a`) of integers and a sequence of `n` arrays
   326|         0|            0|            0|  0.00%|    (`choices`), `a` and each choice array are first broadcast, as necessary,
   327|         0|            0|            0|  0.00%|    to arrays of a common shape; calling these *Ba* and *Bchoices[i], i =
   328|         0|            0|            0|  0.00%|    0,...,n-1* we have that, necessarily, ``Ba.shape == Bchoices[i].shape``
   329|         0|            0|            0|  0.00%|    for each `i`.  Then, a new array with shape ``Ba.shape`` is created as
   330|         0|            0|            0|  0.00%|    follows:
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|    * if ``mode=raise`` (the default), then, first of all, each element of
   333|         0|            0|            0|  0.00%|      `a` (and thus `Ba`) must be in the range `[0, n-1]`; now, suppose that
   334|         0|            0|            0|  0.00%|      `i` (in that range) is the value at the `(j0, j1, ..., jm)` position
   335|         0|            0|            0|  0.00%|      in `Ba` - then the value at the same position in the new array is the
   336|         0|            0|            0|  0.00%|      value in `Bchoices[i]` at that same position;
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    * if ``mode=wrap``, values in `a` (and thus `Ba`) may be any (signed)
   339|         0|            0|            0|  0.00%|      integer; modular arithmetic is used to map integers outside the range
   340|         0|            0|            0|  0.00%|      `[0, n-1]` back into that range; and then the new array is constructed
   341|         0|            0|            0|  0.00%|      as above;
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    * if ``mode=clip``, values in `a` (and thus `Ba`) may be any (signed)
   344|         0|            0|            0|  0.00%|      integer; negative integers are mapped to 0; values greater than `n-1`
   345|         0|            0|            0|  0.00%|      are mapped to `n-1`; and then the new array is constructed as above.
   346|         0|            0|            0|  0.00%|
   347|         0|            0|            0|  0.00%|    Parameters
   348|         0|            0|            0|  0.00%|    ----------
   349|         0|            0|            0|  0.00%|    a : int array
   350|         0|            0|            0|  0.00%|        This array must contain integers in `[0, n-1]`, where `n` is the number
   351|         0|            0|            0|  0.00%|        of choices, unless ``mode=wrap`` or ``mode=clip``, in which cases any
   352|         0|            0|            0|  0.00%|        integers are permissible.
   353|         0|            0|            0|  0.00%|    choices : sequence of arrays
   354|         0|            0|            0|  0.00%|        Choice arrays. `a` and all of the choices must be broadcastable to the
   355|         0|            0|            0|  0.00%|        same shape.  If `choices` is itself an array (not recommended), then
   356|         0|            0|            0|  0.00%|        its outermost dimension (i.e., the one corresponding to
   357|         0|            0|            0|  0.00%|        ``choices.shape[0]``) is taken as defining the "sequence".
   358|         0|            0|            0|  0.00%|    out : array, optional
   359|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
   360|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype. Note that `out` is always
   361|         0|            0|            0|  0.00%|        buffered if `mode='raise'`; use other modes for better performance.
   362|         0|            0|            0|  0.00%|    mode : {'raise' (default), 'wrap', 'clip'}, optional
   363|         0|            0|            0|  0.00%|        Specifies how indices outside `[0, n-1]` will be treated:
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|          * 'raise' : an exception is raised
   366|         0|            0|            0|  0.00%|          * 'wrap' : value becomes value mod `n`
   367|         0|            0|            0|  0.00%|          * 'clip' : values < 0 are mapped to 0, values > n-1 are mapped to n-1
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    Returns
   370|         0|            0|            0|  0.00%|    -------
   371|         0|            0|            0|  0.00%|    merged_array : array
   372|         0|            0|            0|  0.00%|        The merged result.
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    Raises
   375|         0|            0|            0|  0.00%|    ------
   376|         0|            0|            0|  0.00%|    ValueError: shape mismatch
   377|         0|            0|            0|  0.00%|        If `a` and each choice array are not all broadcastable to the same
   378|         0|            0|            0|  0.00%|        shape.
   379|         0|            0|            0|  0.00%|
   380|         0|            0|            0|  0.00%|    See Also
   381|         0|            0|            0|  0.00%|    --------
   382|         0|            0|            0|  0.00%|    ndarray.choose : equivalent method
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    Notes
   385|         0|            0|            0|  0.00%|    -----
   386|         0|            0|            0|  0.00%|    To reduce the chance of misinterpretation, even though the following
   387|         0|            0|            0|  0.00%|    "abuse" is nominally supported, `choices` should neither be, nor be
   388|         0|            0|            0|  0.00%|    thought of as, a single array, i.e., the outermost sequence-like container
   389|         0|            0|            0|  0.00%|    should be either a list or a tuple.
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    Examples
   392|         0|            0|            0|  0.00%|    --------
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    >>> choices = [[0, 1, 2, 3], [10, 11, 12, 13],
   395|         0|            0|            0|  0.00%|    ...   [20, 21, 22, 23], [30, 31, 32, 33]]
   396|         0|            0|            0|  0.00%|    >>> np.choose([2, 3, 1, 0], choices
   397|         0|            0|            0|  0.00%|    ... # the first element of the result will be the first element of the
   398|         0|            0|            0|  0.00%|    ... # third (2+1) "array" in choices, namely, 20; the second element
   399|         0|            0|            0|  0.00%|    ... # will be the second element of the fourth (3+1) choice array, i.e.,
   400|         0|            0|            0|  0.00%|    ... # 31, etc.
   401|         0|            0|            0|  0.00%|    ... )
   402|         0|            0|            0|  0.00%|    array([20, 31, 12,  3])
   403|         0|            0|            0|  0.00%|    >>> np.choose([2, 4, 1, 0], choices, mode='clip') # 4 goes to 3 (4-1)
   404|         0|            0|            0|  0.00%|    array([20, 31, 12,  3])
   405|         0|            0|            0|  0.00%|    >>> # because there are 4 choice arrays
   406|         0|            0|            0|  0.00%|    >>> np.choose([2, 4, 1, 0], choices, mode='wrap') # 4 goes to (4 mod 4)
   407|         0|            0|            0|  0.00%|    array([20,  1, 12,  3])
   408|         0|            0|            0|  0.00%|    >>> # i.e., 0
   409|         0|            0|            0|  0.00%|
   410|         0|            0|            0|  0.00%|    A couple examples illustrating how choose broadcasts:
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|    >>> a = [[1, 0, 1], [0, 1, 0], [1, 0, 1]]
   413|         0|            0|            0|  0.00%|    >>> choices = [-10, 10]
   414|         0|            0|            0|  0.00%|    >>> np.choose(a, choices)
   415|         0|            0|            0|  0.00%|    array([[ 10, -10,  10],
   416|         0|            0|            0|  0.00%|           [-10,  10, -10],
   417|         0|            0|            0|  0.00%|           [ 10, -10,  10]])
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    >>> # With thanks to Anne Archibald
   420|         0|            0|            0|  0.00%|    >>> a = np.array([0, 1]).reshape((2,1,1))
   421|         0|            0|            0|  0.00%|    >>> c1 = np.array([1, 2, 3]).reshape((1,3,1))
   422|         0|            0|            0|  0.00%|    >>> c2 = np.array([-1, -2, -3, -4, -5]).reshape((1,1,5))
   423|         0|            0|            0|  0.00%|    >>> np.choose(a, (c1, c2)) # result is 2x3x5, res[0,:,:]=c1, res[1,:,:]=c2
   424|         0|            0|            0|  0.00%|    array([[[ 1,  1,  1,  1,  1],
   425|         0|            0|            0|  0.00%|            [ 2,  2,  2,  2,  2],
   426|         0|            0|            0|  0.00%|            [ 3,  3,  3,  3,  3]],
   427|         0|            0|            0|  0.00%|           [[-1, -2, -3, -4, -5],
   428|         0|            0|            0|  0.00%|            [-1, -2, -3, -4, -5],
   429|         0|            0|            0|  0.00%|            [-1, -2, -3, -4, -5]]])
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|    """
   432|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'choose', choices, out=out, mode=mode)
   433|         0|            0|            0|  0.00%|
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|def _repeat_dispatcher(a, repeats, axis=None):
   436|         0|            0|            0|  0.00%|    return (a,)
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|@array_function_dispatch(_repeat_dispatcher)
   440|         0|            0|            0|  0.00%|def repeat(a, repeats, axis=None):
   441|         0|            0|            0|  0.00%|    """
   442|         0|            0|            0|  0.00%|    Repeat elements of an array.
   443|         0|            0|            0|  0.00%|
   444|         0|            0|            0|  0.00%|    Parameters
   445|         0|            0|            0|  0.00%|    ----------
   446|         0|            0|            0|  0.00%|    a : array_like
   447|         0|            0|            0|  0.00%|        Input array.
   448|         0|            0|            0|  0.00%|    repeats : int or array of ints
   449|         0|            0|            0|  0.00%|        The number of repetitions for each element.  `repeats` is broadcasted
   450|         0|            0|            0|  0.00%|        to fit the shape of the given axis.
   451|         0|            0|            0|  0.00%|    axis : int, optional
   452|         0|            0|            0|  0.00%|        The axis along which to repeat values.  By default, use the
   453|         0|            0|            0|  0.00%|        flattened input array, and return a flat output array.
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    Returns
   456|         0|            0|            0|  0.00%|    -------
   457|         0|            0|            0|  0.00%|    repeated_array : ndarray
   458|         0|            0|            0|  0.00%|        Output array which has the same shape as `a`, except along
   459|         0|            0|            0|  0.00%|        the given axis.
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    See Also
   462|         0|            0|            0|  0.00%|    --------
   463|         0|            0|            0|  0.00%|    tile : Tile an array.
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    Examples
   466|         0|            0|            0|  0.00%|    --------
   467|         0|            0|            0|  0.00%|    >>> np.repeat(3, 4)
   468|         0|            0|            0|  0.00%|    array([3, 3, 3, 3])
   469|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2],[3,4]])
   470|         0|            0|            0|  0.00%|    >>> np.repeat(x, 2)
   471|         0|            0|            0|  0.00%|    array([1, 1, 2, 2, 3, 3, 4, 4])
   472|         0|            0|            0|  0.00%|    >>> np.repeat(x, 3, axis=1)
   473|         0|            0|            0|  0.00%|    array([[1, 1, 1, 2, 2, 2],
   474|         0|            0|            0|  0.00%|           [3, 3, 3, 4, 4, 4]])
   475|         0|            0|            0|  0.00%|    >>> np.repeat(x, [1, 2], axis=0)
   476|         0|            0|            0|  0.00%|    array([[1, 2],
   477|         0|            0|            0|  0.00%|           [3, 4],
   478|         0|            0|            0|  0.00%|           [3, 4]])
   479|         0|            0|            0|  0.00%|
   480|         0|            0|            0|  0.00%|    """
   481|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'repeat', repeats, axis=axis)
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|def _put_dispatcher(a, ind, v, mode=None):
   485|         0|            0|            0|  0.00%|    return (a, ind, v)
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|
   488|         0|            0|            0|  0.00%|@array_function_dispatch(_put_dispatcher)
   489|         0|            0|            0|  0.00%|def put(a, ind, v, mode='raise'):
   490|         0|            0|            0|  0.00%|    """
   491|         0|            0|            0|  0.00%|    Replaces specified elements of an array with given values.
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    The indexing works on the flattened target array. `put` is roughly
   494|         0|            0|            0|  0.00%|    equivalent to:
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    ::
   497|         0|            0|            0|  0.00%|
   498|         0|            0|            0|  0.00%|        a.flat[ind] = v
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|    Parameters
   501|         0|            0|            0|  0.00%|    ----------
   502|         0|            0|            0|  0.00%|    a : ndarray
   503|         0|            0|            0|  0.00%|        Target array.
   504|         0|            0|            0|  0.00%|    ind : array_like
   505|         0|            0|            0|  0.00%|        Target indices, interpreted as integers.
   506|         0|            0|            0|  0.00%|    v : array_like
   507|         0|            0|            0|  0.00%|        Values to place in `a` at target indices. If `v` is shorter than
   508|         0|            0|            0|  0.00%|        `ind` it will be repeated as necessary.
   509|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
   510|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices will behave.
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|        * 'raise' -- raise an error (default)
   513|         0|            0|            0|  0.00%|        * 'wrap' -- wrap around
   514|         0|            0|            0|  0.00%|        * 'clip' -- clip to the range
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|        'clip' mode means that all indices that are too large are replaced
   517|         0|            0|            0|  0.00%|        by the index that addresses the last element along that axis. Note
   518|         0|            0|            0|  0.00%|        that this disables indexing with negative numbers. In 'raise' mode,
   519|         0|            0|            0|  0.00%|        if an exception occurs the target array may still be modified.
   520|         0|            0|            0|  0.00%|
   521|         0|            0|            0|  0.00%|    See Also
   522|         0|            0|            0|  0.00%|    --------
   523|         0|            0|            0|  0.00%|    putmask, place
   524|         0|            0|            0|  0.00%|    put_along_axis : Put elements by matching the array and the index arrays
   525|         0|            0|            0|  0.00%|
   526|         0|            0|            0|  0.00%|    Examples
   527|         0|            0|            0|  0.00%|    --------
   528|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   529|         0|            0|            0|  0.00%|    >>> np.put(a, [0, 2], [-44, -55])
   530|         0|            0|            0|  0.00%|    >>> a
   531|         0|            0|            0|  0.00%|    array([-44,   1, -55,   3,   4])
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   534|         0|            0|            0|  0.00%|    >>> np.put(a, 22, -5, mode='clip')
   535|         0|            0|            0|  0.00%|    >>> a
   536|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3, -5])
   537|         0|            0|            0|  0.00%|
   538|         0|            0|            0|  0.00%|    """
   539|         0|            0|            0|  0.00%|    try:
   540|         0|            0|            0|  0.00%|        put = a.put
   541|         0|            0|            0|  0.00%|    except AttributeError:
   542|         0|            0|            0|  0.00%|        raise TypeError("argument 1 must be numpy.ndarray, "
   543|         0|            0|            0|  0.00%|                        "not {name}".format(name=type(a).__name__))
   544|         0|            0|            0|  0.00%|
   545|         0|            0|            0|  0.00%|    return put(ind, v, mode=mode)
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|def _swapaxes_dispatcher(a, axis1, axis2):
   549|         0|            0|            0|  0.00%|    return (a,)
   550|         0|            0|            0|  0.00%|
   551|         0|            0|            0|  0.00%|
   552|         0|            0|            0|  0.00%|@array_function_dispatch(_swapaxes_dispatcher)
   553|         0|            0|            0|  0.00%|def swapaxes(a, axis1, axis2):
   554|         0|            0|            0|  0.00%|    """
   555|         0|            0|            0|  0.00%|    Interchange two axes of an array.
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    Parameters
   558|         0|            0|            0|  0.00%|    ----------
   559|         0|            0|            0|  0.00%|    a : array_like
   560|         0|            0|            0|  0.00%|        Input array.
   561|         0|            0|            0|  0.00%|    axis1 : int
   562|         0|            0|            0|  0.00%|        First axis.
   563|         0|            0|            0|  0.00%|    axis2 : int
   564|         0|            0|            0|  0.00%|        Second axis.
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|    Returns
   567|         0|            0|            0|  0.00%|    -------
   568|         0|            0|            0|  0.00%|    a_swapped : ndarray
   569|         0|            0|            0|  0.00%|        For NumPy >= 1.10.0, if `a` is an ndarray, then a view of `a` is
   570|         0|            0|            0|  0.00%|        returned; otherwise a new array is created. For earlier NumPy
   571|         0|            0|            0|  0.00%|        versions a view of `a` is returned only if the order of the
   572|         0|            0|            0|  0.00%|        axes is changed, otherwise the input array is returned.
   573|         0|            0|            0|  0.00%|
   574|         0|            0|            0|  0.00%|    Examples
   575|         0|            0|            0|  0.00%|    --------
   576|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3]])
   577|         0|            0|            0|  0.00%|    >>> np.swapaxes(x,0,1)
   578|         0|            0|            0|  0.00%|    array([[1],
   579|         0|            0|            0|  0.00%|           [2],
   580|         0|            0|            0|  0.00%|           [3]])
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    >>> x = np.array([[[0,1],[2,3]],[[4,5],[6,7]]])
   583|         0|            0|            0|  0.00%|    >>> x
   584|         0|            0|            0|  0.00%|    array([[[0, 1],
   585|         0|            0|            0|  0.00%|            [2, 3]],
   586|         0|            0|            0|  0.00%|           [[4, 5],
   587|         0|            0|            0|  0.00%|            [6, 7]]])
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    >>> np.swapaxes(x,0,2)
   590|         0|            0|            0|  0.00%|    array([[[0, 4],
   591|         0|            0|            0|  0.00%|            [2, 6]],
   592|         0|            0|            0|  0.00%|           [[1, 5],
   593|         0|            0|            0|  0.00%|            [3, 7]]])
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    """
   596|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'swapaxes', axis1, axis2)
   597|         0|            0|            0|  0.00%|
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|def _transpose_dispatcher(a, axes=None):
   600|         0|            0|            0|  0.00%|    return (a,)
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|
   603|         0|            0|            0|  0.00%|@array_function_dispatch(_transpose_dispatcher)
   604|         0|            0|            0|  0.00%|def transpose(a, axes=None):
   605|         0|            0|            0|  0.00%|    """
   606|         0|            0|            0|  0.00%|    Permute the dimensions of an array.
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    Parameters
   609|         0|            0|            0|  0.00%|    ----------
   610|         0|            0|            0|  0.00%|    a : array_like
   611|         0|            0|            0|  0.00%|        Input array.
   612|         0|            0|            0|  0.00%|    axes : list of ints, optional
   613|         0|            0|            0|  0.00%|        By default, reverse the dimensions, otherwise permute the axes
   614|         0|            0|            0|  0.00%|        according to the values given.
   615|         0|            0|            0|  0.00%|
   616|         0|            0|            0|  0.00%|    Returns
   617|         0|            0|            0|  0.00%|    -------
   618|         0|            0|            0|  0.00%|    p : ndarray
   619|         0|            0|            0|  0.00%|        `a` with its axes permuted.  A view is returned whenever
   620|         0|            0|            0|  0.00%|        possible.
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    See Also
   623|         0|            0|            0|  0.00%|    --------
   624|         0|            0|            0|  0.00%|    moveaxis
   625|         0|            0|            0|  0.00%|    argsort
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    Notes
   628|         0|            0|            0|  0.00%|    -----
   629|         0|            0|            0|  0.00%|    Use `transpose(a, argsort(axes))` to invert the transposition of tensors
   630|         0|            0|            0|  0.00%|    when using the `axes` keyword argument.
   631|         0|            0|            0|  0.00%|
   632|         0|            0|            0|  0.00%|    Transposing a 1-D array returns an unchanged view of the original array.
   633|         0|            0|            0|  0.00%|
   634|         0|            0|            0|  0.00%|    Examples
   635|         0|            0|            0|  0.00%|    --------
   636|         0|            0|            0|  0.00%|    >>> x = np.arange(4).reshape((2,2))
   637|         0|            0|            0|  0.00%|    >>> x
   638|         0|            0|            0|  0.00%|    array([[0, 1],
   639|         0|            0|            0|  0.00%|           [2, 3]])
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|    >>> np.transpose(x)
   642|         0|            0|            0|  0.00%|    array([[0, 2],
   643|         0|            0|            0|  0.00%|           [1, 3]])
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    >>> x = np.ones((1, 2, 3))
   646|         0|            0|            0|  0.00%|    >>> np.transpose(x, (1, 0, 2)).shape
   647|         0|            0|            0|  0.00%|    (2, 1, 3)
   648|         0|            0|            0|  0.00%|
   649|         0|            0|            0|  0.00%|    """
   650|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'transpose', axes)
   651|         0|            0|            0|  0.00%|
   652|         0|            0|            0|  0.00%|
   653|         1|  3.57628e-06|  3.57628e-06|  0.00%|def _partition_dispatcher(a, kth, axis=None, kind=None, order=None):
   654|         1|  4.05312e-06|  4.05312e-06|  0.00%|    return (a,)
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|
   657|         1|  7.15256e-06|  7.15256e-06|  0.00%|@array_function_dispatch(_partition_dispatcher)
   658|         0|            0|            0|  0.00%|def partition(a, kth, axis=-1, kind='introselect', order=None):
   659|         0|            0|            0|  0.00%|    """
   660|         0|            0|            0|  0.00%|    Return a partitioned copy of an array.
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|    Creates a copy of the array with its elements rearranged in such a
   663|         0|            0|            0|  0.00%|    way that the value of the element in k-th position is in the
   664|         0|            0|            0|  0.00%|    position it would be in a sorted array. All elements smaller than
   665|         0|            0|            0|  0.00%|    the k-th element are moved before this element and all equal or
   666|         0|            0|            0|  0.00%|    greater are moved behind it. The ordering of the elements in the two
   667|         0|            0|            0|  0.00%|    partitions is undefined.
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   670|         0|            0|            0|  0.00%|
   671|         0|            0|            0|  0.00%|    Parameters
   672|         0|            0|            0|  0.00%|    ----------
   673|         0|            0|            0|  0.00%|    a : array_like
   674|         0|            0|            0|  0.00%|        Array to be sorted.
   675|         0|            0|            0|  0.00%|    kth : int or sequence of ints
   676|         0|            0|            0|  0.00%|        Element index to partition by. The k-th value of the element
   677|         0|            0|            0|  0.00%|        will be in its final sorted position and all smaller elements
   678|         0|            0|            0|  0.00%|        will be moved before it and all equal or greater elements behind
   679|         0|            0|            0|  0.00%|        it. The order of all elements in the partitions is undefined. If
   680|         0|            0|            0|  0.00%|        provided with a sequence of k-th it will partition all elements
   681|         0|            0|            0|  0.00%|        indexed by k-th  of them into their sorted position at once.
   682|         0|            0|            0|  0.00%|    axis : int or None, optional
   683|         0|            0|            0|  0.00%|        Axis along which to sort. If None, the array is flattened before
   684|         0|            0|            0|  0.00%|        sorting. The default is -1, which sorts along the last axis.
   685|         0|            0|            0|  0.00%|    kind : {'introselect'}, optional
   686|         0|            0|            0|  0.00%|        Selection algorithm. Default is 'introselect'.
   687|         0|            0|            0|  0.00%|    order : str or list of str, optional
   688|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument
   689|         0|            0|            0|  0.00%|        specifies which fields to compare first, second, etc.  A single
   690|         0|            0|            0|  0.00%|        field can be specified as a string.  Not all fields need be
   691|         0|            0|            0|  0.00%|        specified, but unspecified fields will still be used, in the
   692|         0|            0|            0|  0.00%|        order in which they come up in the dtype, to break ties.
   693|         0|            0|            0|  0.00%|
   694|         0|            0|            0|  0.00%|    Returns
   695|         0|            0|            0|  0.00%|    -------
   696|         0|            0|            0|  0.00%|    partitioned_array : ndarray
   697|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
   698|         0|            0|            0|  0.00%|
   699|         0|            0|            0|  0.00%|    See Also
   700|         0|            0|            0|  0.00%|    --------
   701|         0|            0|            0|  0.00%|    ndarray.partition : Method to sort an array in-place.
   702|         0|            0|            0|  0.00%|    argpartition : Indirect partition.
   703|         0|            0|            0|  0.00%|    sort : Full sorting
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|    Notes
   706|         0|            0|            0|  0.00%|    -----
   707|         0|            0|            0|  0.00%|    The various selection algorithms are characterized by their average
   708|         0|            0|            0|  0.00%|    speed, worst case performance, work space size, and whether they are
   709|         0|            0|            0|  0.00%|    stable. A stable sort keeps items with the same key in the same
   710|         0|            0|            0|  0.00%|    relative order. The available algorithms have the following
   711|         0|            0|            0|  0.00%|    properties:
   712|         0|            0|            0|  0.00%|
   713|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   714|         0|            0|            0|  0.00%|       kind            speed   worst case    work space  stable
   715|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   716|         0|            0|            0|  0.00%|    'introselect'        1        O(n)           0         no
   717|         0|            0|            0|  0.00%|    ================= ======= ============= ============ =======
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|    All the partition algorithms make temporary copies of the data when
   720|         0|            0|            0|  0.00%|    partitioning along any but the last axis.  Consequently,
   721|         0|            0|            0|  0.00%|    partitioning along the last axis is faster and uses less space than
   722|         0|            0|            0|  0.00%|    partitioning along any other axis.
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|    The sort order for complex numbers is lexicographic. If both the
   725|         0|            0|            0|  0.00%|    real and imaginary parts are non-nan then the order is determined by
   726|         0|            0|            0|  0.00%|    the real parts except when they are equal, in which case the order
   727|         0|            0|            0|  0.00%|    is determined by the imaginary parts.
   728|         0|            0|            0|  0.00%|
   729|         0|            0|            0|  0.00%|    Examples
   730|         0|            0|            0|  0.00%|    --------
   731|         0|            0|            0|  0.00%|    >>> a = np.array([3, 4, 2, 1])
   732|         0|            0|            0|  0.00%|    >>> np.partition(a, 3)
   733|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   734|         0|            0|            0|  0.00%|
   735|         0|            0|            0|  0.00%|    >>> np.partition(a, (1, 3))
   736|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    """
   739|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if axis is None:
   740|         0|            0|            0|  0.00%|        # flatten returns (1, N) for np.matrix, so always use the last axis
   741|         1|  1.83582e-05|  1.83582e-05|  0.00%|        a = asanyarray(a).flatten()
(call)|         1|  5.48363e-06|  5.48363e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
   742|         1|  5.24521e-06|  5.24521e-06|  0.00%|        axis = -1
   743|         0|            0|            0|  0.00%|    else:
   744|         0|            0|            0|  0.00%|        a = asanyarray(a).copy(order="K")
   745|         1|  3.00407e-05|  3.00407e-05|  0.00%|    a.partition(kth, axis=axis, kind=kind, order=order)
   746|         1|  5.00679e-06|  5.00679e-06|  0.00%|    return a
   747|         0|            0|            0|  0.00%|
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|def _argpartition_dispatcher(a, kth, axis=None, kind=None, order=None):
   750|         0|            0|            0|  0.00%|    return (a,)
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|
   753|         0|            0|            0|  0.00%|@array_function_dispatch(_argpartition_dispatcher)
   754|         0|            0|            0|  0.00%|def argpartition(a, kth, axis=-1, kind='introselect', order=None):
   755|         0|            0|            0|  0.00%|    """
   756|         0|            0|            0|  0.00%|    Perform an indirect partition along the given axis using the
   757|         0|            0|            0|  0.00%|    algorithm specified by the `kind` keyword. It returns an array of
   758|         0|            0|            0|  0.00%|    indices of the same shape as `a` that index data along the given
   759|         0|            0|            0|  0.00%|    axis in partitioned order.
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|    .. versionadded:: 1.8.0
   762|         0|            0|            0|  0.00%|
   763|         0|            0|            0|  0.00%|    Parameters
   764|         0|            0|            0|  0.00%|    ----------
   765|         0|            0|            0|  0.00%|    a : array_like
   766|         0|            0|            0|  0.00%|        Array to sort.
   767|         0|            0|            0|  0.00%|    kth : int or sequence of ints
   768|         0|            0|            0|  0.00%|        Element index to partition by. The k-th element will be in its
   769|         0|            0|            0|  0.00%|        final sorted position and all smaller elements will be moved
   770|         0|            0|            0|  0.00%|        before it and all larger elements behind it. The order all
   771|         0|            0|            0|  0.00%|        elements in the partitions is undefined. If provided with a
   772|         0|            0|            0|  0.00%|        sequence of k-th it will partition all of them into their sorted
   773|         0|            0|            0|  0.00%|        position at once.
   774|         0|            0|            0|  0.00%|    axis : int or None, optional
   775|         0|            0|            0|  0.00%|        Axis along which to sort. The default is -1 (the last axis). If
   776|         0|            0|            0|  0.00%|        None, the flattened array is used.
   777|         0|            0|            0|  0.00%|    kind : {'introselect'}, optional
   778|         0|            0|            0|  0.00%|        Selection algorithm. Default is 'introselect'
   779|         0|            0|            0|  0.00%|    order : str or list of str, optional
   780|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument
   781|         0|            0|            0|  0.00%|        specifies which fields to compare first, second, etc. A single
   782|         0|            0|            0|  0.00%|        field can be specified as a string, and not all fields need be
   783|         0|            0|            0|  0.00%|        specified, but unspecified fields will still be used, in the
   784|         0|            0|            0|  0.00%|        order in which they come up in the dtype, to break ties.
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|    Returns
   787|         0|            0|            0|  0.00%|    -------
   788|         0|            0|            0|  0.00%|    index_array : ndarray, int
   789|         0|            0|            0|  0.00%|        Array of indices that partition `a` along the specified axis.
   790|         0|            0|            0|  0.00%|        If `a` is one-dimensional, ``a[index_array]`` yields a partitioned `a`.
   791|         0|            0|            0|  0.00%|        More generally, ``np.take_along_axis(a, index_array, axis=a)`` always
   792|         0|            0|            0|  0.00%|        yields the partitioned `a`, irrespective of dimensionality.
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|    See Also
   795|         0|            0|            0|  0.00%|    --------
   796|         0|            0|            0|  0.00%|    partition : Describes partition algorithms used.
   797|         0|            0|            0|  0.00%|    ndarray.partition : Inplace partition.
   798|         0|            0|            0|  0.00%|    argsort : Full indirect sort
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    Notes
   801|         0|            0|            0|  0.00%|    -----
   802|         0|            0|            0|  0.00%|    See `partition` for notes on the different selection algorithms.
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|    Examples
   805|         0|            0|            0|  0.00%|    --------
   806|         0|            0|            0|  0.00%|    One dimensional array:
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    >>> x = np.array([3, 4, 2, 1])
   809|         0|            0|            0|  0.00%|    >>> x[np.argpartition(x, 3)]
   810|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   811|         0|            0|            0|  0.00%|    >>> x[np.argpartition(x, (1, 3))]
   812|         0|            0|            0|  0.00%|    array([1, 2, 3, 4])
   813|         0|            0|            0|  0.00%|
   814|         0|            0|            0|  0.00%|    >>> x = [3, 4, 2, 1]
   815|         0|            0|            0|  0.00%|    >>> np.array(x)[np.argpartition(x, 3)]
   816|         0|            0|            0|  0.00%|    array([2, 1, 3, 4])
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|    """
   819|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argpartition', kth, axis=axis, kind=kind, order=order)
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|def _sort_dispatcher(a, axis=None, kind=None, order=None):
   823|         0|            0|            0|  0.00%|    return (a,)
   824|         0|            0|            0|  0.00%|
   825|         0|            0|            0|  0.00%|
   826|         0|            0|            0|  0.00%|@array_function_dispatch(_sort_dispatcher)
   827|         0|            0|            0|  0.00%|def sort(a, axis=-1, kind=None, order=None):
   828|         0|            0|            0|  0.00%|    """
   829|         0|            0|            0|  0.00%|    Return a sorted copy of an array.
   830|         0|            0|            0|  0.00%|
   831|         0|            0|            0|  0.00%|    Parameters
   832|         0|            0|            0|  0.00%|    ----------
   833|         0|            0|            0|  0.00%|    a : array_like
   834|         0|            0|            0|  0.00%|        Array to be sorted.
   835|         0|            0|            0|  0.00%|    axis : int or None, optional
   836|         0|            0|            0|  0.00%|        Axis along which to sort. If None, the array is flattened before
   837|         0|            0|            0|  0.00%|        sorting. The default is -1, which sorts along the last axis.
   838|         0|            0|            0|  0.00%|    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
   839|         0|            0|            0|  0.00%|        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
   840|         0|            0|            0|  0.00%|        and 'mergesort' use timsort or radix sort under the covers and, in general,
   841|         0|            0|            0|  0.00%|        the actual implementation will vary with data type. The 'mergesort' option
   842|         0|            0|            0|  0.00%|        is retained for backwards compatibility.
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|        .. versionchanged:: 1.15.0.
   845|         0|            0|            0|  0.00%|           The 'stable' option was added.
   846|         0|            0|            0|  0.00%|
   847|         0|            0|            0|  0.00%|    order : str or list of str, optional
   848|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument specifies
   849|         0|            0|            0|  0.00%|        which fields to compare first, second, etc.  A single field can
   850|         0|            0|            0|  0.00%|        be specified as a string, and not all fields need be specified,
   851|         0|            0|            0|  0.00%|        but unspecified fields will still be used, in the order in which
   852|         0|            0|            0|  0.00%|        they come up in the dtype, to break ties.
   853|         0|            0|            0|  0.00%|
   854|         0|            0|            0|  0.00%|    Returns
   855|         0|            0|            0|  0.00%|    -------
   856|         0|            0|            0|  0.00%|    sorted_array : ndarray
   857|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|    See Also
   860|         0|            0|            0|  0.00%|    --------
   861|         0|            0|            0|  0.00%|    ndarray.sort : Method to sort an array in-place.
   862|         0|            0|            0|  0.00%|    argsort : Indirect sort.
   863|         0|            0|            0|  0.00%|    lexsort : Indirect stable sort on multiple keys.
   864|         0|            0|            0|  0.00%|    searchsorted : Find elements in a sorted array.
   865|         0|            0|            0|  0.00%|    partition : Partial sort.
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|    Notes
   868|         0|            0|            0|  0.00%|    -----
   869|         0|            0|            0|  0.00%|    The various sorting algorithms are characterized by their average speed,
   870|         0|            0|            0|  0.00%|    worst case performance, work space size, and whether they are stable. A
   871|         0|            0|            0|  0.00%|    stable sort keeps items with the same key in the same relative
   872|         0|            0|            0|  0.00%|    order. The four algorithms implemented in NumPy have the following
   873|         0|            0|            0|  0.00%|    properties:
   874|         0|            0|            0|  0.00%|
   875|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   876|         0|            0|            0|  0.00%|       kind      speed   worst case    work space   stable
   877|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   878|         0|            0|            0|  0.00%|    'quicksort'    1     O(n^2)            0          no
   879|         0|            0|            0|  0.00%|    'heapsort'     3     O(n*log(n))       0          no
   880|         0|            0|            0|  0.00%|    'mergesort'    2     O(n*log(n))      ~n/2        yes
   881|         0|            0|            0|  0.00%|    'timsort'      2     O(n*log(n))      ~n/2        yes
   882|         0|            0|            0|  0.00%|    =========== ======= ============= ============ ========
   883|         0|            0|            0|  0.00%|
   884|         0|            0|            0|  0.00%|    .. note:: The datatype determines which of 'mergesort' or 'timsort'
   885|         0|            0|            0|  0.00%|       is actually used, even if 'mergesort' is specified. User selection
   886|         0|            0|            0|  0.00%|       at a finer scale is not currently available.
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|    All the sort algorithms make temporary copies of the data when
   889|         0|            0|            0|  0.00%|    sorting along any but the last axis.  Consequently, sorting along
   890|         0|            0|            0|  0.00%|    the last axis is faster and uses less space than sorting along
   891|         0|            0|            0|  0.00%|    any other axis.
   892|         0|            0|            0|  0.00%|
   893|         0|            0|            0|  0.00%|    The sort order for complex numbers is lexicographic. If both the real
   894|         0|            0|            0|  0.00%|    and imaginary parts are non-nan then the order is determined by the
   895|         0|            0|            0|  0.00%|    real parts except when they are equal, in which case the order is
   896|         0|            0|            0|  0.00%|    determined by the imaginary parts.
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|    Previous to numpy 1.4.0 sorting real and complex arrays containing nan
   899|         0|            0|            0|  0.00%|    values led to undefined behaviour. In numpy versions >= 1.4.0 nan
   900|         0|            0|            0|  0.00%|    values are sorted to the end. The extended sort order is:
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|      * Real: [R, nan]
   903|         0|            0|            0|  0.00%|      * Complex: [R + Rj, R + nanj, nan + Rj, nan + nanj]
   904|         0|            0|            0|  0.00%|
   905|         0|            0|            0|  0.00%|    where R is a non-nan real value. Complex values with the same nan
   906|         0|            0|            0|  0.00%|    placements are sorted according to the non-nan part if it exists.
   907|         0|            0|            0|  0.00%|    Non-nan values are sorted as before.
   908|         0|            0|            0|  0.00%|
   909|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
   910|         0|            0|            0|  0.00%|
   911|         0|            0|            0|  0.00%|    quicksort has been changed to an introsort which will switch
   912|         0|            0|            0|  0.00%|    heapsort when it does not make enough progress. This makes its
   913|         0|            0|            0|  0.00%|    worst case O(n*log(n)).
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|    'stable' automatically choses the best stable sorting algorithm
   916|         0|            0|            0|  0.00%|    for the data type being sorted. It, along with 'mergesort' is
   917|         0|            0|            0|  0.00%|    currently mapped to timsort or radix sort depending on the
   918|         0|            0|            0|  0.00%|    data type. API forward compatibility currently limits the
   919|         0|            0|            0|  0.00%|    ability to select the implementation and it is hardwired for the different
   920|         0|            0|            0|  0.00%|    data types.
   921|         0|            0|            0|  0.00%|
   922|         0|            0|            0|  0.00%|    .. versionadded:: 1.17.0
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|    Timsort is added for better performance on already or nearly
   925|         0|            0|            0|  0.00%|    sorted data. On random data timsort is almost identical to
   926|         0|            0|            0|  0.00%|    mergesort. It is now used for stable sort while quicksort is still the
   927|         0|            0|            0|  0.00%|    default sort if none is chosen. For details of timsort, refer to
   928|         0|            0|            0|  0.00%|    `CPython listsort.txt <https://github.com/python/cpython/blob/3.7/Objects/listsort.txt>`_.
   929|         0|            0|            0|  0.00%|    'mergesort' and 'stable' are mapped to radix sort for integer data types. Radix sort is an
   930|         0|            0|            0|  0.00%|    O(n) sort instead of O(n log n).
   931|         0|            0|            0|  0.00%|
   932|         0|            0|            0|  0.00%|    Examples
   933|         0|            0|            0|  0.00%|    --------
   934|         0|            0|            0|  0.00%|    >>> a = np.array([[1,4],[3,1]])
   935|         0|            0|            0|  0.00%|    >>> np.sort(a)                # sort along the last axis
   936|         0|            0|            0|  0.00%|    array([[1, 4],
   937|         0|            0|            0|  0.00%|           [1, 3]])
   938|         0|            0|            0|  0.00%|    >>> np.sort(a, axis=None)     # sort the flattened array
   939|         0|            0|            0|  0.00%|    array([1, 1, 3, 4])
   940|         0|            0|            0|  0.00%|    >>> np.sort(a, axis=0)        # sort along the first axis
   941|         0|            0|            0|  0.00%|    array([[1, 1],
   942|         0|            0|            0|  0.00%|           [3, 4]])
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|    Use the `order` keyword to specify a field to use when sorting a
   945|         0|            0|            0|  0.00%|    structured array:
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|    >>> dtype = [('name', 'S10'), ('height', float), ('age', int)]
   948|         0|            0|            0|  0.00%|    >>> values = [('Arthur', 1.8, 41), ('Lancelot', 1.9, 38),
   949|         0|            0|            0|  0.00%|    ...           ('Galahad', 1.7, 38)]
   950|         0|            0|            0|  0.00%|    >>> a = np.array(values, dtype=dtype)       # create a structured array
   951|         0|            0|            0|  0.00%|    >>> np.sort(a, order='height')                        # doctest: +SKIP
   952|         0|            0|            0|  0.00%|    array([('Galahad', 1.7, 38), ('Arthur', 1.8, 41),
   953|         0|            0|            0|  0.00%|           ('Lancelot', 1.8999999999999999, 38)],
   954|         0|            0|            0|  0.00%|          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
   955|         0|            0|            0|  0.00%|
   956|         0|            0|            0|  0.00%|    Sort by age, then height if ages are equal:
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|    >>> np.sort(a, order=['age', 'height'])               # doctest: +SKIP
   959|         0|            0|            0|  0.00%|    array([('Galahad', 1.7, 38), ('Lancelot', 1.8999999999999999, 38),
   960|         0|            0|            0|  0.00%|           ('Arthur', 1.8, 41)],
   961|         0|            0|            0|  0.00%|          dtype=[('name', '|S10'), ('height', '<f8'), ('age', '<i4')])
   962|         0|            0|            0|  0.00%|
   963|         0|            0|            0|  0.00%|    """
   964|         0|            0|            0|  0.00%|    if axis is None:
   965|         0|            0|            0|  0.00%|        # flatten returns (1, N) for np.matrix, so always use the last axis
   966|         0|            0|            0|  0.00%|        a = asanyarray(a).flatten()
   967|         0|            0|            0|  0.00%|        axis = -1
   968|         0|            0|            0|  0.00%|    else:
   969|         0|            0|            0|  0.00%|        a = asanyarray(a).copy(order="K")
   970|         0|            0|            0|  0.00%|    a.sort(axis=axis, kind=kind, order=order)
   971|         0|            0|            0|  0.00%|    return a
   972|         0|            0|            0|  0.00%|
   973|         0|            0|            0|  0.00%|
   974|         0|            0|            0|  0.00%|def _argsort_dispatcher(a, axis=None, kind=None, order=None):
   975|         0|            0|            0|  0.00%|    return (a,)
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|
   978|         0|            0|            0|  0.00%|@array_function_dispatch(_argsort_dispatcher)
   979|         0|            0|            0|  0.00%|def argsort(a, axis=-1, kind=None, order=None):
   980|         0|            0|            0|  0.00%|    """
   981|         0|            0|            0|  0.00%|    Returns the indices that would sort an array.
   982|         0|            0|            0|  0.00%|
   983|         0|            0|            0|  0.00%|    Perform an indirect sort along the given axis using the algorithm specified
   984|         0|            0|            0|  0.00%|    by the `kind` keyword. It returns an array of indices of the same shape as
   985|         0|            0|            0|  0.00%|    `a` that index data along the given axis in sorted order.
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|    Parameters
   988|         0|            0|            0|  0.00%|    ----------
   989|         0|            0|            0|  0.00%|    a : array_like
   990|         0|            0|            0|  0.00%|        Array to sort.
   991|         0|            0|            0|  0.00%|    axis : int or None, optional
   992|         0|            0|            0|  0.00%|        Axis along which to sort.  The default is -1 (the last axis). If None,
   993|         0|            0|            0|  0.00%|        the flattened array is used.
   994|         0|            0|            0|  0.00%|    kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
   995|         0|            0|            0|  0.00%|        Sorting algorithm. The default is 'quicksort'. Note that both 'stable'
   996|         0|            0|            0|  0.00%|        and 'mergesort' use timsort under the covers and, in general, the
   997|         0|            0|            0|  0.00%|        actual implementation will vary with data type. The 'mergesort' option
   998|         0|            0|            0|  0.00%|        is retained for backwards compatibility.
   999|         0|            0|            0|  0.00%|
  1000|         0|            0|            0|  0.00%|        .. versionchanged:: 1.15.0.
  1001|         0|            0|            0|  0.00%|           The 'stable' option was added.
  1002|         0|            0|            0|  0.00%|    order : str or list of str, optional
  1003|         0|            0|            0|  0.00%|        When `a` is an array with fields defined, this argument specifies
  1004|         0|            0|            0|  0.00%|        which fields to compare first, second, etc.  A single field can
  1005|         0|            0|            0|  0.00%|        be specified as a string, and not all fields need be specified,
  1006|         0|            0|            0|  0.00%|        but unspecified fields will still be used, in the order in which
  1007|         0|            0|            0|  0.00%|        they come up in the dtype, to break ties.
  1008|         0|            0|            0|  0.00%|
  1009|         0|            0|            0|  0.00%|    Returns
  1010|         0|            0|            0|  0.00%|    -------
  1011|         0|            0|            0|  0.00%|    index_array : ndarray, int
  1012|         0|            0|            0|  0.00%|        Array of indices that sort `a` along the specified `axis`.
  1013|         0|            0|            0|  0.00%|        If `a` is one-dimensional, ``a[index_array]`` yields a sorted `a`.
  1014|         0|            0|            0|  0.00%|        More generally, ``np.take_along_axis(a, index_array, axis=axis)``
  1015|         0|            0|            0|  0.00%|        always yields the sorted `a`, irrespective of dimensionality.
  1016|         0|            0|            0|  0.00%|
  1017|         0|            0|            0|  0.00%|    See Also
  1018|         0|            0|            0|  0.00%|    --------
  1019|         0|            0|            0|  0.00%|    sort : Describes sorting algorithms used.
  1020|         0|            0|            0|  0.00%|    lexsort : Indirect stable sort with multiple keys.
  1021|         0|            0|            0|  0.00%|    ndarray.sort : Inplace sort.
  1022|         0|            0|            0|  0.00%|    argpartition : Indirect partial sort.
  1023|         0|            0|            0|  0.00%|
  1024|         0|            0|            0|  0.00%|    Notes
  1025|         0|            0|            0|  0.00%|    -----
  1026|         0|            0|            0|  0.00%|    See `sort` for notes on the different sorting algorithms.
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|    As of NumPy 1.4.0 `argsort` works with real/complex arrays containing
  1029|         0|            0|            0|  0.00%|    nan values. The enhanced sort order is documented in `sort`.
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|    Examples
  1032|         0|            0|            0|  0.00%|    --------
  1033|         0|            0|            0|  0.00%|    One dimensional array:
  1034|         0|            0|            0|  0.00%|
  1035|         0|            0|            0|  0.00%|    >>> x = np.array([3, 1, 2])
  1036|         0|            0|            0|  0.00%|    >>> np.argsort(x)
  1037|         0|            0|            0|  0.00%|    array([1, 2, 0])
  1038|         0|            0|            0|  0.00%|
  1039|         0|            0|            0|  0.00%|    Two-dimensional array:
  1040|         0|            0|            0|  0.00%|
  1041|         0|            0|            0|  0.00%|    >>> x = np.array([[0, 3], [2, 2]])
  1042|         0|            0|            0|  0.00%|    >>> x
  1043|         0|            0|            0|  0.00%|    array([[0, 3],
  1044|         0|            0|            0|  0.00%|           [2, 2]])
  1045|         0|            0|            0|  0.00%|
  1046|         0|            0|            0|  0.00%|    >>> ind = np.argsort(x, axis=0)  # sorts along first axis (down)
  1047|         0|            0|            0|  0.00%|    >>> ind
  1048|         0|            0|            0|  0.00%|    array([[0, 1],
  1049|         0|            0|            0|  0.00%|           [1, 0]])
  1050|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, ind, axis=0)  # same as np.sort(x, axis=0)
  1051|         0|            0|            0|  0.00%|    array([[0, 2],
  1052|         0|            0|            0|  0.00%|           [2, 3]])
  1053|         0|            0|            0|  0.00%|
  1054|         0|            0|            0|  0.00%|    >>> ind = np.argsort(x, axis=1)  # sorts along last axis (across)
  1055|         0|            0|            0|  0.00%|    >>> ind
  1056|         0|            0|            0|  0.00%|    array([[0, 1],
  1057|         0|            0|            0|  0.00%|           [0, 1]])
  1058|         0|            0|            0|  0.00%|    >>> np.take_along_axis(x, ind, axis=1)  # same as np.sort(x, axis=1)
  1059|         0|            0|            0|  0.00%|    array([[0, 3],
  1060|         0|            0|            0|  0.00%|           [2, 2]])
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|    Indices of the sorted elements of a N-dimensional array:
  1063|         0|            0|            0|  0.00%|
  1064|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argsort(x, axis=None), x.shape)
  1065|         0|            0|            0|  0.00%|    >>> ind
  1066|         0|            0|            0|  0.00%|    (array([0, 1, 1, 0]), array([0, 0, 1, 1]))
  1067|         0|            0|            0|  0.00%|    >>> x[ind]  # same as np.sort(x, axis=None)
  1068|         0|            0|            0|  0.00%|    array([0, 2, 2, 3])
  1069|         0|            0|            0|  0.00%|
  1070|         0|            0|            0|  0.00%|    Sorting with keys:
  1071|         0|            0|            0|  0.00%|
  1072|         0|            0|            0|  0.00%|    >>> x = np.array([(1, 0), (0, 1)], dtype=[('x', '<i4'), ('y', '<i4')])
  1073|         0|            0|            0|  0.00%|    >>> x
  1074|         0|            0|            0|  0.00%|    array([(1, 0), (0, 1)],
  1075|         0|            0|            0|  0.00%|          dtype=[('x', '<i4'), ('y', '<i4')])
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|    >>> np.argsort(x, order=('x','y'))
  1078|         0|            0|            0|  0.00%|    array([1, 0])
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|    >>> np.argsort(x, order=('y','x'))
  1081|         0|            0|            0|  0.00%|    array([0, 1])
  1082|         0|            0|            0|  0.00%|
  1083|         0|            0|            0|  0.00%|    """
  1084|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argsort', axis=axis, kind=kind, order=order)
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|
  1087|         0|            0|            0|  0.00%|def _argmax_dispatcher(a, axis=None, out=None):
  1088|         0|            0|            0|  0.00%|    return (a, out)
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|
  1091|         0|            0|            0|  0.00%|@array_function_dispatch(_argmax_dispatcher)
  1092|         0|            0|            0|  0.00%|def argmax(a, axis=None, out=None):
  1093|         0|            0|            0|  0.00%|    """
  1094|         0|            0|            0|  0.00%|    Returns the indices of the maximum values along an axis.
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|    Parameters
  1097|         0|            0|            0|  0.00%|    ----------
  1098|         0|            0|            0|  0.00%|    a : array_like
  1099|         0|            0|            0|  0.00%|        Input array.
  1100|         0|            0|            0|  0.00%|    axis : int, optional
  1101|         0|            0|            0|  0.00%|        By default, the index is into the flattened array, otherwise
  1102|         0|            0|            0|  0.00%|        along the specified axis.
  1103|         0|            0|            0|  0.00%|    out : array, optional
  1104|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
  1105|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype.
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|    Returns
  1108|         0|            0|            0|  0.00%|    -------
  1109|         0|            0|            0|  0.00%|    index_array : ndarray of ints
  1110|         0|            0|            0|  0.00%|        Array of indices into the array. It has the same shape as `a.shape`
  1111|         0|            0|            0|  0.00%|        with the dimension along `axis` removed.
  1112|         0|            0|            0|  0.00%|
  1113|         0|            0|            0|  0.00%|    See Also
  1114|         0|            0|            0|  0.00%|    --------
  1115|         0|            0|            0|  0.00%|    ndarray.argmax, argmin
  1116|         0|            0|            0|  0.00%|    amax : The maximum value along a given axis.
  1117|         0|            0|            0|  0.00%|    unravel_index : Convert a flat index into an index tuple.
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|    Notes
  1120|         0|            0|            0|  0.00%|    -----
  1121|         0|            0|            0|  0.00%|    In case of multiple occurrences of the maximum values, the indices
  1122|         0|            0|            0|  0.00%|    corresponding to the first occurrence are returned.
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|    Examples
  1125|         0|            0|            0|  0.00%|    --------
  1126|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2,3) + 10
  1127|         0|            0|            0|  0.00%|    >>> a
  1128|         0|            0|            0|  0.00%|    array([[10, 11, 12],
  1129|         0|            0|            0|  0.00%|           [13, 14, 15]])
  1130|         0|            0|            0|  0.00%|    >>> np.argmax(a)
  1131|         0|            0|            0|  0.00%|    5
  1132|         0|            0|            0|  0.00%|    >>> np.argmax(a, axis=0)
  1133|         0|            0|            0|  0.00%|    array([1, 1, 1])
  1134|         0|            0|            0|  0.00%|    >>> np.argmax(a, axis=1)
  1135|         0|            0|            0|  0.00%|    array([2, 2])
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|    Indexes of the maximal elements of a N-dimensional array:
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argmax(a, axis=None), a.shape)
  1140|         0|            0|            0|  0.00%|    >>> ind
  1141|         0|            0|            0|  0.00%|    (1, 2)
  1142|         0|            0|            0|  0.00%|    >>> a[ind]
  1143|         0|            0|            0|  0.00%|    15
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|    >>> b = np.arange(6)
  1146|         0|            0|            0|  0.00%|    >>> b[1] = 5
  1147|         0|            0|            0|  0.00%|    >>> b
  1148|         0|            0|            0|  0.00%|    array([0, 5, 2, 3, 4, 5])
  1149|         0|            0|            0|  0.00%|    >>> np.argmax(b)  # Only the first occurrence is returned.
  1150|         0|            0|            0|  0.00%|    1
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|    """
  1153|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argmax', axis=axis, out=out)
  1154|         0|            0|            0|  0.00%|
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|def _argmin_dispatcher(a, axis=None, out=None):
  1157|         0|            0|            0|  0.00%|    return (a, out)
  1158|         0|            0|            0|  0.00%|
  1159|         0|            0|            0|  0.00%|
  1160|         0|            0|            0|  0.00%|@array_function_dispatch(_argmin_dispatcher)
  1161|         0|            0|            0|  0.00%|def argmin(a, axis=None, out=None):
  1162|         0|            0|            0|  0.00%|    """
  1163|         0|            0|            0|  0.00%|    Returns the indices of the minimum values along an axis.
  1164|         0|            0|            0|  0.00%|
  1165|         0|            0|            0|  0.00%|    Parameters
  1166|         0|            0|            0|  0.00%|    ----------
  1167|         0|            0|            0|  0.00%|    a : array_like
  1168|         0|            0|            0|  0.00%|        Input array.
  1169|         0|            0|            0|  0.00%|    axis : int, optional
  1170|         0|            0|            0|  0.00%|        By default, the index is into the flattened array, otherwise
  1171|         0|            0|            0|  0.00%|        along the specified axis.
  1172|         0|            0|            0|  0.00%|    out : array, optional
  1173|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
  1174|         0|            0|            0|  0.00%|        be of the appropriate shape and dtype.
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|    Returns
  1177|         0|            0|            0|  0.00%|    -------
  1178|         0|            0|            0|  0.00%|    index_array : ndarray of ints
  1179|         0|            0|            0|  0.00%|        Array of indices into the array. It has the same shape as `a.shape`
  1180|         0|            0|            0|  0.00%|        with the dimension along `axis` removed.
  1181|         0|            0|            0|  0.00%|
  1182|         0|            0|            0|  0.00%|    See Also
  1183|         0|            0|            0|  0.00%|    --------
  1184|         0|            0|            0|  0.00%|    ndarray.argmin, argmax
  1185|         0|            0|            0|  0.00%|    amin : The minimum value along a given axis.
  1186|         0|            0|            0|  0.00%|    unravel_index : Convert a flat index into an index tuple.
  1187|         0|            0|            0|  0.00%|
  1188|         0|            0|            0|  0.00%|    Notes
  1189|         0|            0|            0|  0.00%|    -----
  1190|         0|            0|            0|  0.00%|    In case of multiple occurrences of the minimum values, the indices
  1191|         0|            0|            0|  0.00%|    corresponding to the first occurrence are returned.
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    Examples
  1194|         0|            0|            0|  0.00%|    --------
  1195|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2,3) + 10
  1196|         0|            0|            0|  0.00%|    >>> a
  1197|         0|            0|            0|  0.00%|    array([[10, 11, 12],
  1198|         0|            0|            0|  0.00%|           [13, 14, 15]])
  1199|         0|            0|            0|  0.00%|    >>> np.argmin(a)
  1200|         0|            0|            0|  0.00%|    0
  1201|         0|            0|            0|  0.00%|    >>> np.argmin(a, axis=0)
  1202|         0|            0|            0|  0.00%|    array([0, 0, 0])
  1203|         0|            0|            0|  0.00%|    >>> np.argmin(a, axis=1)
  1204|         0|            0|            0|  0.00%|    array([0, 0])
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|    Indices of the minimum elements of a N-dimensional array:
  1207|         0|            0|            0|  0.00%|
  1208|         0|            0|            0|  0.00%|    >>> ind = np.unravel_index(np.argmin(a, axis=None), a.shape)
  1209|         0|            0|            0|  0.00%|    >>> ind
  1210|         0|            0|            0|  0.00%|    (0, 0)
  1211|         0|            0|            0|  0.00%|    >>> a[ind]
  1212|         0|            0|            0|  0.00%|    10
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|    >>> b = np.arange(6) + 10
  1215|         0|            0|            0|  0.00%|    >>> b[4] = 10
  1216|         0|            0|            0|  0.00%|    >>> b
  1217|         0|            0|            0|  0.00%|    array([10, 11, 12, 13, 10, 15])
  1218|         0|            0|            0|  0.00%|    >>> np.argmin(b)  # Only the first occurrence is returned.
  1219|         0|            0|            0|  0.00%|    0
  1220|         0|            0|            0|  0.00%|
  1221|         0|            0|            0|  0.00%|    """
  1222|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'argmin', axis=axis, out=out)
  1223|         0|            0|            0|  0.00%|
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|def _searchsorted_dispatcher(a, v, side=None, sorter=None):
  1226|         0|            0|            0|  0.00%|    return (a, v, sorter)
  1227|         0|            0|            0|  0.00%|
  1228|         0|            0|            0|  0.00%|
  1229|         0|            0|            0|  0.00%|@array_function_dispatch(_searchsorted_dispatcher)
  1230|         0|            0|            0|  0.00%|def searchsorted(a, v, side='left', sorter=None):
  1231|         0|            0|            0|  0.00%|    """
  1232|         0|            0|            0|  0.00%|    Find indices where elements should be inserted to maintain order.
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|    Find the indices into a sorted array `a` such that, if the
  1235|         0|            0|            0|  0.00%|    corresponding elements in `v` were inserted before the indices, the
  1236|         0|            0|            0|  0.00%|    order of `a` would be preserved.
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|    Assuming that `a` is sorted:
  1239|         0|            0|            0|  0.00%|
  1240|         0|            0|            0|  0.00%|    ======  ============================
  1241|         0|            0|            0|  0.00%|    `side`  returned index `i` satisfies
  1242|         0|            0|            0|  0.00%|    ======  ============================
  1243|         0|            0|            0|  0.00%|    left    ``a[i-1] < v <= a[i]``
  1244|         0|            0|            0|  0.00%|    right   ``a[i-1] <= v < a[i]``
  1245|         0|            0|            0|  0.00%|    ======  ============================
  1246|         0|            0|            0|  0.00%|
  1247|         0|            0|            0|  0.00%|    Parameters
  1248|         0|            0|            0|  0.00%|    ----------
  1249|         0|            0|            0|  0.00%|    a : 1-D array_like
  1250|         0|            0|            0|  0.00%|        Input array. If `sorter` is None, then it must be sorted in
  1251|         0|            0|            0|  0.00%|        ascending order, otherwise `sorter` must be an array of indices
  1252|         0|            0|            0|  0.00%|        that sort it.
  1253|         0|            0|            0|  0.00%|    v : array_like
  1254|         0|            0|            0|  0.00%|        Values to insert into `a`.
  1255|         0|            0|            0|  0.00%|    side : {'left', 'right'}, optional
  1256|         0|            0|            0|  0.00%|        If 'left', the index of the first suitable location found is given.
  1257|         0|            0|            0|  0.00%|        If 'right', return the last such index.  If there is no suitable
  1258|         0|            0|            0|  0.00%|        index, return either 0 or N (where N is the length of `a`).
  1259|         0|            0|            0|  0.00%|    sorter : 1-D array_like, optional
  1260|         0|            0|            0|  0.00%|        Optional array of integer indices that sort array a into ascending
  1261|         0|            0|            0|  0.00%|        order. They are typically the result of argsort.
  1262|         0|            0|            0|  0.00%|
  1263|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1264|         0|            0|            0|  0.00%|
  1265|         0|            0|            0|  0.00%|    Returns
  1266|         0|            0|            0|  0.00%|    -------
  1267|         0|            0|            0|  0.00%|    indices : array of ints
  1268|         0|            0|            0|  0.00%|        Array of insertion points with the same shape as `v`.
  1269|         0|            0|            0|  0.00%|
  1270|         0|            0|            0|  0.00%|    See Also
  1271|         0|            0|            0|  0.00%|    --------
  1272|         0|            0|            0|  0.00%|    sort : Return a sorted copy of an array.
  1273|         0|            0|            0|  0.00%|    histogram : Produce histogram from 1-D data.
  1274|         0|            0|            0|  0.00%|
  1275|         0|            0|            0|  0.00%|    Notes
  1276|         0|            0|            0|  0.00%|    -----
  1277|         0|            0|            0|  0.00%|    Binary search is used to find the required insertion points.
  1278|         0|            0|            0|  0.00%|
  1279|         0|            0|            0|  0.00%|    As of NumPy 1.4.0 `searchsorted` works with real/complex arrays containing
  1280|         0|            0|            0|  0.00%|    `nan` values. The enhanced sort order is documented in `sort`.
  1281|         0|            0|            0|  0.00%|
  1282|         0|            0|            0|  0.00%|    This function uses the same algorithm as the builtin python `bisect.bisect_left`
  1283|         0|            0|            0|  0.00%|    (``side='left'``) and `bisect.bisect_right` (``side='right'``) functions,
  1284|         0|            0|            0|  0.00%|    which is also vectorized in the `v` argument.
  1285|         0|            0|            0|  0.00%|
  1286|         0|            0|            0|  0.00%|    Examples
  1287|         0|            0|            0|  0.00%|    --------
  1288|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], 3)
  1289|         0|            0|            0|  0.00%|    2
  1290|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], 3, side='right')
  1291|         0|            0|            0|  0.00%|    3
  1292|         0|            0|            0|  0.00%|    >>> np.searchsorted([1,2,3,4,5], [-10, 10, 2, 3])
  1293|         0|            0|            0|  0.00%|    array([0, 5, 1, 2])
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|    """
  1296|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'searchsorted', v, side=side, sorter=sorter)
  1297|         0|            0|            0|  0.00%|
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|def _resize_dispatcher(a, new_shape):
  1300|         0|            0|            0|  0.00%|    return (a,)
  1301|         0|            0|            0|  0.00%|
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|@array_function_dispatch(_resize_dispatcher)
  1304|         0|            0|            0|  0.00%|def resize(a, new_shape):
  1305|         0|            0|            0|  0.00%|    """
  1306|         0|            0|            0|  0.00%|    Return a new array with the specified shape.
  1307|         0|            0|            0|  0.00%|
  1308|         0|            0|            0|  0.00%|    If the new array is larger than the original array, then the new
  1309|         0|            0|            0|  0.00%|    array is filled with repeated copies of `a`.  Note that this behavior
  1310|         0|            0|            0|  0.00%|    is different from a.resize(new_shape) which fills with zeros instead
  1311|         0|            0|            0|  0.00%|    of repeated copies of `a`.
  1312|         0|            0|            0|  0.00%|
  1313|         0|            0|            0|  0.00%|    Parameters
  1314|         0|            0|            0|  0.00%|    ----------
  1315|         0|            0|            0|  0.00%|    a : array_like
  1316|         0|            0|            0|  0.00%|        Array to be resized.
  1317|         0|            0|            0|  0.00%|
  1318|         0|            0|            0|  0.00%|    new_shape : int or tuple of int
  1319|         0|            0|            0|  0.00%|        Shape of resized array.
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|    Returns
  1322|         0|            0|            0|  0.00%|    -------
  1323|         0|            0|            0|  0.00%|    reshaped_array : ndarray
  1324|         0|            0|            0|  0.00%|        The new array is formed from the data in the old array, repeated
  1325|         0|            0|            0|  0.00%|        if necessary to fill out the required number of elements.  The
  1326|         0|            0|            0|  0.00%|        data are repeated in the order that they are stored in memory.
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|    See Also
  1329|         0|            0|            0|  0.00%|    --------
  1330|         0|            0|            0|  0.00%|    ndarray.resize : resize an array in-place.
  1331|         0|            0|            0|  0.00%|
  1332|         0|            0|            0|  0.00%|    Notes
  1333|         0|            0|            0|  0.00%|    -----
  1334|         0|            0|            0|  0.00%|    Warning: This functionality does **not** consider axes separately,
  1335|         0|            0|            0|  0.00%|    i.e. it does not apply interpolation/extrapolation.
  1336|         0|            0|            0|  0.00%|    It fills the return array with the required number of elements, taken
  1337|         0|            0|            0|  0.00%|    from `a` as they are laid out in memory, disregarding strides and axes.
  1338|         0|            0|            0|  0.00%|    (This is in case the new shape is smaller. For larger, see above.)
  1339|         0|            0|            0|  0.00%|    This functionality is therefore not suitable to resize images,
  1340|         0|            0|            0|  0.00%|    or data where each axis represents a separate and distinct entity.
  1341|         0|            0|            0|  0.00%|
  1342|         0|            0|            0|  0.00%|    Examples
  1343|         0|            0|            0|  0.00%|    --------
  1344|         0|            0|            0|  0.00%|    >>> a=np.array([[0,1],[2,3]])
  1345|         0|            0|            0|  0.00%|    >>> np.resize(a,(2,3))
  1346|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1347|         0|            0|            0|  0.00%|           [3, 0, 1]])
  1348|         0|            0|            0|  0.00%|    >>> np.resize(a,(1,4))
  1349|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3]])
  1350|         0|            0|            0|  0.00%|    >>> np.resize(a,(2,4))
  1351|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3],
  1352|         0|            0|            0|  0.00%|           [0, 1, 2, 3]])
  1353|         0|            0|            0|  0.00%|
  1354|         0|            0|            0|  0.00%|    """
  1355|         0|            0|            0|  0.00%|    if isinstance(new_shape, (int, nt.integer)):
  1356|         0|            0|            0|  0.00%|        new_shape = (new_shape,)
  1357|         0|            0|            0|  0.00%|    a = ravel(a)
  1358|         0|            0|            0|  0.00%|    Na = len(a)
  1359|         0|            0|            0|  0.00%|    total_size = um.multiply.reduce(new_shape)
  1360|         0|            0|            0|  0.00%|    if Na == 0 or total_size == 0:
  1361|         0|            0|            0|  0.00%|        return mu.zeros(new_shape, a.dtype)
  1362|         0|            0|            0|  0.00%|
  1363|         0|            0|            0|  0.00%|    n_copies = int(total_size / Na)
  1364|         0|            0|            0|  0.00%|    extra = total_size % Na
  1365|         0|            0|            0|  0.00%|
  1366|         0|            0|            0|  0.00%|    if extra != 0:
  1367|         0|            0|            0|  0.00%|        n_copies = n_copies + 1
  1368|         0|            0|            0|  0.00%|        extra = Na - extra
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|    a = concatenate((a,) * n_copies)
  1371|         0|            0|            0|  0.00%|    if extra > 0:
  1372|         0|            0|            0|  0.00%|        a = a[:-extra]
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    return reshape(a, new_shape)
  1375|         0|            0|            0|  0.00%|
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|def _squeeze_dispatcher(a, axis=None):
  1378|         0|            0|            0|  0.00%|    return (a,)
  1379|         0|            0|            0|  0.00%|
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|@array_function_dispatch(_squeeze_dispatcher)
  1382|         0|            0|            0|  0.00%|def squeeze(a, axis=None):
  1383|         0|            0|            0|  0.00%|    """
  1384|         0|            0|            0|  0.00%|    Remove single-dimensional entries from the shape of an array.
  1385|         0|            0|            0|  0.00%|
  1386|         0|            0|            0|  0.00%|    Parameters
  1387|         0|            0|            0|  0.00%|    ----------
  1388|         0|            0|            0|  0.00%|    a : array_like
  1389|         0|            0|            0|  0.00%|        Input data.
  1390|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  1391|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1392|         0|            0|            0|  0.00%|
  1393|         0|            0|            0|  0.00%|        Selects a subset of the single-dimensional entries in the
  1394|         0|            0|            0|  0.00%|        shape. If an axis is selected with shape entry greater than
  1395|         0|            0|            0|  0.00%|        one, an error is raised.
  1396|         0|            0|            0|  0.00%|
  1397|         0|            0|            0|  0.00%|    Returns
  1398|         0|            0|            0|  0.00%|    -------
  1399|         0|            0|            0|  0.00%|    squeezed : ndarray
  1400|         0|            0|            0|  0.00%|        The input array, but with all or a subset of the
  1401|         0|            0|            0|  0.00%|        dimensions of length 1 removed. This is always `a` itself
  1402|         0|            0|            0|  0.00%|        or a view into `a`.
  1403|         0|            0|            0|  0.00%|
  1404|         0|            0|            0|  0.00%|    Raises
  1405|         0|            0|            0|  0.00%|    ------
  1406|         0|            0|            0|  0.00%|    ValueError
  1407|         0|            0|            0|  0.00%|        If `axis` is not `None`, and an axis being squeezed is not of length 1
  1408|         0|            0|            0|  0.00%|
  1409|         0|            0|            0|  0.00%|    See Also
  1410|         0|            0|            0|  0.00%|    --------
  1411|         0|            0|            0|  0.00%|    expand_dims : The inverse operation, adding singleton dimensions
  1412|         0|            0|            0|  0.00%|    reshape : Insert, remove, and combine dimensions, and resize existing ones
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|    Examples
  1415|         0|            0|            0|  0.00%|    --------
  1416|         0|            0|            0|  0.00%|    >>> x = np.array([[[0], [1], [2]]])
  1417|         0|            0|            0|  0.00%|    >>> x.shape
  1418|         0|            0|            0|  0.00%|    (1, 3, 1)
  1419|         0|            0|            0|  0.00%|    >>> np.squeeze(x).shape
  1420|         0|            0|            0|  0.00%|    (3,)
  1421|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=0).shape
  1422|         0|            0|            0|  0.00%|    (3, 1)
  1423|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=1).shape
  1424|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1425|         0|            0|            0|  0.00%|    ...
  1426|         0|            0|            0|  0.00%|    ValueError: cannot select an axis to squeeze out which has size not equal to one
  1427|         0|            0|            0|  0.00%|    >>> np.squeeze(x, axis=2).shape
  1428|         0|            0|            0|  0.00%|    (1, 3)
  1429|         0|            0|            0|  0.00%|
  1430|         0|            0|            0|  0.00%|    """
  1431|         0|            0|            0|  0.00%|    try:
  1432|         0|            0|            0|  0.00%|        squeeze = a.squeeze
  1433|         0|            0|            0|  0.00%|    except AttributeError:
  1434|         0|            0|            0|  0.00%|        return _wrapit(a, 'squeeze', axis=axis)
  1435|         0|            0|            0|  0.00%|    if axis is None:
  1436|         0|            0|            0|  0.00%|        return squeeze()
  1437|         0|            0|            0|  0.00%|    else:
  1438|         0|            0|            0|  0.00%|        return squeeze(axis=axis)
  1439|         0|            0|            0|  0.00%|
  1440|         0|            0|            0|  0.00%|
  1441|         0|            0|            0|  0.00%|def _diagonal_dispatcher(a, offset=None, axis1=None, axis2=None):
  1442|         0|            0|            0|  0.00%|    return (a,)
  1443|         0|            0|            0|  0.00%|
  1444|         0|            0|            0|  0.00%|
  1445|         0|            0|            0|  0.00%|@array_function_dispatch(_diagonal_dispatcher)
  1446|         0|            0|            0|  0.00%|def diagonal(a, offset=0, axis1=0, axis2=1):
  1447|         0|            0|            0|  0.00%|    """
  1448|         0|            0|            0|  0.00%|    Return specified diagonals.
  1449|         0|            0|            0|  0.00%|
  1450|         0|            0|            0|  0.00%|    If `a` is 2-D, returns the diagonal of `a` with the given offset,
  1451|         0|            0|            0|  0.00%|    i.e., the collection of elements of the form ``a[i, i+offset]``.  If
  1452|         0|            0|            0|  0.00%|    `a` has more than two dimensions, then the axes specified by `axis1`
  1453|         0|            0|            0|  0.00%|    and `axis2` are used to determine the 2-D sub-array whose diagonal is
  1454|         0|            0|            0|  0.00%|    returned.  The shape of the resulting array can be determined by
  1455|         0|            0|            0|  0.00%|    removing `axis1` and `axis2` and appending an index to the right equal
  1456|         0|            0|            0|  0.00%|    to the size of the resulting diagonals.
  1457|         0|            0|            0|  0.00%|
  1458|         0|            0|            0|  0.00%|    In versions of NumPy prior to 1.7, this function always returned a new,
  1459|         0|            0|            0|  0.00%|    independent array containing a copy of the values in the diagonal.
  1460|         0|            0|            0|  0.00%|
  1461|         0|            0|            0|  0.00%|    In NumPy 1.7 and 1.8, it continues to return a copy of the diagonal,
  1462|         0|            0|            0|  0.00%|    but depending on this fact is deprecated. Writing to the resulting
  1463|         0|            0|            0|  0.00%|    array continues to work as it used to, but a FutureWarning is issued.
  1464|         0|            0|            0|  0.00%|
  1465|         0|            0|            0|  0.00%|    Starting in NumPy 1.9 it returns a read-only view on the original array.
  1466|         0|            0|            0|  0.00%|    Attempting to write to the resulting array will produce an error.
  1467|         0|            0|            0|  0.00%|
  1468|         0|            0|            0|  0.00%|    In some future release, it will return a read/write view and writing to
  1469|         0|            0|            0|  0.00%|    the returned array will alter your original array.  The returned array
  1470|         0|            0|            0|  0.00%|    will have the same type as the input array.
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|    If you don't write to the array returned by this function, then you can
  1473|         0|            0|            0|  0.00%|    just ignore all of the above.
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|    If you depend on the current behavior, then we suggest copying the
  1476|         0|            0|            0|  0.00%|    returned array explicitly, i.e., use ``np.diagonal(a).copy()`` instead
  1477|         0|            0|            0|  0.00%|    of just ``np.diagonal(a)``. This will work with both past and future
  1478|         0|            0|            0|  0.00%|    versions of NumPy.
  1479|         0|            0|            0|  0.00%|
  1480|         0|            0|            0|  0.00%|    Parameters
  1481|         0|            0|            0|  0.00%|    ----------
  1482|         0|            0|            0|  0.00%|    a : array_like
  1483|         0|            0|            0|  0.00%|        Array from which the diagonals are taken.
  1484|         0|            0|            0|  0.00%|    offset : int, optional
  1485|         0|            0|            0|  0.00%|        Offset of the diagonal from the main diagonal.  Can be positive or
  1486|         0|            0|            0|  0.00%|        negative.  Defaults to main diagonal (0).
  1487|         0|            0|            0|  0.00%|    axis1 : int, optional
  1488|         0|            0|            0|  0.00%|        Axis to be used as the first axis of the 2-D sub-arrays from which
  1489|         0|            0|            0|  0.00%|        the diagonals should be taken.  Defaults to first axis (0).
  1490|         0|            0|            0|  0.00%|    axis2 : int, optional
  1491|         0|            0|            0|  0.00%|        Axis to be used as the second axis of the 2-D sub-arrays from
  1492|         0|            0|            0|  0.00%|        which the diagonals should be taken. Defaults to second axis (1).
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    Returns
  1495|         0|            0|            0|  0.00%|    -------
  1496|         0|            0|            0|  0.00%|    array_of_diagonals : ndarray
  1497|         0|            0|            0|  0.00%|        If `a` is 2-D, then a 1-D array containing the diagonal and of the
  1498|         0|            0|            0|  0.00%|        same type as `a` is returned unless `a` is a `matrix`, in which case
  1499|         0|            0|            0|  0.00%|        a 1-D array rather than a (2-D) `matrix` is returned in order to
  1500|         0|            0|            0|  0.00%|        maintain backward compatibility.
  1501|         0|            0|            0|  0.00%|
  1502|         0|            0|            0|  0.00%|        If ``a.ndim > 2``, then the dimensions specified by `axis1` and `axis2`
  1503|         0|            0|            0|  0.00%|        are removed, and a new axis inserted at the end corresponding to the
  1504|         0|            0|            0|  0.00%|        diagonal.
  1505|         0|            0|            0|  0.00%|
  1506|         0|            0|            0|  0.00%|    Raises
  1507|         0|            0|            0|  0.00%|    ------
  1508|         0|            0|            0|  0.00%|    ValueError
  1509|         0|            0|            0|  0.00%|        If the dimension of `a` is less than 2.
  1510|         0|            0|            0|  0.00%|
  1511|         0|            0|            0|  0.00%|    See Also
  1512|         0|            0|            0|  0.00%|    --------
  1513|         0|            0|            0|  0.00%|    diag : MATLAB work-a-like for 1-D and 2-D arrays.
  1514|         0|            0|            0|  0.00%|    diagflat : Create diagonal arrays.
  1515|         0|            0|            0|  0.00%|    trace : Sum along diagonals.
  1516|         0|            0|            0|  0.00%|
  1517|         0|            0|            0|  0.00%|    Examples
  1518|         0|            0|            0|  0.00%|    --------
  1519|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape(2,2)
  1520|         0|            0|            0|  0.00%|    >>> a
  1521|         0|            0|            0|  0.00%|    array([[0, 1],
  1522|         0|            0|            0|  0.00%|           [2, 3]])
  1523|         0|            0|            0|  0.00%|    >>> a.diagonal()
  1524|         0|            0|            0|  0.00%|    array([0, 3])
  1525|         0|            0|            0|  0.00%|    >>> a.diagonal(1)
  1526|         0|            0|            0|  0.00%|    array([1])
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|    A 3-D example:
  1529|         0|            0|            0|  0.00%|
  1530|         0|            0|            0|  0.00%|    >>> a = np.arange(8).reshape(2,2,2); a
  1531|         0|            0|            0|  0.00%|    array([[[0, 1],
  1532|         0|            0|            0|  0.00%|            [2, 3]],
  1533|         0|            0|            0|  0.00%|           [[4, 5],
  1534|         0|            0|            0|  0.00%|            [6, 7]]])
  1535|         0|            0|            0|  0.00%|    >>> a.diagonal(0,  # Main diagonals of two arrays created by skipping
  1536|         0|            0|            0|  0.00%|    ...            0,  # across the outer(left)-most axis last and
  1537|         0|            0|            0|  0.00%|    ...            1)  # the "middle" (row) axis first.
  1538|         0|            0|            0|  0.00%|    array([[0, 6],
  1539|         0|            0|            0|  0.00%|           [1, 7]])
  1540|         0|            0|            0|  0.00%|
  1541|         0|            0|            0|  0.00%|    The sub-arrays whose main diagonals we just obtained; note that each
  1542|         0|            0|            0|  0.00%|    corresponds to fixing the right-most (column) axis, and that the
  1543|         0|            0|            0|  0.00%|    diagonals are "packed" in rows.
  1544|         0|            0|            0|  0.00%|
  1545|         0|            0|            0|  0.00%|    >>> a[:,:,0]  # main diagonal is [0 6]
  1546|         0|            0|            0|  0.00%|    array([[0, 2],
  1547|         0|            0|            0|  0.00%|           [4, 6]])
  1548|         0|            0|            0|  0.00%|    >>> a[:,:,1]  # main diagonal is [1 7]
  1549|         0|            0|            0|  0.00%|    array([[1, 3],
  1550|         0|            0|            0|  0.00%|           [5, 7]])
  1551|         0|            0|            0|  0.00%|
  1552|         0|            0|            0|  0.00%|    The anti-diagonal can be obtained by reversing the order of elements
  1553|         0|            0|            0|  0.00%|    using either `numpy.flipud` or `numpy.fliplr`.
  1554|         0|            0|            0|  0.00%|
  1555|         0|            0|            0|  0.00%|    >>> a = np.arange(9).reshape(3, 3)
  1556|         0|            0|            0|  0.00%|    >>> a
  1557|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1558|         0|            0|            0|  0.00%|           [3, 4, 5],
  1559|         0|            0|            0|  0.00%|           [6, 7, 8]])
  1560|         0|            0|            0|  0.00%|    >>> np.fliplr(a).diagonal()  # Horizontal flip
  1561|         0|            0|            0|  0.00%|    array([2, 4, 6])
  1562|         0|            0|            0|  0.00%|    >>> np.flipud(a).diagonal()  # Vertical flip
  1563|         0|            0|            0|  0.00%|    array([6, 4, 2])
  1564|         0|            0|            0|  0.00%|
  1565|         0|            0|            0|  0.00%|    Note that the order in which the diagonal is retrieved varies depending
  1566|         0|            0|            0|  0.00%|    on the flip function.
  1567|         0|            0|            0|  0.00%|    """
  1568|         0|            0|            0|  0.00%|    if isinstance(a, np.matrix):
  1569|         0|            0|            0|  0.00%|        # Make diagonal of matrix 1-D to preserve backward compatibility.
  1570|         0|            0|            0|  0.00%|        return asarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)
  1571|         0|            0|            0|  0.00%|    else:
  1572|         0|            0|            0|  0.00%|        return asanyarray(a).diagonal(offset=offset, axis1=axis1, axis2=axis2)
  1573|         0|            0|            0|  0.00%|
  1574|         0|            0|            0|  0.00%|
  1575|         0|            0|            0|  0.00%|def _trace_dispatcher(
  1576|         0|            0|            0|  0.00%|        a, offset=None, axis1=None, axis2=None, dtype=None, out=None):
  1577|         0|            0|            0|  0.00%|    return (a, out)
  1578|         0|            0|            0|  0.00%|
  1579|         0|            0|            0|  0.00%|
  1580|         0|            0|            0|  0.00%|@array_function_dispatch(_trace_dispatcher)
  1581|         0|            0|            0|  0.00%|def trace(a, offset=0, axis1=0, axis2=1, dtype=None, out=None):
  1582|         0|            0|            0|  0.00%|    """
  1583|         0|            0|            0|  0.00%|    Return the sum along diagonals of the array.
  1584|         0|            0|            0|  0.00%|
  1585|         0|            0|            0|  0.00%|    If `a` is 2-D, the sum along its diagonal with the given offset
  1586|         0|            0|            0|  0.00%|    is returned, i.e., the sum of elements ``a[i,i+offset]`` for all i.
  1587|         0|            0|            0|  0.00%|
  1588|         0|            0|            0|  0.00%|    If `a` has more than two dimensions, then the axes specified by axis1 and
  1589|         0|            0|            0|  0.00%|    axis2 are used to determine the 2-D sub-arrays whose traces are returned.
  1590|         0|            0|            0|  0.00%|    The shape of the resulting array is the same as that of `a` with `axis1`
  1591|         0|            0|            0|  0.00%|    and `axis2` removed.
  1592|         0|            0|            0|  0.00%|
  1593|         0|            0|            0|  0.00%|    Parameters
  1594|         0|            0|            0|  0.00%|    ----------
  1595|         0|            0|            0|  0.00%|    a : array_like
  1596|         0|            0|            0|  0.00%|        Input array, from which the diagonals are taken.
  1597|         0|            0|            0|  0.00%|    offset : int, optional
  1598|         0|            0|            0|  0.00%|        Offset of the diagonal from the main diagonal. Can be both positive
  1599|         0|            0|            0|  0.00%|        and negative. Defaults to 0.
  1600|         0|            0|            0|  0.00%|    axis1, axis2 : int, optional
  1601|         0|            0|            0|  0.00%|        Axes to be used as the first and second axis of the 2-D sub-arrays
  1602|         0|            0|            0|  0.00%|        from which the diagonals should be taken. Defaults are the first two
  1603|         0|            0|            0|  0.00%|        axes of `a`.
  1604|         0|            0|            0|  0.00%|    dtype : dtype, optional
  1605|         0|            0|            0|  0.00%|        Determines the data-type of the returned array and of the accumulator
  1606|         0|            0|            0|  0.00%|        where the elements are summed. If dtype has the value None and `a` is
  1607|         0|            0|            0|  0.00%|        of integer type of precision less than the default integer
  1608|         0|            0|            0|  0.00%|        precision, then the default integer precision is used. Otherwise,
  1609|         0|            0|            0|  0.00%|        the precision is the same as that of `a`.
  1610|         0|            0|            0|  0.00%|    out : ndarray, optional
  1611|         0|            0|            0|  0.00%|        Array into which the output is placed. Its type is preserved and
  1612|         0|            0|            0|  0.00%|        it must be of the right shape to hold the output.
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|    Returns
  1615|         0|            0|            0|  0.00%|    -------
  1616|         0|            0|            0|  0.00%|    sum_along_diagonals : ndarray
  1617|         0|            0|            0|  0.00%|        If `a` is 2-D, the sum along the diagonal is returned.  If `a` has
  1618|         0|            0|            0|  0.00%|        larger dimensions, then an array of sums along diagonals is returned.
  1619|         0|            0|            0|  0.00%|
  1620|         0|            0|            0|  0.00%|    See Also
  1621|         0|            0|            0|  0.00%|    --------
  1622|         0|            0|            0|  0.00%|    diag, diagonal, diagflat
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|    Examples
  1625|         0|            0|            0|  0.00%|    --------
  1626|         0|            0|            0|  0.00%|    >>> np.trace(np.eye(3))
  1627|         0|            0|            0|  0.00%|    3.0
  1628|         0|            0|            0|  0.00%|    >>> a = np.arange(8).reshape((2,2,2))
  1629|         0|            0|            0|  0.00%|    >>> np.trace(a)
  1630|         0|            0|            0|  0.00%|    array([6, 8])
  1631|         0|            0|            0|  0.00%|
  1632|         0|            0|            0|  0.00%|    >>> a = np.arange(24).reshape((2,2,2,3))
  1633|         0|            0|            0|  0.00%|    >>> np.trace(a).shape
  1634|         0|            0|            0|  0.00%|    (2, 3)
  1635|         0|            0|            0|  0.00%|
  1636|         0|            0|            0|  0.00%|    """
  1637|         0|            0|            0|  0.00%|    if isinstance(a, np.matrix):
  1638|         0|            0|            0|  0.00%|        # Get trace of matrix via an array to preserve backward compatibility.
  1639|         0|            0|            0|  0.00%|        return asarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)
  1640|         0|            0|            0|  0.00%|    else:
  1641|         0|            0|            0|  0.00%|        return asanyarray(a).trace(offset=offset, axis1=axis1, axis2=axis2, dtype=dtype, out=out)
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|
  1644|         0|            0|            0|  0.00%|def _ravel_dispatcher(a, order=None):
  1645|         0|            0|            0|  0.00%|    return (a,)
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|
  1648|         0|            0|            0|  0.00%|@array_function_dispatch(_ravel_dispatcher)
  1649|         0|            0|            0|  0.00%|def ravel(a, order='C'):
  1650|         0|            0|            0|  0.00%|    """Return a contiguous flattened array.
  1651|         0|            0|            0|  0.00%|
  1652|         0|            0|            0|  0.00%|    A 1-D array, containing the elements of the input, is returned.  A copy is
  1653|         0|            0|            0|  0.00%|    made only if needed.
  1654|         0|            0|            0|  0.00%|
  1655|         0|            0|            0|  0.00%|    As of NumPy 1.10, the returned array will have the same type as the input
  1656|         0|            0|            0|  0.00%|    array. (for example, a masked array will be returned for a masked array
  1657|         0|            0|            0|  0.00%|    input)
  1658|         0|            0|            0|  0.00%|
  1659|         0|            0|            0|  0.00%|    Parameters
  1660|         0|            0|            0|  0.00%|    ----------
  1661|         0|            0|            0|  0.00%|    a : array_like
  1662|         0|            0|            0|  0.00%|        Input array.  The elements in `a` are read in the order specified by
  1663|         0|            0|            0|  0.00%|        `order`, and packed as a 1-D array.
  1664|         0|            0|            0|  0.00%|    order : {'C','F', 'A', 'K'}, optional
  1665|         0|            0|            0|  0.00%|
  1666|         0|            0|            0|  0.00%|        The elements of `a` are read using this index order. 'C' means
  1667|         0|            0|            0|  0.00%|        to index the elements in row-major, C-style order,
  1668|         0|            0|            0|  0.00%|        with the last axis index changing fastest, back to the first
  1669|         0|            0|            0|  0.00%|        axis index changing slowest.  'F' means to index the elements
  1670|         0|            0|            0|  0.00%|        in column-major, Fortran-style order, with the
  1671|         0|            0|            0|  0.00%|        first index changing fastest, and the last index changing
  1672|         0|            0|            0|  0.00%|        slowest. Note that the 'C' and 'F' options take no account of
  1673|         0|            0|            0|  0.00%|        the memory layout of the underlying array, and only refer to
  1674|         0|            0|            0|  0.00%|        the order of axis indexing.  'A' means to read the elements in
  1675|         0|            0|            0|  0.00%|        Fortran-like index order if `a` is Fortran *contiguous* in
  1676|         0|            0|            0|  0.00%|        memory, C-like order otherwise.  'K' means to read the
  1677|         0|            0|            0|  0.00%|        elements in the order they occur in memory, except for
  1678|         0|            0|            0|  0.00%|        reversing the data when strides are negative.  By default, 'C'
  1679|         0|            0|            0|  0.00%|        index order is used.
  1680|         0|            0|            0|  0.00%|
  1681|         0|            0|            0|  0.00%|    Returns
  1682|         0|            0|            0|  0.00%|    -------
  1683|         0|            0|            0|  0.00%|    y : array_like
  1684|         0|            0|            0|  0.00%|        y is an array of the same subtype as `a`, with shape ``(a.size,)``.
  1685|         0|            0|            0|  0.00%|        Note that matrices are special cased for backward compatibility, if `a`
  1686|         0|            0|            0|  0.00%|        is a matrix, then y is a 1-D ndarray.
  1687|         0|            0|            0|  0.00%|
  1688|         0|            0|            0|  0.00%|    See Also
  1689|         0|            0|            0|  0.00%|    --------
  1690|         0|            0|            0|  0.00%|    ndarray.flat : 1-D iterator over an array.
  1691|         0|            0|            0|  0.00%|    ndarray.flatten : 1-D array copy of the elements of an array
  1692|         0|            0|            0|  0.00%|                      in row-major order.
  1693|         0|            0|            0|  0.00%|    ndarray.reshape : Change the shape of an array without changing its data.
  1694|         0|            0|            0|  0.00%|
  1695|         0|            0|            0|  0.00%|    Notes
  1696|         0|            0|            0|  0.00%|    -----
  1697|         0|            0|            0|  0.00%|    In row-major, C-style order, in two dimensions, the row index
  1698|         0|            0|            0|  0.00%|    varies the slowest, and the column index the quickest.  This can
  1699|         0|            0|            0|  0.00%|    be generalized to multiple dimensions, where row-major order
  1700|         0|            0|            0|  0.00%|    implies that the index along the first axis varies slowest, and
  1701|         0|            0|            0|  0.00%|    the index along the last quickest.  The opposite holds for
  1702|         0|            0|            0|  0.00%|    column-major, Fortran-style index ordering.
  1703|         0|            0|            0|  0.00%|
  1704|         0|            0|            0|  0.00%|    When a view is desired in as many cases as possible, ``arr.reshape(-1)``
  1705|         0|            0|            0|  0.00%|    may be preferable.
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|    Examples
  1708|         0|            0|            0|  0.00%|    --------
  1709|         0|            0|            0|  0.00%|    It is equivalent to ``reshape(-1, order=order)``.
  1710|         0|            0|            0|  0.00%|
  1711|         0|            0|            0|  0.00%|    >>> x = np.array([[1, 2, 3], [4, 5, 6]])
  1712|         0|            0|            0|  0.00%|    >>> np.ravel(x)
  1713|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1714|         0|            0|            0|  0.00%|
  1715|         0|            0|            0|  0.00%|    >>> x.reshape(-1)
  1716|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1717|         0|            0|            0|  0.00%|
  1718|         0|            0|            0|  0.00%|    >>> np.ravel(x, order='F')
  1719|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|    When ``order`` is 'A', it will preserve the array's 'C' or 'F' ordering:
  1722|         0|            0|            0|  0.00%|
  1723|         0|            0|            0|  0.00%|    >>> np.ravel(x.T)
  1724|         0|            0|            0|  0.00%|    array([1, 4, 2, 5, 3, 6])
  1725|         0|            0|            0|  0.00%|    >>> np.ravel(x.T, order='A')
  1726|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 5, 6])
  1727|         0|            0|            0|  0.00%|
  1728|         0|            0|            0|  0.00%|    When ``order`` is 'K', it will preserve orderings that are neither 'C'
  1729|         0|            0|            0|  0.00%|    nor 'F', but won't reverse axes:
  1730|         0|            0|            0|  0.00%|
  1731|         0|            0|            0|  0.00%|    >>> a = np.arange(3)[::-1]; a
  1732|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1733|         0|            0|            0|  0.00%|    >>> a.ravel(order='C')
  1734|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1735|         0|            0|            0|  0.00%|    >>> a.ravel(order='K')
  1736|         0|            0|            0|  0.00%|    array([2, 1, 0])
  1737|         0|            0|            0|  0.00%|
  1738|         0|            0|            0|  0.00%|    >>> a = np.arange(12).reshape(2,3,2).swapaxes(1,2); a
  1739|         0|            0|            0|  0.00%|    array([[[ 0,  2,  4],
  1740|         0|            0|            0|  0.00%|            [ 1,  3,  5]],
  1741|         0|            0|            0|  0.00%|           [[ 6,  8, 10],
  1742|         0|            0|            0|  0.00%|            [ 7,  9, 11]]])
  1743|         0|            0|            0|  0.00%|    >>> a.ravel(order='C')
  1744|         0|            0|            0|  0.00%|    array([ 0,  2,  4,  1,  3,  5,  6,  8, 10,  7,  9, 11])
  1745|         0|            0|            0|  0.00%|    >>> a.ravel(order='K')
  1746|         0|            0|            0|  0.00%|    array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])
  1747|         0|            0|            0|  0.00%|
  1748|         0|            0|            0|  0.00%|    """
  1749|         0|            0|            0|  0.00%|    if isinstance(a, np.matrix):
  1750|         0|            0|            0|  0.00%|        return asarray(a).ravel(order=order)
  1751|         0|            0|            0|  0.00%|    else:
  1752|         0|            0|            0|  0.00%|        return asanyarray(a).ravel(order=order)
  1753|         0|            0|            0|  0.00%|
  1754|         0|            0|            0|  0.00%|
  1755|         0|            0|            0|  0.00%|def _nonzero_dispatcher(a):
  1756|         0|            0|            0|  0.00%|    return (a,)
  1757|         0|            0|            0|  0.00%|
  1758|         0|            0|            0|  0.00%|
  1759|         0|            0|            0|  0.00%|@array_function_dispatch(_nonzero_dispatcher)
  1760|         0|            0|            0|  0.00%|def nonzero(a):
  1761|         0|            0|            0|  0.00%|    """
  1762|         0|            0|            0|  0.00%|    Return the indices of the elements that are non-zero.
  1763|         0|            0|            0|  0.00%|
  1764|         0|            0|            0|  0.00%|    Returns a tuple of arrays, one for each dimension of `a`,
  1765|         0|            0|            0|  0.00%|    containing the indices of the non-zero elements in that
  1766|         0|            0|            0|  0.00%|    dimension. The values in `a` are always tested and returned in
  1767|         0|            0|            0|  0.00%|    row-major, C-style order.
  1768|         0|            0|            0|  0.00%|
  1769|         0|            0|            0|  0.00%|    To group the indices by element, rather than dimension, use `argwhere`,
  1770|         0|            0|            0|  0.00%|    which returns a row for each non-zero element.
  1771|         0|            0|            0|  0.00%|
  1772|         0|            0|            0|  0.00%|    .. note::
  1773|         0|            0|            0|  0.00%|        When called on a zero-d array or scalar, ``nonzero(a)`` is treated
  1774|         0|            0|            0|  0.00%|        as ``nonzero(atleast1d(a))``.
  1775|         0|            0|            0|  0.00%|
  1776|         0|            0|            0|  0.00%|        ..deprecated:: 1.17.0
  1777|         0|            0|            0|  0.00%|            Use `atleast1d` explicitly if this behavior is deliberate.
  1778|         0|            0|            0|  0.00%|
  1779|         0|            0|            0|  0.00%|    Parameters
  1780|         0|            0|            0|  0.00%|    ----------
  1781|         0|            0|            0|  0.00%|    a : array_like
  1782|         0|            0|            0|  0.00%|        Input array.
  1783|         0|            0|            0|  0.00%|
  1784|         0|            0|            0|  0.00%|    Returns
  1785|         0|            0|            0|  0.00%|    -------
  1786|         0|            0|            0|  0.00%|    tuple_of_arrays : tuple
  1787|         0|            0|            0|  0.00%|        Indices of elements that are non-zero.
  1788|         0|            0|            0|  0.00%|
  1789|         0|            0|            0|  0.00%|    See Also
  1790|         0|            0|            0|  0.00%|    --------
  1791|         0|            0|            0|  0.00%|    flatnonzero :
  1792|         0|            0|            0|  0.00%|        Return indices that are non-zero in the flattened version of the input
  1793|         0|            0|            0|  0.00%|        array.
  1794|         0|            0|            0|  0.00%|    ndarray.nonzero :
  1795|         0|            0|            0|  0.00%|        Equivalent ndarray method.
  1796|         0|            0|            0|  0.00%|    count_nonzero :
  1797|         0|            0|            0|  0.00%|        Counts the number of non-zero elements in the input array.
  1798|         0|            0|            0|  0.00%|
  1799|         0|            0|            0|  0.00%|    Notes
  1800|         0|            0|            0|  0.00%|    -----
  1801|         0|            0|            0|  0.00%|    While the nonzero values can be obtained with ``a[nonzero(a)]``, it is
  1802|         0|            0|            0|  0.00%|    recommended to use ``x[x.astype(bool)]`` or ``x[x != 0]`` instead, which
  1803|         0|            0|            0|  0.00%|    will correctly handle 0-d arrays.
  1804|         0|            0|            0|  0.00%|
  1805|         0|            0|            0|  0.00%|    Examples
  1806|         0|            0|            0|  0.00%|    --------
  1807|         0|            0|            0|  0.00%|    >>> x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])
  1808|         0|            0|            0|  0.00%|    >>> x
  1809|         0|            0|            0|  0.00%|    array([[3, 0, 0],
  1810|         0|            0|            0|  0.00%|           [0, 4, 0],
  1811|         0|            0|            0|  0.00%|           [5, 6, 0]])
  1812|         0|            0|            0|  0.00%|    >>> np.nonzero(x)
  1813|         0|            0|            0|  0.00%|    (array([0, 1, 2, 2]), array([0, 1, 0, 1]))
  1814|         0|            0|            0|  0.00%|
  1815|         0|            0|            0|  0.00%|    >>> x[np.nonzero(x)]
  1816|         0|            0|            0|  0.00%|    array([3, 4, 5, 6])
  1817|         0|            0|            0|  0.00%|    >>> np.transpose(np.nonzero(x))
  1818|         0|            0|            0|  0.00%|    array([[0, 0],
  1819|         0|            0|            0|  0.00%|           [1, 1],
  1820|         0|            0|            0|  0.00%|           [2, 0],
  1821|         0|            0|            0|  0.00%|           [2, 1]])
  1822|         0|            0|            0|  0.00%|
  1823|         0|            0|            0|  0.00%|    A common use for ``nonzero`` is to find the indices of an array, where
  1824|         0|            0|            0|  0.00%|    a condition is True.  Given an array `a`, the condition `a` > 3 is a
  1825|         0|            0|            0|  0.00%|    boolean array and since False is interpreted as 0, np.nonzero(a > 3)
  1826|         0|            0|            0|  0.00%|    yields the indices of the `a` where the condition is true.
  1827|         0|            0|            0|  0.00%|
  1828|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])
  1829|         0|            0|            0|  0.00%|    >>> a > 3
  1830|         0|            0|            0|  0.00%|    array([[False, False, False],
  1831|         0|            0|            0|  0.00%|           [ True,  True,  True],
  1832|         0|            0|            0|  0.00%|           [ True,  True,  True]])
  1833|         0|            0|            0|  0.00%|    >>> np.nonzero(a > 3)
  1834|         0|            0|            0|  0.00%|    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  1835|         0|            0|            0|  0.00%|
  1836|         0|            0|            0|  0.00%|    Using this result to index `a` is equivalent to using the mask directly:
  1837|         0|            0|            0|  0.00%|
  1838|         0|            0|            0|  0.00%|    >>> a[np.nonzero(a > 3)]
  1839|         0|            0|            0|  0.00%|    array([4, 5, 6, 7, 8, 9])
  1840|         0|            0|            0|  0.00%|    >>> a[a > 3]  # prefer this spelling
  1841|         0|            0|            0|  0.00%|    array([4, 5, 6, 7, 8, 9])
  1842|         0|            0|            0|  0.00%|
  1843|         0|            0|            0|  0.00%|    ``nonzero`` can also be called as a method of the array.
  1844|         0|            0|            0|  0.00%|
  1845|         0|            0|            0|  0.00%|    >>> (a > 3).nonzero()
  1846|         0|            0|            0|  0.00%|    (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  1847|         0|            0|            0|  0.00%|
  1848|         0|            0|            0|  0.00%|    """
  1849|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'nonzero')
  1850|         0|            0|            0|  0.00%|
  1851|         0|            0|            0|  0.00%|
  1852|         0|            0|            0|  0.00%|def _shape_dispatcher(a):
  1853|         0|            0|            0|  0.00%|    return (a,)
  1854|         0|            0|            0|  0.00%|
  1855|         0|            0|            0|  0.00%|
  1856|         0|            0|            0|  0.00%|@array_function_dispatch(_shape_dispatcher)
  1857|         0|            0|            0|  0.00%|def shape(a):
  1858|         0|            0|            0|  0.00%|    """
  1859|         0|            0|            0|  0.00%|    Return the shape of an array.
  1860|         0|            0|            0|  0.00%|
  1861|         0|            0|            0|  0.00%|    Parameters
  1862|         0|            0|            0|  0.00%|    ----------
  1863|         0|            0|            0|  0.00%|    a : array_like
  1864|         0|            0|            0|  0.00%|        Input array.
  1865|         0|            0|            0|  0.00%|
  1866|         0|            0|            0|  0.00%|    Returns
  1867|         0|            0|            0|  0.00%|    -------
  1868|         0|            0|            0|  0.00%|    shape : tuple of ints
  1869|         0|            0|            0|  0.00%|        The elements of the shape tuple give the lengths of the
  1870|         0|            0|            0|  0.00%|        corresponding array dimensions.
  1871|         0|            0|            0|  0.00%|
  1872|         0|            0|            0|  0.00%|    See Also
  1873|         0|            0|            0|  0.00%|    --------
  1874|         0|            0|            0|  0.00%|    alen
  1875|         0|            0|            0|  0.00%|    ndarray.shape : Equivalent array method.
  1876|         0|            0|            0|  0.00%|
  1877|         0|            0|            0|  0.00%|    Examples
  1878|         0|            0|            0|  0.00%|    --------
  1879|         0|            0|            0|  0.00%|    >>> np.shape(np.eye(3))
  1880|         0|            0|            0|  0.00%|    (3, 3)
  1881|         0|            0|            0|  0.00%|    >>> np.shape([[1, 2]])
  1882|         0|            0|            0|  0.00%|    (1, 2)
  1883|         0|            0|            0|  0.00%|    >>> np.shape([0])
  1884|         0|            0|            0|  0.00%|    (1,)
  1885|         0|            0|            0|  0.00%|    >>> np.shape(0)
  1886|         0|            0|            0|  0.00%|    ()
  1887|         0|            0|            0|  0.00%|
  1888|         0|            0|            0|  0.00%|    >>> a = np.array([(1, 2), (3, 4)], dtype=[('x', 'i4'), ('y', 'i4')])
  1889|         0|            0|            0|  0.00%|    >>> np.shape(a)
  1890|         0|            0|            0|  0.00%|    (2,)
  1891|         0|            0|            0|  0.00%|    >>> a.shape
  1892|         0|            0|            0|  0.00%|    (2,)
  1893|         0|            0|            0|  0.00%|
  1894|         0|            0|            0|  0.00%|    """
  1895|         0|            0|            0|  0.00%|    try:
  1896|         0|            0|            0|  0.00%|        result = a.shape
  1897|         0|            0|            0|  0.00%|    except AttributeError:
  1898|         0|            0|            0|  0.00%|        result = asarray(a).shape
  1899|         0|            0|            0|  0.00%|    return result
  1900|         0|            0|            0|  0.00%|
  1901|         0|            0|            0|  0.00%|
  1902|         0|            0|            0|  0.00%|def _compress_dispatcher(condition, a, axis=None, out=None):
  1903|         0|            0|            0|  0.00%|    return (condition, a, out)
  1904|         0|            0|            0|  0.00%|
  1905|         0|            0|            0|  0.00%|
  1906|         0|            0|            0|  0.00%|@array_function_dispatch(_compress_dispatcher)
  1907|         0|            0|            0|  0.00%|def compress(condition, a, axis=None, out=None):
  1908|         0|            0|            0|  0.00%|    """
  1909|         0|            0|            0|  0.00%|    Return selected slices of an array along given axis.
  1910|         0|            0|            0|  0.00%|
  1911|         0|            0|            0|  0.00%|    When working along a given axis, a slice along that axis is returned in
  1912|         0|            0|            0|  0.00%|    `output` for each index where `condition` evaluates to True. When
  1913|         0|            0|            0|  0.00%|    working on a 1-D array, `compress` is equivalent to `extract`.
  1914|         0|            0|            0|  0.00%|
  1915|         0|            0|            0|  0.00%|    Parameters
  1916|         0|            0|            0|  0.00%|    ----------
  1917|         0|            0|            0|  0.00%|    condition : 1-D array of bools
  1918|         0|            0|            0|  0.00%|        Array that selects which entries to return. If len(condition)
  1919|         0|            0|            0|  0.00%|        is less than the size of `a` along the given axis, then output is
  1920|         0|            0|            0|  0.00%|        truncated to the length of the condition array.
  1921|         0|            0|            0|  0.00%|    a : array_like
  1922|         0|            0|            0|  0.00%|        Array from which to extract a part.
  1923|         0|            0|            0|  0.00%|    axis : int, optional
  1924|         0|            0|            0|  0.00%|        Axis along which to take slices. If None (default), work on the
  1925|         0|            0|            0|  0.00%|        flattened array.
  1926|         0|            0|            0|  0.00%|    out : ndarray, optional
  1927|         0|            0|            0|  0.00%|        Output array.  Its type is preserved and it must be of the right
  1928|         0|            0|            0|  0.00%|        shape to hold the output.
  1929|         0|            0|            0|  0.00%|
  1930|         0|            0|            0|  0.00%|    Returns
  1931|         0|            0|            0|  0.00%|    -------
  1932|         0|            0|            0|  0.00%|    compressed_array : ndarray
  1933|         0|            0|            0|  0.00%|        A copy of `a` without the slices along axis for which `condition`
  1934|         0|            0|            0|  0.00%|        is false.
  1935|         0|            0|            0|  0.00%|
  1936|         0|            0|            0|  0.00%|    See Also
  1937|         0|            0|            0|  0.00%|    --------
  1938|         0|            0|            0|  0.00%|    take, choose, diag, diagonal, select
  1939|         0|            0|            0|  0.00%|    ndarray.compress : Equivalent method in ndarray
  1940|         0|            0|            0|  0.00%|    np.extract: Equivalent method when working on 1-D arrays
  1941|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|    Examples
  1944|         0|            0|            0|  0.00%|    --------
  1945|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4], [5, 6]])
  1946|         0|            0|            0|  0.00%|    >>> a
  1947|         0|            0|            0|  0.00%|    array([[1, 2],
  1948|         0|            0|            0|  0.00%|           [3, 4],
  1949|         0|            0|            0|  0.00%|           [5, 6]])
  1950|         0|            0|            0|  0.00%|    >>> np.compress([0, 1], a, axis=0)
  1951|         0|            0|            0|  0.00%|    array([[3, 4]])
  1952|         0|            0|            0|  0.00%|    >>> np.compress([False, True, True], a, axis=0)
  1953|         0|            0|            0|  0.00%|    array([[3, 4],
  1954|         0|            0|            0|  0.00%|           [5, 6]])
  1955|         0|            0|            0|  0.00%|    >>> np.compress([False, True], a, axis=1)
  1956|         0|            0|            0|  0.00%|    array([[2],
  1957|         0|            0|            0|  0.00%|           [4],
  1958|         0|            0|            0|  0.00%|           [6]])
  1959|         0|            0|            0|  0.00%|
  1960|         0|            0|            0|  0.00%|    Working on the flattened array does not return slices along an axis but
  1961|         0|            0|            0|  0.00%|    selects elements.
  1962|         0|            0|            0|  0.00%|
  1963|         0|            0|            0|  0.00%|    >>> np.compress([False, True], a)
  1964|         0|            0|            0|  0.00%|    array([2])
  1965|         0|            0|            0|  0.00%|
  1966|         0|            0|            0|  0.00%|    """
  1967|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'compress', condition, axis=axis, out=out)
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|def _clip_dispatcher(a, a_min, a_max, out=None, **kwargs):
  1971|         0|            0|            0|  0.00%|    return (a, a_min, a_max)
  1972|         0|            0|            0|  0.00%|
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|@array_function_dispatch(_clip_dispatcher)
  1975|         0|            0|            0|  0.00%|def clip(a, a_min, a_max, out=None, **kwargs):
  1976|         0|            0|            0|  0.00%|    """
  1977|         0|            0|            0|  0.00%|    Clip (limit) the values in an array.
  1978|         0|            0|            0|  0.00%|
  1979|         0|            0|            0|  0.00%|    Given an interval, values outside the interval are clipped to
  1980|         0|            0|            0|  0.00%|    the interval edges.  For example, if an interval of ``[0, 1]``
  1981|         0|            0|            0|  0.00%|    is specified, values smaller than 0 become 0, and values larger
  1982|         0|            0|            0|  0.00%|    than 1 become 1.
  1983|         0|            0|            0|  0.00%|
  1984|         0|            0|            0|  0.00%|    Equivalent to but faster than ``np.maximum(a_min, np.minimum(a, a_max))``.
  1985|         0|            0|            0|  0.00%|    No check is performed to ensure ``a_min < a_max``.
  1986|         0|            0|            0|  0.00%|
  1987|         0|            0|            0|  0.00%|    Parameters
  1988|         0|            0|            0|  0.00%|    ----------
  1989|         0|            0|            0|  0.00%|    a : array_like
  1990|         0|            0|            0|  0.00%|        Array containing elements to clip.
  1991|         0|            0|            0|  0.00%|    a_min : scalar or array_like or `None`
  1992|         0|            0|            0|  0.00%|        Minimum value. If `None`, clipping is not performed on lower
  1993|         0|            0|            0|  0.00%|        interval edge. Not more than one of `a_min` and `a_max` may be
  1994|         0|            0|            0|  0.00%|        `None`.
  1995|         0|            0|            0|  0.00%|    a_max : scalar or array_like or `None`
  1996|         0|            0|            0|  0.00%|        Maximum value. If `None`, clipping is not performed on upper
  1997|         0|            0|            0|  0.00%|        interval edge. Not more than one of `a_min` and `a_max` may be
  1998|         0|            0|            0|  0.00%|        `None`. If `a_min` or `a_max` are array_like, then the three
  1999|         0|            0|            0|  0.00%|        arrays will be broadcasted to match their shapes.
  2000|         0|            0|            0|  0.00%|    out : ndarray, optional
  2001|         0|            0|            0|  0.00%|        The results will be placed in this array. It may be the input
  2002|         0|            0|            0|  0.00%|        array for in-place clipping.  `out` must be of the right shape
  2003|         0|            0|            0|  0.00%|        to hold the output.  Its type is preserved.
  2004|         0|            0|            0|  0.00%|    **kwargs
  2005|         0|            0|            0|  0.00%|        For other keyword-only arguments, see the
  2006|         0|            0|            0|  0.00%|        :ref:`ufunc docs <ufuncs.kwargs>`.
  2007|         0|            0|            0|  0.00%|
  2008|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2009|         0|            0|            0|  0.00%|
  2010|         0|            0|            0|  0.00%|    Returns
  2011|         0|            0|            0|  0.00%|    -------
  2012|         0|            0|            0|  0.00%|    clipped_array : ndarray
  2013|         0|            0|            0|  0.00%|        An array with the elements of `a`, but where values
  2014|         0|            0|            0|  0.00%|        < `a_min` are replaced with `a_min`, and those > `a_max`
  2015|         0|            0|            0|  0.00%|        with `a_max`.
  2016|         0|            0|            0|  0.00%|
  2017|         0|            0|            0|  0.00%|    See Also
  2018|         0|            0|            0|  0.00%|    --------
  2019|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  2020|         0|            0|            0|  0.00%|
  2021|         0|            0|            0|  0.00%|    Examples
  2022|         0|            0|            0|  0.00%|    --------
  2023|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
  2024|         0|            0|            0|  0.00%|    >>> np.clip(a, 1, 8)
  2025|         0|            0|            0|  0.00%|    array([1, 1, 2, 3, 4, 5, 6, 7, 8, 8])
  2026|         0|            0|            0|  0.00%|    >>> a
  2027|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  2028|         0|            0|            0|  0.00%|    >>> np.clip(a, 3, 6, out=a)
  2029|         0|            0|            0|  0.00%|    array([3, 3, 3, 3, 4, 5, 6, 6, 6, 6])
  2030|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
  2031|         0|            0|            0|  0.00%|    >>> a
  2032|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])
  2033|         0|            0|            0|  0.00%|    >>> np.clip(a, [3, 4, 1, 1, 1, 4, 4, 4, 4, 4], 8)
  2034|         0|            0|            0|  0.00%|    array([3, 4, 2, 3, 4, 5, 6, 7, 8, 8])
  2035|         0|            0|            0|  0.00%|
  2036|         0|            0|            0|  0.00%|    """
  2037|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'clip', a_min, a_max, out=out, **kwargs)
  2038|         0|            0|            0|  0.00%|
  2039|         0|            0|            0|  0.00%|
  2040|         0|            0|            0|  0.00%|def _sum_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
  2041|         0|            0|            0|  0.00%|                    initial=None, where=None):
  2042|         0|            0|            0|  0.00%|    return (a, out)
  2043|         0|            0|            0|  0.00%|
  2044|         0|            0|            0|  0.00%|
  2045|         0|            0|            0|  0.00%|@array_function_dispatch(_sum_dispatcher)
  2046|         0|            0|            0|  0.00%|def sum(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
  2047|         0|            0|            0|  0.00%|        initial=np._NoValue, where=np._NoValue):
  2048|         0|            0|            0|  0.00%|    """
  2049|         0|            0|            0|  0.00%|    Sum of array elements over a given axis.
  2050|         0|            0|            0|  0.00%|
  2051|         0|            0|            0|  0.00%|    Parameters
  2052|         0|            0|            0|  0.00%|    ----------
  2053|         0|            0|            0|  0.00%|    a : array_like
  2054|         0|            0|            0|  0.00%|        Elements to sum.
  2055|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2056|         0|            0|            0|  0.00%|        Axis or axes along which a sum is performed.  The default,
  2057|         0|            0|            0|  0.00%|        axis=None, will sum all of the elements of the input array.  If
  2058|         0|            0|            0|  0.00%|        axis is negative it counts from the last to the first axis.
  2059|         0|            0|            0|  0.00%|
  2060|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2061|         0|            0|            0|  0.00%|
  2062|         0|            0|            0|  0.00%|        If axis is a tuple of ints, a sum is performed on all of the axes
  2063|         0|            0|            0|  0.00%|        specified in the tuple instead of a single axis or all the axes as
  2064|         0|            0|            0|  0.00%|        before.
  2065|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2066|         0|            0|            0|  0.00%|        The type of the returned array and of the accumulator in which the
  2067|         0|            0|            0|  0.00%|        elements are summed.  The dtype of `a` is used by default unless `a`
  2068|         0|            0|            0|  0.00%|        has an integer dtype of less precision than the default platform
  2069|         0|            0|            0|  0.00%|        integer.  In that case, if `a` is signed then the platform integer
  2070|         0|            0|            0|  0.00%|        is used while if `a` is unsigned then an unsigned integer of the
  2071|         0|            0|            0|  0.00%|        same precision as the platform integer is used.
  2072|         0|            0|            0|  0.00%|    out : ndarray, optional
  2073|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  2074|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  2075|         0|            0|            0|  0.00%|        values will be cast if necessary.
  2076|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2077|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2078|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2079|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2080|         0|            0|            0|  0.00%|
  2081|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2082|         0|            0|            0|  0.00%|        passed through to the `sum` method of sub-classes of
  2083|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2084|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2085|         0|            0|            0|  0.00%|        exceptions will be raised.
  2086|         0|            0|            0|  0.00%|    initial : scalar, optional
  2087|         0|            0|            0|  0.00%|        Starting value for the sum. See `~numpy.ufunc.reduce` for details.
  2088|         0|            0|            0|  0.00%|
  2089|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2090|         0|            0|            0|  0.00%|
  2091|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2092|         0|            0|            0|  0.00%|        Elements to include in the sum. See `~numpy.ufunc.reduce` for details.
  2093|         0|            0|            0|  0.00%|
  2094|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2095|         0|            0|            0|  0.00%|
  2096|         0|            0|            0|  0.00%|    Returns
  2097|         0|            0|            0|  0.00%|    -------
  2098|         0|            0|            0|  0.00%|    sum_along_axis : ndarray
  2099|         0|            0|            0|  0.00%|        An array with the same shape as `a`, with the specified
  2100|         0|            0|            0|  0.00%|        axis removed.   If `a` is a 0-d array, or if `axis` is None, a scalar
  2101|         0|            0|            0|  0.00%|        is returned.  If an output array is specified, a reference to
  2102|         0|            0|            0|  0.00%|        `out` is returned.
  2103|         0|            0|            0|  0.00%|
  2104|         0|            0|            0|  0.00%|    See Also
  2105|         0|            0|            0|  0.00%|    --------
  2106|         0|            0|            0|  0.00%|    ndarray.sum : Equivalent method.
  2107|         0|            0|            0|  0.00%|
  2108|         0|            0|            0|  0.00%|    add.reduce : Equivalent functionality of `add`.
  2109|         0|            0|            0|  0.00%|
  2110|         0|            0|            0|  0.00%|    cumsum : Cumulative sum of array elements.
  2111|         0|            0|            0|  0.00%|
  2112|         0|            0|            0|  0.00%|    trapz : Integration of array values using the composite trapezoidal rule.
  2113|         0|            0|            0|  0.00%|
  2114|         0|            0|            0|  0.00%|    mean, average
  2115|         0|            0|            0|  0.00%|
  2116|         0|            0|            0|  0.00%|    Notes
  2117|         0|            0|            0|  0.00%|    -----
  2118|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2119|         0|            0|            0|  0.00%|    raised on overflow.
  2120|         0|            0|            0|  0.00%|
  2121|         0|            0|            0|  0.00%|    The sum of an empty array is the neutral element 0:
  2122|         0|            0|            0|  0.00%|
  2123|         0|            0|            0|  0.00%|    >>> np.sum([])
  2124|         0|            0|            0|  0.00%|    0.0
  2125|         0|            0|            0|  0.00%|
  2126|         0|            0|            0|  0.00%|    For floating point numbers the numerical precision of sum (and
  2127|         0|            0|            0|  0.00%|    ``np.add.reduce``) is in general limited by directly adding each number
  2128|         0|            0|            0|  0.00%|    individually to the result causing rounding errors in every step.
  2129|         0|            0|            0|  0.00%|    However, often numpy will use a  numerically better approach (partial
  2130|         0|            0|            0|  0.00%|    pairwise summation) leading to improved precision in many use-cases.
  2131|         0|            0|            0|  0.00%|    This improved precision is always provided when no ``axis`` is given.
  2132|         0|            0|            0|  0.00%|    When ``axis`` is given, it will depend on which axis is summed.
  2133|         0|            0|            0|  0.00%|    Technically, to provide the best speed possible, the improved precision
  2134|         0|            0|            0|  0.00%|    is only used when the summation is along the fast axis in memory.
  2135|         0|            0|            0|  0.00%|    Note that the exact precision may vary depending on other parameters.
  2136|         0|            0|            0|  0.00%|    In contrast to NumPy, Python's ``math.fsum`` function uses a slower but
  2137|         0|            0|            0|  0.00%|    more precise approach to summation.
  2138|         0|            0|            0|  0.00%|    Especially when summing a large number of lower precision floating point
  2139|         0|            0|            0|  0.00%|    numbers, such as ``float32``, numerical errors can become significant.
  2140|         0|            0|            0|  0.00%|    In such cases it can be advisable to use `dtype="float64"` to use a higher
  2141|         0|            0|            0|  0.00%|    precision for the output.
  2142|         0|            0|            0|  0.00%|
  2143|         0|            0|            0|  0.00%|    Examples
  2144|         0|            0|            0|  0.00%|    --------
  2145|         0|            0|            0|  0.00%|    >>> np.sum([0.5, 1.5])
  2146|         0|            0|            0|  0.00%|    2.0
  2147|         0|            0|            0|  0.00%|    >>> np.sum([0.5, 0.7, 0.2, 1.5], dtype=np.int32)
  2148|         0|            0|            0|  0.00%|    1
  2149|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]])
  2150|         0|            0|            0|  0.00%|    6
  2151|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]], axis=0)
  2152|         0|            0|            0|  0.00%|    array([0, 6])
  2153|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [0, 5]], axis=1)
  2154|         0|            0|            0|  0.00%|    array([1, 5])
  2155|         0|            0|            0|  0.00%|    >>> np.sum([[0, 1], [np.nan, 5]], where=[False, True], axis=1)
  2156|         0|            0|            0|  0.00%|    array([1., 5.])
  2157|         0|            0|            0|  0.00%|
  2158|         0|            0|            0|  0.00%|    If the accumulator is too small, overflow occurs:
  2159|         0|            0|            0|  0.00%|
  2160|         0|            0|            0|  0.00%|    >>> np.ones(128, dtype=np.int8).sum(dtype=np.int8)
  2161|         0|            0|            0|  0.00%|    -128
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|    You can also start the sum with a value other than zero:
  2164|         0|            0|            0|  0.00%|
  2165|         0|            0|            0|  0.00%|    >>> np.sum([10], initial=5)
  2166|         0|            0|            0|  0.00%|    15
  2167|         0|            0|            0|  0.00%|    """
  2168|         0|            0|            0|  0.00%|    if isinstance(a, _gentype):
  2169|         0|            0|            0|  0.00%|        # 2018-02-25, 1.15.0
  2170|         0|            0|            0|  0.00%|        warnings.warn(
  2171|         0|            0|            0|  0.00%|            "Calling np.sum(generator) is deprecated, and in the future will give a different result. "
  2172|         0|            0|            0|  0.00%|            "Use np.sum(np.fromiter(generator)) or the python sum builtin instead.",
  2173|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=3)
  2174|         0|            0|            0|  0.00%|
  2175|         0|            0|            0|  0.00%|        res = _sum_(a)
  2176|         0|            0|            0|  0.00%|        if out is not None:
  2177|         0|            0|            0|  0.00%|            out[...] = res
  2178|         0|            0|            0|  0.00%|            return out
  2179|         0|            0|            0|  0.00%|        return res
  2180|         0|            0|            0|  0.00%|
  2181|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.add, 'sum', axis, dtype, out, keepdims=keepdims,
  2182|         0|            0|            0|  0.00%|                          initial=initial, where=where)
  2183|         0|            0|            0|  0.00%|
  2184|         0|            0|            0|  0.00%|
  2185|         1|   2.6226e-06|   2.6226e-06|  0.00%|def _any_dispatcher(a, axis=None, out=None, keepdims=None):
  2186|         1|  4.05312e-06|  4.05312e-06|  0.00%|    return (a, out)
  2187|         0|            0|            0|  0.00%|
  2188|         0|            0|            0|  0.00%|
  2189|         1|   6.4373e-06|   6.4373e-06|  0.00%|@array_function_dispatch(_any_dispatcher)
  2190|         0|            0|            0|  0.00%|def any(a, axis=None, out=None, keepdims=np._NoValue):
  2191|         0|            0|            0|  0.00%|    """
  2192|         0|            0|            0|  0.00%|    Test whether any array element along a given axis evaluates to True.
  2193|         0|            0|            0|  0.00%|
  2194|         0|            0|            0|  0.00%|    Returns single boolean unless `axis` is not ``None``
  2195|         0|            0|            0|  0.00%|
  2196|         0|            0|            0|  0.00%|    Parameters
  2197|         0|            0|            0|  0.00%|    ----------
  2198|         0|            0|            0|  0.00%|    a : array_like
  2199|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  2200|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2201|         0|            0|            0|  0.00%|        Axis or axes along which a logical OR reduction is performed.
  2202|         0|            0|            0|  0.00%|        The default (`axis` = `None`) is to perform a logical OR over all
  2203|         0|            0|            0|  0.00%|        the dimensions of the input array. `axis` may be negative, in
  2204|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2207|         0|            0|            0|  0.00%|
  2208|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2209|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2210|         0|            0|            0|  0.00%|    out : ndarray, optional
  2211|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  It must have
  2212|         0|            0|            0|  0.00%|        the same shape as the expected output and its type is preserved
  2213|         0|            0|            0|  0.00%|        (e.g., if it is of type float, then it will remain so, returning
  2214|         0|            0|            0|  0.00%|        1.0 for True and 0.0 for False, regardless of the type of `a`).
  2215|         0|            0|            0|  0.00%|        See `doc.ufuncs` (Section "Output arguments") for details.
  2216|         0|            0|            0|  0.00%|
  2217|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2218|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2219|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2220|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2221|         0|            0|            0|  0.00%|
  2222|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2223|         0|            0|            0|  0.00%|        passed through to the `any` method of sub-classes of
  2224|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2225|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2226|         0|            0|            0|  0.00%|        exceptions will be raised.
  2227|         0|            0|            0|  0.00%|
  2228|         0|            0|            0|  0.00%|    Returns
  2229|         0|            0|            0|  0.00%|    -------
  2230|         0|            0|            0|  0.00%|    any : bool or ndarray
  2231|         0|            0|            0|  0.00%|        A new boolean or `ndarray` is returned unless `out` is specified,
  2232|         0|            0|            0|  0.00%|        in which case a reference to `out` is returned.
  2233|         0|            0|            0|  0.00%|
  2234|         0|            0|            0|  0.00%|    See Also
  2235|         0|            0|            0|  0.00%|    --------
  2236|         0|            0|            0|  0.00%|    ndarray.any : equivalent method
  2237|         0|            0|            0|  0.00%|
  2238|         0|            0|            0|  0.00%|    all : Test whether all elements along a given axis evaluate to True.
  2239|         0|            0|            0|  0.00%|
  2240|         0|            0|            0|  0.00%|    Notes
  2241|         0|            0|            0|  0.00%|    -----
  2242|         0|            0|            0|  0.00%|    Not a Number (NaN), positive infinity and negative infinity evaluate
  2243|         0|            0|            0|  0.00%|    to `True` because these are not equal to zero.
  2244|         0|            0|            0|  0.00%|
  2245|         0|            0|            0|  0.00%|    Examples
  2246|         0|            0|            0|  0.00%|    --------
  2247|         0|            0|            0|  0.00%|    >>> np.any([[True, False], [True, True]])
  2248|         0|            0|            0|  0.00%|    True
  2249|         0|            0|            0|  0.00%|
  2250|         0|            0|            0|  0.00%|    >>> np.any([[True, False], [False, False]], axis=0)
  2251|         0|            0|            0|  0.00%|    array([ True, False])
  2252|         0|            0|            0|  0.00%|
  2253|         0|            0|            0|  0.00%|    >>> np.any([-1, 0, 5])
  2254|         0|            0|            0|  0.00%|    True
  2255|         0|            0|            0|  0.00%|
  2256|         0|            0|            0|  0.00%|    >>> np.any(np.nan)
  2257|         0|            0|            0|  0.00%|    True
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|    >>> o=np.array(False)
  2260|         0|            0|            0|  0.00%|    >>> z=np.any([-1, 4, 5], out=o)
  2261|         0|            0|            0|  0.00%|    >>> z, o
  2262|         0|            0|            0|  0.00%|    (array(True), array(True))
  2263|         0|            0|            0|  0.00%|    >>> # Check now that z is a reference to o
  2264|         0|            0|            0|  0.00%|    >>> z is o
  2265|         0|            0|            0|  0.00%|    True
  2266|         0|            0|            0|  0.00%|    >>> id(z), id(o) # identity of z and o              # doctest: +SKIP
  2267|         0|            0|            0|  0.00%|    (191614240, 191614240)
  2268|         0|            0|            0|  0.00%|
  2269|         0|            0|            0|  0.00%|    """
  2270|         1|  2.02656e-05|  2.02656e-05|  0.00%|    return _wrapreduction(a, np.logical_or, 'any', axis, None, out, keepdims=keepdims)
(call)|         1|  0.000101566|  0.000101566|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:73 _wrapreduction
  2271|         0|            0|            0|  0.00%|
  2272|         0|            0|            0|  0.00%|
  2273|         0|            0|            0|  0.00%|def _all_dispatcher(a, axis=None, out=None, keepdims=None):
  2274|         0|            0|            0|  0.00%|    return (a, out)
  2275|         0|            0|            0|  0.00%|
  2276|         0|            0|            0|  0.00%|
  2277|         0|            0|            0|  0.00%|@array_function_dispatch(_all_dispatcher)
  2278|         0|            0|            0|  0.00%|def all(a, axis=None, out=None, keepdims=np._NoValue):
  2279|         0|            0|            0|  0.00%|    """
  2280|         0|            0|            0|  0.00%|    Test whether all array elements along a given axis evaluate to True.
  2281|         0|            0|            0|  0.00%|
  2282|         0|            0|            0|  0.00%|    Parameters
  2283|         0|            0|            0|  0.00%|    ----------
  2284|         0|            0|            0|  0.00%|    a : array_like
  2285|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  2286|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2287|         0|            0|            0|  0.00%|        Axis or axes along which a logical AND reduction is performed.
  2288|         0|            0|            0|  0.00%|        The default (`axis` = `None`) is to perform a logical AND over all
  2289|         0|            0|            0|  0.00%|        the dimensions of the input array. `axis` may be negative, in
  2290|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2293|         0|            0|            0|  0.00%|
  2294|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2295|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2296|         0|            0|            0|  0.00%|    out : ndarray, optional
  2297|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.
  2298|         0|            0|            0|  0.00%|        It must have the same shape as the expected output and its
  2299|         0|            0|            0|  0.00%|        type is preserved (e.g., if ``dtype(out)`` is float, the result
  2300|         0|            0|            0|  0.00%|        will consist of 0.0's and 1.0's).  See `doc.ufuncs` (Section
  2301|         0|            0|            0|  0.00%|        "Output arguments") for more details.
  2302|         0|            0|            0|  0.00%|
  2303|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2304|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2305|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2306|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2307|         0|            0|            0|  0.00%|
  2308|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2309|         0|            0|            0|  0.00%|        passed through to the `all` method of sub-classes of
  2310|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2311|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2312|         0|            0|            0|  0.00%|        exceptions will be raised.
  2313|         0|            0|            0|  0.00%|
  2314|         0|            0|            0|  0.00%|    Returns
  2315|         0|            0|            0|  0.00%|    -------
  2316|         0|            0|            0|  0.00%|    all : ndarray, bool
  2317|         0|            0|            0|  0.00%|        A new boolean or array is returned unless `out` is specified,
  2318|         0|            0|            0|  0.00%|        in which case a reference to `out` is returned.
  2319|         0|            0|            0|  0.00%|
  2320|         0|            0|            0|  0.00%|    See Also
  2321|         0|            0|            0|  0.00%|    --------
  2322|         0|            0|            0|  0.00%|    ndarray.all : equivalent method
  2323|         0|            0|            0|  0.00%|
  2324|         0|            0|            0|  0.00%|    any : Test whether any element along a given axis evaluates to True.
  2325|         0|            0|            0|  0.00%|
  2326|         0|            0|            0|  0.00%|    Notes
  2327|         0|            0|            0|  0.00%|    -----
  2328|         0|            0|            0|  0.00%|    Not a Number (NaN), positive infinity and negative infinity
  2329|         0|            0|            0|  0.00%|    evaluate to `True` because these are not equal to zero.
  2330|         0|            0|            0|  0.00%|
  2331|         0|            0|            0|  0.00%|    Examples
  2332|         0|            0|            0|  0.00%|    --------
  2333|         0|            0|            0|  0.00%|    >>> np.all([[True,False],[True,True]])
  2334|         0|            0|            0|  0.00%|    False
  2335|         0|            0|            0|  0.00%|
  2336|         0|            0|            0|  0.00%|    >>> np.all([[True,False],[True,True]], axis=0)
  2337|         0|            0|            0|  0.00%|    array([ True, False])
  2338|         0|            0|            0|  0.00%|
  2339|         0|            0|            0|  0.00%|    >>> np.all([-1, 4, 5])
  2340|         0|            0|            0|  0.00%|    True
  2341|         0|            0|            0|  0.00%|
  2342|         0|            0|            0|  0.00%|    >>> np.all([1.0, np.nan])
  2343|         0|            0|            0|  0.00%|    True
  2344|         0|            0|            0|  0.00%|
  2345|         0|            0|            0|  0.00%|    >>> o=np.array(False)
  2346|         0|            0|            0|  0.00%|    >>> z=np.all([-1, 4, 5], out=o)
  2347|         0|            0|            0|  0.00%|    >>> id(z), id(o), z
  2348|         0|            0|            0|  0.00%|    (28293632, 28293632, array(True)) # may vary
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|    """
  2351|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.logical_and, 'all', axis, None, out, keepdims=keepdims)
  2352|         0|            0|            0|  0.00%|
  2353|         0|            0|            0|  0.00%|
  2354|         0|            0|            0|  0.00%|def _cumsum_dispatcher(a, axis=None, dtype=None, out=None):
  2355|         0|            0|            0|  0.00%|    return (a, out)
  2356|         0|            0|            0|  0.00%|
  2357|         0|            0|            0|  0.00%|
  2358|         0|            0|            0|  0.00%|@array_function_dispatch(_cumsum_dispatcher)
  2359|         0|            0|            0|  0.00%|def cumsum(a, axis=None, dtype=None, out=None):
  2360|         0|            0|            0|  0.00%|    """
  2361|         0|            0|            0|  0.00%|    Return the cumulative sum of the elements along a given axis.
  2362|         0|            0|            0|  0.00%|
  2363|         0|            0|            0|  0.00%|    Parameters
  2364|         0|            0|            0|  0.00%|    ----------
  2365|         0|            0|            0|  0.00%|    a : array_like
  2366|         0|            0|            0|  0.00%|        Input array.
  2367|         0|            0|            0|  0.00%|    axis : int, optional
  2368|         0|            0|            0|  0.00%|        Axis along which the cumulative sum is computed. The default
  2369|         0|            0|            0|  0.00%|        (None) is to compute the cumsum over the flattened array.
  2370|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2371|         0|            0|            0|  0.00%|        Type of the returned array and of the accumulator in which the
  2372|         0|            0|            0|  0.00%|        elements are summed.  If `dtype` is not specified, it defaults
  2373|         0|            0|            0|  0.00%|        to the dtype of `a`, unless `a` has an integer dtype with a
  2374|         0|            0|            0|  0.00%|        precision less than that of the default platform integer.  In
  2375|         0|            0|            0|  0.00%|        that case, the default platform integer is used.
  2376|         0|            0|            0|  0.00%|    out : ndarray, optional
  2377|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  2378|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output
  2379|         0|            0|            0|  0.00%|        but the type will be cast if necessary. See `doc.ufuncs`
  2380|         0|            0|            0|  0.00%|        (Section "Output arguments") for more details.
  2381|         0|            0|            0|  0.00%|
  2382|         0|            0|            0|  0.00%|    Returns
  2383|         0|            0|            0|  0.00%|    -------
  2384|         0|            0|            0|  0.00%|    cumsum_along_axis : ndarray.
  2385|         0|            0|            0|  0.00%|        A new array holding the result is returned unless `out` is
  2386|         0|            0|            0|  0.00%|        specified, in which case a reference to `out` is returned. The
  2387|         0|            0|            0|  0.00%|        result has the same size as `a`, and the same shape as `a` if
  2388|         0|            0|            0|  0.00%|        `axis` is not None or `a` is a 1-d array.
  2389|         0|            0|            0|  0.00%|
  2390|         0|            0|            0|  0.00%|
  2391|         0|            0|            0|  0.00%|    See Also
  2392|         0|            0|            0|  0.00%|    --------
  2393|         0|            0|            0|  0.00%|    sum : Sum array elements.
  2394|         0|            0|            0|  0.00%|
  2395|         0|            0|            0|  0.00%|    trapz : Integration of array values using the composite trapezoidal rule.
  2396|         0|            0|            0|  0.00%|
  2397|         0|            0|            0|  0.00%|    diff :  Calculate the n-th discrete difference along given axis.
  2398|         0|            0|            0|  0.00%|
  2399|         0|            0|            0|  0.00%|    Notes
  2400|         0|            0|            0|  0.00%|    -----
  2401|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2402|         0|            0|            0|  0.00%|    raised on overflow.
  2403|         0|            0|            0|  0.00%|
  2404|         0|            0|            0|  0.00%|    Examples
  2405|         0|            0|            0|  0.00%|    --------
  2406|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3], [4,5,6]])
  2407|         0|            0|            0|  0.00%|    >>> a
  2408|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  2409|         0|            0|            0|  0.00%|           [4, 5, 6]])
  2410|         0|            0|            0|  0.00%|    >>> np.cumsum(a)
  2411|         0|            0|            0|  0.00%|    array([ 1,  3,  6, 10, 15, 21])
  2412|         0|            0|            0|  0.00%|    >>> np.cumsum(a, dtype=float)     # specifies type of output value(s)
  2413|         0|            0|            0|  0.00%|    array([  1.,   3.,   6.,  10.,  15.,  21.])
  2414|         0|            0|            0|  0.00%|
  2415|         0|            0|            0|  0.00%|    >>> np.cumsum(a,axis=0)      # sum over rows for each of the 3 columns
  2416|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  2417|         0|            0|            0|  0.00%|           [5, 7, 9]])
  2418|         0|            0|            0|  0.00%|    >>> np.cumsum(a,axis=1)      # sum over columns for each of the 2 rows
  2419|         0|            0|            0|  0.00%|    array([[ 1,  3,  6],
  2420|         0|            0|            0|  0.00%|           [ 4,  9, 15]])
  2421|         0|            0|            0|  0.00%|
  2422|         0|            0|            0|  0.00%|    """
  2423|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'cumsum', axis=axis, dtype=dtype, out=out)
  2424|         0|            0|            0|  0.00%|
  2425|         0|            0|            0|  0.00%|
  2426|         0|            0|            0|  0.00%|def _ptp_dispatcher(a, axis=None, out=None, keepdims=None):
  2427|         0|            0|            0|  0.00%|    return (a, out)
  2428|         0|            0|            0|  0.00%|
  2429|         0|            0|            0|  0.00%|
  2430|         0|            0|            0|  0.00%|@array_function_dispatch(_ptp_dispatcher)
  2431|         0|            0|            0|  0.00%|def ptp(a, axis=None, out=None, keepdims=np._NoValue):
  2432|         0|            0|            0|  0.00%|    """
  2433|         0|            0|            0|  0.00%|    Range of values (maximum - minimum) along an axis.
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|    The name of the function comes from the acronym for 'peak to peak'.
  2436|         0|            0|            0|  0.00%|
  2437|         0|            0|            0|  0.00%|    Parameters
  2438|         0|            0|            0|  0.00%|    ----------
  2439|         0|            0|            0|  0.00%|    a : array_like
  2440|         0|            0|            0|  0.00%|        Input values.
  2441|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2442|         0|            0|            0|  0.00%|        Axis along which to find the peaks.  By default, flatten the
  2443|         0|            0|            0|  0.00%|        array.  `axis` may be negative, in
  2444|         0|            0|            0|  0.00%|        which case it counts from the last to the first axis.
  2445|         0|            0|            0|  0.00%|
  2446|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2447|         0|            0|            0|  0.00%|
  2448|         0|            0|            0|  0.00%|        If this is a tuple of ints, a reduction is performed on multiple
  2449|         0|            0|            0|  0.00%|        axes, instead of a single axis or all the axes as before.
  2450|         0|            0|            0|  0.00%|    out : array_like
  2451|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  2452|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  2453|         0|            0|            0|  0.00%|        but the type of the output values will be cast if necessary.
  2454|         0|            0|            0|  0.00%|
  2455|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2456|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2457|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2458|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2459|         0|            0|            0|  0.00%|
  2460|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2461|         0|            0|            0|  0.00%|        passed through to the `ptp` method of sub-classes of
  2462|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2463|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2464|         0|            0|            0|  0.00%|        exceptions will be raised.
  2465|         0|            0|            0|  0.00%|
  2466|         0|            0|            0|  0.00%|    Returns
  2467|         0|            0|            0|  0.00%|    -------
  2468|         0|            0|            0|  0.00%|    ptp : ndarray
  2469|         0|            0|            0|  0.00%|        A new array holding the result, unless `out` was
  2470|         0|            0|            0|  0.00%|        specified, in which case a reference to `out` is returned.
  2471|         0|            0|            0|  0.00%|
  2472|         0|            0|            0|  0.00%|    Examples
  2473|         0|            0|            0|  0.00%|    --------
  2474|         0|            0|            0|  0.00%|    >>> x = np.arange(4).reshape((2,2))
  2475|         0|            0|            0|  0.00%|    >>> x
  2476|         0|            0|            0|  0.00%|    array([[0, 1],
  2477|         0|            0|            0|  0.00%|           [2, 3]])
  2478|         0|            0|            0|  0.00%|
  2479|         0|            0|            0|  0.00%|    >>> np.ptp(x, axis=0)
  2480|         0|            0|            0|  0.00%|    array([2, 2])
  2481|         0|            0|            0|  0.00%|
  2482|         0|            0|            0|  0.00%|    >>> np.ptp(x, axis=1)
  2483|         0|            0|            0|  0.00%|    array([1, 1])
  2484|         0|            0|            0|  0.00%|
  2485|         0|            0|            0|  0.00%|    """
  2486|         0|            0|            0|  0.00%|    kwargs = {}
  2487|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  2488|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  2489|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  2490|         0|            0|            0|  0.00%|        try:
  2491|         0|            0|            0|  0.00%|            ptp = a.ptp
  2492|         0|            0|            0|  0.00%|        except AttributeError:
  2493|         0|            0|            0|  0.00%|            pass
  2494|         0|            0|            0|  0.00%|        else:
  2495|         0|            0|            0|  0.00%|            return ptp(axis=axis, out=out, **kwargs)
  2496|         0|            0|            0|  0.00%|    return _methods._ptp(a, axis=axis, out=out, **kwargs)
  2497|         0|            0|            0|  0.00%|
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|def _amax_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
  2500|         0|            0|            0|  0.00%|                     where=None):
  2501|         0|            0|            0|  0.00%|    return (a, out)
  2502|         0|            0|            0|  0.00%|
  2503|         0|            0|            0|  0.00%|
  2504|         0|            0|            0|  0.00%|@array_function_dispatch(_amax_dispatcher)
  2505|         0|            0|            0|  0.00%|def amax(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
  2506|         0|            0|            0|  0.00%|         where=np._NoValue):
  2507|         0|            0|            0|  0.00%|    """
  2508|         0|            0|            0|  0.00%|    Return the maximum of an array or maximum along an axis.
  2509|         0|            0|            0|  0.00%|
  2510|         0|            0|            0|  0.00%|    Parameters
  2511|         0|            0|            0|  0.00%|    ----------
  2512|         0|            0|            0|  0.00%|    a : array_like
  2513|         0|            0|            0|  0.00%|        Input data.
  2514|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2515|         0|            0|            0|  0.00%|        Axis or axes along which to operate.  By default, flattened input is
  2516|         0|            0|            0|  0.00%|        used.
  2517|         0|            0|            0|  0.00%|
  2518|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2519|         0|            0|            0|  0.00%|
  2520|         0|            0|            0|  0.00%|        If this is a tuple of ints, the maximum is selected over multiple axes,
  2521|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  2522|         0|            0|            0|  0.00%|    out : ndarray, optional
  2523|         0|            0|            0|  0.00%|        Alternative output array in which to place the result.  Must
  2524|         0|            0|            0|  0.00%|        be of the same shape and buffer length as the expected output.
  2525|         0|            0|            0|  0.00%|        See `doc.ufuncs` (Section "Output arguments") for more details.
  2526|         0|            0|            0|  0.00%|
  2527|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2528|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2529|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2530|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2531|         0|            0|            0|  0.00%|
  2532|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2533|         0|            0|            0|  0.00%|        passed through to the `amax` method of sub-classes of
  2534|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2535|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2536|         0|            0|            0|  0.00%|        exceptions will be raised.
  2537|         0|            0|            0|  0.00%|
  2538|         0|            0|            0|  0.00%|    initial : scalar, optional
  2539|         0|            0|            0|  0.00%|        The minimum value of an output element. Must be present to allow
  2540|         0|            0|            0|  0.00%|        computation on empty slice. See `~numpy.ufunc.reduce` for details.
  2541|         0|            0|            0|  0.00%|
  2542|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2543|         0|            0|            0|  0.00%|
  2544|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2545|         0|            0|            0|  0.00%|        Elements to compare for the maximum. See `~numpy.ufunc.reduce`
  2546|         0|            0|            0|  0.00%|        for details.
  2547|         0|            0|            0|  0.00%|
  2548|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2549|         0|            0|            0|  0.00%|
  2550|         0|            0|            0|  0.00%|    Returns
  2551|         0|            0|            0|  0.00%|    -------
  2552|         0|            0|            0|  0.00%|    amax : ndarray or scalar
  2553|         0|            0|            0|  0.00%|        Maximum of `a`. If `axis` is None, the result is a scalar value.
  2554|         0|            0|            0|  0.00%|        If `axis` is given, the result is an array of dimension
  2555|         0|            0|            0|  0.00%|        ``a.ndim - 1``.
  2556|         0|            0|            0|  0.00%|
  2557|         0|            0|            0|  0.00%|    See Also
  2558|         0|            0|            0|  0.00%|    --------
  2559|         0|            0|            0|  0.00%|    amin :
  2560|         0|            0|            0|  0.00%|        The minimum value of an array along a given axis, propagating any NaNs.
  2561|         0|            0|            0|  0.00%|    nanmax :
  2562|         0|            0|            0|  0.00%|        The maximum value of an array along a given axis, ignoring any NaNs.
  2563|         0|            0|            0|  0.00%|    maximum :
  2564|         0|            0|            0|  0.00%|        Element-wise maximum of two arrays, propagating any NaNs.
  2565|         0|            0|            0|  0.00%|    fmax :
  2566|         0|            0|            0|  0.00%|        Element-wise maximum of two arrays, ignoring any NaNs.
  2567|         0|            0|            0|  0.00%|    argmax :
  2568|         0|            0|            0|  0.00%|        Return the indices of the maximum values.
  2569|         0|            0|            0|  0.00%|
  2570|         0|            0|            0|  0.00%|    nanmin, minimum, fmin
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|    Notes
  2573|         0|            0|            0|  0.00%|    -----
  2574|         0|            0|            0|  0.00%|    NaN values are propagated, that is if at least one item is NaN, the
  2575|         0|            0|            0|  0.00%|    corresponding max value will be NaN as well. To ignore NaN values
  2576|         0|            0|            0|  0.00%|    (MATLAB behavior), please use nanmax.
  2577|         0|            0|            0|  0.00%|
  2578|         0|            0|            0|  0.00%|    Don't use `amax` for element-wise comparison of 2 arrays; when
  2579|         0|            0|            0|  0.00%|    ``a.shape[0]`` is 2, ``maximum(a[0], a[1])`` is faster than
  2580|         0|            0|            0|  0.00%|    ``amax(a, axis=0)``.
  2581|         0|            0|            0|  0.00%|
  2582|         0|            0|            0|  0.00%|    Examples
  2583|         0|            0|            0|  0.00%|    --------
  2584|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape((2,2))
  2585|         0|            0|            0|  0.00%|    >>> a
  2586|         0|            0|            0|  0.00%|    array([[0, 1],
  2587|         0|            0|            0|  0.00%|           [2, 3]])
  2588|         0|            0|            0|  0.00%|    >>> np.amax(a)           # Maximum of the flattened array
  2589|         0|            0|            0|  0.00%|    3
  2590|         0|            0|            0|  0.00%|    >>> np.amax(a, axis=0)   # Maxima along the first axis
  2591|         0|            0|            0|  0.00%|    array([2, 3])
  2592|         0|            0|            0|  0.00%|    >>> np.amax(a, axis=1)   # Maxima along the second axis
  2593|         0|            0|            0|  0.00%|    array([1, 3])
  2594|         0|            0|            0|  0.00%|    >>> np.amax(a, where=[False, True], initial=-1, axis=0)
  2595|         0|            0|            0|  0.00%|    array([-1,  3])
  2596|         0|            0|            0|  0.00%|    >>> b = np.arange(5, dtype=float)
  2597|         0|            0|            0|  0.00%|    >>> b[2] = np.NaN
  2598|         0|            0|            0|  0.00%|    >>> np.amax(b)
  2599|         0|            0|            0|  0.00%|    nan
  2600|         0|            0|            0|  0.00%|    >>> np.amax(b, where=~np.isnan(b), initial=-1)
  2601|         0|            0|            0|  0.00%|    4.0
  2602|         0|            0|            0|  0.00%|    >>> np.nanmax(b)
  2603|         0|            0|            0|  0.00%|    4.0
  2604|         0|            0|            0|  0.00%|
  2605|         0|            0|            0|  0.00%|    You can use an initial value to compute the maximum of an empty slice, or
  2606|         0|            0|            0|  0.00%|    to initialize it to a different value:
  2607|         0|            0|            0|  0.00%|
  2608|         0|            0|            0|  0.00%|    >>> np.max([[-50], [10]], axis=-1, initial=0)
  2609|         0|            0|            0|  0.00%|    array([ 0, 10])
  2610|         0|            0|            0|  0.00%|
  2611|         0|            0|            0|  0.00%|    Notice that the initial value is used as one of the elements for which the
  2612|         0|            0|            0|  0.00%|    maximum is determined, unlike for the default argument Python's max
  2613|         0|            0|            0|  0.00%|    function, which is only used for empty iterables.
  2614|         0|            0|            0|  0.00%|
  2615|         0|            0|            0|  0.00%|    >>> np.max([5], initial=6)
  2616|         0|            0|            0|  0.00%|    6
  2617|         0|            0|            0|  0.00%|    >>> max([5], default=6)
  2618|         0|            0|            0|  0.00%|    5
  2619|         0|            0|            0|  0.00%|    """
  2620|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.maximum, 'max', axis, None, out,
  2621|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  2622|         0|            0|            0|  0.00%|
  2623|         0|            0|            0|  0.00%|
  2624|         0|            0|            0|  0.00%|def _amin_dispatcher(a, axis=None, out=None, keepdims=None, initial=None,
  2625|         0|            0|            0|  0.00%|                     where=None):
  2626|         0|            0|            0|  0.00%|    return (a, out)
  2627|         0|            0|            0|  0.00%|
  2628|         0|            0|            0|  0.00%|
  2629|         0|            0|            0|  0.00%|@array_function_dispatch(_amin_dispatcher)
  2630|         0|            0|            0|  0.00%|def amin(a, axis=None, out=None, keepdims=np._NoValue, initial=np._NoValue,
  2631|         0|            0|            0|  0.00%|         where=np._NoValue):
  2632|         0|            0|            0|  0.00%|    """
  2633|         0|            0|            0|  0.00%|    Return the minimum of an array or minimum along an axis.
  2634|         0|            0|            0|  0.00%|
  2635|         0|            0|            0|  0.00%|    Parameters
  2636|         0|            0|            0|  0.00%|    ----------
  2637|         0|            0|            0|  0.00%|    a : array_like
  2638|         0|            0|            0|  0.00%|        Input data.
  2639|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2640|         0|            0|            0|  0.00%|        Axis or axes along which to operate.  By default, flattened input is
  2641|         0|            0|            0|  0.00%|        used.
  2642|         0|            0|            0|  0.00%|
  2643|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2644|         0|            0|            0|  0.00%|
  2645|         0|            0|            0|  0.00%|        If this is a tuple of ints, the minimum is selected over multiple axes,
  2646|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  2647|         0|            0|            0|  0.00%|    out : ndarray, optional
  2648|         0|            0|            0|  0.00%|        Alternative output array in which to place the result.  Must
  2649|         0|            0|            0|  0.00%|        be of the same shape and buffer length as the expected output.
  2650|         0|            0|            0|  0.00%|        See `doc.ufuncs` (Section "Output arguments") for more details.
  2651|         0|            0|            0|  0.00%|
  2652|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2653|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  2654|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  2655|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  2656|         0|            0|            0|  0.00%|
  2657|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2658|         0|            0|            0|  0.00%|        passed through to the `amin` method of sub-classes of
  2659|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2660|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2661|         0|            0|            0|  0.00%|        exceptions will be raised.
  2662|         0|            0|            0|  0.00%|
  2663|         0|            0|            0|  0.00%|    initial : scalar, optional
  2664|         0|            0|            0|  0.00%|        The maximum value of an output element. Must be present to allow
  2665|         0|            0|            0|  0.00%|        computation on empty slice. See `~numpy.ufunc.reduce` for details.
  2666|         0|            0|            0|  0.00%|
  2667|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2668|         0|            0|            0|  0.00%|
  2669|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2670|         0|            0|            0|  0.00%|        Elements to compare for the minimum. See `~numpy.ufunc.reduce`
  2671|         0|            0|            0|  0.00%|        for details.
  2672|         0|            0|            0|  0.00%|
  2673|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2674|         0|            0|            0|  0.00%|
  2675|         0|            0|            0|  0.00%|    Returns
  2676|         0|            0|            0|  0.00%|    -------
  2677|         0|            0|            0|  0.00%|    amin : ndarray or scalar
  2678|         0|            0|            0|  0.00%|        Minimum of `a`. If `axis` is None, the result is a scalar value.
  2679|         0|            0|            0|  0.00%|        If `axis` is given, the result is an array of dimension
  2680|         0|            0|            0|  0.00%|        ``a.ndim - 1``.
  2681|         0|            0|            0|  0.00%|
  2682|         0|            0|            0|  0.00%|    See Also
  2683|         0|            0|            0|  0.00%|    --------
  2684|         0|            0|            0|  0.00%|    amax :
  2685|         0|            0|            0|  0.00%|        The maximum value of an array along a given axis, propagating any NaNs.
  2686|         0|            0|            0|  0.00%|    nanmin :
  2687|         0|            0|            0|  0.00%|        The minimum value of an array along a given axis, ignoring any NaNs.
  2688|         0|            0|            0|  0.00%|    minimum :
  2689|         0|            0|            0|  0.00%|        Element-wise minimum of two arrays, propagating any NaNs.
  2690|         0|            0|            0|  0.00%|    fmin :
  2691|         0|            0|            0|  0.00%|        Element-wise minimum of two arrays, ignoring any NaNs.
  2692|         0|            0|            0|  0.00%|    argmin :
  2693|         0|            0|            0|  0.00%|        Return the indices of the minimum values.
  2694|         0|            0|            0|  0.00%|
  2695|         0|            0|            0|  0.00%|    nanmax, maximum, fmax
  2696|         0|            0|            0|  0.00%|
  2697|         0|            0|            0|  0.00%|    Notes
  2698|         0|            0|            0|  0.00%|    -----
  2699|         0|            0|            0|  0.00%|    NaN values are propagated, that is if at least one item is NaN, the
  2700|         0|            0|            0|  0.00%|    corresponding min value will be NaN as well. To ignore NaN values
  2701|         0|            0|            0|  0.00%|    (MATLAB behavior), please use nanmin.
  2702|         0|            0|            0|  0.00%|
  2703|         0|            0|            0|  0.00%|    Don't use `amin` for element-wise comparison of 2 arrays; when
  2704|         0|            0|            0|  0.00%|    ``a.shape[0]`` is 2, ``minimum(a[0], a[1])`` is faster than
  2705|         0|            0|            0|  0.00%|    ``amin(a, axis=0)``.
  2706|         0|            0|            0|  0.00%|
  2707|         0|            0|            0|  0.00%|    Examples
  2708|         0|            0|            0|  0.00%|    --------
  2709|         0|            0|            0|  0.00%|    >>> a = np.arange(4).reshape((2,2))
  2710|         0|            0|            0|  0.00%|    >>> a
  2711|         0|            0|            0|  0.00%|    array([[0, 1],
  2712|         0|            0|            0|  0.00%|           [2, 3]])
  2713|         0|            0|            0|  0.00%|    >>> np.amin(a)           # Minimum of the flattened array
  2714|         0|            0|            0|  0.00%|    0
  2715|         0|            0|            0|  0.00%|    >>> np.amin(a, axis=0)   # Minima along the first axis
  2716|         0|            0|            0|  0.00%|    array([0, 1])
  2717|         0|            0|            0|  0.00%|    >>> np.amin(a, axis=1)   # Minima along the second axis
  2718|         0|            0|            0|  0.00%|    array([0, 2])
  2719|         0|            0|            0|  0.00%|    >>> np.amin(a, where=[False, True], initial=10, axis=0)
  2720|         0|            0|            0|  0.00%|    array([10,  1])
  2721|         0|            0|            0|  0.00%|
  2722|         0|            0|            0|  0.00%|    >>> b = np.arange(5, dtype=float)
  2723|         0|            0|            0|  0.00%|    >>> b[2] = np.NaN
  2724|         0|            0|            0|  0.00%|    >>> np.amin(b)
  2725|         0|            0|            0|  0.00%|    nan
  2726|         0|            0|            0|  0.00%|    >>> np.amin(b, where=~np.isnan(b), initial=10)
  2727|         0|            0|            0|  0.00%|    0.0
  2728|         0|            0|            0|  0.00%|    >>> np.nanmin(b)
  2729|         0|            0|            0|  0.00%|    0.0
  2730|         0|            0|            0|  0.00%|
  2731|         0|            0|            0|  0.00%|    >>> np.min([[-50], [10]], axis=-1, initial=0)
  2732|         0|            0|            0|  0.00%|    array([-50,   0])
  2733|         0|            0|            0|  0.00%|
  2734|         0|            0|            0|  0.00%|    Notice that the initial value is used as one of the elements for which the
  2735|         0|            0|            0|  0.00%|    minimum is determined, unlike for the default argument Python's max
  2736|         0|            0|            0|  0.00%|    function, which is only used for empty iterables.
  2737|         0|            0|            0|  0.00%|
  2738|         0|            0|            0|  0.00%|    Notice that this isn't the same as Python's ``default`` argument.
  2739|         0|            0|            0|  0.00%|
  2740|         0|            0|            0|  0.00%|    >>> np.min([6], initial=5)
  2741|         0|            0|            0|  0.00%|    5
  2742|         0|            0|            0|  0.00%|    >>> min([6], default=5)
  2743|         0|            0|            0|  0.00%|    6
  2744|         0|            0|            0|  0.00%|    """
  2745|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.minimum, 'min', axis, None, out,
  2746|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  2747|         0|            0|            0|  0.00%|
  2748|         0|            0|            0|  0.00%|
  2749|         0|            0|            0|  0.00%|def _alen_dispathcer(a):
  2750|         0|            0|            0|  0.00%|    return (a,)
  2751|         0|            0|            0|  0.00%|
  2752|         0|            0|            0|  0.00%|
  2753|         0|            0|            0|  0.00%|@array_function_dispatch(_alen_dispathcer)
  2754|         0|            0|            0|  0.00%|def alen(a):
  2755|         0|            0|            0|  0.00%|    """
  2756|         0|            0|            0|  0.00%|    Return the length of the first dimension of the input array.
  2757|         0|            0|            0|  0.00%|
  2758|         0|            0|            0|  0.00%|    Parameters
  2759|         0|            0|            0|  0.00%|    ----------
  2760|         0|            0|            0|  0.00%|    a : array_like
  2761|         0|            0|            0|  0.00%|       Input array.
  2762|         0|            0|            0|  0.00%|
  2763|         0|            0|            0|  0.00%|    Returns
  2764|         0|            0|            0|  0.00%|    -------
  2765|         0|            0|            0|  0.00%|    alen : int
  2766|         0|            0|            0|  0.00%|       Length of the first dimension of `a`.
  2767|         0|            0|            0|  0.00%|
  2768|         0|            0|            0|  0.00%|    See Also
  2769|         0|            0|            0|  0.00%|    --------
  2770|         0|            0|            0|  0.00%|    shape, size
  2771|         0|            0|            0|  0.00%|
  2772|         0|            0|            0|  0.00%|    Examples
  2773|         0|            0|            0|  0.00%|    --------
  2774|         0|            0|            0|  0.00%|    >>> a = np.zeros((7,4,5))
  2775|         0|            0|            0|  0.00%|    >>> a.shape[0]
  2776|         0|            0|            0|  0.00%|    7
  2777|         0|            0|            0|  0.00%|    >>> np.alen(a)
  2778|         0|            0|            0|  0.00%|    7
  2779|         0|            0|            0|  0.00%|
  2780|         0|            0|            0|  0.00%|    """
  2781|         0|            0|            0|  0.00%|    try:
  2782|         0|            0|            0|  0.00%|        return len(a)
  2783|         0|            0|            0|  0.00%|    except TypeError:
  2784|         0|            0|            0|  0.00%|        return len(array(a, ndmin=1))
  2785|         0|            0|            0|  0.00%|
  2786|         0|            0|            0|  0.00%|
  2787|         0|            0|            0|  0.00%|def _prod_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None,
  2788|         0|            0|            0|  0.00%|                     initial=None, where=None):
  2789|         0|            0|            0|  0.00%|    return (a, out)
  2790|         0|            0|            0|  0.00%|
  2791|         0|            0|            0|  0.00%|
  2792|         0|            0|            0|  0.00%|@array_function_dispatch(_prod_dispatcher)
  2793|         0|            0|            0|  0.00%|def prod(a, axis=None, dtype=None, out=None, keepdims=np._NoValue,
  2794|         0|            0|            0|  0.00%|         initial=np._NoValue, where=np._NoValue):
  2795|         0|            0|            0|  0.00%|    """
  2796|         0|            0|            0|  0.00%|    Return the product of array elements over a given axis.
  2797|         0|            0|            0|  0.00%|
  2798|         0|            0|            0|  0.00%|    Parameters
  2799|         0|            0|            0|  0.00%|    ----------
  2800|         0|            0|            0|  0.00%|    a : array_like
  2801|         0|            0|            0|  0.00%|        Input data.
  2802|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  2803|         0|            0|            0|  0.00%|        Axis or axes along which a product is performed.  The default,
  2804|         0|            0|            0|  0.00%|        axis=None, will calculate the product of all the elements in the
  2805|         0|            0|            0|  0.00%|        input array. If axis is negative it counts from the last to the
  2806|         0|            0|            0|  0.00%|        first axis.
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  2809|         0|            0|            0|  0.00%|
  2810|         0|            0|            0|  0.00%|        If axis is a tuple of ints, a product is performed on all of the
  2811|         0|            0|            0|  0.00%|        axes specified in the tuple instead of a single axis or all the
  2812|         0|            0|            0|  0.00%|        axes as before.
  2813|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2814|         0|            0|            0|  0.00%|        The type of the returned array, as well as of the accumulator in
  2815|         0|            0|            0|  0.00%|        which the elements are multiplied.  The dtype of `a` is used by
  2816|         0|            0|            0|  0.00%|        default unless `a` has an integer dtype of less precision than the
  2817|         0|            0|            0|  0.00%|        default platform integer.  In that case, if `a` is signed then the
  2818|         0|            0|            0|  0.00%|        platform integer is used while if `a` is unsigned then an unsigned
  2819|         0|            0|            0|  0.00%|        integer of the same precision as the platform integer is used.
  2820|         0|            0|            0|  0.00%|    out : ndarray, optional
  2821|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  2822|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  2823|         0|            0|            0|  0.00%|        values will be cast if necessary.
  2824|         0|            0|            0|  0.00%|    keepdims : bool, optional
  2825|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in the
  2826|         0|            0|            0|  0.00%|        result as dimensions with size one. With this option, the result
  2827|         0|            0|            0|  0.00%|        will broadcast correctly against the input array.
  2828|         0|            0|            0|  0.00%|
  2829|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  2830|         0|            0|            0|  0.00%|        passed through to the `prod` method of sub-classes of
  2831|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  2832|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  2833|         0|            0|            0|  0.00%|        exceptions will be raised.
  2834|         0|            0|            0|  0.00%|    initial : scalar, optional
  2835|         0|            0|            0|  0.00%|        The starting value for this product. See `~numpy.ufunc.reduce` for details.
  2836|         0|            0|            0|  0.00%|
  2837|         0|            0|            0|  0.00%|        .. versionadded:: 1.15.0
  2838|         0|            0|            0|  0.00%|
  2839|         0|            0|            0|  0.00%|    where : array_like of bool, optional
  2840|         0|            0|            0|  0.00%|        Elements to include in the product. See `~numpy.ufunc.reduce` for details.
  2841|         0|            0|            0|  0.00%|
  2842|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
  2843|         0|            0|            0|  0.00%|
  2844|         0|            0|            0|  0.00%|    Returns
  2845|         0|            0|            0|  0.00%|    -------
  2846|         0|            0|            0|  0.00%|    product_along_axis : ndarray, see `dtype` parameter above.
  2847|         0|            0|            0|  0.00%|        An array shaped as `a` but with the specified axis removed.
  2848|         0|            0|            0|  0.00%|        Returns a reference to `out` if specified.
  2849|         0|            0|            0|  0.00%|
  2850|         0|            0|            0|  0.00%|    See Also
  2851|         0|            0|            0|  0.00%|    --------
  2852|         0|            0|            0|  0.00%|    ndarray.prod : equivalent method
  2853|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  2854|         0|            0|            0|  0.00%|
  2855|         0|            0|            0|  0.00%|    Notes
  2856|         0|            0|            0|  0.00%|    -----
  2857|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2858|         0|            0|            0|  0.00%|    raised on overflow.  That means that, on a 32-bit platform:
  2859|         0|            0|            0|  0.00%|
  2860|         0|            0|            0|  0.00%|    >>> x = np.array([536870910, 536870910, 536870910, 536870910])
  2861|         0|            0|            0|  0.00%|    >>> np.prod(x)
  2862|         0|            0|            0|  0.00%|    16 # may vary
  2863|         0|            0|            0|  0.00%|
  2864|         0|            0|            0|  0.00%|    The product of an empty array is the neutral element 1:
  2865|         0|            0|            0|  0.00%|
  2866|         0|            0|            0|  0.00%|    >>> np.prod([])
  2867|         0|            0|            0|  0.00%|    1.0
  2868|         0|            0|            0|  0.00%|
  2869|         0|            0|            0|  0.00%|    Examples
  2870|         0|            0|            0|  0.00%|    --------
  2871|         0|            0|            0|  0.00%|    By default, calculate the product of all elements:
  2872|         0|            0|            0|  0.00%|
  2873|         0|            0|            0|  0.00%|    >>> np.prod([1.,2.])
  2874|         0|            0|            0|  0.00%|    2.0
  2875|         0|            0|            0|  0.00%|
  2876|         0|            0|            0|  0.00%|    Even when the input array is two-dimensional:
  2877|         0|            0|            0|  0.00%|
  2878|         0|            0|            0|  0.00%|    >>> np.prod([[1.,2.],[3.,4.]])
  2879|         0|            0|            0|  0.00%|    24.0
  2880|         0|            0|            0|  0.00%|
  2881|         0|            0|            0|  0.00%|    But we can also specify the axis over which to multiply:
  2882|         0|            0|            0|  0.00%|
  2883|         0|            0|            0|  0.00%|    >>> np.prod([[1.,2.],[3.,4.]], axis=1)
  2884|         0|            0|            0|  0.00%|    array([  2.,  12.])
  2885|         0|            0|            0|  0.00%|
  2886|         0|            0|            0|  0.00%|    Or select specific elements to include:
  2887|         0|            0|            0|  0.00%|
  2888|         0|            0|            0|  0.00%|    >>> np.prod([1., np.nan, 3.], where=[True, False, True])
  2889|         0|            0|            0|  0.00%|    3.0
  2890|         0|            0|            0|  0.00%|
  2891|         0|            0|            0|  0.00%|    If the type of `x` is unsigned, then the output type is
  2892|         0|            0|            0|  0.00%|    the unsigned platform integer:
  2893|         0|            0|            0|  0.00%|
  2894|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3], dtype=np.uint8)
  2895|         0|            0|            0|  0.00%|    >>> np.prod(x).dtype == np.uint
  2896|         0|            0|            0|  0.00%|    True
  2897|         0|            0|            0|  0.00%|
  2898|         0|            0|            0|  0.00%|    If `x` is of a signed integer type, then the output type
  2899|         0|            0|            0|  0.00%|    is the default platform integer:
  2900|         0|            0|            0|  0.00%|
  2901|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3], dtype=np.int8)
  2902|         0|            0|            0|  0.00%|    >>> np.prod(x).dtype == int
  2903|         0|            0|            0|  0.00%|    True
  2904|         0|            0|            0|  0.00%|
  2905|         0|            0|            0|  0.00%|    You can also start the product with a value other than one:
  2906|         0|            0|            0|  0.00%|
  2907|         0|            0|            0|  0.00%|    >>> np.prod([1, 2], initial=5)
  2908|         0|            0|            0|  0.00%|    10
  2909|         0|            0|            0|  0.00%|    """
  2910|         0|            0|            0|  0.00%|    return _wrapreduction(a, np.multiply, 'prod', axis, dtype, out,
  2911|         0|            0|            0|  0.00%|                          keepdims=keepdims, initial=initial, where=where)
  2912|         0|            0|            0|  0.00%|
  2913|         0|            0|            0|  0.00%|
  2914|         0|            0|            0|  0.00%|def _cumprod_dispatcher(a, axis=None, dtype=None, out=None):
  2915|         0|            0|            0|  0.00%|    return (a, out)
  2916|         0|            0|            0|  0.00%|
  2917|         0|            0|            0|  0.00%|
  2918|         0|            0|            0|  0.00%|@array_function_dispatch(_cumprod_dispatcher)
  2919|         0|            0|            0|  0.00%|def cumprod(a, axis=None, dtype=None, out=None):
  2920|         0|            0|            0|  0.00%|    """
  2921|         0|            0|            0|  0.00%|    Return the cumulative product of elements along a given axis.
  2922|         0|            0|            0|  0.00%|
  2923|         0|            0|            0|  0.00%|    Parameters
  2924|         0|            0|            0|  0.00%|    ----------
  2925|         0|            0|            0|  0.00%|    a : array_like
  2926|         0|            0|            0|  0.00%|        Input array.
  2927|         0|            0|            0|  0.00%|    axis : int, optional
  2928|         0|            0|            0|  0.00%|        Axis along which the cumulative product is computed.  By default
  2929|         0|            0|            0|  0.00%|        the input is flattened.
  2930|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2931|         0|            0|            0|  0.00%|        Type of the returned array, as well as of the accumulator in which
  2932|         0|            0|            0|  0.00%|        the elements are multiplied.  If *dtype* is not specified, it
  2933|         0|            0|            0|  0.00%|        defaults to the dtype of `a`, unless `a` has an integer dtype with
  2934|         0|            0|            0|  0.00%|        a precision less than that of the default platform integer.  In
  2935|         0|            0|            0|  0.00%|        that case, the default platform integer is used instead.
  2936|         0|            0|            0|  0.00%|    out : ndarray, optional
  2937|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  2938|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output
  2939|         0|            0|            0|  0.00%|        but the type of the resulting values will be cast if necessary.
  2940|         0|            0|            0|  0.00%|
  2941|         0|            0|            0|  0.00%|    Returns
  2942|         0|            0|            0|  0.00%|    -------
  2943|         0|            0|            0|  0.00%|    cumprod : ndarray
  2944|         0|            0|            0|  0.00%|        A new array holding the result is returned unless `out` is
  2945|         0|            0|            0|  0.00%|        specified, in which case a reference to out is returned.
  2946|         0|            0|            0|  0.00%|
  2947|         0|            0|            0|  0.00%|    See Also
  2948|         0|            0|            0|  0.00%|    --------
  2949|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  2950|         0|            0|            0|  0.00%|
  2951|         0|            0|            0|  0.00%|    Notes
  2952|         0|            0|            0|  0.00%|    -----
  2953|         0|            0|            0|  0.00%|    Arithmetic is modular when using integer types, and no error is
  2954|         0|            0|            0|  0.00%|    raised on overflow.
  2955|         0|            0|            0|  0.00%|
  2956|         0|            0|            0|  0.00%|    Examples
  2957|         0|            0|            0|  0.00%|    --------
  2958|         0|            0|            0|  0.00%|    >>> a = np.array([1,2,3])
  2959|         0|            0|            0|  0.00%|    >>> np.cumprod(a) # intermediate results 1, 1*2
  2960|         0|            0|            0|  0.00%|    ...               # total product 1*2*3 = 6
  2961|         0|            0|            0|  0.00%|    array([1, 2, 6])
  2962|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]])
  2963|         0|            0|            0|  0.00%|    >>> np.cumprod(a, dtype=float) # specify type of output
  2964|         0|            0|            0|  0.00%|    array([   1.,    2.,    6.,   24.,  120.,  720.])
  2965|         0|            0|            0|  0.00%|
  2966|         0|            0|            0|  0.00%|    The cumulative product for each column (i.e., over the rows) of `a`:
  2967|         0|            0|            0|  0.00%|
  2968|         0|            0|            0|  0.00%|    >>> np.cumprod(a, axis=0)
  2969|         0|            0|            0|  0.00%|    array([[ 1,  2,  3],
  2970|         0|            0|            0|  0.00%|           [ 4, 10, 18]])
  2971|         0|            0|            0|  0.00%|
  2972|         0|            0|            0|  0.00%|    The cumulative product for each row (i.e. over the columns) of `a`:
  2973|         0|            0|            0|  0.00%|
  2974|         0|            0|            0|  0.00%|    >>> np.cumprod(a,axis=1)
  2975|         0|            0|            0|  0.00%|    array([[  1,   2,   6],
  2976|         0|            0|            0|  0.00%|           [  4,  20, 120]])
  2977|         0|            0|            0|  0.00%|
  2978|         0|            0|            0|  0.00%|    """
  2979|         0|            0|            0|  0.00%|    return _wrapfunc(a, 'cumprod', axis=axis, dtype=dtype, out=out)
  2980|         0|            0|            0|  0.00%|
  2981|         0|            0|            0|  0.00%|
  2982|         1|  3.57628e-06|  3.57628e-06|  0.00%|def _ndim_dispatcher(a):
  2983|         1|  8.82149e-06|  8.82149e-06|  0.00%|    return (a,)
  2984|         0|            0|            0|  0.00%|
  2985|         0|            0|            0|  0.00%|
  2986|         1|  5.48363e-06|  5.48363e-06|  0.00%|@array_function_dispatch(_ndim_dispatcher)
  2987|         0|            0|            0|  0.00%|def ndim(a):
  2988|         0|            0|            0|  0.00%|    """
  2989|         0|            0|            0|  0.00%|    Return the number of dimensions of an array.
  2990|         0|            0|            0|  0.00%|
  2991|         0|            0|            0|  0.00%|    Parameters
  2992|         0|            0|            0|  0.00%|    ----------
  2993|         0|            0|            0|  0.00%|    a : array_like
  2994|         0|            0|            0|  0.00%|        Input array.  If it is not already an ndarray, a conversion is
  2995|         0|            0|            0|  0.00%|        attempted.
  2996|         0|            0|            0|  0.00%|
  2997|         0|            0|            0|  0.00%|    Returns
  2998|         0|            0|            0|  0.00%|    -------
  2999|         0|            0|            0|  0.00%|    number_of_dimensions : int
  3000|         0|            0|            0|  0.00%|        The number of dimensions in `a`.  Scalars are zero-dimensional.
  3001|         0|            0|            0|  0.00%|
  3002|         0|            0|            0|  0.00%|    See Also
  3003|         0|            0|            0|  0.00%|    --------
  3004|         0|            0|            0|  0.00%|    ndarray.ndim : equivalent method
  3005|         0|            0|            0|  0.00%|    shape : dimensions of array
  3006|         0|            0|            0|  0.00%|    ndarray.shape : dimensions of array
  3007|         0|            0|            0|  0.00%|
  3008|         0|            0|            0|  0.00%|    Examples
  3009|         0|            0|            0|  0.00%|    --------
  3010|         0|            0|            0|  0.00%|    >>> np.ndim([[1,2,3],[4,5,6]])
  3011|         0|            0|            0|  0.00%|    2
  3012|         0|            0|            0|  0.00%|    >>> np.ndim(np.array([[1,2,3],[4,5,6]]))
  3013|         0|            0|            0|  0.00%|    2
  3014|         0|            0|            0|  0.00%|    >>> np.ndim(1)
  3015|         0|            0|            0|  0.00%|    0
  3016|         0|            0|            0|  0.00%|
  3017|         0|            0|            0|  0.00%|    """
  3018|         1|  3.57628e-06|  3.57628e-06|  0.00%|    try:
  3019|         1|  6.67572e-06|  6.67572e-06|  0.00%|        return a.ndim
  3020|         0|            0|            0|  0.00%|    except AttributeError:
  3021|         0|            0|            0|  0.00%|        return asarray(a).ndim
  3022|         0|            0|            0|  0.00%|
  3023|         0|            0|            0|  0.00%|
  3024|         0|            0|            0|  0.00%|def _size_dispatcher(a, axis=None):
  3025|         0|            0|            0|  0.00%|    return (a,)
  3026|         0|            0|            0|  0.00%|
  3027|         0|            0|            0|  0.00%|
  3028|         0|            0|            0|  0.00%|@array_function_dispatch(_size_dispatcher)
  3029|         0|            0|            0|  0.00%|def size(a, axis=None):
  3030|         0|            0|            0|  0.00%|    """
  3031|         0|            0|            0|  0.00%|    Return the number of elements along a given axis.
  3032|         0|            0|            0|  0.00%|
  3033|         0|            0|            0|  0.00%|    Parameters
  3034|         0|            0|            0|  0.00%|    ----------
  3035|         0|            0|            0|  0.00%|    a : array_like
  3036|         0|            0|            0|  0.00%|        Input data.
  3037|         0|            0|            0|  0.00%|    axis : int, optional
  3038|         0|            0|            0|  0.00%|        Axis along which the elements are counted.  By default, give
  3039|         0|            0|            0|  0.00%|        the total number of elements.
  3040|         0|            0|            0|  0.00%|
  3041|         0|            0|            0|  0.00%|    Returns
  3042|         0|            0|            0|  0.00%|    -------
  3043|         0|            0|            0|  0.00%|    element_count : int
  3044|         0|            0|            0|  0.00%|        Number of elements along the specified axis.
  3045|         0|            0|            0|  0.00%|
  3046|         0|            0|            0|  0.00%|    See Also
  3047|         0|            0|            0|  0.00%|    --------
  3048|         0|            0|            0|  0.00%|    shape : dimensions of array
  3049|         0|            0|            0|  0.00%|    ndarray.shape : dimensions of array
  3050|         0|            0|            0|  0.00%|    ndarray.size : number of elements in array
  3051|         0|            0|            0|  0.00%|
  3052|         0|            0|            0|  0.00%|    Examples
  3053|         0|            0|            0|  0.00%|    --------
  3054|         0|            0|            0|  0.00%|    >>> a = np.array([[1,2,3],[4,5,6]])
  3055|         0|            0|            0|  0.00%|    >>> np.size(a)
  3056|         0|            0|            0|  0.00%|    6
  3057|         0|            0|            0|  0.00%|    >>> np.size(a,1)
  3058|         0|            0|            0|  0.00%|    3
  3059|         0|            0|            0|  0.00%|    >>> np.size(a,0)
  3060|         0|            0|            0|  0.00%|    2
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|    """
  3063|         0|            0|            0|  0.00%|    if axis is None:
  3064|         0|            0|            0|  0.00%|        try:
  3065|         0|            0|            0|  0.00%|            return a.size
  3066|         0|            0|            0|  0.00%|        except AttributeError:
  3067|         0|            0|            0|  0.00%|            return asarray(a).size
  3068|         0|            0|            0|  0.00%|    else:
  3069|         0|            0|            0|  0.00%|        try:
  3070|         0|            0|            0|  0.00%|            return a.shape[axis]
  3071|         0|            0|            0|  0.00%|        except AttributeError:
  3072|         0|            0|            0|  0.00%|            return asarray(a).shape[axis]
  3073|         0|            0|            0|  0.00%|
  3074|         0|            0|            0|  0.00%|
  3075|         4|  1.62125e-05|  4.05312e-06|  0.00%|def _around_dispatcher(a, decimals=None, out=None):
  3076|         4|  1.16825e-05|  2.92063e-06|  0.00%|    return (a, out)
  3077|         0|            0|            0|  0.00%|
  3078|         0|            0|            0|  0.00%|
  3079|         2|  5.96046e-06|  2.98023e-06|  0.00%|@array_function_dispatch(_around_dispatcher)
  3080|         0|            0|            0|  0.00%|def around(a, decimals=0, out=None):
  3081|         0|            0|            0|  0.00%|    """
  3082|         0|            0|            0|  0.00%|    Evenly round to the given number of decimals.
  3083|         0|            0|            0|  0.00%|
  3084|         0|            0|            0|  0.00%|    Parameters
  3085|         0|            0|            0|  0.00%|    ----------
  3086|         0|            0|            0|  0.00%|    a : array_like
  3087|         0|            0|            0|  0.00%|        Input data.
  3088|         0|            0|            0|  0.00%|    decimals : int, optional
  3089|         0|            0|            0|  0.00%|        Number of decimal places to round to (default: 0).  If
  3090|         0|            0|            0|  0.00%|        decimals is negative, it specifies the number of positions to
  3091|         0|            0|            0|  0.00%|        the left of the decimal point.
  3092|         0|            0|            0|  0.00%|    out : ndarray, optional
  3093|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  3094|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type of the output
  3095|         0|            0|            0|  0.00%|        values will be cast if necessary. See `doc.ufuncs` (Section
  3096|         0|            0|            0|  0.00%|        "Output arguments") for details.
  3097|         0|            0|            0|  0.00%|
  3098|         0|            0|            0|  0.00%|    Returns
  3099|         0|            0|            0|  0.00%|    -------
  3100|         0|            0|            0|  0.00%|    rounded_array : ndarray
  3101|         0|            0|            0|  0.00%|        An array of the same type as `a`, containing the rounded values.
  3102|         0|            0|            0|  0.00%|        Unless `out` was specified, a new array is created.  A reference to
  3103|         0|            0|            0|  0.00%|        the result is returned.
  3104|         0|            0|            0|  0.00%|
  3105|         0|            0|            0|  0.00%|        The real and imaginary parts of complex numbers are rounded
  3106|         0|            0|            0|  0.00%|        separately.  The result of rounding a float is a float.
  3107|         0|            0|            0|  0.00%|
  3108|         0|            0|            0|  0.00%|    See Also
  3109|         0|            0|            0|  0.00%|    --------
  3110|         0|            0|            0|  0.00%|    ndarray.round : equivalent method
  3111|         0|            0|            0|  0.00%|
  3112|         0|            0|            0|  0.00%|    ceil, fix, floor, rint, trunc
  3113|         0|            0|            0|  0.00%|
  3114|         0|            0|            0|  0.00%|
  3115|         0|            0|            0|  0.00%|    Notes
  3116|         0|            0|            0|  0.00%|    -----
  3117|         0|            0|            0|  0.00%|    For values exactly halfway between rounded decimal values, NumPy
  3118|         0|            0|            0|  0.00%|    rounds to the nearest even value. Thus 1.5 and 2.5 round to 2.0,
  3119|         0|            0|            0|  0.00%|    -0.5 and 0.5 round to 0.0, etc. Results may also be surprising due
  3120|         0|            0|            0|  0.00%|    to the inexact representation of decimal fractions in the IEEE
  3121|         0|            0|            0|  0.00%|    floating point standard [1]_ and errors introduced when scaling
  3122|         0|            0|            0|  0.00%|    by powers of ten.
  3123|         0|            0|            0|  0.00%|
  3124|         0|            0|            0|  0.00%|    References
  3125|         0|            0|            0|  0.00%|    ----------
  3126|         0|            0|            0|  0.00%|    .. [1] "Lecture Notes on the Status of IEEE 754", William Kahan,
  3127|         0|            0|            0|  0.00%|           https://people.eecs.berkeley.edu/~wkahan/ieee754status/IEEE754.PDF
  3128|         0|            0|            0|  0.00%|    .. [2] "How Futile are Mindless Assessments of
  3129|         0|            0|            0|  0.00%|           Roundoff in Floating-Point Computation?", William Kahan,
  3130|         0|            0|            0|  0.00%|           https://people.eecs.berkeley.edu/~wkahan/Mindless.pdf
  3131|         0|            0|            0|  0.00%|
  3132|         0|            0|            0|  0.00%|    Examples
  3133|         0|            0|            0|  0.00%|    --------
  3134|         0|            0|            0|  0.00%|    >>> np.around([0.37, 1.64])
  3135|         0|            0|            0|  0.00%|    array([0.,  2.])
  3136|         0|            0|            0|  0.00%|    >>> np.around([0.37, 1.64], decimals=1)
  3137|         0|            0|            0|  0.00%|    array([0.4,  1.6])
  3138|         0|            0|            0|  0.00%|    >>> np.around([.5, 1.5, 2.5, 3.5, 4.5]) # rounds to nearest even value
  3139|         0|            0|            0|  0.00%|    array([0.,  2.,  2.,  4.,  4.])
  3140|         0|            0|            0|  0.00%|    >>> np.around([1,2,3,11], decimals=1) # ndarray of ints is returned
  3141|         0|            0|            0|  0.00%|    array([ 1,  2,  3, 11])
  3142|         0|            0|            0|  0.00%|    >>> np.around([1,2,3,11], decimals=-1)
  3143|         0|            0|            0|  0.00%|    array([ 0,  0,  0, 10])
  3144|         0|            0|            0|  0.00%|
  3145|         0|            0|            0|  0.00%|    """
  3146|         2|  2.02656e-05|  1.01328e-05|  0.00%|    return _wrapfunc(a, 'round', decimals=decimals, out=out)
(call)|         2|  0.000167608|  8.38041e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:55 _wrapfunc
  3147|         0|            0|            0|  0.00%|
  3148|         0|            0|            0|  0.00%|
  3149|         1|  2.86102e-06|  2.86102e-06|  0.00%|def _mean_dispatcher(a, axis=None, dtype=None, out=None, keepdims=None):
  3150|         1|   3.8147e-06|   3.8147e-06|  0.00%|    return (a, out)
  3151|         0|            0|            0|  0.00%|
  3152|         0|            0|            0|  0.00%|
  3153|         1|  8.10623e-06|  8.10623e-06|  0.00%|@array_function_dispatch(_mean_dispatcher)
  3154|         0|            0|            0|  0.00%|def mean(a, axis=None, dtype=None, out=None, keepdims=np._NoValue):
  3155|         0|            0|            0|  0.00%|    """
  3156|         0|            0|            0|  0.00%|    Compute the arithmetic mean along the specified axis.
  3157|         0|            0|            0|  0.00%|
  3158|         0|            0|            0|  0.00%|    Returns the average of the array elements.  The average is taken over
  3159|         0|            0|            0|  0.00%|    the flattened array by default, otherwise over the specified axis.
  3160|         0|            0|            0|  0.00%|    `float64` intermediate and return values are used for integer inputs.
  3161|         0|            0|            0|  0.00%|
  3162|         0|            0|            0|  0.00%|    Parameters
  3163|         0|            0|            0|  0.00%|    ----------
  3164|         0|            0|            0|  0.00%|    a : array_like
  3165|         0|            0|            0|  0.00%|        Array containing numbers whose mean is desired. If `a` is not an
  3166|         0|            0|            0|  0.00%|        array, a conversion is attempted.
  3167|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3168|         0|            0|            0|  0.00%|        Axis or axes along which the means are computed. The default is to
  3169|         0|            0|            0|  0.00%|        compute the mean of the flattened array.
  3170|         0|            0|            0|  0.00%|
  3171|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3172|         0|            0|            0|  0.00%|
  3173|         0|            0|            0|  0.00%|        If this is a tuple of ints, a mean is performed over multiple axes,
  3174|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  3175|         0|            0|            0|  0.00%|    dtype : data-type, optional
  3176|         0|            0|            0|  0.00%|        Type to use in computing the mean.  For integer inputs, the default
  3177|         0|            0|            0|  0.00%|        is `float64`; for floating point inputs, it is the same as the
  3178|         0|            0|            0|  0.00%|        input dtype.
  3179|         0|            0|            0|  0.00%|    out : ndarray, optional
  3180|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  The default
  3181|         0|            0|            0|  0.00%|        is ``None``; if provided, it must have the same shape as the
  3182|         0|            0|            0|  0.00%|        expected output, but the type will be cast if necessary.
  3183|         0|            0|            0|  0.00%|        See `doc.ufuncs` for details.
  3184|         0|            0|            0|  0.00%|
  3185|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3186|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3187|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3188|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3189|         0|            0|            0|  0.00%|
  3190|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3191|         0|            0|            0|  0.00%|        passed through to the `mean` method of sub-classes of
  3192|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3193|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3194|         0|            0|            0|  0.00%|        exceptions will be raised.
  3195|         0|            0|            0|  0.00%|
  3196|         0|            0|            0|  0.00%|    Returns
  3197|         0|            0|            0|  0.00%|    -------
  3198|         0|            0|            0|  0.00%|    m : ndarray, see dtype parameter above
  3199|         0|            0|            0|  0.00%|        If `out=None`, returns a new array containing the mean values,
  3200|         0|            0|            0|  0.00%|        otherwise a reference to the output array is returned.
  3201|         0|            0|            0|  0.00%|
  3202|         0|            0|            0|  0.00%|    See Also
  3203|         0|            0|            0|  0.00%|    --------
  3204|         0|            0|            0|  0.00%|    average : Weighted average
  3205|         0|            0|            0|  0.00%|    std, var, nanmean, nanstd, nanvar
  3206|         0|            0|            0|  0.00%|
  3207|         0|            0|            0|  0.00%|    Notes
  3208|         0|            0|            0|  0.00%|    -----
  3209|         0|            0|            0|  0.00%|    The arithmetic mean is the sum of the elements along the axis divided
  3210|         0|            0|            0|  0.00%|    by the number of elements.
  3211|         0|            0|            0|  0.00%|
  3212|         0|            0|            0|  0.00%|    Note that for floating-point input, the mean is computed using the
  3213|         0|            0|            0|  0.00%|    same precision the input has.  Depending on the input data, this can
  3214|         0|            0|            0|  0.00%|    cause the results to be inaccurate, especially for `float32` (see
  3215|         0|            0|            0|  0.00%|    example below).  Specifying a higher-precision accumulator using the
  3216|         0|            0|            0|  0.00%|    `dtype` keyword can alleviate this issue.
  3217|         0|            0|            0|  0.00%|
  3218|         0|            0|            0|  0.00%|    By default, `float16` results are computed using `float32` intermediates
  3219|         0|            0|            0|  0.00%|    for extra precision.
  3220|         0|            0|            0|  0.00%|
  3221|         0|            0|            0|  0.00%|    Examples
  3222|         0|            0|            0|  0.00%|    --------
  3223|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3224|         0|            0|            0|  0.00%|    >>> np.mean(a)
  3225|         0|            0|            0|  0.00%|    2.5
  3226|         0|            0|            0|  0.00%|    >>> np.mean(a, axis=0)
  3227|         0|            0|            0|  0.00%|    array([2., 3.])
  3228|         0|            0|            0|  0.00%|    >>> np.mean(a, axis=1)
  3229|         0|            0|            0|  0.00%|    array([1.5, 3.5])
  3230|         0|            0|            0|  0.00%|
  3231|         0|            0|            0|  0.00%|    In single precision, `mean` can be inaccurate:
  3232|         0|            0|            0|  0.00%|
  3233|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3234|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3235|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3236|         0|            0|            0|  0.00%|    >>> np.mean(a)
  3237|         0|            0|            0|  0.00%|    0.54999924
  3238|         0|            0|            0|  0.00%|
  3239|         0|            0|            0|  0.00%|    Computing the mean in float64 is more accurate:
  3240|         0|            0|            0|  0.00%|
  3241|         0|            0|            0|  0.00%|    >>> np.mean(a, dtype=np.float64)
  3242|         0|            0|            0|  0.00%|    0.55000000074505806 # may vary
  3243|         0|            0|            0|  0.00%|
  3244|         0|            0|            0|  0.00%|    """
  3245|         1|  4.29153e-06|  4.29153e-06|  0.00%|    kwargs = {}
  3246|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if keepdims is not np._NoValue:
  3247|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3248|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if type(a) is not mu.ndarray:
  3249|         0|            0|            0|  0.00%|        try:
  3250|         0|            0|            0|  0.00%|            mean = a.mean
  3251|         0|            0|            0|  0.00%|        except AttributeError:
  3252|         0|            0|            0|  0.00%|            pass
  3253|         0|            0|            0|  0.00%|        else:
  3254|         0|            0|            0|  0.00%|            return mean(axis=axis, dtype=dtype, out=out, **kwargs)
  3255|         0|            0|            0|  0.00%|
  3256|         1|  5.48363e-06|  5.48363e-06|  0.00%|    return _methods._mean(a, axis=axis, dtype=dtype,
  3257|         1|   1.5974e-05|   1.5974e-05|  0.00%|                          out=out, **kwargs)
(call)|         1|  0.000141382|  0.000141382|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_methods.py:134 _mean
  3258|         0|            0|            0|  0.00%|
  3259|         0|            0|            0|  0.00%|
  3260|         0|            0|            0|  0.00%|def _std_dispatcher(
  3261|         0|            0|            0|  0.00%|        a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
  3262|         0|            0|            0|  0.00%|    return (a, out)
  3263|         0|            0|            0|  0.00%|
  3264|         0|            0|            0|  0.00%|
  3265|         0|            0|            0|  0.00%|@array_function_dispatch(_std_dispatcher)
  3266|         0|            0|            0|  0.00%|def std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
  3267|         0|            0|            0|  0.00%|    """
  3268|         0|            0|            0|  0.00%|    Compute the standard deviation along the specified axis.
  3269|         0|            0|            0|  0.00%|
  3270|         0|            0|            0|  0.00%|    Returns the standard deviation, a measure of the spread of a distribution,
  3271|         0|            0|            0|  0.00%|    of the array elements. The standard deviation is computed for the
  3272|         0|            0|            0|  0.00%|    flattened array by default, otherwise over the specified axis.
  3273|         0|            0|            0|  0.00%|
  3274|         0|            0|            0|  0.00%|    Parameters
  3275|         0|            0|            0|  0.00%|    ----------
  3276|         0|            0|            0|  0.00%|    a : array_like
  3277|         0|            0|            0|  0.00%|        Calculate the standard deviation of these values.
  3278|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3279|         0|            0|            0|  0.00%|        Axis or axes along which the standard deviation is computed. The
  3280|         0|            0|            0|  0.00%|        default is to compute the standard deviation of the flattened array.
  3281|         0|            0|            0|  0.00%|
  3282|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3283|         0|            0|            0|  0.00%|
  3284|         0|            0|            0|  0.00%|        If this is a tuple of ints, a standard deviation is performed over
  3285|         0|            0|            0|  0.00%|        multiple axes, instead of a single axis or all the axes as before.
  3286|         0|            0|            0|  0.00%|    dtype : dtype, optional
  3287|         0|            0|            0|  0.00%|        Type to use in computing the standard deviation. For arrays of
  3288|         0|            0|            0|  0.00%|        integer type the default is float64, for arrays of float types it is
  3289|         0|            0|            0|  0.00%|        the same as the array type.
  3290|         0|            0|            0|  0.00%|    out : ndarray, optional
  3291|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must have
  3292|         0|            0|            0|  0.00%|        the same shape as the expected output but the type (of the calculated
  3293|         0|            0|            0|  0.00%|        values) will be cast if necessary.
  3294|         0|            0|            0|  0.00%|    ddof : int, optional
  3295|         0|            0|            0|  0.00%|        Means Delta Degrees of Freedom.  The divisor used in calculations
  3296|         0|            0|            0|  0.00%|        is ``N - ddof``, where ``N`` represents the number of elements.
  3297|         0|            0|            0|  0.00%|        By default `ddof` is zero.
  3298|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3299|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3300|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3301|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3302|         0|            0|            0|  0.00%|
  3303|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3304|         0|            0|            0|  0.00%|        passed through to the `std` method of sub-classes of
  3305|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3306|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3307|         0|            0|            0|  0.00%|        exceptions will be raised.
  3308|         0|            0|            0|  0.00%|
  3309|         0|            0|            0|  0.00%|    Returns
  3310|         0|            0|            0|  0.00%|    -------
  3311|         0|            0|            0|  0.00%|    standard_deviation : ndarray, see dtype parameter above.
  3312|         0|            0|            0|  0.00%|        If `out` is None, return a new array containing the standard deviation,
  3313|         0|            0|            0|  0.00%|        otherwise return a reference to the output array.
  3314|         0|            0|            0|  0.00%|
  3315|         0|            0|            0|  0.00%|    See Also
  3316|         0|            0|            0|  0.00%|    --------
  3317|         0|            0|            0|  0.00%|    var, mean, nanmean, nanstd, nanvar
  3318|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  3319|         0|            0|            0|  0.00%|
  3320|         0|            0|            0|  0.00%|    Notes
  3321|         0|            0|            0|  0.00%|    -----
  3322|         0|            0|            0|  0.00%|    The standard deviation is the square root of the average of the squared
  3323|         0|            0|            0|  0.00%|    deviations from the mean, i.e., ``std = sqrt(mean(abs(x - x.mean())**2))``.
  3324|         0|            0|            0|  0.00%|
  3325|         0|            0|            0|  0.00%|    The average squared deviation is normally calculated as
  3326|         0|            0|            0|  0.00%|    ``x.sum() / N``, where ``N = len(x)``.  If, however, `ddof` is specified,
  3327|         0|            0|            0|  0.00%|    the divisor ``N - ddof`` is used instead. In standard statistical
  3328|         0|            0|            0|  0.00%|    practice, ``ddof=1`` provides an unbiased estimator of the variance
  3329|         0|            0|            0|  0.00%|    of the infinite population. ``ddof=0`` provides a maximum likelihood
  3330|         0|            0|            0|  0.00%|    estimate of the variance for normally distributed variables. The
  3331|         0|            0|            0|  0.00%|    standard deviation computed in this function is the square root of
  3332|         0|            0|            0|  0.00%|    the estimated variance, so even with ``ddof=1``, it will not be an
  3333|         0|            0|            0|  0.00%|    unbiased estimate of the standard deviation per se.
  3334|         0|            0|            0|  0.00%|
  3335|         0|            0|            0|  0.00%|    Note that, for complex numbers, `std` takes the absolute
  3336|         0|            0|            0|  0.00%|    value before squaring, so that the result is always real and nonnegative.
  3337|         0|            0|            0|  0.00%|
  3338|         0|            0|            0|  0.00%|    For floating-point input, the *std* is computed using the same
  3339|         0|            0|            0|  0.00%|    precision the input has. Depending on the input data, this can cause
  3340|         0|            0|            0|  0.00%|    the results to be inaccurate, especially for float32 (see example below).
  3341|         0|            0|            0|  0.00%|    Specifying a higher-accuracy accumulator using the `dtype` keyword can
  3342|         0|            0|            0|  0.00%|    alleviate this issue.
  3343|         0|            0|            0|  0.00%|
  3344|         0|            0|            0|  0.00%|    Examples
  3345|         0|            0|            0|  0.00%|    --------
  3346|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3347|         0|            0|            0|  0.00%|    >>> np.std(a)
  3348|         0|            0|            0|  0.00%|    1.1180339887498949 # may vary
  3349|         0|            0|            0|  0.00%|    >>> np.std(a, axis=0)
  3350|         0|            0|            0|  0.00%|    array([1.,  1.])
  3351|         0|            0|            0|  0.00%|    >>> np.std(a, axis=1)
  3352|         0|            0|            0|  0.00%|    array([0.5,  0.5])
  3353|         0|            0|            0|  0.00%|
  3354|         0|            0|            0|  0.00%|    In single precision, std() can be inaccurate:
  3355|         0|            0|            0|  0.00%|
  3356|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3357|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3358|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3359|         0|            0|            0|  0.00%|    >>> np.std(a)
  3360|         0|            0|            0|  0.00%|    0.45000005
  3361|         0|            0|            0|  0.00%|
  3362|         0|            0|            0|  0.00%|    Computing the standard deviation in float64 is more accurate:
  3363|         0|            0|            0|  0.00%|
  3364|         0|            0|            0|  0.00%|    >>> np.std(a, dtype=np.float64)
  3365|         0|            0|            0|  0.00%|    0.44999999925494177 # may vary
  3366|         0|            0|            0|  0.00%|
  3367|         0|            0|            0|  0.00%|    """
  3368|         0|            0|            0|  0.00%|    kwargs = {}
  3369|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  3370|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3371|         0|            0|            0|  0.00%|
  3372|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  3373|         0|            0|            0|  0.00%|        try:
  3374|         0|            0|            0|  0.00%|            std = a.std
  3375|         0|            0|            0|  0.00%|        except AttributeError:
  3376|         0|            0|            0|  0.00%|            pass
  3377|         0|            0|            0|  0.00%|        else:
  3378|         0|            0|            0|  0.00%|            return std(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)
  3379|         0|            0|            0|  0.00%|
  3380|         0|            0|            0|  0.00%|    return _methods._std(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
  3381|         0|            0|            0|  0.00%|                         **kwargs)
  3382|         0|            0|            0|  0.00%|
  3383|         0|            0|            0|  0.00%|
  3384|         0|            0|            0|  0.00%|def _var_dispatcher(
  3385|         0|            0|            0|  0.00%|        a, axis=None, dtype=None, out=None, ddof=None, keepdims=None):
  3386|         0|            0|            0|  0.00%|    return (a, out)
  3387|         0|            0|            0|  0.00%|
  3388|         0|            0|            0|  0.00%|
  3389|         0|            0|            0|  0.00%|@array_function_dispatch(_var_dispatcher)
  3390|         0|            0|            0|  0.00%|def var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=np._NoValue):
  3391|         0|            0|            0|  0.00%|    """
  3392|         0|            0|            0|  0.00%|    Compute the variance along the specified axis.
  3393|         0|            0|            0|  0.00%|
  3394|         0|            0|            0|  0.00%|    Returns the variance of the array elements, a measure of the spread of a
  3395|         0|            0|            0|  0.00%|    distribution.  The variance is computed for the flattened array by
  3396|         0|            0|            0|  0.00%|    default, otherwise over the specified axis.
  3397|         0|            0|            0|  0.00%|
  3398|         0|            0|            0|  0.00%|    Parameters
  3399|         0|            0|            0|  0.00%|    ----------
  3400|         0|            0|            0|  0.00%|    a : array_like
  3401|         0|            0|            0|  0.00%|        Array containing numbers whose variance is desired.  If `a` is not an
  3402|         0|            0|            0|  0.00%|        array, a conversion is attempted.
  3403|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
  3404|         0|            0|            0|  0.00%|        Axis or axes along which the variance is computed.  The default is to
  3405|         0|            0|            0|  0.00%|        compute the variance of the flattened array.
  3406|         0|            0|            0|  0.00%|
  3407|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  3408|         0|            0|            0|  0.00%|
  3409|         0|            0|            0|  0.00%|        If this is a tuple of ints, a variance is performed over multiple axes,
  3410|         0|            0|            0|  0.00%|        instead of a single axis or all the axes as before.
  3411|         0|            0|            0|  0.00%|    dtype : data-type, optional
  3412|         0|            0|            0|  0.00%|        Type to use in computing the variance.  For arrays of integer type
  3413|         0|            0|            0|  0.00%|        the default is `float32`; for arrays of float types it is the same as
  3414|         0|            0|            0|  0.00%|        the array type.
  3415|         0|            0|            0|  0.00%|    out : ndarray, optional
  3416|         0|            0|            0|  0.00%|        Alternate output array in which to place the result.  It must have
  3417|         0|            0|            0|  0.00%|        the same shape as the expected output, but the type is cast if
  3418|         0|            0|            0|  0.00%|        necessary.
  3419|         0|            0|            0|  0.00%|    ddof : int, optional
  3420|         0|            0|            0|  0.00%|        "Delta Degrees of Freedom": the divisor used in the calculation is
  3421|         0|            0|            0|  0.00%|        ``N - ddof``, where ``N`` represents the number of elements. By
  3422|         0|            0|            0|  0.00%|        default `ddof` is zero.
  3423|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3424|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3425|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3426|         0|            0|            0|  0.00%|        the result will broadcast correctly against the input array.
  3427|         0|            0|            0|  0.00%|
  3428|         0|            0|            0|  0.00%|        If the default value is passed, then `keepdims` will not be
  3429|         0|            0|            0|  0.00%|        passed through to the `var` method of sub-classes of
  3430|         0|            0|            0|  0.00%|        `ndarray`, however any non-default value will be.  If the
  3431|         0|            0|            0|  0.00%|        sub-class' method does not implement `keepdims` any
  3432|         0|            0|            0|  0.00%|        exceptions will be raised.
  3433|         0|            0|            0|  0.00%|
  3434|         0|            0|            0|  0.00%|    Returns
  3435|         0|            0|            0|  0.00%|    -------
  3436|         0|            0|            0|  0.00%|    variance : ndarray, see dtype parameter above
  3437|         0|            0|            0|  0.00%|        If ``out=None``, returns a new array containing the variance;
  3438|         0|            0|            0|  0.00%|        otherwise, a reference to the output array is returned.
  3439|         0|            0|            0|  0.00%|
  3440|         0|            0|            0|  0.00%|    See Also
  3441|         0|            0|            0|  0.00%|    --------
  3442|         0|            0|            0|  0.00%|    std, mean, nanmean, nanstd, nanvar
  3443|         0|            0|            0|  0.00%|    numpy.doc.ufuncs : Section "Output arguments"
  3444|         0|            0|            0|  0.00%|
  3445|         0|            0|            0|  0.00%|    Notes
  3446|         0|            0|            0|  0.00%|    -----
  3447|         0|            0|            0|  0.00%|    The variance is the average of the squared deviations from the mean,
  3448|         0|            0|            0|  0.00%|    i.e.,  ``var = mean(abs(x - x.mean())**2)``.
  3449|         0|            0|            0|  0.00%|
  3450|         0|            0|            0|  0.00%|    The mean is normally calculated as ``x.sum() / N``, where ``N = len(x)``.
  3451|         0|            0|            0|  0.00%|    If, however, `ddof` is specified, the divisor ``N - ddof`` is used
  3452|         0|            0|            0|  0.00%|    instead.  In standard statistical practice, ``ddof=1`` provides an
  3453|         0|            0|            0|  0.00%|    unbiased estimator of the variance of a hypothetical infinite population.
  3454|         0|            0|            0|  0.00%|    ``ddof=0`` provides a maximum likelihood estimate of the variance for
  3455|         0|            0|            0|  0.00%|    normally distributed variables.
  3456|         0|            0|            0|  0.00%|
  3457|         0|            0|            0|  0.00%|    Note that for complex numbers, the absolute value is taken before
  3458|         0|            0|            0|  0.00%|    squaring, so that the result is always real and nonnegative.
  3459|         0|            0|            0|  0.00%|
  3460|         0|            0|            0|  0.00%|    For floating-point input, the variance is computed using the same
  3461|         0|            0|            0|  0.00%|    precision the input has.  Depending on the input data, this can cause
  3462|         0|            0|            0|  0.00%|    the results to be inaccurate, especially for `float32` (see example
  3463|         0|            0|            0|  0.00%|    below).  Specifying a higher-accuracy accumulator using the ``dtype``
  3464|         0|            0|            0|  0.00%|    keyword can alleviate this issue.
  3465|         0|            0|            0|  0.00%|
  3466|         0|            0|            0|  0.00%|    Examples
  3467|         0|            0|            0|  0.00%|    --------
  3468|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2], [3, 4]])
  3469|         0|            0|            0|  0.00%|    >>> np.var(a)
  3470|         0|            0|            0|  0.00%|    1.25
  3471|         0|            0|            0|  0.00%|    >>> np.var(a, axis=0)
  3472|         0|            0|            0|  0.00%|    array([1.,  1.])
  3473|         0|            0|            0|  0.00%|    >>> np.var(a, axis=1)
  3474|         0|            0|            0|  0.00%|    array([0.25,  0.25])
  3475|         0|            0|            0|  0.00%|
  3476|         0|            0|            0|  0.00%|    In single precision, var() can be inaccurate:
  3477|         0|            0|            0|  0.00%|
  3478|         0|            0|            0|  0.00%|    >>> a = np.zeros((2, 512*512), dtype=np.float32)
  3479|         0|            0|            0|  0.00%|    >>> a[0, :] = 1.0
  3480|         0|            0|            0|  0.00%|    >>> a[1, :] = 0.1
  3481|         0|            0|            0|  0.00%|    >>> np.var(a)
  3482|         0|            0|            0|  0.00%|    0.20250003
  3483|         0|            0|            0|  0.00%|
  3484|         0|            0|            0|  0.00%|    Computing the variance in float64 is more accurate:
  3485|         0|            0|            0|  0.00%|
  3486|         0|            0|            0|  0.00%|    >>> np.var(a, dtype=np.float64)
  3487|         0|            0|            0|  0.00%|    0.20249999932944759 # may vary
  3488|         0|            0|            0|  0.00%|    >>> ((1-0.55)**2 + (0.1-0.55)**2)/2
  3489|         0|            0|            0|  0.00%|    0.2025
  3490|         0|            0|            0|  0.00%|
  3491|         0|            0|            0|  0.00%|    """
  3492|         0|            0|            0|  0.00%|    kwargs = {}
  3493|         0|            0|            0|  0.00%|    if keepdims is not np._NoValue:
  3494|         0|            0|            0|  0.00%|        kwargs['keepdims'] = keepdims
  3495|         0|            0|            0|  0.00%|
  3496|         0|            0|            0|  0.00%|    if type(a) is not mu.ndarray:
  3497|         0|            0|            0|  0.00%|        try:
  3498|         0|            0|            0|  0.00%|            var = a.var
  3499|         0|            0|            0|  0.00%|
  3500|         0|            0|            0|  0.00%|        except AttributeError:
  3501|         0|            0|            0|  0.00%|            pass
  3502|         0|            0|            0|  0.00%|        else:
  3503|         0|            0|            0|  0.00%|            return var(axis=axis, dtype=dtype, out=out, ddof=ddof, **kwargs)
  3504|         0|            0|            0|  0.00%|
  3505|         0|            0|            0|  0.00%|    return _methods._var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
  3506|         0|            0|            0|  0.00%|                         **kwargs)
  3507|         0|            0|            0|  0.00%|
  3508|         0|            0|            0|  0.00%|
  3509|         0|            0|            0|  0.00%|# Aliases of other functions. These have their own definitions only so that
  3510|         0|            0|            0|  0.00%|# they can have unique docstrings.
  3511|         0|            0|            0|  0.00%|
  3512|         2|  4.76837e-06|  2.38419e-06|  0.00%|@array_function_dispatch(_around_dispatcher)
  3513|         0|            0|            0|  0.00%|def round_(a, decimals=0, out=None):
  3514|         0|            0|            0|  0.00%|    """
  3515|         0|            0|            0|  0.00%|    Round an array to the given number of decimals.
  3516|         0|            0|            0|  0.00%|
  3517|         0|            0|            0|  0.00%|    See Also
  3518|         0|            0|            0|  0.00%|    --------
  3519|         0|            0|            0|  0.00%|    around : equivalent function; see for details.
  3520|         0|            0|            0|  0.00%|    """
  3521|         2|  1.85966e-05|  9.29832e-06|  0.00%|    return around(a, decimals=decimals, out=out)
(call)|         2|  0.000251532|  0.000125766|  0.00%|# <__array_function__ internals>_9:2 around
  3522|         0|            0|            0|  0.00%|
  3523|         0|            0|            0|  0.00%|
  3524|         0|            0|            0|  0.00%|@array_function_dispatch(_prod_dispatcher, verify=False)
  3525|         0|            0|            0|  0.00%|def product(*args, **kwargs):
  3526|         0|            0|            0|  0.00%|    """
  3527|         0|            0|            0|  0.00%|    Return the product of array elements over a given axis.
  3528|         0|            0|            0|  0.00%|
  3529|         0|            0|            0|  0.00%|    See Also
  3530|         0|            0|            0|  0.00%|    --------
  3531|         0|            0|            0|  0.00%|    prod : equivalent function; see for details.
  3532|         0|            0|            0|  0.00%|    """
  3533|         0|            0|            0|  0.00%|    return prod(*args, **kwargs)
  3534|         0|            0|            0|  0.00%|
  3535|         0|            0|            0|  0.00%|
  3536|         0|            0|            0|  0.00%|@array_function_dispatch(_cumprod_dispatcher, verify=False)
  3537|         0|            0|            0|  0.00%|def cumproduct(*args, **kwargs):
  3538|         0|            0|            0|  0.00%|    """
  3539|         0|            0|            0|  0.00%|    Return the cumulative product over the given axis.
  3540|         0|            0|            0|  0.00%|
  3541|         0|            0|            0|  0.00%|    See Also
  3542|         0|            0|            0|  0.00%|    --------
  3543|         0|            0|            0|  0.00%|    cumprod : equivalent function; see for details.
  3544|         0|            0|            0|  0.00%|    """
  3545|         0|            0|            0|  0.00%|    return cumprod(*args, **kwargs)
  3546|         0|            0|            0|  0.00%|
  3547|         0|            0|            0|  0.00%|
  3548|         0|            0|            0|  0.00%|@array_function_dispatch(_any_dispatcher, verify=False)
  3549|         0|            0|            0|  0.00%|def sometrue(*args, **kwargs):
  3550|         0|            0|            0|  0.00%|    """
  3551|         0|            0|            0|  0.00%|    Check whether some values are true.
  3552|         0|            0|            0|  0.00%|
  3553|         0|            0|            0|  0.00%|    Refer to `any` for full documentation.
  3554|         0|            0|            0|  0.00%|
  3555|         0|            0|            0|  0.00%|    See Also
  3556|         0|            0|            0|  0.00%|    --------
  3557|         0|            0|            0|  0.00%|    any : equivalent function; see for details.
  3558|         0|            0|            0|  0.00%|    """
  3559|         0|            0|            0|  0.00%|    return any(*args, **kwargs)
  3560|         0|            0|            0|  0.00%|
  3561|         0|            0|            0|  0.00%|
  3562|         0|            0|            0|  0.00%|@array_function_dispatch(_all_dispatcher, verify=False)
  3563|         0|            0|            0|  0.00%|def alltrue(*args, **kwargs):
  3564|         0|            0|            0|  0.00%|    """
  3565|         0|            0|            0|  0.00%|    Check if all elements of input array are true.
  3566|         0|            0|            0|  0.00%|
  3567|         0|            0|            0|  0.00%|    See Also
  3568|         0|            0|            0|  0.00%|    --------
  3569|         0|            0|            0|  0.00%|    numpy.all : Equivalent function; see for details.
  3570|         0|            0|            0|  0.00%|    """
  3571|         0|            0|            0|  0.00%|    return all(*args, **kwargs)
  3572|         0|            0|            0|  0.00%|
  3573|         0|            0|            0|  0.00%|
  3574|         0|            0|            0|  0.00%|@array_function_dispatch(_ndim_dispatcher)
  3575|         0|            0|            0|  0.00%|def rank(a):
  3576|         0|            0|            0|  0.00%|    """
  3577|         0|            0|            0|  0.00%|    Return the number of dimensions of an array.
  3578|         0|            0|            0|  0.00%|
  3579|         0|            0|            0|  0.00%|    .. note::
  3580|         0|            0|            0|  0.00%|        This function is deprecated in NumPy 1.9 to avoid confusion with
  3581|         0|            0|            0|  0.00%|        `numpy.linalg.matrix_rank`. The ``ndim`` attribute or function
  3582|         0|            0|            0|  0.00%|        should be used instead.
  3583|         0|            0|            0|  0.00%|
  3584|         0|            0|            0|  0.00%|    See Also
  3585|         0|            0|            0|  0.00%|    --------
  3586|         0|            0|            0|  0.00%|    ndim : equivalent non-deprecated function
  3587|         0|            0|            0|  0.00%|
  3588|         0|            0|            0|  0.00%|    Notes
  3589|         0|            0|            0|  0.00%|    -----
  3590|         0|            0|            0|  0.00%|    In the old Numeric package, `rank` was the term used for the number of
  3591|         0|            0|            0|  0.00%|    dimensions, but in NumPy `ndim` is used instead.
  3592|         0|            0|            0|  0.00%|    """
  3593|         0|            0|            0|  0.00%|    # 2014-04-12, 1.9
  3594|         0|            0|            0|  0.00%|    warnings.warn(
  3595|         0|            0|            0|  0.00%|        "`rank` is deprecated; use the `ndim` attribute or function instead. "
  3596|         0|            0|            0|  0.00%|        "To find the rank of a matrix see `numpy.linalg.matrix_rank`.",
  3597|         0|            0|            0|  0.00%|        VisibleDeprecationWarning, stacklevel=3)
  3598|         0|            0|            0|  0.00%|    return ndim(a)
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/function_base.py
File duration: 0.000456095s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import functools
     4|         0|            0|            0|  0.00%|import warnings
     5|         0|            0|            0|  0.00%|import operator
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|from . import numeric as _nx
     8|         0|            0|            0|  0.00%|from .numeric import (result_type, NaN, shares_memory, MAY_SHARE_BOUNDS,
     9|         0|            0|            0|  0.00%|                      TooHardError, asanyarray, ndim)
    10|         0|            0|            0|  0.00%|from numpy.core.multiarray import add_docstring
    11|         0|            0|            0|  0.00%|from numpy.core import overrides
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|__all__ = ['logspace', 'linspace', 'geomspace']
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|
    16|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    17|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|
    20|         1|  6.19888e-06|  6.19888e-06|  0.00%|def _index_deprecate(i, stacklevel=2):
    21|         1|  4.05312e-06|  4.05312e-06|  0.00%|    try:
    22|         1|  5.00679e-06|  5.00679e-06|  0.00%|        i = operator.index(i)
    23|         0|            0|            0|  0.00%|    except TypeError:
    24|         0|            0|            0|  0.00%|        msg = ("object of type {} cannot be safely interpreted as "
    25|         0|            0|            0|  0.00%|               "an integer.".format(type(i)))
    26|         0|            0|            0|  0.00%|        i = int(i)
    27|         0|            0|            0|  0.00%|        stacklevel += 1
    28|         0|            0|            0|  0.00%|        warnings.warn(msg, DeprecationWarning, stacklevel=stacklevel)
    29|         1|   3.8147e-06|   3.8147e-06|  0.00%|    return i
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|
    32|         1|  4.76837e-06|  4.76837e-06|  0.00%|def _linspace_dispatcher(start, stop, num=None, endpoint=None, retstep=None,
    33|         0|            0|            0|  0.00%|                         dtype=None, axis=None):
    34|         1|  1.07288e-05|  1.07288e-05|  0.00%|    return (start, stop)
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|
    37|         1|  1.04904e-05|  1.04904e-05|  0.00%|@array_function_dispatch(_linspace_dispatcher)
    38|         0|            0|            0|  0.00%|def linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None,
    39|         0|            0|            0|  0.00%|             axis=0):
    40|         0|            0|            0|  0.00%|    """
    41|         0|            0|            0|  0.00%|    Return evenly spaced numbers over a specified interval.
    42|         0|            0|            0|  0.00%|
    43|         0|            0|            0|  0.00%|    Returns `num` evenly spaced samples, calculated over the
    44|         0|            0|            0|  0.00%|    interval [`start`, `stop`].
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|    The endpoint of the interval can optionally be excluded.
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|    .. versionchanged:: 1.16.0
    49|         0|            0|            0|  0.00%|        Non-scalar `start` and `stop` are now supported.
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|    Parameters
    52|         0|            0|            0|  0.00%|    ----------
    53|         0|            0|            0|  0.00%|    start : array_like
    54|         0|            0|            0|  0.00%|        The starting value of the sequence.
    55|         0|            0|            0|  0.00%|    stop : array_like
    56|         0|            0|            0|  0.00%|        The end value of the sequence, unless `endpoint` is set to False.
    57|         0|            0|            0|  0.00%|        In that case, the sequence consists of all but the last of ``num + 1``
    58|         0|            0|            0|  0.00%|        evenly spaced samples, so that `stop` is excluded.  Note that the step
    59|         0|            0|            0|  0.00%|        size changes when `endpoint` is False.
    60|         0|            0|            0|  0.00%|    num : int, optional
    61|         0|            0|            0|  0.00%|        Number of samples to generate. Default is 50. Must be non-negative.
    62|         0|            0|            0|  0.00%|    endpoint : bool, optional
    63|         0|            0|            0|  0.00%|        If True, `stop` is the last sample. Otherwise, it is not included.
    64|         0|            0|            0|  0.00%|        Default is True.
    65|         0|            0|            0|  0.00%|    retstep : bool, optional
    66|         0|            0|            0|  0.00%|        If True, return (`samples`, `step`), where `step` is the spacing
    67|         0|            0|            0|  0.00%|        between samples.
    68|         0|            0|            0|  0.00%|    dtype : dtype, optional
    69|         0|            0|            0|  0.00%|        The type of the output array.  If `dtype` is not given, infer the data
    70|         0|            0|            0|  0.00%|        type from the other input arguments.
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
    73|         0|            0|            0|  0.00%|
    74|         0|            0|            0|  0.00%|    axis : int, optional
    75|         0|            0|            0|  0.00%|        The axis in the result to store the samples.  Relevant only if start
    76|         0|            0|            0|  0.00%|        or stop are array-like.  By default (0), the samples will be along a
    77|         0|            0|            0|  0.00%|        new axis inserted at the beginning. Use -1 to get an axis at the end.
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|        .. versionadded:: 1.16.0
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    Returns
    82|         0|            0|            0|  0.00%|    -------
    83|         0|            0|            0|  0.00%|    samples : ndarray
    84|         0|            0|            0|  0.00%|        There are `num` equally spaced samples in the closed interval
    85|         0|            0|            0|  0.00%|        ``[start, stop]`` or the half-open interval ``[start, stop)``
    86|         0|            0|            0|  0.00%|        (depending on whether `endpoint` is True or False).
    87|         0|            0|            0|  0.00%|    step : float, optional
    88|         0|            0|            0|  0.00%|        Only returned if `retstep` is True
    89|         0|            0|            0|  0.00%|
    90|         0|            0|            0|  0.00%|        Size of spacing between samples.
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|    See Also
    94|         0|            0|            0|  0.00%|    --------
    95|         0|            0|            0|  0.00%|    arange : Similar to `linspace`, but uses a step size (instead of the
    96|         0|            0|            0|  0.00%|             number of samples).
    97|         0|            0|            0|  0.00%|    geomspace : Similar to `linspace`, but with numbers spaced evenly on a log
    98|         0|            0|            0|  0.00%|                scale (a geometric progression).
    99|         0|            0|            0|  0.00%|    logspace : Similar to `geomspace`, but with the end points specified as
   100|         0|            0|            0|  0.00%|               logarithms.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    Examples
   103|         0|            0|            0|  0.00%|    --------
   104|         0|            0|            0|  0.00%|    >>> np.linspace(2.0, 3.0, num=5)
   105|         0|            0|            0|  0.00%|    array([2.  , 2.25, 2.5 , 2.75, 3.  ])
   106|         0|            0|            0|  0.00%|    >>> np.linspace(2.0, 3.0, num=5, endpoint=False)
   107|         0|            0|            0|  0.00%|    array([2. ,  2.2,  2.4,  2.6,  2.8])
   108|         0|            0|            0|  0.00%|    >>> np.linspace(2.0, 3.0, num=5, retstep=True)
   109|         0|            0|            0|  0.00%|    (array([2.  ,  2.25,  2.5 ,  2.75,  3.  ]), 0.25)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|    Graphical illustration:
   112|         0|            0|            0|  0.00%|
   113|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
   114|         0|            0|            0|  0.00%|    >>> N = 8
   115|         0|            0|            0|  0.00%|    >>> y = np.zeros(N)
   116|         0|            0|            0|  0.00%|    >>> x1 = np.linspace(0, 10, N, endpoint=True)
   117|         0|            0|            0|  0.00%|    >>> x2 = np.linspace(0, 10, N, endpoint=False)
   118|         0|            0|            0|  0.00%|    >>> plt.plot(x1, y, 'o')
   119|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   120|         0|            0|            0|  0.00%|    >>> plt.plot(x2, y + 0.5, 'o')
   121|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   122|         0|            0|            0|  0.00%|    >>> plt.ylim([-0.5, 1])
   123|         0|            0|            0|  0.00%|    (-0.5, 1)
   124|         0|            0|            0|  0.00%|    >>> plt.show()
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    """
   127|         0|            0|            0|  0.00%|    # 2016-02-25, 1.12
   128|         1|   1.4782e-05|   1.4782e-05|  0.00%|    num = _index_deprecate(num)
(call)|         1|  1.90735e-05|  1.90735e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/function_base.py:20 _index_deprecate
   129|         1|  5.24521e-06|  5.24521e-06|  0.00%|    if num < 0:
   130|         0|            0|            0|  0.00%|        raise ValueError("Number of samples, %s, must be non-negative." % num)
   131|         1|  5.00679e-06|  5.00679e-06|  0.00%|    div = (num - 1) if endpoint else num
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    # Convert float/complex array scalars to float, gh-3504
   134|         0|            0|            0|  0.00%|    # and make sure one can use variables that have an __array_interface__, gh-6634
   135|         1|  3.57628e-05|  3.57628e-05|  0.00%|    start = asanyarray(start) * 1.0
(call)|         1|  2.47955e-05|  2.47955e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
   136|         1|  2.64645e-05|  2.64645e-05|  0.00%|    stop  = asanyarray(stop)  * 1.0
(call)|         1|  7.62939e-06|  7.62939e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
   137|         0|            0|            0|  0.00%|
   138|         1|  2.21729e-05|  2.21729e-05|  0.00%|    dt = result_type(start, stop, float(num))
(call)|         1|  5.10216e-05|  5.10216e-05|  0.00%|# <__array_function__ internals>_0:2 result_type
   139|         1|  5.24521e-06|  5.24521e-06|  0.00%|    if dtype is None:
   140|         1|  1.23978e-05|  1.23978e-05|  0.00%|        dtype = dt
   141|         0|            0|            0|  0.00%|
   142|         1|  0.000123739|  0.000123739|  0.00%|    delta = stop - start
   143|         1|  3.62396e-05|  3.62396e-05|  0.00%|    y = _nx.arange(0, num, dtype=dt).reshape((-1,) + (1,) * ndim(delta))
(call)|         1|  6.69956e-05|  6.69956e-05|  0.00%|# <__array_function__ internals>_1:2 ndim
   144|         0|            0|            0|  0.00%|    # In-place multiplication y *= delta/div is faster, but prevents the multiplicant
   145|         0|            0|            0|  0.00%|    # from overriding what class is produced, and thus prevents, e.g. use of Quantities,
   146|         0|            0|            0|  0.00%|    # see gh-7142. Hence, we multiply in place only for standard scalar types.
   147|         1|   1.7643e-05|   1.7643e-05|  0.00%|    _mult_inplace = _nx.isscalar(delta)
(call)|         1|  1.74046e-05|  1.74046e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1782 isscalar
   148|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if num > 1:
   149|         1|  6.67572e-06|  6.67572e-06|  0.00%|        step = delta / div
   150|         1|  2.00272e-05|  2.00272e-05|  0.00%|        if _nx.any(step == 0):
(call)|         1|  0.000172377|  0.000172377|  0.00%|# <__array_function__ internals>_2:2 any
   151|         0|            0|            0|  0.00%|            # Special handling for denormal numbers, gh-5437
   152|         0|            0|            0|  0.00%|            y /= div
   153|         0|            0|            0|  0.00%|            if _mult_inplace:
   154|         0|            0|            0|  0.00%|                y *= delta
   155|         0|            0|            0|  0.00%|            else:
   156|         0|            0|            0|  0.00%|                y = y * delta
   157|         0|            0|            0|  0.00%|        else:
   158|         1|  4.76837e-06|  4.76837e-06|  0.00%|            if _mult_inplace:
   159|         1|  2.74181e-05|  2.74181e-05|  0.00%|                y *= step
   160|         0|            0|            0|  0.00%|            else:
   161|         0|            0|            0|  0.00%|                y = y * step
   162|         0|            0|            0|  0.00%|    else:
   163|         0|            0|            0|  0.00%|        # 0 and 1 item long sequences have an undefined step
   164|         0|            0|            0|  0.00%|        step = NaN
   165|         0|            0|            0|  0.00%|        # Multiply with delta to allow possible override of output class.
   166|         0|            0|            0|  0.00%|        y = y * delta
   167|         0|            0|            0|  0.00%|
   168|         1|   1.3113e-05|   1.3113e-05|  0.00%|    y += start
   169|         0|            0|            0|  0.00%|
   170|         1|  7.15256e-06|  7.15256e-06|  0.00%|    if endpoint and num > 1:
   171|         1|  5.96046e-06|  5.96046e-06|  0.00%|        y[-1] = stop
   172|         0|            0|            0|  0.00%|
   173|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if axis != 0:
   174|         0|            0|            0|  0.00%|        y = _nx.moveaxis(y, 0, axis)
   175|         0|            0|            0|  0.00%|
   176|         1|  4.29153e-06|  4.29153e-06|  0.00%|    if retstep:
   177|         0|            0|            0|  0.00%|        return y.astype(dtype, copy=False), step
   178|         0|            0|            0|  0.00%|    else:
   179|         1|  8.34465e-06|  8.34465e-06|  0.00%|        return y.astype(dtype, copy=False)
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|def _logspace_dispatcher(start, stop, num=None, endpoint=None, base=None,
   183|         0|            0|            0|  0.00%|                         dtype=None, axis=None):
   184|         0|            0|            0|  0.00%|    return (start, stop)
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|@array_function_dispatch(_logspace_dispatcher)
   188|         0|            0|            0|  0.00%|def logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None,
   189|         0|            0|            0|  0.00%|             axis=0):
   190|         0|            0|            0|  0.00%|    """
   191|         0|            0|            0|  0.00%|    Return numbers spaced evenly on a log scale.
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    In linear space, the sequence starts at ``base ** start``
   194|         0|            0|            0|  0.00%|    (`base` to the power of `start`) and ends with ``base ** stop``
   195|         0|            0|            0|  0.00%|    (see `endpoint` below).
   196|         0|            0|            0|  0.00%|
   197|         0|            0|            0|  0.00%|    .. versionchanged:: 1.16.0
   198|         0|            0|            0|  0.00%|        Non-scalar `start` and `stop` are now supported.
   199|         0|            0|            0|  0.00%|
   200|         0|            0|            0|  0.00%|    Parameters
   201|         0|            0|            0|  0.00%|    ----------
   202|         0|            0|            0|  0.00%|    start : array_like
   203|         0|            0|            0|  0.00%|        ``base ** start`` is the starting value of the sequence.
   204|         0|            0|            0|  0.00%|    stop : array_like
   205|         0|            0|            0|  0.00%|        ``base ** stop`` is the final value of the sequence, unless `endpoint`
   206|         0|            0|            0|  0.00%|        is False.  In that case, ``num + 1`` values are spaced over the
   207|         0|            0|            0|  0.00%|        interval in log-space, of which all but the last (a sequence of
   208|         0|            0|            0|  0.00%|        length `num`) are returned.
   209|         0|            0|            0|  0.00%|    num : integer, optional
   210|         0|            0|            0|  0.00%|        Number of samples to generate.  Default is 50.
   211|         0|            0|            0|  0.00%|    endpoint : boolean, optional
   212|         0|            0|            0|  0.00%|        If true, `stop` is the last sample. Otherwise, it is not included.
   213|         0|            0|            0|  0.00%|        Default is True.
   214|         0|            0|            0|  0.00%|    base : float, optional
   215|         0|            0|            0|  0.00%|        The base of the log space. The step size between the elements in
   216|         0|            0|            0|  0.00%|        ``ln(samples) / ln(base)`` (or ``log_base(samples)``) is uniform.
   217|         0|            0|            0|  0.00%|        Default is 10.0.
   218|         0|            0|            0|  0.00%|    dtype : dtype
   219|         0|            0|            0|  0.00%|        The type of the output array.  If `dtype` is not given, infer the data
   220|         0|            0|            0|  0.00%|        type from the other input arguments.
   221|         0|            0|            0|  0.00%|    axis : int, optional
   222|         0|            0|            0|  0.00%|        The axis in the result to store the samples.  Relevant only if start
   223|         0|            0|            0|  0.00%|        or stop are array-like.  By default (0), the samples will be along a
   224|         0|            0|            0|  0.00%|        new axis inserted at the beginning. Use -1 to get an axis at the end.
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|        .. versionadded:: 1.16.0
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|
   229|         0|            0|            0|  0.00%|    Returns
   230|         0|            0|            0|  0.00%|    -------
   231|         0|            0|            0|  0.00%|    samples : ndarray
   232|         0|            0|            0|  0.00%|        `num` samples, equally spaced on a log scale.
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|    See Also
   235|         0|            0|            0|  0.00%|    --------
   236|         0|            0|            0|  0.00%|    arange : Similar to linspace, with the step size specified instead of the
   237|         0|            0|            0|  0.00%|             number of samples. Note that, when used with a float endpoint, the
   238|         0|            0|            0|  0.00%|             endpoint may or may not be included.
   239|         0|            0|            0|  0.00%|    linspace : Similar to logspace, but with the samples uniformly distributed
   240|         0|            0|            0|  0.00%|               in linear space, instead of log space.
   241|         0|            0|            0|  0.00%|    geomspace : Similar to logspace, but with endpoints specified directly.
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|    Notes
   244|         0|            0|            0|  0.00%|    -----
   245|         0|            0|            0|  0.00%|    Logspace is equivalent to the code
   246|         0|            0|            0|  0.00%|
   247|         0|            0|            0|  0.00%|    >>> y = np.linspace(start, stop, num=num, endpoint=endpoint)
   248|         0|            0|            0|  0.00%|    ... # doctest: +SKIP
   249|         0|            0|            0|  0.00%|    >>> power(base, y).astype(dtype)
   250|         0|            0|            0|  0.00%|    ... # doctest: +SKIP
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    Examples
   253|         0|            0|            0|  0.00%|    --------
   254|         0|            0|            0|  0.00%|    >>> np.logspace(2.0, 3.0, num=4)
   255|         0|            0|            0|  0.00%|    array([ 100.        ,  215.443469  ,  464.15888336, 1000.        ])
   256|         0|            0|            0|  0.00%|    >>> np.logspace(2.0, 3.0, num=4, endpoint=False)
   257|         0|            0|            0|  0.00%|    array([100.        ,  177.827941  ,  316.22776602,  562.34132519])
   258|         0|            0|            0|  0.00%|    >>> np.logspace(2.0, 3.0, num=4, base=2.0)
   259|         0|            0|            0|  0.00%|    array([4.        ,  5.0396842 ,  6.34960421,  8.        ])
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    Graphical illustration:
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
   264|         0|            0|            0|  0.00%|    >>> N = 10
   265|         0|            0|            0|  0.00%|    >>> x1 = np.logspace(0.1, 1, N, endpoint=True)
   266|         0|            0|            0|  0.00%|    >>> x2 = np.logspace(0.1, 1, N, endpoint=False)
   267|         0|            0|            0|  0.00%|    >>> y = np.zeros(N)
   268|         0|            0|            0|  0.00%|    >>> plt.plot(x1, y, 'o')
   269|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   270|         0|            0|            0|  0.00%|    >>> plt.plot(x2, y + 0.5, 'o')
   271|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   272|         0|            0|            0|  0.00%|    >>> plt.ylim([-0.5, 1])
   273|         0|            0|            0|  0.00%|    (-0.5, 1)
   274|         0|            0|            0|  0.00%|    >>> plt.show()
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    """
   277|         0|            0|            0|  0.00%|    y = linspace(start, stop, num=num, endpoint=endpoint, axis=axis)
   278|         0|            0|            0|  0.00%|    if dtype is None:
   279|         0|            0|            0|  0.00%|        return _nx.power(base, y)
   280|         0|            0|            0|  0.00%|    return _nx.power(base, y).astype(dtype, copy=False)
   281|         0|            0|            0|  0.00%|
   282|         0|            0|            0|  0.00%|
   283|         0|            0|            0|  0.00%|def _geomspace_dispatcher(start, stop, num=None, endpoint=None, dtype=None,
   284|         0|            0|            0|  0.00%|                          axis=None):
   285|         0|            0|            0|  0.00%|    return (start, stop)
   286|         0|            0|            0|  0.00%|
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|@array_function_dispatch(_geomspace_dispatcher)
   289|         0|            0|            0|  0.00%|def geomspace(start, stop, num=50, endpoint=True, dtype=None, axis=0):
   290|         0|            0|            0|  0.00%|    """
   291|         0|            0|            0|  0.00%|    Return numbers spaced evenly on a log scale (a geometric progression).
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|    This is similar to `logspace`, but with endpoints specified directly.
   294|         0|            0|            0|  0.00%|    Each output sample is a constant multiple of the previous.
   295|         0|            0|            0|  0.00%|
   296|         0|            0|            0|  0.00%|    .. versionchanged:: 1.16.0
   297|         0|            0|            0|  0.00%|        Non-scalar `start` and `stop` are now supported.
   298|         0|            0|            0|  0.00%|
   299|         0|            0|            0|  0.00%|    Parameters
   300|         0|            0|            0|  0.00%|    ----------
   301|         0|            0|            0|  0.00%|    start : array_like
   302|         0|            0|            0|  0.00%|        The starting value of the sequence.
   303|         0|            0|            0|  0.00%|    stop : array_like
   304|         0|            0|            0|  0.00%|        The final value of the sequence, unless `endpoint` is False.
   305|         0|            0|            0|  0.00%|        In that case, ``num + 1`` values are spaced over the
   306|         0|            0|            0|  0.00%|        interval in log-space, of which all but the last (a sequence of
   307|         0|            0|            0|  0.00%|        length `num`) are returned.
   308|         0|            0|            0|  0.00%|    num : integer, optional
   309|         0|            0|            0|  0.00%|        Number of samples to generate.  Default is 50.
   310|         0|            0|            0|  0.00%|    endpoint : boolean, optional
   311|         0|            0|            0|  0.00%|        If true, `stop` is the last sample. Otherwise, it is not included.
   312|         0|            0|            0|  0.00%|        Default is True.
   313|         0|            0|            0|  0.00%|    dtype : dtype
   314|         0|            0|            0|  0.00%|        The type of the output array.  If `dtype` is not given, infer the data
   315|         0|            0|            0|  0.00%|        type from the other input arguments.
   316|         0|            0|            0|  0.00%|    axis : int, optional
   317|         0|            0|            0|  0.00%|        The axis in the result to store the samples.  Relevant only if start
   318|         0|            0|            0|  0.00%|        or stop are array-like.  By default (0), the samples will be along a
   319|         0|            0|            0|  0.00%|        new axis inserted at the beginning. Use -1 to get an axis at the end.
   320|         0|            0|            0|  0.00%|
   321|         0|            0|            0|  0.00%|        .. versionadded:: 1.16.0
   322|         0|            0|            0|  0.00%|
   323|         0|            0|            0|  0.00%|    Returns
   324|         0|            0|            0|  0.00%|    -------
   325|         0|            0|            0|  0.00%|    samples : ndarray
   326|         0|            0|            0|  0.00%|        `num` samples, equally spaced on a log scale.
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    See Also
   329|         0|            0|            0|  0.00%|    --------
   330|         0|            0|            0|  0.00%|    logspace : Similar to geomspace, but with endpoints specified using log
   331|         0|            0|            0|  0.00%|               and base.
   332|         0|            0|            0|  0.00%|    linspace : Similar to geomspace, but with arithmetic instead of geometric
   333|         0|            0|            0|  0.00%|               progression.
   334|         0|            0|            0|  0.00%|    arange : Similar to linspace, with the step size specified instead of the
   335|         0|            0|            0|  0.00%|             number of samples.
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|    Notes
   338|         0|            0|            0|  0.00%|    -----
   339|         0|            0|            0|  0.00%|    If the inputs or dtype are complex, the output will follow a logarithmic
   340|         0|            0|            0|  0.00%|    spiral in the complex plane.  (There are an infinite number of spirals
   341|         0|            0|            0|  0.00%|    passing through two points; the output will follow the shortest such path.)
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Examples
   344|         0|            0|            0|  0.00%|    --------
   345|         0|            0|            0|  0.00%|    >>> np.geomspace(1, 1000, num=4)
   346|         0|            0|            0|  0.00%|    array([    1.,    10.,   100.,  1000.])
   347|         0|            0|            0|  0.00%|    >>> np.geomspace(1, 1000, num=3, endpoint=False)
   348|         0|            0|            0|  0.00%|    array([   1.,   10.,  100.])
   349|         0|            0|            0|  0.00%|    >>> np.geomspace(1, 1000, num=4, endpoint=False)
   350|         0|            0|            0|  0.00%|    array([   1.        ,    5.62341325,   31.6227766 ,  177.827941  ])
   351|         0|            0|            0|  0.00%|    >>> np.geomspace(1, 256, num=9)
   352|         0|            0|            0|  0.00%|    array([   1.,    2.,    4.,    8.,   16.,   32.,   64.,  128.,  256.])
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    Note that the above may not produce exact integers:
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|    >>> np.geomspace(1, 256, num=9, dtype=int)
   357|         0|            0|            0|  0.00%|    array([  1,   2,   4,   7,  16,  32,  63, 127, 256])
   358|         0|            0|            0|  0.00%|    >>> np.around(np.geomspace(1, 256, num=9)).astype(int)
   359|         0|            0|            0|  0.00%|    array([  1,   2,   4,   8,  16,  32,  64, 128, 256])
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    Negative, decreasing, and complex inputs are allowed:
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    >>> np.geomspace(1000, 1, num=4)
   364|         0|            0|            0|  0.00%|    array([1000.,  100.,   10.,    1.])
   365|         0|            0|            0|  0.00%|    >>> np.geomspace(-1000, -1, num=4)
   366|         0|            0|            0|  0.00%|    array([-1000.,  -100.,   -10.,    -1.])
   367|         0|            0|            0|  0.00%|    >>> np.geomspace(1j, 1000j, num=4)  # Straight line
   368|         0|            0|            0|  0.00%|    array([0.   +1.j, 0.  +10.j, 0. +100.j, 0.+1000.j])
   369|         0|            0|            0|  0.00%|    >>> np.geomspace(-1+0j, 1+0j, num=5)  # Circle
   370|         0|            0|            0|  0.00%|    array([-1.00000000e+00+1.22464680e-16j, -7.07106781e-01+7.07106781e-01j,
   371|         0|            0|            0|  0.00%|            6.12323400e-17+1.00000000e+00j,  7.07106781e-01+7.07106781e-01j,
   372|         0|            0|            0|  0.00%|            1.00000000e+00+0.00000000e+00j])
   373|         0|            0|            0|  0.00%|
   374|         0|            0|            0|  0.00%|    Graphical illustration of ``endpoint`` parameter:
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
   377|         0|            0|            0|  0.00%|    >>> N = 10
   378|         0|            0|            0|  0.00%|    >>> y = np.zeros(N)
   379|         0|            0|            0|  0.00%|    >>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=True), y + 1, 'o')
   380|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   381|         0|            0|            0|  0.00%|    >>> plt.semilogx(np.geomspace(1, 1000, N, endpoint=False), y + 2, 'o')
   382|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
   383|         0|            0|            0|  0.00%|    >>> plt.axis([0.5, 2000, 0, 3])
   384|         0|            0|            0|  0.00%|    [0.5, 2000, 0, 3]
   385|         0|            0|            0|  0.00%|    >>> plt.grid(True, color='0.7', linestyle='-', which='both', axis='both')
   386|         0|            0|            0|  0.00%|    >>> plt.show()
   387|         0|            0|            0|  0.00%|
   388|         0|            0|            0|  0.00%|    """
   389|         0|            0|            0|  0.00%|    start = asanyarray(start)
   390|         0|            0|            0|  0.00%|    stop = asanyarray(stop)
   391|         0|            0|            0|  0.00%|    if _nx.any(start == 0) or _nx.any(stop == 0):
   392|         0|            0|            0|  0.00%|        raise ValueError('Geometric sequence cannot include zero')
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    dt = result_type(start, stop, float(num), _nx.zeros((), dtype))
   395|         0|            0|            0|  0.00%|    if dtype is None:
   396|         0|            0|            0|  0.00%|        dtype = dt
   397|         0|            0|            0|  0.00%|    else:
   398|         0|            0|            0|  0.00%|        # complex to dtype('complex128'), for instance
   399|         0|            0|            0|  0.00%|        dtype = _nx.dtype(dtype)
   400|         0|            0|            0|  0.00%|
   401|         0|            0|            0|  0.00%|    # Promote both arguments to the same dtype in case, for instance, one is
   402|         0|            0|            0|  0.00%|    # complex and another is negative and log would produce NaN otherwise.
   403|         0|            0|            0|  0.00%|    # Copy since we may change things in-place further down.
   404|         0|            0|            0|  0.00%|    start = start.astype(dt, copy=True)
   405|         0|            0|            0|  0.00%|    stop = stop.astype(dt, copy=True)
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|    out_sign = _nx.ones(_nx.broadcast(start, stop).shape, dt)
   408|         0|            0|            0|  0.00%|    # Avoid negligible real or imaginary parts in output by rotating to
   409|         0|            0|            0|  0.00%|    # positive real, calculating, then undoing rotation
   410|         0|            0|            0|  0.00%|    if _nx.issubdtype(dt, _nx.complexfloating):
   411|         0|            0|            0|  0.00%|        all_imag = (start.real == 0.) & (stop.real == 0.)
   412|         0|            0|            0|  0.00%|        if _nx.any(all_imag):
   413|         0|            0|            0|  0.00%|            start[all_imag] = start[all_imag].imag
   414|         0|            0|            0|  0.00%|            stop[all_imag] = stop[all_imag].imag
   415|         0|            0|            0|  0.00%|            out_sign[all_imag] = 1j
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|    both_negative = (_nx.sign(start) == -1) & (_nx.sign(stop) == -1)
   418|         0|            0|            0|  0.00%|    if _nx.any(both_negative):
   419|         0|            0|            0|  0.00%|        _nx.negative(start, out=start, where=both_negative)
   420|         0|            0|            0|  0.00%|        _nx.negative(stop, out=stop, where=both_negative)
   421|         0|            0|            0|  0.00%|        _nx.negative(out_sign, out=out_sign, where=both_negative)
   422|         0|            0|            0|  0.00%|
   423|         0|            0|            0|  0.00%|    log_start = _nx.log10(start)
   424|         0|            0|            0|  0.00%|    log_stop = _nx.log10(stop)
   425|         0|            0|            0|  0.00%|    result = out_sign * logspace(log_start, log_stop, num=num,
   426|         0|            0|            0|  0.00%|                                 endpoint=endpoint, base=10.0, dtype=dtype)
   427|         0|            0|            0|  0.00%|    if axis != 0:
   428|         0|            0|            0|  0.00%|        result = _nx.moveaxis(result, 0, axis)
   429|         0|            0|            0|  0.00%|
   430|         0|            0|            0|  0.00%|    return result.astype(dtype, copy=False)
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|#always succeed
   434|         0|            0|            0|  0.00%|def _add_docstring(obj, doc):
   435|         0|            0|            0|  0.00%|    try:
   436|         0|            0|            0|  0.00%|        add_docstring(obj, doc)
   437|         0|            0|            0|  0.00%|    except Exception:
   438|         0|            0|            0|  0.00%|        pass
   439|         0|            0|            0|  0.00%|
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|def add_newdoc(place, obj, doc):
   442|         0|            0|            0|  0.00%|    """
   443|         0|            0|            0|  0.00%|    Adds documentation to obj which is in module place.
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    If doc is a string add it to obj as a docstring
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    If doc is a tuple, then the first element is interpreted as
   448|         0|            0|            0|  0.00%|       an attribute of obj and the second as the docstring
   449|         0|            0|            0|  0.00%|          (method, docstring)
   450|         0|            0|            0|  0.00%|
   451|         0|            0|            0|  0.00%|    If doc is a list, then each element of the list should be a
   452|         0|            0|            0|  0.00%|       sequence of length two --> [(method1, docstring1),
   453|         0|            0|            0|  0.00%|       (method2, docstring2), ...]
   454|         0|            0|            0|  0.00%|
   455|         0|            0|            0|  0.00%|    This routine never raises an error if the docstring can't be written, but
   456|         0|            0|            0|  0.00%|    will raise an error if the object being documented does not exist.
   457|         0|            0|            0|  0.00%|
   458|         0|            0|            0|  0.00%|    This routine cannot modify read-only docstrings, as appear
   459|         0|            0|            0|  0.00%|    in new-style classes or built-in functions. Because this
   460|         0|            0|            0|  0.00%|    routine never raises an error the caller must check manually
   461|         0|            0|            0|  0.00%|    that the docstrings were changed.
   462|         0|            0|            0|  0.00%|    """
   463|         0|            0|            0|  0.00%|    new = getattr(__import__(place, globals(), {}, [obj]), obj)
   464|         0|            0|            0|  0.00%|    if isinstance(doc, str):
   465|         0|            0|            0|  0.00%|        _add_docstring(new, doc.strip())
   466|         0|            0|            0|  0.00%|    elif isinstance(doc, tuple):
   467|         0|            0|            0|  0.00%|        _add_docstring(getattr(new, doc[0]), doc[1].strip())
   468|         0|            0|            0|  0.00%|    elif isinstance(doc, list):
   469|         0|            0|            0|  0.00%|        for val in doc:
   470|         0|            0|            0|  0.00%|            _add_docstring(getattr(new, val[0]), val[1].strip())
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py
File duration: 0.000425339s (0.01%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|try:
     4|         0|            0|            0|  0.00%|    # Accessing collections abstract classes from collections
     5|         0|            0|            0|  0.00%|    # has been deprecated since Python 3.3
     6|         0|            0|            0|  0.00%|    import collections.abc as collections_abc
     7|         0|            0|            0|  0.00%|except ImportError:
     8|         0|            0|            0|  0.00%|    import collections as collections_abc
     9|         0|            0|            0|  0.00%|import functools
    10|         0|            0|            0|  0.00%|import re
    11|         0|            0|            0|  0.00%|import sys
    12|         0|            0|            0|  0.00%|import warnings
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|import numpy as np
    15|         0|            0|            0|  0.00%|import numpy.core.numeric as _nx
    16|         0|            0|            0|  0.00%|from numpy.core import atleast_1d, transpose
    17|         0|            0|            0|  0.00%|from numpy.core.numeric import (
    18|         0|            0|            0|  0.00%|    ones, zeros, arange, concatenate, array, asarray, asanyarray, empty,
    19|         0|            0|            0|  0.00%|    empty_like, ndarray, around, floor, ceil, take, dot, where, intp,
    20|         0|            0|            0|  0.00%|    integer, isscalar, absolute
    21|         0|            0|            0|  0.00%|    )
    22|         0|            0|            0|  0.00%|from numpy.core.umath import (
    23|         0|            0|            0|  0.00%|    pi, add, arctan2, frompyfunc, cos, less_equal, sqrt, sin,
    24|         0|            0|            0|  0.00%|    mod, exp, not_equal, subtract
    25|         0|            0|            0|  0.00%|    )
    26|         0|            0|            0|  0.00%|from numpy.core.fromnumeric import (
    27|         0|            0|            0|  0.00%|    ravel, nonzero, partition, mean, any, sum
    28|         0|            0|            0|  0.00%|    )
    29|         0|            0|            0|  0.00%|from numpy.core.numerictypes import typecodes
    30|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    31|         0|            0|            0|  0.00%|from numpy.core import overrides
    32|         0|            0|            0|  0.00%|from numpy.core.function_base import add_newdoc
    33|         0|            0|            0|  0.00%|from numpy.lib.twodim_base import diag
    34|         0|            0|            0|  0.00%|from numpy.core.multiarray import (
    35|         0|            0|            0|  0.00%|    _insert, add_docstring, bincount, normalize_axis_index, _monotonicity,
    36|         0|            0|            0|  0.00%|    interp as compiled_interp, interp_complex as compiled_interp_complex
    37|         0|            0|            0|  0.00%|    )
    38|         0|            0|            0|  0.00%|from numpy.core.umath import _add_newdoc_ufunc as add_newdoc_ufunc
    39|         0|            0|            0|  0.00%|from numpy.compat import long
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|if sys.version_info[0] < 3:
    42|         0|            0|            0|  0.00%|    # Force range to be a generator, for np.delete's usage.
    43|         0|            0|            0|  0.00%|    range = xrange
    44|         0|            0|            0|  0.00%|    import __builtin__ as builtins
    45|         0|            0|            0|  0.00%|else:
    46|         0|            0|            0|  0.00%|    import builtins
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|
    49|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    50|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|# needed in this module for compatibility
    54|         0|            0|            0|  0.00%|from numpy.lib.histograms import histogram, histogramdd
    55|         0|            0|            0|  0.00%|
    56|         0|            0|            0|  0.00%|__all__ = [
    57|         0|            0|            0|  0.00%|    'select', 'piecewise', 'trim_zeros', 'copy', 'iterable', 'percentile',
    58|         0|            0|            0|  0.00%|    'diff', 'gradient', 'angle', 'unwrap', 'sort_complex', 'disp', 'flip',
    59|         0|            0|            0|  0.00%|    'rot90', 'extract', 'place', 'vectorize', 'asarray_chkfinite', 'average',
    60|         0|            0|            0|  0.00%|    'bincount', 'digitize', 'cov', 'corrcoef',
    61|         0|            0|            0|  0.00%|    'msort', 'median', 'sinc', 'hamming', 'hanning', 'bartlett',
    62|         0|            0|            0|  0.00%|    'blackman', 'kaiser', 'trapz', 'i0', 'add_newdoc', 'add_docstring',
    63|         0|            0|            0|  0.00%|    'meshgrid', 'delete', 'insert', 'append', 'interp', 'add_newdoc_ufunc',
    64|         0|            0|            0|  0.00%|    'quantile'
    65|         0|            0|            0|  0.00%|    ]
    66|         0|            0|            0|  0.00%|
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|def _rot90_dispatcher(m, k=None, axes=None):
    69|         0|            0|            0|  0.00%|    return (m,)
    70|         0|            0|            0|  0.00%|
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|@array_function_dispatch(_rot90_dispatcher)
    73|         0|            0|            0|  0.00%|def rot90(m, k=1, axes=(0,1)):
    74|         0|            0|            0|  0.00%|    """
    75|         0|            0|            0|  0.00%|    Rotate an array by 90 degrees in the plane specified by axes.
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|    Rotation direction is from the first towards the second axis.
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|    Parameters
    80|         0|            0|            0|  0.00%|    ----------
    81|         0|            0|            0|  0.00%|    m : array_like
    82|         0|            0|            0|  0.00%|        Array of two or more dimensions.
    83|         0|            0|            0|  0.00%|    k : integer
    84|         0|            0|            0|  0.00%|        Number of times the array is rotated by 90 degrees.
    85|         0|            0|            0|  0.00%|    axes: (2,) array_like
    86|         0|            0|            0|  0.00%|        The array is rotated in the plane defined by the axes.
    87|         0|            0|            0|  0.00%|        Axes must be different.
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|    Returns
    92|         0|            0|            0|  0.00%|    -------
    93|         0|            0|            0|  0.00%|    y : ndarray
    94|         0|            0|            0|  0.00%|        A rotated view of `m`.
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|    See Also
    97|         0|            0|            0|  0.00%|    --------
    98|         0|            0|            0|  0.00%|    flip : Reverse the order of elements in an array along the given axis.
    99|         0|            0|            0|  0.00%|    fliplr : Flip an array horizontally.
   100|         0|            0|            0|  0.00%|    flipud : Flip an array vertically.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    Notes
   103|         0|            0|            0|  0.00%|    -----
   104|         0|            0|            0|  0.00%|    rot90(m, k=1, axes=(1,0)) is the reverse of rot90(m, k=1, axes=(0,1))
   105|         0|            0|            0|  0.00%|    rot90(m, k=1, axes=(1,0)) is equivalent to rot90(m, k=-1, axes=(0,1))
   106|         0|            0|            0|  0.00%|
   107|         0|            0|            0|  0.00%|    Examples
   108|         0|            0|            0|  0.00%|    --------
   109|         0|            0|            0|  0.00%|    >>> m = np.array([[1,2],[3,4]], int)
   110|         0|            0|            0|  0.00%|    >>> m
   111|         0|            0|            0|  0.00%|    array([[1, 2],
   112|         0|            0|            0|  0.00%|           [3, 4]])
   113|         0|            0|            0|  0.00%|    >>> np.rot90(m)
   114|         0|            0|            0|  0.00%|    array([[2, 4],
   115|         0|            0|            0|  0.00%|           [1, 3]])
   116|         0|            0|            0|  0.00%|    >>> np.rot90(m, 2)
   117|         0|            0|            0|  0.00%|    array([[4, 3],
   118|         0|            0|            0|  0.00%|           [2, 1]])
   119|         0|            0|            0|  0.00%|    >>> m = np.arange(8).reshape((2,2,2))
   120|         0|            0|            0|  0.00%|    >>> np.rot90(m, 1, (1,2))
   121|         0|            0|            0|  0.00%|    array([[[1, 3],
   122|         0|            0|            0|  0.00%|            [0, 2]],
   123|         0|            0|            0|  0.00%|           [[5, 7],
   124|         0|            0|            0|  0.00%|            [4, 6]]])
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    """
   127|         0|            0|            0|  0.00%|    axes = tuple(axes)
   128|         0|            0|            0|  0.00%|    if len(axes) != 2:
   129|         0|            0|            0|  0.00%|        raise ValueError("len(axes) must be 2.")
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|    m = asanyarray(m)
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|    if axes[0] == axes[1] or absolute(axes[0] - axes[1]) == m.ndim:
   134|         0|            0|            0|  0.00%|        raise ValueError("Axes must be different.")
   135|         0|            0|            0|  0.00%|
   136|         0|            0|            0|  0.00%|    if (axes[0] >= m.ndim or axes[0] < -m.ndim
   137|         0|            0|            0|  0.00%|        or axes[1] >= m.ndim or axes[1] < -m.ndim):
   138|         0|            0|            0|  0.00%|        raise ValueError("Axes={} out of range for array of ndim={}."
   139|         0|            0|            0|  0.00%|            .format(axes, m.ndim))
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    k %= 4
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    if k == 0:
   144|         0|            0|            0|  0.00%|        return m[:]
   145|         0|            0|            0|  0.00%|    if k == 2:
   146|         0|            0|            0|  0.00%|        return flip(flip(m, axes[0]), axes[1])
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    axes_list = arange(0, m.ndim)
   149|         0|            0|            0|  0.00%|    (axes_list[axes[0]], axes_list[axes[1]]) = (axes_list[axes[1]],
   150|         0|            0|            0|  0.00%|                                                axes_list[axes[0]])
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    if k == 1:
   153|         0|            0|            0|  0.00%|        return transpose(flip(m,axes[1]), axes_list)
   154|         0|            0|            0|  0.00%|    else:
   155|         0|            0|            0|  0.00%|        # k == 3
   156|         0|            0|            0|  0.00%|        return flip(transpose(m, axes_list), axes[1])
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|def _flip_dispatcher(m, axis=None):
   160|         0|            0|            0|  0.00%|    return (m,)
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|
   163|         0|            0|            0|  0.00%|@array_function_dispatch(_flip_dispatcher)
   164|         0|            0|            0|  0.00%|def flip(m, axis=None):
   165|         0|            0|            0|  0.00%|    """
   166|         0|            0|            0|  0.00%|    Reverse the order of elements in an array along the given axis.
   167|         0|            0|            0|  0.00%|
   168|         0|            0|            0|  0.00%|    The shape of the array is preserved, but the elements are reordered.
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
   171|         0|            0|            0|  0.00%|
   172|         0|            0|            0|  0.00%|    Parameters
   173|         0|            0|            0|  0.00%|    ----------
   174|         0|            0|            0|  0.00%|    m : array_like
   175|         0|            0|            0|  0.00%|        Input array.
   176|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   177|         0|            0|            0|  0.00%|         Axis or axes along which to flip over. The default,
   178|         0|            0|            0|  0.00%|         axis=None, will flip over all of the axes of the input array.
   179|         0|            0|            0|  0.00%|         If axis is negative it counts from the last to the first axis.
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|         If axis is a tuple of ints, flipping is performed on all of the axes
   182|         0|            0|            0|  0.00%|         specified in the tuple.
   183|         0|            0|            0|  0.00%|
   184|         0|            0|            0|  0.00%|         .. versionchanged:: 1.15.0
   185|         0|            0|            0|  0.00%|            None and tuples of axes are supported
   186|         0|            0|            0|  0.00%|
   187|         0|            0|            0|  0.00%|    Returns
   188|         0|            0|            0|  0.00%|    -------
   189|         0|            0|            0|  0.00%|    out : array_like
   190|         0|            0|            0|  0.00%|        A view of `m` with the entries of axis reversed.  Since a view is
   191|         0|            0|            0|  0.00%|        returned, this operation is done in constant time.
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|    See Also
   194|         0|            0|            0|  0.00%|    --------
   195|         0|            0|            0|  0.00%|    flipud : Flip an array vertically (axis=0).
   196|         0|            0|            0|  0.00%|    fliplr : Flip an array horizontally (axis=1).
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    Notes
   199|         0|            0|            0|  0.00%|    -----
   200|         0|            0|            0|  0.00%|    flip(m, 0) is equivalent to flipud(m).
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|    flip(m, 1) is equivalent to fliplr(m).
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    flip(m, n) corresponds to ``m[...,::-1,...]`` with ``::-1`` at position n.
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|    flip(m) corresponds to ``m[::-1,::-1,...,::-1]`` with ``::-1`` at all
   207|         0|            0|            0|  0.00%|    positions.
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    flip(m, (0, 1)) corresponds to ``m[::-1,::-1,...]`` with ``::-1`` at
   210|         0|            0|            0|  0.00%|    position 0 and position 1.
   211|         0|            0|            0|  0.00%|
   212|         0|            0|            0|  0.00%|    Examples
   213|         0|            0|            0|  0.00%|    --------
   214|         0|            0|            0|  0.00%|    >>> A = np.arange(8).reshape((2,2,2))
   215|         0|            0|            0|  0.00%|    >>> A
   216|         0|            0|            0|  0.00%|    array([[[0, 1],
   217|         0|            0|            0|  0.00%|            [2, 3]],
   218|         0|            0|            0|  0.00%|           [[4, 5],
   219|         0|            0|            0|  0.00%|            [6, 7]]])
   220|         0|            0|            0|  0.00%|    >>> np.flip(A, 0)
   221|         0|            0|            0|  0.00%|    array([[[4, 5],
   222|         0|            0|            0|  0.00%|            [6, 7]],
   223|         0|            0|            0|  0.00%|           [[0, 1],
   224|         0|            0|            0|  0.00%|            [2, 3]]])
   225|         0|            0|            0|  0.00%|    >>> np.flip(A, 1)
   226|         0|            0|            0|  0.00%|    array([[[2, 3],
   227|         0|            0|            0|  0.00%|            [0, 1]],
   228|         0|            0|            0|  0.00%|           [[6, 7],
   229|         0|            0|            0|  0.00%|            [4, 5]]])
   230|         0|            0|            0|  0.00%|    >>> np.flip(A)
   231|         0|            0|            0|  0.00%|    array([[[7, 6],
   232|         0|            0|            0|  0.00%|            [5, 4]],
   233|         0|            0|            0|  0.00%|           [[3, 2],
   234|         0|            0|            0|  0.00%|            [1, 0]]])
   235|         0|            0|            0|  0.00%|    >>> np.flip(A, (0, 2))
   236|         0|            0|            0|  0.00%|    array([[[5, 4],
   237|         0|            0|            0|  0.00%|            [7, 6]],
   238|         0|            0|            0|  0.00%|           [[1, 0],
   239|         0|            0|            0|  0.00%|            [3, 2]]])
   240|         0|            0|            0|  0.00%|    >>> A = np.random.randn(3,4,5)
   241|         0|            0|            0|  0.00%|    >>> np.all(np.flip(A,2) == A[:,:,::-1,...])
   242|         0|            0|            0|  0.00%|    True
   243|         0|            0|            0|  0.00%|    """
   244|         0|            0|            0|  0.00%|    if not hasattr(m, 'ndim'):
   245|         0|            0|            0|  0.00%|        m = asarray(m)
   246|         0|            0|            0|  0.00%|    if axis is None:
   247|         0|            0|            0|  0.00%|        indexer = (np.s_[::-1],) * m.ndim
   248|         0|            0|            0|  0.00%|    else:
   249|         0|            0|            0|  0.00%|        axis = _nx.normalize_axis_tuple(axis, m.ndim)
   250|         0|            0|            0|  0.00%|        indexer = [np.s_[:]] * m.ndim
   251|         0|            0|            0|  0.00%|        for ax in axis:
   252|         0|            0|            0|  0.00%|            indexer[ax] = np.s_[::-1]
   253|         0|            0|            0|  0.00%|        indexer = tuple(indexer)
   254|         0|            0|            0|  0.00%|    return m[indexer]
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|@set_module('numpy')
   258|         0|            0|            0|  0.00%|def iterable(y):
   259|         0|            0|            0|  0.00%|    """
   260|         0|            0|            0|  0.00%|    Check whether or not an object can be iterated over.
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|    Parameters
   263|         0|            0|            0|  0.00%|    ----------
   264|         0|            0|            0|  0.00%|    y : object
   265|         0|            0|            0|  0.00%|      Input object.
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    Returns
   268|         0|            0|            0|  0.00%|    -------
   269|         0|            0|            0|  0.00%|    b : bool
   270|         0|            0|            0|  0.00%|      Return ``True`` if the object has an iterator method or is a
   271|         0|            0|            0|  0.00%|      sequence and ``False`` otherwise.
   272|         0|            0|            0|  0.00%|
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|    Examples
   275|         0|            0|            0|  0.00%|    --------
   276|         0|            0|            0|  0.00%|    >>> np.iterable([1, 2, 3])
   277|         0|            0|            0|  0.00%|    True
   278|         0|            0|            0|  0.00%|    >>> np.iterable(2)
   279|         0|            0|            0|  0.00%|    False
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    """
   282|         0|            0|            0|  0.00%|    try:
   283|         0|            0|            0|  0.00%|        iter(y)
   284|         0|            0|            0|  0.00%|    except TypeError:
   285|         0|            0|            0|  0.00%|        return False
   286|         0|            0|            0|  0.00%|    return True
   287|         0|            0|            0|  0.00%|
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|def _average_dispatcher(a, axis=None, weights=None, returned=None):
   290|         0|            0|            0|  0.00%|    return (a, weights)
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         0|            0|            0|  0.00%|@array_function_dispatch(_average_dispatcher)
   294|         0|            0|            0|  0.00%|def average(a, axis=None, weights=None, returned=False):
   295|         0|            0|            0|  0.00%|    """
   296|         0|            0|            0|  0.00%|    Compute the weighted average along the specified axis.
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    Parameters
   299|         0|            0|            0|  0.00%|    ----------
   300|         0|            0|            0|  0.00%|    a : array_like
   301|         0|            0|            0|  0.00%|        Array containing data to be averaged. If `a` is not an array, a
   302|         0|            0|            0|  0.00%|        conversion is attempted.
   303|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   304|         0|            0|            0|  0.00%|        Axis or axes along which to average `a`.  The default,
   305|         0|            0|            0|  0.00%|        axis=None, will average over all of the elements of the input array.
   306|         0|            0|            0|  0.00%|        If axis is negative it counts from the last to the first axis.
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|        If axis is a tuple of ints, averaging is performed on all of the axes
   311|         0|            0|            0|  0.00%|        specified in the tuple instead of a single axis or all the axes as
   312|         0|            0|            0|  0.00%|        before.
   313|         0|            0|            0|  0.00%|    weights : array_like, optional
   314|         0|            0|            0|  0.00%|        An array of weights associated with the values in `a`. Each value in
   315|         0|            0|            0|  0.00%|        `a` contributes to the average according to its associated weight.
   316|         0|            0|            0|  0.00%|        The weights array can either be 1-D (in which case its length must be
   317|         0|            0|            0|  0.00%|        the size of `a` along the given axis) or of the same shape as `a`.
   318|         0|            0|            0|  0.00%|        If `weights=None`, then all data in `a` are assumed to have a
   319|         0|            0|            0|  0.00%|        weight equal to one.
   320|         0|            0|            0|  0.00%|    returned : bool, optional
   321|         0|            0|            0|  0.00%|        Default is `False`. If `True`, the tuple (`average`, `sum_of_weights`)
   322|         0|            0|            0|  0.00%|        is returned, otherwise only the average is returned.
   323|         0|            0|            0|  0.00%|        If `weights=None`, `sum_of_weights` is equivalent to the number of
   324|         0|            0|            0|  0.00%|        elements over which the average is taken.
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|    Returns
   328|         0|            0|            0|  0.00%|    -------
   329|         0|            0|            0|  0.00%|    retval, [sum_of_weights] : array_type or double
   330|         0|            0|            0|  0.00%|        Return the average along the specified axis. When `returned` is `True`,
   331|         0|            0|            0|  0.00%|        return a tuple with the average as the first element and the sum
   332|         0|            0|            0|  0.00%|        of the weights as the second element. `sum_of_weights` is of the
   333|         0|            0|            0|  0.00%|        same type as `retval`. The result dtype follows a genereal pattern.
   334|         0|            0|            0|  0.00%|        If `weights` is None, the result dtype will be that of `a` , or ``float64``
   335|         0|            0|            0|  0.00%|        if `a` is integral. Otherwise, if `weights` is not None and `a` is non-
   336|         0|            0|            0|  0.00%|        integral, the result type will be the type of lowest precision capable of
   337|         0|            0|            0|  0.00%|        representing values of both `a` and `weights`. If `a` happens to be
   338|         0|            0|            0|  0.00%|        integral, the previous rules still applies but the result dtype will
   339|         0|            0|            0|  0.00%|        at least be ``float64``.
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|    Raises
   342|         0|            0|            0|  0.00%|    ------
   343|         0|            0|            0|  0.00%|    ZeroDivisionError
   344|         0|            0|            0|  0.00%|        When all weights along axis are zero. See `numpy.ma.average` for a
   345|         0|            0|            0|  0.00%|        version robust to this type of error.
   346|         0|            0|            0|  0.00%|    TypeError
   347|         0|            0|            0|  0.00%|        When the length of 1D `weights` is not the same as the shape of `a`
   348|         0|            0|            0|  0.00%|        along axis.
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    See Also
   351|         0|            0|            0|  0.00%|    --------
   352|         0|            0|            0|  0.00%|    mean
   353|         0|            0|            0|  0.00%|
   354|         0|            0|            0|  0.00%|    ma.average : average for masked arrays -- useful if your data contains
   355|         0|            0|            0|  0.00%|                 "missing" values
   356|         0|            0|            0|  0.00%|    numpy.result_type : Returns the type that results from applying the
   357|         0|            0|            0|  0.00%|                        numpy type promotion rules to the arguments.
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|    Examples
   360|         0|            0|            0|  0.00%|    --------
   361|         0|            0|            0|  0.00%|    >>> data = list(range(1,5))
   362|         0|            0|            0|  0.00%|    >>> data
   363|         0|            0|            0|  0.00%|    [1, 2, 3, 4]
   364|         0|            0|            0|  0.00%|    >>> np.average(data)
   365|         0|            0|            0|  0.00%|    2.5
   366|         0|            0|            0|  0.00%|    >>> np.average(range(1,11), weights=range(10,0,-1))
   367|         0|            0|            0|  0.00%|    4.0
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|    >>> data = np.arange(6).reshape((3,2))
   370|         0|            0|            0|  0.00%|    >>> data
   371|         0|            0|            0|  0.00%|    array([[0, 1],
   372|         0|            0|            0|  0.00%|           [2, 3],
   373|         0|            0|            0|  0.00%|           [4, 5]])
   374|         0|            0|            0|  0.00%|    >>> np.average(data, axis=1, weights=[1./4, 3./4])
   375|         0|            0|            0|  0.00%|    array([0.75, 2.75, 4.75])
   376|         0|            0|            0|  0.00%|    >>> np.average(data, weights=[1./4, 3./4])
   377|         0|            0|            0|  0.00%|    Traceback (most recent call last):
   378|         0|            0|            0|  0.00%|        ...
   379|         0|            0|            0|  0.00%|    TypeError: Axis must be specified when shapes of a and weights differ.
   380|         0|            0|            0|  0.00%|
   381|         0|            0|            0|  0.00%|    >>> a = np.ones(5, dtype=np.float128)
   382|         0|            0|            0|  0.00%|    >>> w = np.ones(5, dtype=np.complex64)
   383|         0|            0|            0|  0.00%|    >>> avg = np.average(a, weights=w)
   384|         0|            0|            0|  0.00%|    >>> print(avg.dtype)
   385|         0|            0|            0|  0.00%|    complex256
   386|         0|            0|            0|  0.00%|    """
   387|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
   388|         0|            0|            0|  0.00%|
   389|         0|            0|            0|  0.00%|    if weights is None:
   390|         0|            0|            0|  0.00%|        avg = a.mean(axis)
   391|         0|            0|            0|  0.00%|        scl = avg.dtype.type(a.size/avg.size)
   392|         0|            0|            0|  0.00%|    else:
   393|         0|            0|            0|  0.00%|        wgt = np.asanyarray(weights)
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|        if issubclass(a.dtype.type, (np.integer, np.bool_)):
   396|         0|            0|            0|  0.00%|            result_dtype = np.result_type(a.dtype, wgt.dtype, 'f8')
   397|         0|            0|            0|  0.00%|        else:
   398|         0|            0|            0|  0.00%|            result_dtype = np.result_type(a.dtype, wgt.dtype)
   399|         0|            0|            0|  0.00%|
   400|         0|            0|            0|  0.00%|        # Sanity checks
   401|         0|            0|            0|  0.00%|        if a.shape != wgt.shape:
   402|         0|            0|            0|  0.00%|            if axis is None:
   403|         0|            0|            0|  0.00%|                raise TypeError(
   404|         0|            0|            0|  0.00%|                    "Axis must be specified when shapes of a and weights "
   405|         0|            0|            0|  0.00%|                    "differ.")
   406|         0|            0|            0|  0.00%|            if wgt.ndim != 1:
   407|         0|            0|            0|  0.00%|                raise TypeError(
   408|         0|            0|            0|  0.00%|                    "1D weights expected when shapes of a and weights differ.")
   409|         0|            0|            0|  0.00%|            if wgt.shape[0] != a.shape[axis]:
   410|         0|            0|            0|  0.00%|                raise ValueError(
   411|         0|            0|            0|  0.00%|                    "Length of weights not compatible with specified axis.")
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|            # setup wgt to broadcast along axis
   414|         0|            0|            0|  0.00%|            wgt = np.broadcast_to(wgt, (a.ndim-1)*(1,) + wgt.shape)
   415|         0|            0|            0|  0.00%|            wgt = wgt.swapaxes(-1, axis)
   416|         0|            0|            0|  0.00%|
   417|         0|            0|            0|  0.00%|        scl = wgt.sum(axis=axis, dtype=result_dtype)
   418|         0|            0|            0|  0.00%|        if np.any(scl == 0.0):
   419|         0|            0|            0|  0.00%|            raise ZeroDivisionError(
   420|         0|            0|            0|  0.00%|                "Weights sum to zero, can't be normalized")
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|        avg = np.multiply(a, wgt, dtype=result_dtype).sum(axis)/scl
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    if returned:
   425|         0|            0|            0|  0.00%|        if scl.shape != avg.shape:
   426|         0|            0|            0|  0.00%|            scl = np.broadcast_to(scl, avg.shape).copy()
   427|         0|            0|            0|  0.00%|        return avg, scl
   428|         0|            0|            0|  0.00%|    else:
   429|         0|            0|            0|  0.00%|        return avg
   430|         0|            0|            0|  0.00%|
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|@set_module('numpy')
   433|         0|            0|            0|  0.00%|def asarray_chkfinite(a, dtype=None, order=None):
   434|         0|            0|            0|  0.00%|    """Convert the input to an array, checking for NaNs or Infs.
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|    Parameters
   437|         0|            0|            0|  0.00%|    ----------
   438|         0|            0|            0|  0.00%|    a : array_like
   439|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to an array.  This
   440|         0|            0|            0|  0.00%|        includes lists, lists of tuples, tuples, tuples of tuples, tuples
   441|         0|            0|            0|  0.00%|        of lists and ndarrays.  Success requires no NaNs or Infs.
   442|         0|            0|            0|  0.00%|    dtype : data-type, optional
   443|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
   444|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   445|         0|            0|            0|  0.00%|         Whether to use row-major (C-style) or
   446|         0|            0|            0|  0.00%|         column-major (Fortran-style) memory representation.
   447|         0|            0|            0|  0.00%|         Defaults to 'C'.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    Returns
   450|         0|            0|            0|  0.00%|    -------
   451|         0|            0|            0|  0.00%|    out : ndarray
   452|         0|            0|            0|  0.00%|        Array interpretation of `a`.  No copy is performed if the input
   453|         0|            0|            0|  0.00%|        is already an ndarray.  If `a` is a subclass of ndarray, a base
   454|         0|            0|            0|  0.00%|        class ndarray is returned.
   455|         0|            0|            0|  0.00%|
   456|         0|            0|            0|  0.00%|    Raises
   457|         0|            0|            0|  0.00%|    ------
   458|         0|            0|            0|  0.00%|    ValueError
   459|         0|            0|            0|  0.00%|        Raises ValueError if `a` contains NaN (Not a Number) or Inf (Infinity).
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    See Also
   462|         0|            0|            0|  0.00%|    --------
   463|         0|            0|            0|  0.00%|    asarray : Create and array.
   464|         0|            0|            0|  0.00%|    asanyarray : Similar function which passes through subclasses.
   465|         0|            0|            0|  0.00%|    ascontiguousarray : Convert input to a contiguous array.
   466|         0|            0|            0|  0.00%|    asfarray : Convert input to a floating point ndarray.
   467|         0|            0|            0|  0.00%|    asfortranarray : Convert input to an ndarray with column-major
   468|         0|            0|            0|  0.00%|                     memory order.
   469|         0|            0|            0|  0.00%|    fromiter : Create an array from an iterator.
   470|         0|            0|            0|  0.00%|    fromfunction : Construct an array by executing a function on grid
   471|         0|            0|            0|  0.00%|                   positions.
   472|         0|            0|            0|  0.00%|
   473|         0|            0|            0|  0.00%|    Examples
   474|         0|            0|            0|  0.00%|    --------
   475|         0|            0|            0|  0.00%|    Convert a list into an array.  If all elements are finite
   476|         0|            0|            0|  0.00%|    ``asarray_chkfinite`` is identical to ``asarray``.
   477|         0|            0|            0|  0.00%|
   478|         0|            0|            0|  0.00%|    >>> a = [1, 2]
   479|         0|            0|            0|  0.00%|    >>> np.asarray_chkfinite(a, dtype=float)
   480|         0|            0|            0|  0.00%|    array([1., 2.])
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    Raises ValueError if array_like contains Nans or Infs.
   483|         0|            0|            0|  0.00%|
   484|         0|            0|            0|  0.00%|    >>> a = [1, 2, np.inf]
   485|         0|            0|            0|  0.00%|    >>> try:
   486|         0|            0|            0|  0.00%|    ...     np.asarray_chkfinite(a)
   487|         0|            0|            0|  0.00%|    ... except ValueError:
   488|         0|            0|            0|  0.00%|    ...     print('ValueError')
   489|         0|            0|            0|  0.00%|    ...
   490|         0|            0|            0|  0.00%|    ValueError
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|    """
   493|         0|            0|            0|  0.00%|    a = asarray(a, dtype=dtype, order=order)
   494|         0|            0|            0|  0.00%|    if a.dtype.char in typecodes['AllFloat'] and not np.isfinite(a).all():
   495|         0|            0|            0|  0.00%|        raise ValueError(
   496|         0|            0|            0|  0.00%|            "array must not contain infs or NaNs")
   497|         0|            0|            0|  0.00%|    return a
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|def _piecewise_dispatcher(x, condlist, funclist, *args, **kw):
   501|         0|            0|            0|  0.00%|    yield x
   502|         0|            0|            0|  0.00%|    # support the undocumented behavior of allowing scalars
   503|         0|            0|            0|  0.00%|    if np.iterable(condlist):
   504|         0|            0|            0|  0.00%|        for c in condlist:
   505|         0|            0|            0|  0.00%|            yield c
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|
   508|         0|            0|            0|  0.00%|@array_function_dispatch(_piecewise_dispatcher)
   509|         0|            0|            0|  0.00%|def piecewise(x, condlist, funclist, *args, **kw):
   510|         0|            0|            0|  0.00%|    """
   511|         0|            0|            0|  0.00%|    Evaluate a piecewise-defined function.
   512|         0|            0|            0|  0.00%|
   513|         0|            0|            0|  0.00%|    Given a set of conditions and corresponding functions, evaluate each
   514|         0|            0|            0|  0.00%|    function on the input data wherever its condition is true.
   515|         0|            0|            0|  0.00%|
   516|         0|            0|            0|  0.00%|    Parameters
   517|         0|            0|            0|  0.00%|    ----------
   518|         0|            0|            0|  0.00%|    x : ndarray or scalar
   519|         0|            0|            0|  0.00%|        The input domain.
   520|         0|            0|            0|  0.00%|    condlist : list of bool arrays or bool scalars
   521|         0|            0|            0|  0.00%|        Each boolean array corresponds to a function in `funclist`.  Wherever
   522|         0|            0|            0|  0.00%|        `condlist[i]` is True, `funclist[i](x)` is used as the output value.
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|        Each boolean array in `condlist` selects a piece of `x`,
   525|         0|            0|            0|  0.00%|        and should therefore be of the same shape as `x`.
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|        The length of `condlist` must correspond to that of `funclist`.
   528|         0|            0|            0|  0.00%|        If one extra function is given, i.e. if
   529|         0|            0|            0|  0.00%|        ``len(funclist) == len(condlist) + 1``, then that extra function
   530|         0|            0|            0|  0.00%|        is the default value, used wherever all conditions are false.
   531|         0|            0|            0|  0.00%|    funclist : list of callables, f(x,*args,**kw), or scalars
   532|         0|            0|            0|  0.00%|        Each function is evaluated over `x` wherever its corresponding
   533|         0|            0|            0|  0.00%|        condition is True.  It should take a 1d array as input and give an 1d
   534|         0|            0|            0|  0.00%|        array or a scalar value as output.  If, instead of a callable,
   535|         0|            0|            0|  0.00%|        a scalar is provided then a constant function (``lambda x: scalar``) is
   536|         0|            0|            0|  0.00%|        assumed.
   537|         0|            0|            0|  0.00%|    args : tuple, optional
   538|         0|            0|            0|  0.00%|        Any further arguments given to `piecewise` are passed to the functions
   539|         0|            0|            0|  0.00%|        upon execution, i.e., if called ``piecewise(..., ..., 1, 'a')``, then
   540|         0|            0|            0|  0.00%|        each function is called as ``f(x, 1, 'a')``.
   541|         0|            0|            0|  0.00%|    kw : dict, optional
   542|         0|            0|            0|  0.00%|        Keyword arguments used in calling `piecewise` are passed to the
   543|         0|            0|            0|  0.00%|        functions upon execution, i.e., if called
   544|         0|            0|            0|  0.00%|        ``piecewise(..., ..., alpha=1)``, then each function is called as
   545|         0|            0|            0|  0.00%|        ``f(x, alpha=1)``.
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|    Returns
   548|         0|            0|            0|  0.00%|    -------
   549|         0|            0|            0|  0.00%|    out : ndarray
   550|         0|            0|            0|  0.00%|        The output is the same shape and type as x and is found by
   551|         0|            0|            0|  0.00%|        calling the functions in `funclist` on the appropriate portions of `x`,
   552|         0|            0|            0|  0.00%|        as defined by the boolean arrays in `condlist`.  Portions not covered
   553|         0|            0|            0|  0.00%|        by any condition have a default value of 0.
   554|         0|            0|            0|  0.00%|
   555|         0|            0|            0|  0.00%|
   556|         0|            0|            0|  0.00%|    See Also
   557|         0|            0|            0|  0.00%|    --------
   558|         0|            0|            0|  0.00%|    choose, select, where
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|    Notes
   561|         0|            0|            0|  0.00%|    -----
   562|         0|            0|            0|  0.00%|    This is similar to choose or select, except that functions are
   563|         0|            0|            0|  0.00%|    evaluated on elements of `x` that satisfy the corresponding condition from
   564|         0|            0|            0|  0.00%|    `condlist`.
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|    The result is::
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|            |--
   569|         0|            0|            0|  0.00%|            |funclist[0](x[condlist[0]])
   570|         0|            0|            0|  0.00%|      out = |funclist[1](x[condlist[1]])
   571|         0|            0|            0|  0.00%|            |...
   572|         0|            0|            0|  0.00%|            |funclist[n2](x[condlist[n2]])
   573|         0|            0|            0|  0.00%|            |--
   574|         0|            0|            0|  0.00%|
   575|         0|            0|            0|  0.00%|    Examples
   576|         0|            0|            0|  0.00%|    --------
   577|         0|            0|            0|  0.00%|    Define the sigma function, which is -1 for ``x < 0`` and +1 for ``x >= 0``.
   578|         0|            0|            0|  0.00%|
   579|         0|            0|            0|  0.00%|    >>> x = np.linspace(-2.5, 2.5, 6)
   580|         0|            0|            0|  0.00%|    >>> np.piecewise(x, [x < 0, x >= 0], [-1, 1])
   581|         0|            0|            0|  0.00%|    array([-1., -1., -1.,  1.,  1.,  1.])
   582|         0|            0|            0|  0.00%|
   583|         0|            0|            0|  0.00%|    Define the absolute value, which is ``-x`` for ``x <0`` and ``x`` for
   584|         0|            0|            0|  0.00%|    ``x >= 0``.
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|    >>> np.piecewise(x, [x < 0, x >= 0], [lambda x: -x, lambda x: x])
   587|         0|            0|            0|  0.00%|    array([2.5,  1.5,  0.5,  0.5,  1.5,  2.5])
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|    Apply the same function to a scalar value.
   590|         0|            0|            0|  0.00%|
   591|         0|            0|            0|  0.00%|    >>> y = -2
   592|         0|            0|            0|  0.00%|    >>> np.piecewise(y, [y < 0, y >= 0], [lambda x: -x, lambda x: x])
   593|         0|            0|            0|  0.00%|    array(2)
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    """
   596|         0|            0|            0|  0.00%|    x = asanyarray(x)
   597|         0|            0|            0|  0.00%|    n2 = len(funclist)
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|    # undocumented: single condition is promoted to a list of one condition
   600|         0|            0|            0|  0.00%|    if isscalar(condlist) or (
   601|         0|            0|            0|  0.00%|            not isinstance(condlist[0], (list, ndarray)) and x.ndim != 0):
   602|         0|            0|            0|  0.00%|        condlist = [condlist]
   603|         0|            0|            0|  0.00%|
   604|         0|            0|            0|  0.00%|    condlist = array(condlist, dtype=bool)
   605|         0|            0|            0|  0.00%|    n = len(condlist)
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|    if n == n2 - 1:  # compute the "otherwise" condition.
   608|         0|            0|            0|  0.00%|        condelse = ~np.any(condlist, axis=0, keepdims=True)
   609|         0|            0|            0|  0.00%|        condlist = np.concatenate([condlist, condelse], axis=0)
   610|         0|            0|            0|  0.00%|        n += 1
   611|         0|            0|            0|  0.00%|    elif n != n2:
   612|         0|            0|            0|  0.00%|        raise ValueError(
   613|         0|            0|            0|  0.00%|            "with {} condition(s), either {} or {} functions are expected"
   614|         0|            0|            0|  0.00%|            .format(n, n, n+1)
   615|         0|            0|            0|  0.00%|        )
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|    y = zeros(x.shape, x.dtype)
   618|         0|            0|            0|  0.00%|    for k in range(n):
   619|         0|            0|            0|  0.00%|        item = funclist[k]
   620|         0|            0|            0|  0.00%|        if not isinstance(item, collections_abc.Callable):
   621|         0|            0|            0|  0.00%|            y[condlist[k]] = item
   622|         0|            0|            0|  0.00%|        else:
   623|         0|            0|            0|  0.00%|            vals = x[condlist[k]]
   624|         0|            0|            0|  0.00%|            if vals.size > 0:
   625|         0|            0|            0|  0.00%|                y[condlist[k]] = item(vals, *args, **kw)
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    return y
   628|         0|            0|            0|  0.00%|
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|def _select_dispatcher(condlist, choicelist, default=None):
   631|         0|            0|            0|  0.00%|    for c in condlist:
   632|         0|            0|            0|  0.00%|        yield c
   633|         0|            0|            0|  0.00%|    for c in choicelist:
   634|         0|            0|            0|  0.00%|        yield c
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|
   637|         0|            0|            0|  0.00%|@array_function_dispatch(_select_dispatcher)
   638|         0|            0|            0|  0.00%|def select(condlist, choicelist, default=0):
   639|         0|            0|            0|  0.00%|    """
   640|         0|            0|            0|  0.00%|    Return an array drawn from elements in choicelist, depending on conditions.
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|    Parameters
   643|         0|            0|            0|  0.00%|    ----------
   644|         0|            0|            0|  0.00%|    condlist : list of bool ndarrays
   645|         0|            0|            0|  0.00%|        The list of conditions which determine from which array in `choicelist`
   646|         0|            0|            0|  0.00%|        the output elements are taken. When multiple conditions are satisfied,
   647|         0|            0|            0|  0.00%|        the first one encountered in `condlist` is used.
   648|         0|            0|            0|  0.00%|    choicelist : list of ndarrays
   649|         0|            0|            0|  0.00%|        The list of arrays from which the output elements are taken. It has
   650|         0|            0|            0|  0.00%|        to be of the same length as `condlist`.
   651|         0|            0|            0|  0.00%|    default : scalar, optional
   652|         0|            0|            0|  0.00%|        The element inserted in `output` when all conditions evaluate to False.
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|    Returns
   655|         0|            0|            0|  0.00%|    -------
   656|         0|            0|            0|  0.00%|    output : ndarray
   657|         0|            0|            0|  0.00%|        The output at position m is the m-th element of the array in
   658|         0|            0|            0|  0.00%|        `choicelist` where the m-th element of the corresponding array in
   659|         0|            0|            0|  0.00%|        `condlist` is True.
   660|         0|            0|            0|  0.00%|
   661|         0|            0|            0|  0.00%|    See Also
   662|         0|            0|            0|  0.00%|    --------
   663|         0|            0|            0|  0.00%|    where : Return elements from one of two arrays depending on condition.
   664|         0|            0|            0|  0.00%|    take, choose, compress, diag, diagonal
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|    Examples
   667|         0|            0|            0|  0.00%|    --------
   668|         0|            0|            0|  0.00%|    >>> x = np.arange(10)
   669|         0|            0|            0|  0.00%|    >>> condlist = [x<3, x>5]
   670|         0|            0|            0|  0.00%|    >>> choicelist = [x, x**2]
   671|         0|            0|            0|  0.00%|    >>> np.select(condlist, choicelist)
   672|         0|            0|            0|  0.00%|    array([ 0,  1,  2, ..., 49, 64, 81])
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|    """
   675|         0|            0|            0|  0.00%|    # Check the size of condlist and choicelist are the same, or abort.
   676|         0|            0|            0|  0.00%|    if len(condlist) != len(choicelist):
   677|         0|            0|            0|  0.00%|        raise ValueError(
   678|         0|            0|            0|  0.00%|            'list of cases must be same length as list of conditions')
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|    # Now that the dtype is known, handle the deprecated select([], []) case
   681|         0|            0|            0|  0.00%|    if len(condlist) == 0:
   682|         0|            0|            0|  0.00%|        # 2014-02-24, 1.9
   683|         0|            0|            0|  0.00%|        warnings.warn("select with an empty condition list is not possible"
   684|         0|            0|            0|  0.00%|                      "and will be deprecated",
   685|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=3)
   686|         0|            0|            0|  0.00%|        return np.asarray(default)[()]
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|    choicelist = [np.asarray(choice) for choice in choicelist]
   689|         0|            0|            0|  0.00%|    choicelist.append(np.asarray(default))
   690|         0|            0|            0|  0.00%|
   691|         0|            0|            0|  0.00%|    # need to get the result type before broadcasting for correct scalar
   692|         0|            0|            0|  0.00%|    # behaviour
   693|         0|            0|            0|  0.00%|    dtype = np.result_type(*choicelist)
   694|         0|            0|            0|  0.00%|
   695|         0|            0|            0|  0.00%|    # Convert conditions to arrays and broadcast conditions and choices
   696|         0|            0|            0|  0.00%|    # as the shape is needed for the result. Doing it separately optimizes
   697|         0|            0|            0|  0.00%|    # for example when all choices are scalars.
   698|         0|            0|            0|  0.00%|    condlist = np.broadcast_arrays(*condlist)
   699|         0|            0|            0|  0.00%|    choicelist = np.broadcast_arrays(*choicelist)
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|    # If cond array is not an ndarray in boolean format or scalar bool, abort.
   702|         0|            0|            0|  0.00%|    deprecated_ints = False
   703|         0|            0|            0|  0.00%|    for i in range(len(condlist)):
   704|         0|            0|            0|  0.00%|        cond = condlist[i]
   705|         0|            0|            0|  0.00%|        if cond.dtype.type is not np.bool_:
   706|         0|            0|            0|  0.00%|            if np.issubdtype(cond.dtype, np.integer):
   707|         0|            0|            0|  0.00%|                # A previous implementation accepted int ndarrays accidentally.
   708|         0|            0|            0|  0.00%|                # Supported here deliberately, but deprecated.
   709|         0|            0|            0|  0.00%|                condlist[i] = condlist[i].astype(bool)
   710|         0|            0|            0|  0.00%|                deprecated_ints = True
   711|         0|            0|            0|  0.00%|            else:
   712|         0|            0|            0|  0.00%|                raise ValueError(
   713|         0|            0|            0|  0.00%|                    'invalid entry {} in condlist: should be boolean ndarray'.format(i))
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|    if deprecated_ints:
   716|         0|            0|            0|  0.00%|        # 2014-02-24, 1.9
   717|         0|            0|            0|  0.00%|        msg = "select condlists containing integer ndarrays is deprecated " \
   718|         0|            0|            0|  0.00%|            "and will be removed in the future. Use `.astype(bool)` to " \
   719|         0|            0|            0|  0.00%|            "convert to bools."
   720|         0|            0|            0|  0.00%|        warnings.warn(msg, DeprecationWarning, stacklevel=3)
   721|         0|            0|            0|  0.00%|
   722|         0|            0|            0|  0.00%|    if choicelist[0].ndim == 0:
   723|         0|            0|            0|  0.00%|        # This may be common, so avoid the call.
   724|         0|            0|            0|  0.00%|        result_shape = condlist[0].shape
   725|         0|            0|            0|  0.00%|    else:
   726|         0|            0|            0|  0.00%|        result_shape = np.broadcast_arrays(condlist[0], choicelist[0])[0].shape
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|    result = np.full(result_shape, choicelist[-1], dtype)
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    # Use np.copyto to burn each choicelist array onto result, using the
   731|         0|            0|            0|  0.00%|    # corresponding condlist as a boolean mask. This is done in reverse
   732|         0|            0|            0|  0.00%|    # order since the first choice should take precedence.
   733|         0|            0|            0|  0.00%|    choicelist = choicelist[-2::-1]
   734|         0|            0|            0|  0.00%|    condlist = condlist[::-1]
   735|         0|            0|            0|  0.00%|    for choice, cond in zip(choicelist, condlist):
   736|         0|            0|            0|  0.00%|        np.copyto(result, choice, where=cond)
   737|         0|            0|            0|  0.00%|
   738|         0|            0|            0|  0.00%|    return result
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|
   741|         0|            0|            0|  0.00%|def _copy_dispatcher(a, order=None):
   742|         0|            0|            0|  0.00%|    return (a,)
   743|         0|            0|            0|  0.00%|
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|@array_function_dispatch(_copy_dispatcher)
   746|         0|            0|            0|  0.00%|def copy(a, order='K'):
   747|         0|            0|            0|  0.00%|    """
   748|         0|            0|            0|  0.00%|    Return an array copy of the given object.
   749|         0|            0|            0|  0.00%|
   750|         0|            0|            0|  0.00%|    Parameters
   751|         0|            0|            0|  0.00%|    ----------
   752|         0|            0|            0|  0.00%|    a : array_like
   753|         0|            0|            0|  0.00%|        Input data.
   754|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', 'K'}, optional
   755|         0|            0|            0|  0.00%|        Controls the memory layout of the copy. 'C' means C-order,
   756|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   757|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   758|         0|            0|            0|  0.00%|        as possible. (Note that this function and :meth:`ndarray.copy` are very
   759|         0|            0|            0|  0.00%|        similar, but have different default values for their order=
   760|         0|            0|            0|  0.00%|        arguments.)
   761|         0|            0|            0|  0.00%|
   762|         0|            0|            0|  0.00%|    Returns
   763|         0|            0|            0|  0.00%|    -------
   764|         0|            0|            0|  0.00%|    arr : ndarray
   765|         0|            0|            0|  0.00%|        Array interpretation of `a`.
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|    Notes
   768|         0|            0|            0|  0.00%|    -----
   769|         0|            0|            0|  0.00%|    This is equivalent to:
   770|         0|            0|            0|  0.00%|
   771|         0|            0|            0|  0.00%|    >>> np.array(a, copy=True)  #doctest: +SKIP
   772|         0|            0|            0|  0.00%|
   773|         0|            0|            0|  0.00%|    Examples
   774|         0|            0|            0|  0.00%|    --------
   775|         0|            0|            0|  0.00%|    Create an array x, with a reference y and a copy z:
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 3])
   778|         0|            0|            0|  0.00%|    >>> y = x
   779|         0|            0|            0|  0.00%|    >>> z = np.copy(x)
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    Note that, when we modify x, y changes, but not z:
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|    >>> x[0] = 10
   784|         0|            0|            0|  0.00%|    >>> x[0] == y[0]
   785|         0|            0|            0|  0.00%|    True
   786|         0|            0|            0|  0.00%|    >>> x[0] == z[0]
   787|         0|            0|            0|  0.00%|    False
   788|         0|            0|            0|  0.00%|
   789|         0|            0|            0|  0.00%|    """
   790|         0|            0|            0|  0.00%|    return array(a, order=order, copy=True)
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|# Basic operations
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|
   795|         0|            0|            0|  0.00%|def _gradient_dispatcher(f, *varargs, **kwargs):
   796|         0|            0|            0|  0.00%|    yield f
   797|         0|            0|            0|  0.00%|    for v in varargs:
   798|         0|            0|            0|  0.00%|        yield v
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|@array_function_dispatch(_gradient_dispatcher)
   802|         0|            0|            0|  0.00%|def gradient(f, *varargs, **kwargs):
   803|         0|            0|            0|  0.00%|    """
   804|         0|            0|            0|  0.00%|    Return the gradient of an N-dimensional array.
   805|         0|            0|            0|  0.00%|
   806|         0|            0|            0|  0.00%|    The gradient is computed using second order accurate central differences
   807|         0|            0|            0|  0.00%|    in the interior points and either first or second order accurate one-sides
   808|         0|            0|            0|  0.00%|    (forward or backwards) differences at the boundaries.
   809|         0|            0|            0|  0.00%|    The returned gradient hence has the same shape as the input array.
   810|         0|            0|            0|  0.00%|
   811|         0|            0|            0|  0.00%|    Parameters
   812|         0|            0|            0|  0.00%|    ----------
   813|         0|            0|            0|  0.00%|    f : array_like
   814|         0|            0|            0|  0.00%|        An N-dimensional array containing samples of a scalar function.
   815|         0|            0|            0|  0.00%|    varargs : list of scalar or array, optional
   816|         0|            0|            0|  0.00%|        Spacing between f values. Default unitary spacing for all dimensions.
   817|         0|            0|            0|  0.00%|        Spacing can be specified using:
   818|         0|            0|            0|  0.00%|
   819|         0|            0|            0|  0.00%|        1. single scalar to specify a sample distance for all dimensions.
   820|         0|            0|            0|  0.00%|        2. N scalars to specify a constant sample distance for each dimension.
   821|         0|            0|            0|  0.00%|           i.e. `dx`, `dy`, `dz`, ...
   822|         0|            0|            0|  0.00%|        3. N arrays to specify the coordinates of the values along each
   823|         0|            0|            0|  0.00%|           dimension of F. The length of the array must match the size of
   824|         0|            0|            0|  0.00%|           the corresponding dimension
   825|         0|            0|            0|  0.00%|        4. Any combination of N scalars/arrays with the meaning of 2. and 3.
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|        If `axis` is given, the number of varargs must equal the number of axes.
   828|         0|            0|            0|  0.00%|        Default: 1.
   829|         0|            0|            0|  0.00%|
   830|         0|            0|            0|  0.00%|    edge_order : {1, 2}, optional
   831|         0|            0|            0|  0.00%|        Gradient is calculated using N-th order accurate differences
   832|         0|            0|            0|  0.00%|        at the boundaries. Default: 1.
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.1
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|    axis : None or int or tuple of ints, optional
   837|         0|            0|            0|  0.00%|        Gradient is calculated only along the given axis or axes
   838|         0|            0|            0|  0.00%|        The default (axis = None) is to calculate the gradient for all the axes
   839|         0|            0|            0|  0.00%|        of the input array. axis may be negative, in which case it counts from
   840|         0|            0|            0|  0.00%|        the last to the first axis.
   841|         0|            0|            0|  0.00%|
   842|         0|            0|            0|  0.00%|        .. versionadded:: 1.11.0
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    Returns
   845|         0|            0|            0|  0.00%|    -------
   846|         0|            0|            0|  0.00%|    gradient : ndarray or list of ndarray
   847|         0|            0|            0|  0.00%|        A set of ndarrays (or a single ndarray if there is only one dimension)
   848|         0|            0|            0|  0.00%|        corresponding to the derivatives of f with respect to each dimension.
   849|         0|            0|            0|  0.00%|        Each derivative has the same shape as f.
   850|         0|            0|            0|  0.00%|
   851|         0|            0|            0|  0.00%|    Examples
   852|         0|            0|            0|  0.00%|    --------
   853|         0|            0|            0|  0.00%|    >>> f = np.array([1, 2, 4, 7, 11, 16], dtype=float)
   854|         0|            0|            0|  0.00%|    >>> np.gradient(f)
   855|         0|            0|            0|  0.00%|    array([1. , 1.5, 2.5, 3.5, 4.5, 5. ])
   856|         0|            0|            0|  0.00%|    >>> np.gradient(f, 2)
   857|         0|            0|            0|  0.00%|    array([0.5 ,  0.75,  1.25,  1.75,  2.25,  2.5 ])
   858|         0|            0|            0|  0.00%|
   859|         0|            0|            0|  0.00%|    Spacing can be also specified with an array that represents the coordinates
   860|         0|            0|            0|  0.00%|    of the values F along the dimensions.
   861|         0|            0|            0|  0.00%|    For instance a uniform spacing:
   862|         0|            0|            0|  0.00%|
   863|         0|            0|            0|  0.00%|    >>> x = np.arange(f.size)
   864|         0|            0|            0|  0.00%|    >>> np.gradient(f, x)
   865|         0|            0|            0|  0.00%|    array([1. ,  1.5,  2.5,  3.5,  4.5,  5. ])
   866|         0|            0|            0|  0.00%|
   867|         0|            0|            0|  0.00%|    Or a non uniform one:
   868|         0|            0|            0|  0.00%|
   869|         0|            0|            0|  0.00%|    >>> x = np.array([0., 1., 1.5, 3.5, 4., 6.], dtype=float)
   870|         0|            0|            0|  0.00%|    >>> np.gradient(f, x)
   871|         0|            0|            0|  0.00%|    array([1. ,  3. ,  3.5,  6.7,  6.9,  2.5])
   872|         0|            0|            0|  0.00%|
   873|         0|            0|            0|  0.00%|    For two dimensional arrays, the return will be two arrays ordered by
   874|         0|            0|            0|  0.00%|    axis. In this example the first array stands for the gradient in
   875|         0|            0|            0|  0.00%|    rows and the second one in columns direction:
   876|         0|            0|            0|  0.00%|
   877|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float))
   878|         0|            0|            0|  0.00%|    [array([[ 2.,  2., -1.],
   879|         0|            0|            0|  0.00%|           [ 2.,  2., -1.]]), array([[1. , 2.5, 4. ],
   880|         0|            0|            0|  0.00%|           [1. , 1. , 1. ]])]
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|    In this example the spacing is also specified:
   883|         0|            0|            0|  0.00%|    uniform for axis=0 and non uniform for axis=1
   884|         0|            0|            0|  0.00%|
   885|         0|            0|            0|  0.00%|    >>> dx = 2.
   886|         0|            0|            0|  0.00%|    >>> y = [1., 1.5, 3.5]
   887|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), dx, y)
   888|         0|            0|            0|  0.00%|    [array([[ 1. ,  1. , -0.5],
   889|         0|            0|            0|  0.00%|           [ 1. ,  1. , -0.5]]), array([[2. , 2. , 2. ],
   890|         0|            0|            0|  0.00%|           [2. , 1.7, 0.5]])]
   891|         0|            0|            0|  0.00%|
   892|         0|            0|            0|  0.00%|    It is possible to specify how boundaries are treated using `edge_order`
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    >>> x = np.array([0, 1, 2, 3, 4])
   895|         0|            0|            0|  0.00%|    >>> f = x**2
   896|         0|            0|            0|  0.00%|    >>> np.gradient(f, edge_order=1)
   897|         0|            0|            0|  0.00%|    array([1.,  2.,  4.,  6.,  7.])
   898|         0|            0|            0|  0.00%|    >>> np.gradient(f, edge_order=2)
   899|         0|            0|            0|  0.00%|    array([0., 2., 4., 6., 8.])
   900|         0|            0|            0|  0.00%|
   901|         0|            0|            0|  0.00%|    The `axis` keyword can be used to specify a subset of axes of which the
   902|         0|            0|            0|  0.00%|    gradient is calculated
   903|         0|            0|            0|  0.00%|
   904|         0|            0|            0|  0.00%|    >>> np.gradient(np.array([[1, 2, 6], [3, 4, 5]], dtype=float), axis=0)
   905|         0|            0|            0|  0.00%|    array([[ 2.,  2., -1.],
   906|         0|            0|            0|  0.00%|           [ 2.,  2., -1.]])
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|    Notes
   909|         0|            0|            0|  0.00%|    -----
   910|         0|            0|            0|  0.00%|    Assuming that :math:`f\\in C^{3}` (i.e., :math:`f` has at least 3 continuous
   911|         0|            0|            0|  0.00%|    derivatives) and let :math:`h_{*}` be a non-homogeneous stepsize, we
   912|         0|            0|            0|  0.00%|    minimize the "consistency error" :math:`\\eta_{i}` between the true gradient
   913|         0|            0|            0|  0.00%|    and its estimate from a linear combination of the neighboring grid-points:
   914|         0|            0|            0|  0.00%|
   915|         0|            0|            0|  0.00%|    .. math::
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|        \\eta_{i} = f_{i}^{\\left(1\\right)} -
   918|         0|            0|            0|  0.00%|                    \\left[ \\alpha f\\left(x_{i}\\right) +
   919|         0|            0|            0|  0.00%|                            \\beta f\\left(x_{i} + h_{d}\\right) +
   920|         0|            0|            0|  0.00%|                            \\gamma f\\left(x_{i}-h_{s}\\right)
   921|         0|            0|            0|  0.00%|                    \\right]
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|    By substituting :math:`f(x_{i} + h_{d})` and :math:`f(x_{i} - h_{s})`
   924|         0|            0|            0|  0.00%|    with their Taylor series expansion, this translates into solving
   925|         0|            0|            0|  0.00%|    the following the linear system:
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|    .. math::
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|        \\left\\{
   930|         0|            0|            0|  0.00%|            \\begin{array}{r}
   931|         0|            0|            0|  0.00%|                \\alpha+\\beta+\\gamma=0 \\\\
   932|         0|            0|            0|  0.00%|                \\beta h_{d}-\\gamma h_{s}=1 \\\\
   933|         0|            0|            0|  0.00%|                \\beta h_{d}^{2}+\\gamma h_{s}^{2}=0
   934|         0|            0|            0|  0.00%|            \\end{array}
   935|         0|            0|            0|  0.00%|        \\right.
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    The resulting approximation of :math:`f_{i}^{(1)}` is the following:
   938|         0|            0|            0|  0.00%|
   939|         0|            0|            0|  0.00%|    .. math::
   940|         0|            0|            0|  0.00%|
   941|         0|            0|            0|  0.00%|        \\hat f_{i}^{(1)} =
   942|         0|            0|            0|  0.00%|            \\frac{
   943|         0|            0|            0|  0.00%|                h_{s}^{2}f\\left(x_{i} + h_{d}\\right)
   944|         0|            0|            0|  0.00%|                + \\left(h_{d}^{2} - h_{s}^{2}\\right)f\\left(x_{i}\\right)
   945|         0|            0|            0|  0.00%|                - h_{d}^{2}f\\left(x_{i}-h_{s}\\right)}
   946|         0|            0|            0|  0.00%|                { h_{s}h_{d}\\left(h_{d} + h_{s}\\right)}
   947|         0|            0|            0|  0.00%|            + \\mathcal{O}\\left(\\frac{h_{d}h_{s}^{2}
   948|         0|            0|            0|  0.00%|                                + h_{s}h_{d}^{2}}{h_{d}
   949|         0|            0|            0|  0.00%|                                + h_{s}}\\right)
   950|         0|            0|            0|  0.00%|
   951|         0|            0|            0|  0.00%|    It is worth noting that if :math:`h_{s}=h_{d}`
   952|         0|            0|            0|  0.00%|    (i.e., data are evenly spaced)
   953|         0|            0|            0|  0.00%|    we find the standard second order approximation:
   954|         0|            0|            0|  0.00%|
   955|         0|            0|            0|  0.00%|    .. math::
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|        \\hat f_{i}^{(1)}=
   958|         0|            0|            0|  0.00%|            \\frac{f\\left(x_{i+1}\\right) - f\\left(x_{i-1}\\right)}{2h}
   959|         0|            0|            0|  0.00%|            + \\mathcal{O}\\left(h^{2}\\right)
   960|         0|            0|            0|  0.00%|
   961|         0|            0|            0|  0.00%|    With a similar procedure the forward/backward approximations used for
   962|         0|            0|            0|  0.00%|    boundaries can be derived.
   963|         0|            0|            0|  0.00%|
   964|         0|            0|            0|  0.00%|    References
   965|         0|            0|            0|  0.00%|    ----------
   966|         0|            0|            0|  0.00%|    .. [1]  Quarteroni A., Sacco R., Saleri F. (2007) Numerical Mathematics
   967|         0|            0|            0|  0.00%|            (Texts in Applied Mathematics). New York: Springer.
   968|         0|            0|            0|  0.00%|    .. [2]  Durran D. R. (1999) Numerical Methods for Wave Equations
   969|         0|            0|            0|  0.00%|            in Geophysical Fluid Dynamics. New York: Springer.
   970|         0|            0|            0|  0.00%|    .. [3]  Fornberg B. (1988) Generation of Finite Difference Formulas on
   971|         0|            0|            0|  0.00%|            Arbitrarily Spaced Grids,
   972|         0|            0|            0|  0.00%|            Mathematics of Computation 51, no. 184 : 699-706.
   973|         0|            0|            0|  0.00%|            `PDF <http://www.ams.org/journals/mcom/1988-51-184/
   974|         0|            0|            0|  0.00%|            S0025-5718-1988-0935077-0/S0025-5718-1988-0935077-0.pdf>`_.
   975|         0|            0|            0|  0.00%|    """
   976|         0|            0|            0|  0.00%|    f = np.asanyarray(f)
   977|         0|            0|            0|  0.00%|    N = f.ndim  # number of dimensions
   978|         0|            0|            0|  0.00%|
   979|         0|            0|            0|  0.00%|    axes = kwargs.pop('axis', None)
   980|         0|            0|            0|  0.00%|    if axes is None:
   981|         0|            0|            0|  0.00%|        axes = tuple(range(N))
   982|         0|            0|            0|  0.00%|    else:
   983|         0|            0|            0|  0.00%|        axes = _nx.normalize_axis_tuple(axes, N)
   984|         0|            0|            0|  0.00%|
   985|         0|            0|            0|  0.00%|    len_axes = len(axes)
   986|         0|            0|            0|  0.00%|    n = len(varargs)
   987|         0|            0|            0|  0.00%|    if n == 0:
   988|         0|            0|            0|  0.00%|        # no spacing argument - use 1 in all axes
   989|         0|            0|            0|  0.00%|        dx = [1.0] * len_axes
   990|         0|            0|            0|  0.00%|    elif n == 1 and np.ndim(varargs[0]) == 0:
   991|         0|            0|            0|  0.00%|        # single scalar for all axes
   992|         0|            0|            0|  0.00%|        dx = varargs * len_axes
   993|         0|            0|            0|  0.00%|    elif n == len_axes:
   994|         0|            0|            0|  0.00%|        # scalar or 1d array for each axis
   995|         0|            0|            0|  0.00%|        dx = list(varargs)
   996|         0|            0|            0|  0.00%|        for i, distances in enumerate(dx):
   997|         0|            0|            0|  0.00%|            if np.ndim(distances) == 0:
   998|         0|            0|            0|  0.00%|                continue
   999|         0|            0|            0|  0.00%|            elif np.ndim(distances) != 1:
  1000|         0|            0|            0|  0.00%|                raise ValueError("distances must be either scalars or 1d")
  1001|         0|            0|            0|  0.00%|            if len(distances) != f.shape[axes[i]]:
  1002|         0|            0|            0|  0.00%|                raise ValueError("when 1d, distances must match "
  1003|         0|            0|            0|  0.00%|                                 "the length of the corresponding dimension")
  1004|         0|            0|            0|  0.00%|            diffx = np.diff(distances)
  1005|         0|            0|            0|  0.00%|            # if distances are constant reduce to the scalar case
  1006|         0|            0|            0|  0.00%|            # since it brings a consistent speedup
  1007|         0|            0|            0|  0.00%|            if (diffx == diffx[0]).all():
  1008|         0|            0|            0|  0.00%|                diffx = diffx[0]
  1009|         0|            0|            0|  0.00%|            dx[i] = diffx
  1010|         0|            0|            0|  0.00%|    else:
  1011|         0|            0|            0|  0.00%|        raise TypeError("invalid number of arguments")
  1012|         0|            0|            0|  0.00%|
  1013|         0|            0|            0|  0.00%|    edge_order = kwargs.pop('edge_order', 1)
  1014|         0|            0|            0|  0.00%|    if kwargs:
  1015|         0|            0|            0|  0.00%|        raise TypeError('"{}" are not valid keyword arguments.'.format(
  1016|         0|            0|            0|  0.00%|                                                  '", "'.join(kwargs.keys())))
  1017|         0|            0|            0|  0.00%|    if edge_order > 2:
  1018|         0|            0|            0|  0.00%|        raise ValueError("'edge_order' greater than 2 not supported")
  1019|         0|            0|            0|  0.00%|
  1020|         0|            0|            0|  0.00%|    # use central differences on interior and one-sided differences on the
  1021|         0|            0|            0|  0.00%|    # endpoints. This preserves second order-accuracy over the full domain.
  1022|         0|            0|            0|  0.00%|
  1023|         0|            0|            0|  0.00%|    outvals = []
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    # create slice objects --- initially all are [:, :, ..., :]
  1026|         0|            0|            0|  0.00%|    slice1 = [slice(None)]*N
  1027|         0|            0|            0|  0.00%|    slice2 = [slice(None)]*N
  1028|         0|            0|            0|  0.00%|    slice3 = [slice(None)]*N
  1029|         0|            0|            0|  0.00%|    slice4 = [slice(None)]*N
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|    otype = f.dtype
  1032|         0|            0|            0|  0.00%|    if otype.type is np.datetime64:
  1033|         0|            0|            0|  0.00%|        # the timedelta dtype with the same unit information
  1034|         0|            0|            0|  0.00%|        otype = np.dtype(otype.name.replace('datetime', 'timedelta'))
  1035|         0|            0|            0|  0.00%|        # view as timedelta to allow addition
  1036|         0|            0|            0|  0.00%|        f = f.view(otype)
  1037|         0|            0|            0|  0.00%|    elif otype.type is np.timedelta64:
  1038|         0|            0|            0|  0.00%|        pass
  1039|         0|            0|            0|  0.00%|    elif np.issubdtype(otype, np.inexact):
  1040|         0|            0|            0|  0.00%|        pass
  1041|         0|            0|            0|  0.00%|    else:
  1042|         0|            0|            0|  0.00%|        # all other types convert to floating point
  1043|         0|            0|            0|  0.00%|        otype = np.double
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|    for axis, ax_dx in zip(axes, dx):
  1046|         0|            0|            0|  0.00%|        if f.shape[axis] < edge_order + 1:
  1047|         0|            0|            0|  0.00%|            raise ValueError(
  1048|         0|            0|            0|  0.00%|                "Shape of array too small to calculate a numerical gradient, "
  1049|         0|            0|            0|  0.00%|                "at least (edge_order + 1) elements are required.")
  1050|         0|            0|            0|  0.00%|        # result allocation
  1051|         0|            0|            0|  0.00%|        out = np.empty_like(f, dtype=otype)
  1052|         0|            0|            0|  0.00%|
  1053|         0|            0|            0|  0.00%|        # spacing for the current axis
  1054|         0|            0|            0|  0.00%|        uniform_spacing = np.ndim(ax_dx) == 0
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|        # Numerical differentiation: 2nd order interior
  1057|         0|            0|            0|  0.00%|        slice1[axis] = slice(1, -1)
  1058|         0|            0|            0|  0.00%|        slice2[axis] = slice(None, -2)
  1059|         0|            0|            0|  0.00%|        slice3[axis] = slice(1, -1)
  1060|         0|            0|            0|  0.00%|        slice4[axis] = slice(2, None)
  1061|         0|            0|            0|  0.00%|
  1062|         0|            0|            0|  0.00%|        if uniform_spacing:
  1063|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice4)] - f[tuple(slice2)]) / (2. * ax_dx)
  1064|         0|            0|            0|  0.00%|        else:
  1065|         0|            0|            0|  0.00%|            dx1 = ax_dx[0:-1]
  1066|         0|            0|            0|  0.00%|            dx2 = ax_dx[1:]
  1067|         0|            0|            0|  0.00%|            a = -(dx2)/(dx1 * (dx1 + dx2))
  1068|         0|            0|            0|  0.00%|            b = (dx2 - dx1) / (dx1 * dx2)
  1069|         0|            0|            0|  0.00%|            c = dx1 / (dx2 * (dx1 + dx2))
  1070|         0|            0|            0|  0.00%|            # fix the shape for broadcasting
  1071|         0|            0|            0|  0.00%|            shape = np.ones(N, dtype=int)
  1072|         0|            0|            0|  0.00%|            shape[axis] = -1
  1073|         0|            0|            0|  0.00%|            a.shape = b.shape = c.shape = shape
  1074|         0|            0|            0|  0.00%|            # 1D equivalent -- out[1:-1] = a * f[:-2] + b * f[1:-1] + c * f[2:]
  1075|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1076|         0|            0|            0|  0.00%|
  1077|         0|            0|            0|  0.00%|        # Numerical differentiation: 1st order edges
  1078|         0|            0|            0|  0.00%|        if edge_order == 1:
  1079|         0|            0|            0|  0.00%|            slice1[axis] = 0
  1080|         0|            0|            0|  0.00%|            slice2[axis] = 1
  1081|         0|            0|            0|  0.00%|            slice3[axis] = 0
  1082|         0|            0|            0|  0.00%|            dx_0 = ax_dx if uniform_spacing else ax_dx[0]
  1083|         0|            0|            0|  0.00%|            # 1D equivalent -- out[0] = (f[1] - f[0]) / (x[1] - x[0])
  1084|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_0
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|            slice1[axis] = -1
  1087|         0|            0|            0|  0.00%|            slice2[axis] = -1
  1088|         0|            0|            0|  0.00%|            slice3[axis] = -2
  1089|         0|            0|            0|  0.00%|            dx_n = ax_dx if uniform_spacing else ax_dx[-1]
  1090|         0|            0|            0|  0.00%|            # 1D equivalent -- out[-1] = (f[-1] - f[-2]) / (x[-1] - x[-2])
  1091|         0|            0|            0|  0.00%|            out[tuple(slice1)] = (f[tuple(slice2)] - f[tuple(slice3)]) / dx_n
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|        # Numerical differentiation: 2nd order edges
  1094|         0|            0|            0|  0.00%|        else:
  1095|         0|            0|            0|  0.00%|            slice1[axis] = 0
  1096|         0|            0|            0|  0.00%|            slice2[axis] = 0
  1097|         0|            0|            0|  0.00%|            slice3[axis] = 1
  1098|         0|            0|            0|  0.00%|            slice4[axis] = 2
  1099|         0|            0|            0|  0.00%|            if uniform_spacing:
  1100|         0|            0|            0|  0.00%|                a = -1.5 / ax_dx
  1101|         0|            0|            0|  0.00%|                b = 2. / ax_dx
  1102|         0|            0|            0|  0.00%|                c = -0.5 / ax_dx
  1103|         0|            0|            0|  0.00%|            else:
  1104|         0|            0|            0|  0.00%|                dx1 = ax_dx[0]
  1105|         0|            0|            0|  0.00%|                dx2 = ax_dx[1]
  1106|         0|            0|            0|  0.00%|                a = -(2. * dx1 + dx2)/(dx1 * (dx1 + dx2))
  1107|         0|            0|            0|  0.00%|                b = (dx1 + dx2) / (dx1 * dx2)
  1108|         0|            0|            0|  0.00%|                c = - dx1 / (dx2 * (dx1 + dx2))
  1109|         0|            0|            0|  0.00%|            # 1D equivalent -- out[0] = a * f[0] + b * f[1] + c * f[2]
  1110|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1111|         0|            0|            0|  0.00%|
  1112|         0|            0|            0|  0.00%|            slice1[axis] = -1
  1113|         0|            0|            0|  0.00%|            slice2[axis] = -3
  1114|         0|            0|            0|  0.00%|            slice3[axis] = -2
  1115|         0|            0|            0|  0.00%|            slice4[axis] = -1
  1116|         0|            0|            0|  0.00%|            if uniform_spacing:
  1117|         0|            0|            0|  0.00%|                a = 0.5 / ax_dx
  1118|         0|            0|            0|  0.00%|                b = -2. / ax_dx
  1119|         0|            0|            0|  0.00%|                c = 1.5 / ax_dx
  1120|         0|            0|            0|  0.00%|            else:
  1121|         0|            0|            0|  0.00%|                dx1 = ax_dx[-2]
  1122|         0|            0|            0|  0.00%|                dx2 = ax_dx[-1]
  1123|         0|            0|            0|  0.00%|                a = (dx2) / (dx1 * (dx1 + dx2))
  1124|         0|            0|            0|  0.00%|                b = - (dx2 + dx1) / (dx1 * dx2)
  1125|         0|            0|            0|  0.00%|                c = (2. * dx2 + dx1) / (dx2 * (dx1 + dx2))
  1126|         0|            0|            0|  0.00%|            # 1D equivalent -- out[-1] = a * f[-3] + b * f[-2] + c * f[-1]
  1127|         0|            0|            0|  0.00%|            out[tuple(slice1)] = a * f[tuple(slice2)] + b * f[tuple(slice3)] + c * f[tuple(slice4)]
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|        outvals.append(out)
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|        # reset the slice object in this dimension to ":"
  1132|         0|            0|            0|  0.00%|        slice1[axis] = slice(None)
  1133|         0|            0|            0|  0.00%|        slice2[axis] = slice(None)
  1134|         0|            0|            0|  0.00%|        slice3[axis] = slice(None)
  1135|         0|            0|            0|  0.00%|        slice4[axis] = slice(None)
  1136|         0|            0|            0|  0.00%|
  1137|         0|            0|            0|  0.00%|    if len_axes == 1:
  1138|         0|            0|            0|  0.00%|        return outvals[0]
  1139|         0|            0|            0|  0.00%|    else:
  1140|         0|            0|            0|  0.00%|        return outvals
  1141|         0|            0|            0|  0.00%|
  1142|         0|            0|            0|  0.00%|
  1143|         1|   3.8147e-06|   3.8147e-06|  0.00%|def _diff_dispatcher(a, n=None, axis=None, prepend=None, append=None):
  1144|         1|  7.86781e-06|  7.86781e-06|  0.00%|    return (a, prepend, append)
  1145|         0|            0|            0|  0.00%|
  1146|         0|            0|            0|  0.00%|
  1147|         1|   1.0252e-05|   1.0252e-05|  0.00%|@array_function_dispatch(_diff_dispatcher)
  1148|         0|            0|            0|  0.00%|def diff(a, n=1, axis=-1, prepend=np._NoValue, append=np._NoValue):
  1149|         0|            0|            0|  0.00%|    """
  1150|         0|            0|            0|  0.00%|    Calculate the n-th discrete difference along the given axis.
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|    The first difference is given by ``out[i] = a[i+1] - a[i]`` along
  1153|         0|            0|            0|  0.00%|    the given axis, higher differences are calculated by using `diff`
  1154|         0|            0|            0|  0.00%|    recursively.
  1155|         0|            0|            0|  0.00%|
  1156|         0|            0|            0|  0.00%|    Parameters
  1157|         0|            0|            0|  0.00%|    ----------
  1158|         0|            0|            0|  0.00%|    a : array_like
  1159|         0|            0|            0|  0.00%|        Input array
  1160|         0|            0|            0|  0.00%|    n : int, optional
  1161|         0|            0|            0|  0.00%|        The number of times values are differenced. If zero, the input
  1162|         0|            0|            0|  0.00%|        is returned as-is.
  1163|         0|            0|            0|  0.00%|    axis : int, optional
  1164|         0|            0|            0|  0.00%|        The axis along which the difference is taken, default is the
  1165|         0|            0|            0|  0.00%|        last axis.
  1166|         0|            0|            0|  0.00%|    prepend, append : array_like, optional
  1167|         0|            0|            0|  0.00%|        Values to prepend or append to "a" along axis prior to
  1168|         0|            0|            0|  0.00%|        performing the difference.  Scalar values are expanded to
  1169|         0|            0|            0|  0.00%|        arrays with length 1 in the direction of axis and the shape
  1170|         0|            0|            0|  0.00%|        of the input array in along all other axes.  Otherwise the
  1171|         0|            0|            0|  0.00%|        dimension and shape must match "a" except along axis.
  1172|         0|            0|            0|  0.00%|
  1173|         0|            0|            0|  0.00%|    Returns
  1174|         0|            0|            0|  0.00%|    -------
  1175|         0|            0|            0|  0.00%|    diff : ndarray
  1176|         0|            0|            0|  0.00%|        The n-th differences. The shape of the output is the same as `a`
  1177|         0|            0|            0|  0.00%|        except along `axis` where the dimension is smaller by `n`. The
  1178|         0|            0|            0|  0.00%|        type of the output is the same as the type of the difference
  1179|         0|            0|            0|  0.00%|        between any two elements of `a`. This is the same as the type of
  1180|         0|            0|            0|  0.00%|        `a` in most cases. A notable exception is `datetime64`, which
  1181|         0|            0|            0|  0.00%|        results in a `timedelta64` output array.
  1182|         0|            0|            0|  0.00%|
  1183|         0|            0|            0|  0.00%|    See Also
  1184|         0|            0|            0|  0.00%|    --------
  1185|         0|            0|            0|  0.00%|    gradient, ediff1d, cumsum
  1186|         0|            0|            0|  0.00%|
  1187|         0|            0|            0|  0.00%|    Notes
  1188|         0|            0|            0|  0.00%|    -----
  1189|         0|            0|            0|  0.00%|    Type is preserved for boolean arrays, so the result will contain
  1190|         0|            0|            0|  0.00%|    `False` when consecutive elements are the same and `True` when they
  1191|         0|            0|            0|  0.00%|    differ.
  1192|         0|            0|            0|  0.00%|
  1193|         0|            0|            0|  0.00%|    For unsigned integer arrays, the results will also be unsigned. This
  1194|         0|            0|            0|  0.00%|    should not be surprising, as the result is consistent with
  1195|         0|            0|            0|  0.00%|    calculating the difference directly:
  1196|         0|            0|            0|  0.00%|
  1197|         0|            0|            0|  0.00%|    >>> u8_arr = np.array([1, 0], dtype=np.uint8)
  1198|         0|            0|            0|  0.00%|    >>> np.diff(u8_arr)
  1199|         0|            0|            0|  0.00%|    array([255], dtype=uint8)
  1200|         0|            0|            0|  0.00%|    >>> u8_arr[1,...] - u8_arr[0,...]
  1201|         0|            0|            0|  0.00%|    255
  1202|         0|            0|            0|  0.00%|
  1203|         0|            0|            0|  0.00%|    If this is not desirable, then the array should be cast to a larger
  1204|         0|            0|            0|  0.00%|    integer type first:
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|    >>> i16_arr = u8_arr.astype(np.int16)
  1207|         0|            0|            0|  0.00%|    >>> np.diff(i16_arr)
  1208|         0|            0|            0|  0.00%|    array([-1], dtype=int16)
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|    Examples
  1211|         0|            0|            0|  0.00%|    --------
  1212|         0|            0|            0|  0.00%|    >>> x = np.array([1, 2, 4, 7, 0])
  1213|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1214|         0|            0|            0|  0.00%|    array([ 1,  2,  3, -7])
  1215|         0|            0|            0|  0.00%|    >>> np.diff(x, n=2)
  1216|         0|            0|            0|  0.00%|    array([  1,   1, -10])
  1217|         0|            0|            0|  0.00%|
  1218|         0|            0|            0|  0.00%|    >>> x = np.array([[1, 3, 6, 10], [0, 5, 6, 8]])
  1219|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1220|         0|            0|            0|  0.00%|    array([[2, 3, 4],
  1221|         0|            0|            0|  0.00%|           [5, 1, 2]])
  1222|         0|            0|            0|  0.00%|    >>> np.diff(x, axis=0)
  1223|         0|            0|            0|  0.00%|    array([[-1,  2,  0, -2]])
  1224|         0|            0|            0|  0.00%|
  1225|         0|            0|            0|  0.00%|    >>> x = np.arange('1066-10-13', '1066-10-16', dtype=np.datetime64)
  1226|         0|            0|            0|  0.00%|    >>> np.diff(x)
  1227|         0|            0|            0|  0.00%|    array([1, 1], dtype='timedelta64[D]')
  1228|         0|            0|            0|  0.00%|
  1229|         0|            0|            0|  0.00%|    """
  1230|         1|  5.24521e-06|  5.24521e-06|  0.00%|    if n == 0:
  1231|         0|            0|            0|  0.00%|        return a
  1232|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if n < 0:
  1233|         0|            0|            0|  0.00%|        raise ValueError(
  1234|         0|            0|            0|  0.00%|            "order must be non-negative but got " + repr(n))
  1235|         0|            0|            0|  0.00%|
  1236|         1|  1.12057e-05|  1.12057e-05|  0.00%|    a = asanyarray(a)
(call)|         1|  9.29832e-06|  9.29832e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
  1237|         1|  5.96046e-06|  5.96046e-06|  0.00%|    nd = a.ndim
  1238|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if nd == 0:
  1239|         0|            0|            0|  0.00%|        raise ValueError("diff requires input that is at least one dimensional")
  1240|         1|  5.48363e-06|  5.48363e-06|  0.00%|    axis = normalize_axis_index(axis, nd)
  1241|         0|            0|            0|  0.00%|
  1242|         1|  5.72205e-06|  5.72205e-06|  0.00%|    combined = []
  1243|         1|  5.00679e-06|  5.00679e-06|  0.00%|    if prepend is not np._NoValue:
  1244|         0|            0|            0|  0.00%|        prepend = np.asanyarray(prepend)
  1245|         0|            0|            0|  0.00%|        if prepend.ndim == 0:
  1246|         0|            0|            0|  0.00%|            shape = list(a.shape)
  1247|         0|            0|            0|  0.00%|            shape[axis] = 1
  1248|         0|            0|            0|  0.00%|            prepend = np.broadcast_to(prepend, tuple(shape))
  1249|         0|            0|            0|  0.00%|        combined.append(prepend)
  1250|         0|            0|            0|  0.00%|
  1251|         1|  5.00679e-06|  5.00679e-06|  0.00%|    combined.append(a)
  1252|         0|            0|            0|  0.00%|
  1253|         1|  6.19888e-06|  6.19888e-06|  0.00%|    if append is not np._NoValue:
  1254|         0|            0|            0|  0.00%|        append = np.asanyarray(append)
  1255|         0|            0|            0|  0.00%|        if append.ndim == 0:
  1256|         0|            0|            0|  0.00%|            shape = list(a.shape)
  1257|         0|            0|            0|  0.00%|            shape[axis] = 1
  1258|         0|            0|            0|  0.00%|            append = np.broadcast_to(append, tuple(shape))
  1259|         0|            0|            0|  0.00%|        combined.append(append)
  1260|         0|            0|            0|  0.00%|
  1261|         1|  4.76837e-06|  4.76837e-06|  0.00%|    if len(combined) > 1:
  1262|         0|            0|            0|  0.00%|        a = np.concatenate(combined, axis)
  1263|         0|            0|            0|  0.00%|
  1264|         1|  5.48363e-06|  5.48363e-06|  0.00%|    slice1 = [slice(None)] * nd
  1265|         1|  5.00679e-06|  5.00679e-06|  0.00%|    slice2 = [slice(None)] * nd
  1266|         1|  5.24521e-06|  5.24521e-06|  0.00%|    slice1[axis] = slice(1, None)
  1267|         1|  4.52995e-06|  4.52995e-06|  0.00%|    slice2[axis] = slice(None, -1)
  1268|         1|  5.00679e-06|  5.00679e-06|  0.00%|    slice1 = tuple(slice1)
  1269|         1|  4.52995e-06|  4.52995e-06|  0.00%|    slice2 = tuple(slice2)
  1270|         0|            0|            0|  0.00%|
  1271|         1|  7.39098e-06|  7.39098e-06|  0.00%|    op = not_equal if a.dtype == np.bool_ else subtract
  1272|         2|  1.14441e-05|  5.72205e-06|  0.00%|    for _ in range(n):
  1273|         1|  1.40667e-05|  1.40667e-05|  0.00%|        a = op(a[slice1], a[slice2])
  1274|         0|            0|            0|  0.00%|
  1275|         1|  3.33786e-06|  3.33786e-06|  0.00%|    return a
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|def _interp_dispatcher(x, xp, fp, left=None, right=None, period=None):
  1279|         0|            0|            0|  0.00%|    return (x, xp, fp)
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|
  1282|         0|            0|            0|  0.00%|@array_function_dispatch(_interp_dispatcher)
  1283|         0|            0|            0|  0.00%|def interp(x, xp, fp, left=None, right=None, period=None):
  1284|         0|            0|            0|  0.00%|    """
  1285|         0|            0|            0|  0.00%|    One-dimensional linear interpolation.
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    Returns the one-dimensional piecewise linear interpolant to a function
  1288|         0|            0|            0|  0.00%|    with given discrete data points (`xp`, `fp`), evaluated at `x`.
  1289|         0|            0|            0|  0.00%|
  1290|         0|            0|            0|  0.00%|    Parameters
  1291|         0|            0|            0|  0.00%|    ----------
  1292|         0|            0|            0|  0.00%|    x : array_like
  1293|         0|            0|            0|  0.00%|        The x-coordinates at which to evaluate the interpolated values.
  1294|         0|            0|            0|  0.00%|
  1295|         0|            0|            0|  0.00%|    xp : 1-D sequence of floats
  1296|         0|            0|            0|  0.00%|        The x-coordinates of the data points, must be increasing if argument
  1297|         0|            0|            0|  0.00%|        `period` is not specified. Otherwise, `xp` is internally sorted after
  1298|         0|            0|            0|  0.00%|        normalizing the periodic boundaries with ``xp = xp % period``.
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    fp : 1-D sequence of float or complex
  1301|         0|            0|            0|  0.00%|        The y-coordinates of the data points, same length as `xp`.
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|    left : optional float or complex corresponding to fp
  1304|         0|            0|            0|  0.00%|        Value to return for `x < xp[0]`, default is `fp[0]`.
  1305|         0|            0|            0|  0.00%|
  1306|         0|            0|            0|  0.00%|    right : optional float or complex corresponding to fp
  1307|         0|            0|            0|  0.00%|        Value to return for `x > xp[-1]`, default is `fp[-1]`.
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|    period : None or float, optional
  1310|         0|            0|            0|  0.00%|        A period for the x-coordinates. This parameter allows the proper
  1311|         0|            0|            0|  0.00%|        interpolation of angular x-coordinates. Parameters `left` and `right`
  1312|         0|            0|            0|  0.00%|        are ignored if `period` is specified.
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  1315|         0|            0|            0|  0.00%|
  1316|         0|            0|            0|  0.00%|    Returns
  1317|         0|            0|            0|  0.00%|    -------
  1318|         0|            0|            0|  0.00%|    y : float or complex (corresponding to fp) or ndarray
  1319|         0|            0|            0|  0.00%|        The interpolated values, same shape as `x`.
  1320|         0|            0|            0|  0.00%|
  1321|         0|            0|            0|  0.00%|    Raises
  1322|         0|            0|            0|  0.00%|    ------
  1323|         0|            0|            0|  0.00%|    ValueError
  1324|         0|            0|            0|  0.00%|        If `xp` and `fp` have different length
  1325|         0|            0|            0|  0.00%|        If `xp` or `fp` are not 1-D sequences
  1326|         0|            0|            0|  0.00%|        If `period == 0`
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|    Notes
  1329|         0|            0|            0|  0.00%|    -----
  1330|         0|            0|            0|  0.00%|    Does not check that the x-coordinate sequence `xp` is increasing.
  1331|         0|            0|            0|  0.00%|    If `xp` is not increasing, the results are nonsense.
  1332|         0|            0|            0|  0.00%|    A simple check for increasing is::
  1333|         0|            0|            0|  0.00%|
  1334|         0|            0|            0|  0.00%|        np.all(np.diff(xp) > 0)
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|    Examples
  1337|         0|            0|            0|  0.00%|    --------
  1338|         0|            0|            0|  0.00%|    >>> xp = [1, 2, 3]
  1339|         0|            0|            0|  0.00%|    >>> fp = [3, 2, 0]
  1340|         0|            0|            0|  0.00%|    >>> np.interp(2.5, xp, fp)
  1341|         0|            0|            0|  0.00%|    1.0
  1342|         0|            0|            0|  0.00%|    >>> np.interp([0, 1, 1.5, 2.72, 3.14], xp, fp)
  1343|         0|            0|            0|  0.00%|    array([3.  , 3.  , 2.5 , 0.56, 0.  ])
  1344|         0|            0|            0|  0.00%|    >>> UNDEF = -99.0
  1345|         0|            0|            0|  0.00%|    >>> np.interp(3.14, xp, fp, right=UNDEF)
  1346|         0|            0|            0|  0.00%|    -99.0
  1347|         0|            0|            0|  0.00%|
  1348|         0|            0|            0|  0.00%|    Plot an interpolant to the sine function:
  1349|         0|            0|            0|  0.00%|
  1350|         0|            0|            0|  0.00%|    >>> x = np.linspace(0, 2*np.pi, 10)
  1351|         0|            0|            0|  0.00%|    >>> y = np.sin(x)
  1352|         0|            0|            0|  0.00%|    >>> xvals = np.linspace(0, 2*np.pi, 50)
  1353|         0|            0|            0|  0.00%|    >>> yinterp = np.interp(xvals, x, y)
  1354|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  1355|         0|            0|            0|  0.00%|    >>> plt.plot(x, y, 'o')
  1356|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  1357|         0|            0|            0|  0.00%|    >>> plt.plot(xvals, yinterp, '-x')
  1358|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  1359|         0|            0|            0|  0.00%|    >>> plt.show()
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|    Interpolation with periodic x-coordinates:
  1362|         0|            0|            0|  0.00%|
  1363|         0|            0|            0|  0.00%|    >>> x = [-180, -170, -185, 185, -10, -5, 0, 365]
  1364|         0|            0|            0|  0.00%|    >>> xp = [190, -190, 350, -350]
  1365|         0|            0|            0|  0.00%|    >>> fp = [5, 10, 3, 4]
  1366|         0|            0|            0|  0.00%|    >>> np.interp(x, xp, fp, period=360)
  1367|         0|            0|            0|  0.00%|    array([7.5 , 5.  , 8.75, 6.25, 3.  , 3.25, 3.5 , 3.75])
  1368|         0|            0|            0|  0.00%|
  1369|         0|            0|            0|  0.00%|    Complex interpolation:
  1370|         0|            0|            0|  0.00%|
  1371|         0|            0|            0|  0.00%|    >>> x = [1.5, 4.0]
  1372|         0|            0|            0|  0.00%|    >>> xp = [2,3,5]
  1373|         0|            0|            0|  0.00%|    >>> fp = [1.0j, 0, 2+3j]
  1374|         0|            0|            0|  0.00%|    >>> np.interp(x, xp, fp)
  1375|         0|            0|            0|  0.00%|    array([0.+1.j , 1.+1.5j])
  1376|         0|            0|            0|  0.00%|
  1377|         0|            0|            0|  0.00%|    """
  1378|         0|            0|            0|  0.00%|
  1379|         0|            0|            0|  0.00%|    fp = np.asarray(fp)
  1380|         0|            0|            0|  0.00%|
  1381|         0|            0|            0|  0.00%|    if np.iscomplexobj(fp):
  1382|         0|            0|            0|  0.00%|        interp_func = compiled_interp_complex
  1383|         0|            0|            0|  0.00%|        input_dtype = np.complex128
  1384|         0|            0|            0|  0.00%|    else:
  1385|         0|            0|            0|  0.00%|        interp_func = compiled_interp
  1386|         0|            0|            0|  0.00%|        input_dtype = np.float64
  1387|         0|            0|            0|  0.00%|
  1388|         0|            0|            0|  0.00%|    if period is not None:
  1389|         0|            0|            0|  0.00%|        if period == 0:
  1390|         0|            0|            0|  0.00%|            raise ValueError("period must be a non-zero value")
  1391|         0|            0|            0|  0.00%|        period = abs(period)
  1392|         0|            0|            0|  0.00%|        left = None
  1393|         0|            0|            0|  0.00%|        right = None
  1394|         0|            0|            0|  0.00%|
  1395|         0|            0|            0|  0.00%|        x = np.asarray(x, dtype=np.float64)
  1396|         0|            0|            0|  0.00%|        xp = np.asarray(xp, dtype=np.float64)
  1397|         0|            0|            0|  0.00%|        fp = np.asarray(fp, dtype=input_dtype)
  1398|         0|            0|            0|  0.00%|
  1399|         0|            0|            0|  0.00%|        if xp.ndim != 1 or fp.ndim != 1:
  1400|         0|            0|            0|  0.00%|            raise ValueError("Data points must be 1-D sequences")
  1401|         0|            0|            0|  0.00%|        if xp.shape[0] != fp.shape[0]:
  1402|         0|            0|            0|  0.00%|            raise ValueError("fp and xp are not of the same length")
  1403|         0|            0|            0|  0.00%|        # normalizing periodic boundaries
  1404|         0|            0|            0|  0.00%|        x = x % period
  1405|         0|            0|            0|  0.00%|        xp = xp % period
  1406|         0|            0|            0|  0.00%|        asort_xp = np.argsort(xp)
  1407|         0|            0|            0|  0.00%|        xp = xp[asort_xp]
  1408|         0|            0|            0|  0.00%|        fp = fp[asort_xp]
  1409|         0|            0|            0|  0.00%|        xp = np.concatenate((xp[-1:]-period, xp, xp[0:1]+period))
  1410|         0|            0|            0|  0.00%|        fp = np.concatenate((fp[-1:], fp, fp[0:1]))
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|    return interp_func(x, xp, fp, left, right)
  1413|         0|            0|            0|  0.00%|
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|def _angle_dispatcher(z, deg=None):
  1416|         0|            0|            0|  0.00%|    return (z,)
  1417|         0|            0|            0|  0.00%|
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|@array_function_dispatch(_angle_dispatcher)
  1420|         0|            0|            0|  0.00%|def angle(z, deg=False):
  1421|         0|            0|            0|  0.00%|    """
  1422|         0|            0|            0|  0.00%|    Return the angle of the complex argument.
  1423|         0|            0|            0|  0.00%|
  1424|         0|            0|            0|  0.00%|    Parameters
  1425|         0|            0|            0|  0.00%|    ----------
  1426|         0|            0|            0|  0.00%|    z : array_like
  1427|         0|            0|            0|  0.00%|        A complex number or sequence of complex numbers.
  1428|         0|            0|            0|  0.00%|    deg : bool, optional
  1429|         0|            0|            0|  0.00%|        Return angle in degrees if True, radians if False (default).
  1430|         0|            0|            0|  0.00%|
  1431|         0|            0|            0|  0.00%|    Returns
  1432|         0|            0|            0|  0.00%|    -------
  1433|         0|            0|            0|  0.00%|    angle : ndarray or scalar
  1434|         0|            0|            0|  0.00%|        The counterclockwise angle from the positive real axis on the complex
  1435|         0|            0|            0|  0.00%|        plane in the range ``(-pi, pi]``, with dtype as numpy.float64.
  1436|         0|            0|            0|  0.00%|
  1437|         0|            0|            0|  0.00%|        ..versionchanged:: 1.16.0
  1438|         0|            0|            0|  0.00%|            This function works on subclasses of ndarray like `ma.array`.
  1439|         0|            0|            0|  0.00%|
  1440|         0|            0|            0|  0.00%|    See Also
  1441|         0|            0|            0|  0.00%|    --------
  1442|         0|            0|            0|  0.00%|    arctan2
  1443|         0|            0|            0|  0.00%|    absolute
  1444|         0|            0|            0|  0.00%|
  1445|         0|            0|            0|  0.00%|    Examples
  1446|         0|            0|            0|  0.00%|    --------
  1447|         0|            0|            0|  0.00%|    >>> np.angle([1.0, 1.0j, 1+1j])               # in radians
  1448|         0|            0|            0|  0.00%|    array([ 0.        ,  1.57079633,  0.78539816]) # may vary
  1449|         0|            0|            0|  0.00%|    >>> np.angle(1+1j, deg=True)                  # in degrees
  1450|         0|            0|            0|  0.00%|    45.0
  1451|         0|            0|            0|  0.00%|
  1452|         0|            0|            0|  0.00%|    """
  1453|         0|            0|            0|  0.00%|    z = asanyarray(z)
  1454|         0|            0|            0|  0.00%|    if issubclass(z.dtype.type, _nx.complexfloating):
  1455|         0|            0|            0|  0.00%|        zimag = z.imag
  1456|         0|            0|            0|  0.00%|        zreal = z.real
  1457|         0|            0|            0|  0.00%|    else:
  1458|         0|            0|            0|  0.00%|        zimag = 0
  1459|         0|            0|            0|  0.00%|        zreal = z
  1460|         0|            0|            0|  0.00%|
  1461|         0|            0|            0|  0.00%|    a = arctan2(zimag, zreal)
  1462|         0|            0|            0|  0.00%|    if deg:
  1463|         0|            0|            0|  0.00%|        a *= 180/pi
  1464|         0|            0|            0|  0.00%|    return a
  1465|         0|            0|            0|  0.00%|
  1466|         0|            0|            0|  0.00%|
  1467|         0|            0|            0|  0.00%|def _unwrap_dispatcher(p, discont=None, axis=None):
  1468|         0|            0|            0|  0.00%|    return (p,)
  1469|         0|            0|            0|  0.00%|
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|@array_function_dispatch(_unwrap_dispatcher)
  1472|         0|            0|            0|  0.00%|def unwrap(p, discont=pi, axis=-1):
  1473|         0|            0|            0|  0.00%|    """
  1474|         0|            0|            0|  0.00%|    Unwrap by changing deltas between values to 2*pi complement.
  1475|         0|            0|            0|  0.00%|
  1476|         0|            0|            0|  0.00%|    Unwrap radian phase `p` by changing absolute jumps greater than
  1477|         0|            0|            0|  0.00%|    `discont` to their 2*pi complement along the given axis.
  1478|         0|            0|            0|  0.00%|
  1479|         0|            0|            0|  0.00%|    Parameters
  1480|         0|            0|            0|  0.00%|    ----------
  1481|         0|            0|            0|  0.00%|    p : array_like
  1482|         0|            0|            0|  0.00%|        Input array.
  1483|         0|            0|            0|  0.00%|    discont : float, optional
  1484|         0|            0|            0|  0.00%|        Maximum discontinuity between values, default is ``pi``.
  1485|         0|            0|            0|  0.00%|    axis : int, optional
  1486|         0|            0|            0|  0.00%|        Axis along which unwrap will operate, default is the last axis.
  1487|         0|            0|            0|  0.00%|
  1488|         0|            0|            0|  0.00%|    Returns
  1489|         0|            0|            0|  0.00%|    -------
  1490|         0|            0|            0|  0.00%|    out : ndarray
  1491|         0|            0|            0|  0.00%|        Output array.
  1492|         0|            0|            0|  0.00%|
  1493|         0|            0|            0|  0.00%|    See Also
  1494|         0|            0|            0|  0.00%|    --------
  1495|         0|            0|            0|  0.00%|    rad2deg, deg2rad
  1496|         0|            0|            0|  0.00%|
  1497|         0|            0|            0|  0.00%|    Notes
  1498|         0|            0|            0|  0.00%|    -----
  1499|         0|            0|            0|  0.00%|    If the discontinuity in `p` is smaller than ``pi``, but larger than
  1500|         0|            0|            0|  0.00%|    `discont`, no unwrapping is done because taking the 2*pi complement
  1501|         0|            0|            0|  0.00%|    would only make the discontinuity larger.
  1502|         0|            0|            0|  0.00%|
  1503|         0|            0|            0|  0.00%|    Examples
  1504|         0|            0|            0|  0.00%|    --------
  1505|         0|            0|            0|  0.00%|    >>> phase = np.linspace(0, np.pi, num=5)
  1506|         0|            0|            0|  0.00%|    >>> phase[3:] += np.pi
  1507|         0|            0|            0|  0.00%|    >>> phase
  1508|         0|            0|            0|  0.00%|    array([ 0.        ,  0.78539816,  1.57079633,  5.49778714,  6.28318531]) # may vary
  1509|         0|            0|            0|  0.00%|    >>> np.unwrap(phase)
  1510|         0|            0|            0|  0.00%|    array([ 0.        ,  0.78539816,  1.57079633, -0.78539816,  0.        ]) # may vary
  1511|         0|            0|            0|  0.00%|
  1512|         0|            0|            0|  0.00%|    """
  1513|         0|            0|            0|  0.00%|    p = asarray(p)
  1514|         0|            0|            0|  0.00%|    nd = p.ndim
  1515|         0|            0|            0|  0.00%|    dd = diff(p, axis=axis)
  1516|         0|            0|            0|  0.00%|    slice1 = [slice(None, None)]*nd     # full slices
  1517|         0|            0|            0|  0.00%|    slice1[axis] = slice(1, None)
  1518|         0|            0|            0|  0.00%|    slice1 = tuple(slice1)
  1519|         0|            0|            0|  0.00%|    ddmod = mod(dd + pi, 2*pi) - pi
  1520|         0|            0|            0|  0.00%|    _nx.copyto(ddmod, pi, where=(ddmod == -pi) & (dd > 0))
  1521|         0|            0|            0|  0.00%|    ph_correct = ddmod - dd
  1522|         0|            0|            0|  0.00%|    _nx.copyto(ph_correct, 0, where=abs(dd) < discont)
  1523|         0|            0|            0|  0.00%|    up = array(p, copy=True, dtype='d')
  1524|         0|            0|            0|  0.00%|    up[slice1] = p[slice1] + ph_correct.cumsum(axis)
  1525|         0|            0|            0|  0.00%|    return up
  1526|         0|            0|            0|  0.00%|
  1527|         0|            0|            0|  0.00%|
  1528|         0|            0|            0|  0.00%|def _sort_complex(a):
  1529|         0|            0|            0|  0.00%|    return (a,)
  1530|         0|            0|            0|  0.00%|
  1531|         0|            0|            0|  0.00%|
  1532|         0|            0|            0|  0.00%|@array_function_dispatch(_sort_complex)
  1533|         0|            0|            0|  0.00%|def sort_complex(a):
  1534|         0|            0|            0|  0.00%|    """
  1535|         0|            0|            0|  0.00%|    Sort a complex array using the real part first, then the imaginary part.
  1536|         0|            0|            0|  0.00%|
  1537|         0|            0|            0|  0.00%|    Parameters
  1538|         0|            0|            0|  0.00%|    ----------
  1539|         0|            0|            0|  0.00%|    a : array_like
  1540|         0|            0|            0|  0.00%|        Input array
  1541|         0|            0|            0|  0.00%|
  1542|         0|            0|            0|  0.00%|    Returns
  1543|         0|            0|            0|  0.00%|    -------
  1544|         0|            0|            0|  0.00%|    out : complex ndarray
  1545|         0|            0|            0|  0.00%|        Always returns a sorted complex array.
  1546|         0|            0|            0|  0.00%|
  1547|         0|            0|            0|  0.00%|    Examples
  1548|         0|            0|            0|  0.00%|    --------
  1549|         0|            0|            0|  0.00%|    >>> np.sort_complex([5, 3, 6, 2, 1])
  1550|         0|            0|            0|  0.00%|    array([1.+0.j, 2.+0.j, 3.+0.j, 5.+0.j, 6.+0.j])
  1551|         0|            0|            0|  0.00%|
  1552|         0|            0|            0|  0.00%|    >>> np.sort_complex([1 + 2j, 2 - 1j, 3 - 2j, 3 - 3j, 3 + 5j])
  1553|         0|            0|            0|  0.00%|    array([1.+2.j,  2.-1.j,  3.-3.j,  3.-2.j,  3.+5.j])
  1554|         0|            0|            0|  0.00%|
  1555|         0|            0|            0|  0.00%|    """
  1556|         0|            0|            0|  0.00%|    b = array(a, copy=True)
  1557|         0|            0|            0|  0.00%|    b.sort()
  1558|         0|            0|            0|  0.00%|    if not issubclass(b.dtype.type, _nx.complexfloating):
  1559|         0|            0|            0|  0.00%|        if b.dtype.char in 'bhBH':
  1560|         0|            0|            0|  0.00%|            return b.astype('F')
  1561|         0|            0|            0|  0.00%|        elif b.dtype.char == 'g':
  1562|         0|            0|            0|  0.00%|            return b.astype('G')
  1563|         0|            0|            0|  0.00%|        else:
  1564|         0|            0|            0|  0.00%|            return b.astype('D')
  1565|         0|            0|            0|  0.00%|    else:
  1566|         0|            0|            0|  0.00%|        return b
  1567|         0|            0|            0|  0.00%|
  1568|         0|            0|            0|  0.00%|
  1569|         0|            0|            0|  0.00%|def _trim_zeros(filt, trim=None):
  1570|         0|            0|            0|  0.00%|    return (filt,)
  1571|         0|            0|            0|  0.00%|
  1572|         0|            0|            0|  0.00%|
  1573|         0|            0|            0|  0.00%|@array_function_dispatch(_trim_zeros)
  1574|         0|            0|            0|  0.00%|def trim_zeros(filt, trim='fb'):
  1575|         0|            0|            0|  0.00%|    """
  1576|         0|            0|            0|  0.00%|    Trim the leading and/or trailing zeros from a 1-D array or sequence.
  1577|         0|            0|            0|  0.00%|
  1578|         0|            0|            0|  0.00%|    Parameters
  1579|         0|            0|            0|  0.00%|    ----------
  1580|         0|            0|            0|  0.00%|    filt : 1-D array or sequence
  1581|         0|            0|            0|  0.00%|        Input array.
  1582|         0|            0|            0|  0.00%|    trim : str, optional
  1583|         0|            0|            0|  0.00%|        A string with 'f' representing trim from front and 'b' to trim from
  1584|         0|            0|            0|  0.00%|        back. Default is 'fb', trim zeros from both front and back of the
  1585|         0|            0|            0|  0.00%|        array.
  1586|         0|            0|            0|  0.00%|
  1587|         0|            0|            0|  0.00%|    Returns
  1588|         0|            0|            0|  0.00%|    -------
  1589|         0|            0|            0|  0.00%|    trimmed : 1-D array or sequence
  1590|         0|            0|            0|  0.00%|        The result of trimming the input. The input data type is preserved.
  1591|         0|            0|            0|  0.00%|
  1592|         0|            0|            0|  0.00%|    Examples
  1593|         0|            0|            0|  0.00%|    --------
  1594|         0|            0|            0|  0.00%|    >>> a = np.array((0, 0, 0, 1, 2, 3, 0, 2, 1, 0))
  1595|         0|            0|            0|  0.00%|    >>> np.trim_zeros(a)
  1596|         0|            0|            0|  0.00%|    array([1, 2, 3, 0, 2, 1])
  1597|         0|            0|            0|  0.00%|
  1598|         0|            0|            0|  0.00%|    >>> np.trim_zeros(a, 'b')
  1599|         0|            0|            0|  0.00%|    array([0, 0, 0, ..., 0, 2, 1])
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|    The input data type is preserved, list/tuple in means list/tuple out.
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    >>> np.trim_zeros([0, 1, 2, 0])
  1604|         0|            0|            0|  0.00%|    [1, 2]
  1605|         0|            0|            0|  0.00%|
  1606|         0|            0|            0|  0.00%|    """
  1607|         0|            0|            0|  0.00%|    first = 0
  1608|         0|            0|            0|  0.00%|    trim = trim.upper()
  1609|         0|            0|            0|  0.00%|    if 'F' in trim:
  1610|         0|            0|            0|  0.00%|        for i in filt:
  1611|         0|            0|            0|  0.00%|            if i != 0.:
  1612|         0|            0|            0|  0.00%|                break
  1613|         0|            0|            0|  0.00%|            else:
  1614|         0|            0|            0|  0.00%|                first = first + 1
  1615|         0|            0|            0|  0.00%|    last = len(filt)
  1616|         0|            0|            0|  0.00%|    if 'B' in trim:
  1617|         0|            0|            0|  0.00%|        for i in filt[::-1]:
  1618|         0|            0|            0|  0.00%|            if i != 0.:
  1619|         0|            0|            0|  0.00%|                break
  1620|         0|            0|            0|  0.00%|            else:
  1621|         0|            0|            0|  0.00%|                last = last - 1
  1622|         0|            0|            0|  0.00%|    return filt[first:last]
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|def _extract_dispatcher(condition, arr):
  1625|         0|            0|            0|  0.00%|    return (condition, arr)
  1626|         0|            0|            0|  0.00%|
  1627|         0|            0|            0|  0.00%|
  1628|         0|            0|            0|  0.00%|@array_function_dispatch(_extract_dispatcher)
  1629|         0|            0|            0|  0.00%|def extract(condition, arr):
  1630|         0|            0|            0|  0.00%|    """
  1631|         0|            0|            0|  0.00%|    Return the elements of an array that satisfy some condition.
  1632|         0|            0|            0|  0.00%|
  1633|         0|            0|            0|  0.00%|    This is equivalent to ``np.compress(ravel(condition), ravel(arr))``.  If
  1634|         0|            0|            0|  0.00%|    `condition` is boolean ``np.extract`` is equivalent to ``arr[condition]``.
  1635|         0|            0|            0|  0.00%|
  1636|         0|            0|            0|  0.00%|    Note that `place` does the exact opposite of `extract`.
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|    Parameters
  1639|         0|            0|            0|  0.00%|    ----------
  1640|         0|            0|            0|  0.00%|    condition : array_like
  1641|         0|            0|            0|  0.00%|        An array whose nonzero or True entries indicate the elements of `arr`
  1642|         0|            0|            0|  0.00%|        to extract.
  1643|         0|            0|            0|  0.00%|    arr : array_like
  1644|         0|            0|            0|  0.00%|        Input array of the same size as `condition`.
  1645|         0|            0|            0|  0.00%|
  1646|         0|            0|            0|  0.00%|    Returns
  1647|         0|            0|            0|  0.00%|    -------
  1648|         0|            0|            0|  0.00%|    extract : ndarray
  1649|         0|            0|            0|  0.00%|        Rank 1 array of values from `arr` where `condition` is True.
  1650|         0|            0|            0|  0.00%|
  1651|         0|            0|            0|  0.00%|    See Also
  1652|         0|            0|            0|  0.00%|    --------
  1653|         0|            0|            0|  0.00%|    take, put, copyto, compress, place
  1654|         0|            0|            0|  0.00%|
  1655|         0|            0|            0|  0.00%|    Examples
  1656|         0|            0|            0|  0.00%|    --------
  1657|         0|            0|            0|  0.00%|    >>> arr = np.arange(12).reshape((3, 4))
  1658|         0|            0|            0|  0.00%|    >>> arr
  1659|         0|            0|            0|  0.00%|    array([[ 0,  1,  2,  3],
  1660|         0|            0|            0|  0.00%|           [ 4,  5,  6,  7],
  1661|         0|            0|            0|  0.00%|           [ 8,  9, 10, 11]])
  1662|         0|            0|            0|  0.00%|    >>> condition = np.mod(arr, 3)==0
  1663|         0|            0|            0|  0.00%|    >>> condition
  1664|         0|            0|            0|  0.00%|    array([[ True, False, False,  True],
  1665|         0|            0|            0|  0.00%|           [False, False,  True, False],
  1666|         0|            0|            0|  0.00%|           [False,  True, False, False]])
  1667|         0|            0|            0|  0.00%|    >>> np.extract(condition, arr)
  1668|         0|            0|            0|  0.00%|    array([0, 3, 6, 9])
  1669|         0|            0|            0|  0.00%|
  1670|         0|            0|            0|  0.00%|
  1671|         0|            0|            0|  0.00%|    If `condition` is boolean:
  1672|         0|            0|            0|  0.00%|
  1673|         0|            0|            0|  0.00%|    >>> arr[condition]
  1674|         0|            0|            0|  0.00%|    array([0, 3, 6, 9])
  1675|         0|            0|            0|  0.00%|
  1676|         0|            0|            0|  0.00%|    """
  1677|         0|            0|            0|  0.00%|    return _nx.take(ravel(arr), nonzero(ravel(condition))[0])
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|
  1680|         0|            0|            0|  0.00%|def _place_dispatcher(arr, mask, vals):
  1681|         0|            0|            0|  0.00%|    return (arr, mask, vals)
  1682|         0|            0|            0|  0.00%|
  1683|         0|            0|            0|  0.00%|
  1684|         0|            0|            0|  0.00%|@array_function_dispatch(_place_dispatcher)
  1685|         0|            0|            0|  0.00%|def place(arr, mask, vals):
  1686|         0|            0|            0|  0.00%|    """
  1687|         0|            0|            0|  0.00%|    Change elements of an array based on conditional and input values.
  1688|         0|            0|            0|  0.00%|
  1689|         0|            0|            0|  0.00%|    Similar to ``np.copyto(arr, vals, where=mask)``, the difference is that
  1690|         0|            0|            0|  0.00%|    `place` uses the first N elements of `vals`, where N is the number of
  1691|         0|            0|            0|  0.00%|    True values in `mask`, while `copyto` uses the elements where `mask`
  1692|         0|            0|            0|  0.00%|    is True.
  1693|         0|            0|            0|  0.00%|
  1694|         0|            0|            0|  0.00%|    Note that `extract` does the exact opposite of `place`.
  1695|         0|            0|            0|  0.00%|
  1696|         0|            0|            0|  0.00%|    Parameters
  1697|         0|            0|            0|  0.00%|    ----------
  1698|         0|            0|            0|  0.00%|    arr : ndarray
  1699|         0|            0|            0|  0.00%|        Array to put data into.
  1700|         0|            0|            0|  0.00%|    mask : array_like
  1701|         0|            0|            0|  0.00%|        Boolean mask array. Must have the same size as `a`.
  1702|         0|            0|            0|  0.00%|    vals : 1-D sequence
  1703|         0|            0|            0|  0.00%|        Values to put into `a`. Only the first N elements are used, where
  1704|         0|            0|            0|  0.00%|        N is the number of True values in `mask`. If `vals` is smaller
  1705|         0|            0|            0|  0.00%|        than N, it will be repeated, and if elements of `a` are to be masked,
  1706|         0|            0|            0|  0.00%|        this sequence must be non-empty.
  1707|         0|            0|            0|  0.00%|
  1708|         0|            0|            0|  0.00%|    See Also
  1709|         0|            0|            0|  0.00%|    --------
  1710|         0|            0|            0|  0.00%|    copyto, put, take, extract
  1711|         0|            0|            0|  0.00%|
  1712|         0|            0|            0|  0.00%|    Examples
  1713|         0|            0|            0|  0.00%|    --------
  1714|         0|            0|            0|  0.00%|    >>> arr = np.arange(6).reshape(2, 3)
  1715|         0|            0|            0|  0.00%|    >>> np.place(arr, arr>2, [44, 55])
  1716|         0|            0|            0|  0.00%|    >>> arr
  1717|         0|            0|            0|  0.00%|    array([[ 0,  1,  2],
  1718|         0|            0|            0|  0.00%|           [44, 55, 44]])
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|    """
  1721|         0|            0|            0|  0.00%|    if not isinstance(arr, np.ndarray):
  1722|         0|            0|            0|  0.00%|        raise TypeError("argument 1 must be numpy.ndarray, "
  1723|         0|            0|            0|  0.00%|                        "not {name}".format(name=type(arr).__name__))
  1724|         0|            0|            0|  0.00%|
  1725|         0|            0|            0|  0.00%|    return _insert(arr, mask, vals)
  1726|         0|            0|            0|  0.00%|
  1727|         0|            0|            0|  0.00%|
  1728|         0|            0|            0|  0.00%|def disp(mesg, device=None, linefeed=True):
  1729|         0|            0|            0|  0.00%|    """
  1730|         0|            0|            0|  0.00%|    Display a message on a device.
  1731|         0|            0|            0|  0.00%|
  1732|         0|            0|            0|  0.00%|    Parameters
  1733|         0|            0|            0|  0.00%|    ----------
  1734|         0|            0|            0|  0.00%|    mesg : str
  1735|         0|            0|            0|  0.00%|        Message to display.
  1736|         0|            0|            0|  0.00%|    device : object
  1737|         0|            0|            0|  0.00%|        Device to write message. If None, defaults to ``sys.stdout`` which is
  1738|         0|            0|            0|  0.00%|        very similar to ``print``. `device` needs to have ``write()`` and
  1739|         0|            0|            0|  0.00%|        ``flush()`` methods.
  1740|         0|            0|            0|  0.00%|    linefeed : bool, optional
  1741|         0|            0|            0|  0.00%|        Option whether to print a line feed or not. Defaults to True.
  1742|         0|            0|            0|  0.00%|
  1743|         0|            0|            0|  0.00%|    Raises
  1744|         0|            0|            0|  0.00%|    ------
  1745|         0|            0|            0|  0.00%|    AttributeError
  1746|         0|            0|            0|  0.00%|        If `device` does not have a ``write()`` or ``flush()`` method.
  1747|         0|            0|            0|  0.00%|
  1748|         0|            0|            0|  0.00%|    Examples
  1749|         0|            0|            0|  0.00%|    --------
  1750|         0|            0|            0|  0.00%|    Besides ``sys.stdout``, a file-like object can also be used as it has
  1751|         0|            0|            0|  0.00%|    both required methods:
  1752|         0|            0|            0|  0.00%|
  1753|         0|            0|            0|  0.00%|    >>> from io import StringIO
  1754|         0|            0|            0|  0.00%|    >>> buf = StringIO()
  1755|         0|            0|            0|  0.00%|    >>> np.disp(u'"Display" in a file', device=buf)
  1756|         0|            0|            0|  0.00%|    >>> buf.getvalue()
  1757|         0|            0|            0|  0.00%|    '"Display" in a file\\n'
  1758|         0|            0|            0|  0.00%|
  1759|         0|            0|            0|  0.00%|    """
  1760|         0|            0|            0|  0.00%|    if device is None:
  1761|         0|            0|            0|  0.00%|        device = sys.stdout
  1762|         0|            0|            0|  0.00%|    if linefeed:
  1763|         0|            0|            0|  0.00%|        device.write('%s\n' % mesg)
  1764|         0|            0|            0|  0.00%|    else:
  1765|         0|            0|            0|  0.00%|        device.write('%s' % mesg)
  1766|         0|            0|            0|  0.00%|    device.flush()
  1767|         0|            0|            0|  0.00%|    return
  1768|         0|            0|            0|  0.00%|
  1769|         0|            0|            0|  0.00%|
  1770|         0|            0|            0|  0.00%|# See https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html
  1771|         0|            0|            0|  0.00%|_DIMENSION_NAME = r'\w+'
  1772|         0|            0|            0|  0.00%|_CORE_DIMENSION_LIST = '(?:{0:}(?:,{0:})*)?'.format(_DIMENSION_NAME)
  1773|         0|            0|            0|  0.00%|_ARGUMENT = r'\({}\)'.format(_CORE_DIMENSION_LIST)
  1774|         0|            0|            0|  0.00%|_ARGUMENT_LIST = '{0:}(?:,{0:})*'.format(_ARGUMENT)
  1775|         0|            0|            0|  0.00%|_SIGNATURE = '^{0:}->{0:}$'.format(_ARGUMENT_LIST)
  1776|         0|            0|            0|  0.00%|
  1777|         0|            0|            0|  0.00%|
  1778|         0|            0|            0|  0.00%|def _parse_gufunc_signature(signature):
  1779|         0|            0|            0|  0.00%|    """
  1780|         0|            0|            0|  0.00%|    Parse string signatures for a generalized universal function.
  1781|         0|            0|            0|  0.00%|
  1782|         0|            0|            0|  0.00%|    Arguments
  1783|         0|            0|            0|  0.00%|    ---------
  1784|         0|            0|            0|  0.00%|    signature : string
  1785|         0|            0|            0|  0.00%|        Generalized universal function signature, e.g., ``(m,n),(n,p)->(m,p)``
  1786|         0|            0|            0|  0.00%|        for ``np.matmul``.
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|    Returns
  1789|         0|            0|            0|  0.00%|    -------
  1790|         0|            0|            0|  0.00%|    Tuple of input and output core dimensions parsed from the signature, each
  1791|         0|            0|            0|  0.00%|    of the form List[Tuple[str, ...]].
  1792|         0|            0|            0|  0.00%|    """
  1793|         0|            0|            0|  0.00%|    if not re.match(_SIGNATURE, signature):
  1794|         0|            0|            0|  0.00%|        raise ValueError(
  1795|         0|            0|            0|  0.00%|            'not a valid gufunc signature: {}'.format(signature))
  1796|         0|            0|            0|  0.00%|    return tuple([tuple(re.findall(_DIMENSION_NAME, arg))
  1797|         0|            0|            0|  0.00%|                  for arg in re.findall(_ARGUMENT, arg_list)]
  1798|         0|            0|            0|  0.00%|                 for arg_list in signature.split('->'))
  1799|         0|            0|            0|  0.00%|
  1800|         0|            0|            0|  0.00%|
  1801|         0|            0|            0|  0.00%|def _update_dim_sizes(dim_sizes, arg, core_dims):
  1802|         0|            0|            0|  0.00%|    """
  1803|         0|            0|            0|  0.00%|    Incrementally check and update core dimension sizes for a single argument.
  1804|         0|            0|            0|  0.00%|
  1805|         0|            0|            0|  0.00%|    Arguments
  1806|         0|            0|            0|  0.00%|    ---------
  1807|         0|            0|            0|  0.00%|    dim_sizes : Dict[str, int]
  1808|         0|            0|            0|  0.00%|        Sizes of existing core dimensions. Will be updated in-place.
  1809|         0|            0|            0|  0.00%|    arg : ndarray
  1810|         0|            0|            0|  0.00%|        Argument to examine.
  1811|         0|            0|            0|  0.00%|    core_dims : Tuple[str, ...]
  1812|         0|            0|            0|  0.00%|        Core dimensions for this argument.
  1813|         0|            0|            0|  0.00%|    """
  1814|         0|            0|            0|  0.00%|    if not core_dims:
  1815|         0|            0|            0|  0.00%|        return
  1816|         0|            0|            0|  0.00%|
  1817|         0|            0|            0|  0.00%|    num_core_dims = len(core_dims)
  1818|         0|            0|            0|  0.00%|    if arg.ndim < num_core_dims:
  1819|         0|            0|            0|  0.00%|        raise ValueError(
  1820|         0|            0|            0|  0.00%|            '%d-dimensional argument does not have enough '
  1821|         0|            0|            0|  0.00%|            'dimensions for all core dimensions %r'
  1822|         0|            0|            0|  0.00%|            % (arg.ndim, core_dims))
  1823|         0|            0|            0|  0.00%|
  1824|         0|            0|            0|  0.00%|    core_shape = arg.shape[-num_core_dims:]
  1825|         0|            0|            0|  0.00%|    for dim, size in zip(core_dims, core_shape):
  1826|         0|            0|            0|  0.00%|        if dim in dim_sizes:
  1827|         0|            0|            0|  0.00%|            if size != dim_sizes[dim]:
  1828|         0|            0|            0|  0.00%|                raise ValueError(
  1829|         0|            0|            0|  0.00%|                    'inconsistent size for core dimension %r: %r vs %r'
  1830|         0|            0|            0|  0.00%|                    % (dim, size, dim_sizes[dim]))
  1831|         0|            0|            0|  0.00%|        else:
  1832|         0|            0|            0|  0.00%|            dim_sizes[dim] = size
  1833|         0|            0|            0|  0.00%|
  1834|         0|            0|            0|  0.00%|
  1835|         0|            0|            0|  0.00%|def _parse_input_dimensions(args, input_core_dims):
  1836|         0|            0|            0|  0.00%|    """
  1837|         0|            0|            0|  0.00%|    Parse broadcast and core dimensions for vectorize with a signature.
  1838|         0|            0|            0|  0.00%|
  1839|         0|            0|            0|  0.00%|    Arguments
  1840|         0|            0|            0|  0.00%|    ---------
  1841|         0|            0|            0|  0.00%|    args : Tuple[ndarray, ...]
  1842|         0|            0|            0|  0.00%|        Tuple of input arguments to examine.
  1843|         0|            0|            0|  0.00%|    input_core_dims : List[Tuple[str, ...]]
  1844|         0|            0|            0|  0.00%|        List of core dimensions corresponding to each input.
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|    Returns
  1847|         0|            0|            0|  0.00%|    -------
  1848|         0|            0|            0|  0.00%|    broadcast_shape : Tuple[int, ...]
  1849|         0|            0|            0|  0.00%|        Common shape to broadcast all non-core dimensions to.
  1850|         0|            0|            0|  0.00%|    dim_sizes : Dict[str, int]
  1851|         0|            0|            0|  0.00%|        Common sizes for named core dimensions.
  1852|         0|            0|            0|  0.00%|    """
  1853|         0|            0|            0|  0.00%|    broadcast_args = []
  1854|         0|            0|            0|  0.00%|    dim_sizes = {}
  1855|         0|            0|            0|  0.00%|    for arg, core_dims in zip(args, input_core_dims):
  1856|         0|            0|            0|  0.00%|        _update_dim_sizes(dim_sizes, arg, core_dims)
  1857|         0|            0|            0|  0.00%|        ndim = arg.ndim - len(core_dims)
  1858|         0|            0|            0|  0.00%|        dummy_array = np.lib.stride_tricks.as_strided(0, arg.shape[:ndim])
  1859|         0|            0|            0|  0.00%|        broadcast_args.append(dummy_array)
  1860|         0|            0|            0|  0.00%|    broadcast_shape = np.lib.stride_tricks._broadcast_shape(*broadcast_args)
  1861|         0|            0|            0|  0.00%|    return broadcast_shape, dim_sizes
  1862|         0|            0|            0|  0.00%|
  1863|         0|            0|            0|  0.00%|
  1864|         0|            0|            0|  0.00%|def _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims):
  1865|         0|            0|            0|  0.00%|    """Helper for calculating broadcast shapes with core dimensions."""
  1866|         0|            0|            0|  0.00%|    return [broadcast_shape + tuple(dim_sizes[dim] for dim in core_dims)
  1867|         0|            0|            0|  0.00%|            for core_dims in list_of_core_dims]
  1868|         0|            0|            0|  0.00%|
  1869|         0|            0|            0|  0.00%|
  1870|         0|            0|            0|  0.00%|def _create_arrays(broadcast_shape, dim_sizes, list_of_core_dims, dtypes):
  1871|         0|            0|            0|  0.00%|    """Helper for creating output arrays in vectorize."""
  1872|         0|            0|            0|  0.00%|    shapes = _calculate_shapes(broadcast_shape, dim_sizes, list_of_core_dims)
  1873|         0|            0|            0|  0.00%|    arrays = tuple(np.empty(shape, dtype=dtype)
  1874|         0|            0|            0|  0.00%|                   for shape, dtype in zip(shapes, dtypes))
  1875|         0|            0|            0|  0.00%|    return arrays
  1876|         0|            0|            0|  0.00%|
  1877|         0|            0|            0|  0.00%|
  1878|         0|            0|            0|  0.00%|@set_module('numpy')
  1879|         0|            0|            0|  0.00%|class vectorize(object):
  1880|         0|            0|            0|  0.00%|    """
  1881|         0|            0|            0|  0.00%|    vectorize(pyfunc, otypes=None, doc=None, excluded=None, cache=False,
  1882|         0|            0|            0|  0.00%|              signature=None)
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|    Generalized function class.
  1885|         0|            0|            0|  0.00%|
  1886|         0|            0|            0|  0.00%|    Define a vectorized function which takes a nested sequence of objects or
  1887|         0|            0|            0|  0.00%|    numpy arrays as inputs and returns a single numpy array or a tuple of numpy
  1888|         0|            0|            0|  0.00%|    arrays. The vectorized function evaluates `pyfunc` over successive tuples
  1889|         0|            0|            0|  0.00%|    of the input arrays like the python map function, except it uses the
  1890|         0|            0|            0|  0.00%|    broadcasting rules of numpy.
  1891|         0|            0|            0|  0.00%|
  1892|         0|            0|            0|  0.00%|    The data type of the output of `vectorized` is determined by calling
  1893|         0|            0|            0|  0.00%|    the function with the first element of the input.  This can be avoided
  1894|         0|            0|            0|  0.00%|    by specifying the `otypes` argument.
  1895|         0|            0|            0|  0.00%|
  1896|         0|            0|            0|  0.00%|    Parameters
  1897|         0|            0|            0|  0.00%|    ----------
  1898|         0|            0|            0|  0.00%|    pyfunc : callable
  1899|         0|            0|            0|  0.00%|        A python function or method.
  1900|         0|            0|            0|  0.00%|    otypes : str or list of dtypes, optional
  1901|         0|            0|            0|  0.00%|        The output data type. It must be specified as either a string of
  1902|         0|            0|            0|  0.00%|        typecode characters or a list of data type specifiers. There should
  1903|         0|            0|            0|  0.00%|        be one data type specifier for each output.
  1904|         0|            0|            0|  0.00%|    doc : str, optional
  1905|         0|            0|            0|  0.00%|        The docstring for the function. If `None`, the docstring will be the
  1906|         0|            0|            0|  0.00%|        ``pyfunc.__doc__``.
  1907|         0|            0|            0|  0.00%|    excluded : set, optional
  1908|         0|            0|            0|  0.00%|        Set of strings or integers representing the positional or keyword
  1909|         0|            0|            0|  0.00%|        arguments for which the function will not be vectorized.  These will be
  1910|         0|            0|            0|  0.00%|        passed directly to `pyfunc` unmodified.
  1911|         0|            0|            0|  0.00%|
  1912|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1913|         0|            0|            0|  0.00%|
  1914|         0|            0|            0|  0.00%|    cache : bool, optional
  1915|         0|            0|            0|  0.00%|       If `True`, then cache the first function call that determines the number
  1916|         0|            0|            0|  0.00%|       of outputs if `otypes` is not provided.
  1917|         0|            0|            0|  0.00%|
  1918|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  1919|         0|            0|            0|  0.00%|
  1920|         0|            0|            0|  0.00%|    signature : string, optional
  1921|         0|            0|            0|  0.00%|        Generalized universal function signature, e.g., ``(m,n),(n)->(m)`` for
  1922|         0|            0|            0|  0.00%|        vectorized matrix-vector multiplication. If provided, ``pyfunc`` will
  1923|         0|            0|            0|  0.00%|        be called with (and expected to return) arrays with shapes given by the
  1924|         0|            0|            0|  0.00%|        size of corresponding core dimensions. By default, ``pyfunc`` is
  1925|         0|            0|            0|  0.00%|        assumed to take scalars as input and output.
  1926|         0|            0|            0|  0.00%|
  1927|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
  1928|         0|            0|            0|  0.00%|
  1929|         0|            0|            0|  0.00%|    Returns
  1930|         0|            0|            0|  0.00%|    -------
  1931|         0|            0|            0|  0.00%|    vectorized : callable
  1932|         0|            0|            0|  0.00%|        Vectorized function.
  1933|         0|            0|            0|  0.00%|
  1934|         0|            0|            0|  0.00%|    See Also
  1935|         0|            0|            0|  0.00%|    --------
  1936|         0|            0|            0|  0.00%|    frompyfunc : Takes an arbitrary Python function and returns a ufunc
  1937|         0|            0|            0|  0.00%|
  1938|         0|            0|            0|  0.00%|    Notes
  1939|         0|            0|            0|  0.00%|    -----
  1940|         0|            0|            0|  0.00%|    The `vectorize` function is provided primarily for convenience, not for
  1941|         0|            0|            0|  0.00%|    performance. The implementation is essentially a for loop.
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|    If `otypes` is not specified, then a call to the function with the
  1944|         0|            0|            0|  0.00%|    first argument will be used to determine the number of outputs.  The
  1945|         0|            0|            0|  0.00%|    results of this call will be cached if `cache` is `True` to prevent
  1946|         0|            0|            0|  0.00%|    calling the function twice.  However, to implement the cache, the
  1947|         0|            0|            0|  0.00%|    original function must be wrapped which will slow down subsequent
  1948|         0|            0|            0|  0.00%|    calls, so only do this if your function is expensive.
  1949|         0|            0|            0|  0.00%|
  1950|         0|            0|            0|  0.00%|    The new keyword argument interface and `excluded` argument support
  1951|         0|            0|            0|  0.00%|    further degrades performance.
  1952|         0|            0|            0|  0.00%|
  1953|         0|            0|            0|  0.00%|    References
  1954|         0|            0|            0|  0.00%|    ----------
  1955|         0|            0|            0|  0.00%|    .. [1] NumPy Reference, section `Generalized Universal Function API
  1956|         0|            0|            0|  0.00%|           <https://docs.scipy.org/doc/numpy/reference/c-api.generalized-ufuncs.html>`_.
  1957|         0|            0|            0|  0.00%|
  1958|         0|            0|            0|  0.00%|    Examples
  1959|         0|            0|            0|  0.00%|    --------
  1960|         0|            0|            0|  0.00%|    >>> def myfunc(a, b):
  1961|         0|            0|            0|  0.00%|    ...     "Return a-b if a>b, otherwise return a+b"
  1962|         0|            0|            0|  0.00%|    ...     if a > b:
  1963|         0|            0|            0|  0.00%|    ...         return a - b
  1964|         0|            0|            0|  0.00%|    ...     else:
  1965|         0|            0|            0|  0.00%|    ...         return a + b
  1966|         0|            0|            0|  0.00%|
  1967|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc)
  1968|         0|            0|            0|  0.00%|    >>> vfunc([1, 2, 3, 4], 2)
  1969|         0|            0|            0|  0.00%|    array([3, 4, 1, 2])
  1970|         0|            0|            0|  0.00%|
  1971|         0|            0|            0|  0.00%|    The docstring is taken from the input function to `vectorize` unless it
  1972|         0|            0|            0|  0.00%|    is specified:
  1973|         0|            0|            0|  0.00%|
  1974|         0|            0|            0|  0.00%|    >>> vfunc.__doc__
  1975|         0|            0|            0|  0.00%|    'Return a-b if a>b, otherwise return a+b'
  1976|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc, doc='Vectorized `myfunc`')
  1977|         0|            0|            0|  0.00%|    >>> vfunc.__doc__
  1978|         0|            0|            0|  0.00%|    'Vectorized `myfunc`'
  1979|         0|            0|            0|  0.00%|
  1980|         0|            0|            0|  0.00%|    The output type is determined by evaluating the first element of the input,
  1981|         0|            0|            0|  0.00%|    unless it is specified:
  1982|         0|            0|            0|  0.00%|
  1983|         0|            0|            0|  0.00%|    >>> out = vfunc([1, 2, 3, 4], 2)
  1984|         0|            0|            0|  0.00%|    >>> type(out[0])
  1985|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
  1986|         0|            0|            0|  0.00%|    >>> vfunc = np.vectorize(myfunc, otypes=[float])
  1987|         0|            0|            0|  0.00%|    >>> out = vfunc([1, 2, 3, 4], 2)
  1988|         0|            0|            0|  0.00%|    >>> type(out[0])
  1989|         0|            0|            0|  0.00%|    <class 'numpy.float64'>
  1990|         0|            0|            0|  0.00%|
  1991|         0|            0|            0|  0.00%|    The `excluded` argument can be used to prevent vectorizing over certain
  1992|         0|            0|            0|  0.00%|    arguments.  This can be useful for array-like arguments of a fixed length
  1993|         0|            0|            0|  0.00%|    such as the coefficients for a polynomial as in `polyval`:
  1994|         0|            0|            0|  0.00%|
  1995|         0|            0|            0|  0.00%|    >>> def mypolyval(p, x):
  1996|         0|            0|            0|  0.00%|    ...     _p = list(p)
  1997|         0|            0|            0|  0.00%|    ...     res = _p.pop(0)
  1998|         0|            0|            0|  0.00%|    ...     while _p:
  1999|         0|            0|            0|  0.00%|    ...         res = res*x + _p.pop(0)
  2000|         0|            0|            0|  0.00%|    ...     return res
  2001|         0|            0|            0|  0.00%|    >>> vpolyval = np.vectorize(mypolyval, excluded=['p'])
  2002|         0|            0|            0|  0.00%|    >>> vpolyval(p=[1, 2, 3], x=[0, 1])
  2003|         0|            0|            0|  0.00%|    array([3, 6])
  2004|         0|            0|            0|  0.00%|
  2005|         0|            0|            0|  0.00%|    Positional arguments may also be excluded by specifying their position:
  2006|         0|            0|            0|  0.00%|
  2007|         0|            0|            0|  0.00%|    >>> vpolyval.excluded.add(0)
  2008|         0|            0|            0|  0.00%|    >>> vpolyval([1, 2, 3], x=[0, 1])
  2009|         0|            0|            0|  0.00%|    array([3, 6])
  2010|         0|            0|            0|  0.00%|
  2011|         0|            0|            0|  0.00%|    The `signature` argument allows for vectorizing functions that act on
  2012|         0|            0|            0|  0.00%|    non-scalar arrays of fixed length. For example, you can use it for a
  2013|         0|            0|            0|  0.00%|    vectorized calculation of Pearson correlation coefficient and its p-value:
  2014|         0|            0|            0|  0.00%|
  2015|         0|            0|            0|  0.00%|    >>> import scipy.stats
  2016|         0|            0|            0|  0.00%|    >>> pearsonr = np.vectorize(scipy.stats.pearsonr,
  2017|         0|            0|            0|  0.00%|    ...                 signature='(n),(n)->(),()')
  2018|         0|            0|            0|  0.00%|    >>> pearsonr([[0, 1, 2, 3]], [[1, 2, 3, 4], [4, 3, 2, 1]])
  2019|         0|            0|            0|  0.00%|    (array([ 1., -1.]), array([ 0.,  0.]))
  2020|         0|            0|            0|  0.00%|
  2021|         0|            0|            0|  0.00%|    Or for a vectorized convolution:
  2022|         0|            0|            0|  0.00%|
  2023|         0|            0|            0|  0.00%|    >>> convolve = np.vectorize(np.convolve, signature='(n),(m)->(k)')
  2024|         0|            0|            0|  0.00%|    >>> convolve(np.eye(4), [1, 2, 1])
  2025|         0|            0|            0|  0.00%|    array([[1., 2., 1., 0., 0., 0.],
  2026|         0|            0|            0|  0.00%|           [0., 1., 2., 1., 0., 0.],
  2027|         0|            0|            0|  0.00%|           [0., 0., 1., 2., 1., 0.],
  2028|         0|            0|            0|  0.00%|           [0., 0., 0., 1., 2., 1.]])
  2029|         0|            0|            0|  0.00%|
  2030|         0|            0|            0|  0.00%|    """
  2031|         0|            0|            0|  0.00%|    def __init__(self, pyfunc, otypes=None, doc=None, excluded=None,
  2032|         0|            0|            0|  0.00%|                 cache=False, signature=None):
  2033|         0|            0|            0|  0.00%|        self.pyfunc = pyfunc
  2034|         0|            0|            0|  0.00%|        self.cache = cache
  2035|         0|            0|            0|  0.00%|        self.signature = signature
  2036|         0|            0|            0|  0.00%|        self._ufunc = None    # Caching to improve default performance
  2037|         0|            0|            0|  0.00%|
  2038|         0|            0|            0|  0.00%|        if doc is None:
  2039|         0|            0|            0|  0.00%|            self.__doc__ = pyfunc.__doc__
  2040|         0|            0|            0|  0.00%|        else:
  2041|         0|            0|            0|  0.00%|            self.__doc__ = doc
  2042|         0|            0|            0|  0.00%|
  2043|         0|            0|            0|  0.00%|        if isinstance(otypes, str):
  2044|         0|            0|            0|  0.00%|            for char in otypes:
  2045|         0|            0|            0|  0.00%|                if char not in typecodes['All']:
  2046|         0|            0|            0|  0.00%|                    raise ValueError("Invalid otype specified: %s" % (char,))
  2047|         0|            0|            0|  0.00%|        elif iterable(otypes):
  2048|         0|            0|            0|  0.00%|            otypes = ''.join([_nx.dtype(x).char for x in otypes])
  2049|         0|            0|            0|  0.00%|        elif otypes is not None:
  2050|         0|            0|            0|  0.00%|            raise ValueError("Invalid otype specification")
  2051|         0|            0|            0|  0.00%|        self.otypes = otypes
  2052|         0|            0|            0|  0.00%|
  2053|         0|            0|            0|  0.00%|        # Excluded variable support
  2054|         0|            0|            0|  0.00%|        if excluded is None:
  2055|         0|            0|            0|  0.00%|            excluded = set()
  2056|         0|            0|            0|  0.00%|        self.excluded = set(excluded)
  2057|         0|            0|            0|  0.00%|
  2058|         0|            0|            0|  0.00%|        if signature is not None:
  2059|         0|            0|            0|  0.00%|            self._in_and_out_core_dims = _parse_gufunc_signature(signature)
  2060|         0|            0|            0|  0.00%|        else:
  2061|         0|            0|            0|  0.00%|            self._in_and_out_core_dims = None
  2062|         0|            0|            0|  0.00%|
  2063|         0|            0|            0|  0.00%|    def __call__(self, *args, **kwargs):
  2064|         0|            0|            0|  0.00%|        """
  2065|         0|            0|            0|  0.00%|        Return arrays with the results of `pyfunc` broadcast (vectorized) over
  2066|         0|            0|            0|  0.00%|        `args` and `kwargs` not in `excluded`.
  2067|         0|            0|            0|  0.00%|        """
  2068|         0|            0|            0|  0.00%|        excluded = self.excluded
  2069|         0|            0|            0|  0.00%|        if not kwargs and not excluded:
  2070|         0|            0|            0|  0.00%|            func = self.pyfunc
  2071|         0|            0|            0|  0.00%|            vargs = args
  2072|         0|            0|            0|  0.00%|        else:
  2073|         0|            0|            0|  0.00%|            # The wrapper accepts only positional arguments: we use `names` and
  2074|         0|            0|            0|  0.00%|            # `inds` to mutate `the_args` and `kwargs` to pass to the original
  2075|         0|            0|            0|  0.00%|            # function.
  2076|         0|            0|            0|  0.00%|            nargs = len(args)
  2077|         0|            0|            0|  0.00%|
  2078|         0|            0|            0|  0.00%|            names = [_n for _n in kwargs if _n not in excluded]
  2079|         0|            0|            0|  0.00%|            inds = [_i for _i in range(nargs) if _i not in excluded]
  2080|         0|            0|            0|  0.00%|            the_args = list(args)
  2081|         0|            0|            0|  0.00%|
  2082|         0|            0|            0|  0.00%|            def func(*vargs):
  2083|         0|            0|            0|  0.00%|                for _n, _i in enumerate(inds):
  2084|         0|            0|            0|  0.00%|                    the_args[_i] = vargs[_n]
  2085|         0|            0|            0|  0.00%|                kwargs.update(zip(names, vargs[len(inds):]))
  2086|         0|            0|            0|  0.00%|                return self.pyfunc(*the_args, **kwargs)
  2087|         0|            0|            0|  0.00%|
  2088|         0|            0|            0|  0.00%|            vargs = [args[_i] for _i in inds]
  2089|         0|            0|            0|  0.00%|            vargs.extend([kwargs[_n] for _n in names])
  2090|         0|            0|            0|  0.00%|
  2091|         0|            0|            0|  0.00%|        return self._vectorize_call(func=func, args=vargs)
  2092|         0|            0|            0|  0.00%|
  2093|         0|            0|            0|  0.00%|    def _get_ufunc_and_otypes(self, func, args):
  2094|         0|            0|            0|  0.00%|        """Return (ufunc, otypes)."""
  2095|         0|            0|            0|  0.00%|        # frompyfunc will fail if args is empty
  2096|         0|            0|            0|  0.00%|        if not args:
  2097|         0|            0|            0|  0.00%|            raise ValueError('args can not be empty')
  2098|         0|            0|            0|  0.00%|
  2099|         0|            0|            0|  0.00%|        if self.otypes is not None:
  2100|         0|            0|            0|  0.00%|            otypes = self.otypes
  2101|         0|            0|            0|  0.00%|            nout = len(otypes)
  2102|         0|            0|            0|  0.00%|
  2103|         0|            0|            0|  0.00%|            # Note logic here: We only *use* self._ufunc if func is self.pyfunc
  2104|         0|            0|            0|  0.00%|            # even though we set self._ufunc regardless.
  2105|         0|            0|            0|  0.00%|            if func is self.pyfunc and self._ufunc is not None:
  2106|         0|            0|            0|  0.00%|                ufunc = self._ufunc
  2107|         0|            0|            0|  0.00%|            else:
  2108|         0|            0|            0|  0.00%|                ufunc = self._ufunc = frompyfunc(func, len(args), nout)
  2109|         0|            0|            0|  0.00%|        else:
  2110|         0|            0|            0|  0.00%|            # Get number of outputs and output types by calling the function on
  2111|         0|            0|            0|  0.00%|            # the first entries of args.  We also cache the result to prevent
  2112|         0|            0|            0|  0.00%|            # the subsequent call when the ufunc is evaluated.
  2113|         0|            0|            0|  0.00%|            # Assumes that ufunc first evaluates the 0th elements in the input
  2114|         0|            0|            0|  0.00%|            # arrays (the input values are not checked to ensure this)
  2115|         0|            0|            0|  0.00%|            args = [asarray(arg) for arg in args]
  2116|         0|            0|            0|  0.00%|            if builtins.any(arg.size == 0 for arg in args):
  2117|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` on size 0 inputs '
  2118|         0|            0|            0|  0.00%|                                 'unless `otypes` is set')
  2119|         0|            0|            0|  0.00%|
  2120|         0|            0|            0|  0.00%|            inputs = [arg.flat[0] for arg in args]
  2121|         0|            0|            0|  0.00%|            outputs = func(*inputs)
  2122|         0|            0|            0|  0.00%|
  2123|         0|            0|            0|  0.00%|            # Performance note: profiling indicates that -- for simple
  2124|         0|            0|            0|  0.00%|            # functions at least -- this wrapping can almost double the
  2125|         0|            0|            0|  0.00%|            # execution time.
  2126|         0|            0|            0|  0.00%|            # Hence we make it optional.
  2127|         0|            0|            0|  0.00%|            if self.cache:
  2128|         0|            0|            0|  0.00%|                _cache = [outputs]
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|                def _func(*vargs):
  2131|         0|            0|            0|  0.00%|                    if _cache:
  2132|         0|            0|            0|  0.00%|                        return _cache.pop()
  2133|         0|            0|            0|  0.00%|                    else:
  2134|         0|            0|            0|  0.00%|                        return func(*vargs)
  2135|         0|            0|            0|  0.00%|            else:
  2136|         0|            0|            0|  0.00%|                _func = func
  2137|         0|            0|            0|  0.00%|
  2138|         0|            0|            0|  0.00%|            if isinstance(outputs, tuple):
  2139|         0|            0|            0|  0.00%|                nout = len(outputs)
  2140|         0|            0|            0|  0.00%|            else:
  2141|         0|            0|            0|  0.00%|                nout = 1
  2142|         0|            0|            0|  0.00%|                outputs = (outputs,)
  2143|         0|            0|            0|  0.00%|
  2144|         0|            0|            0|  0.00%|            otypes = ''.join([asarray(outputs[_k]).dtype.char
  2145|         0|            0|            0|  0.00%|                              for _k in range(nout)])
  2146|         0|            0|            0|  0.00%|
  2147|         0|            0|            0|  0.00%|            # Performance note: profiling indicates that creating the ufunc is
  2148|         0|            0|            0|  0.00%|            # not a significant cost compared with wrapping so it seems not
  2149|         0|            0|            0|  0.00%|            # worth trying to cache this.
  2150|         0|            0|            0|  0.00%|            ufunc = frompyfunc(_func, len(args), nout)
  2151|         0|            0|            0|  0.00%|
  2152|         0|            0|            0|  0.00%|        return ufunc, otypes
  2153|         0|            0|            0|  0.00%|
  2154|         0|            0|            0|  0.00%|    def _vectorize_call(self, func, args):
  2155|         0|            0|            0|  0.00%|        """Vectorized call to `func` over positional `args`."""
  2156|         0|            0|            0|  0.00%|        if self.signature is not None:
  2157|         0|            0|            0|  0.00%|            res = self._vectorize_call_with_signature(func, args)
  2158|         0|            0|            0|  0.00%|        elif not args:
  2159|         0|            0|            0|  0.00%|            res = func()
  2160|         0|            0|            0|  0.00%|        else:
  2161|         0|            0|            0|  0.00%|            ufunc, otypes = self._get_ufunc_and_otypes(func=func, args=args)
  2162|         0|            0|            0|  0.00%|
  2163|         0|            0|            0|  0.00%|            # Convert args to object arrays first
  2164|         0|            0|            0|  0.00%|            inputs = [array(a, copy=False, subok=True, dtype=object)
  2165|         0|            0|            0|  0.00%|                      for a in args]
  2166|         0|            0|            0|  0.00%|
  2167|         0|            0|            0|  0.00%|            outputs = ufunc(*inputs)
  2168|         0|            0|            0|  0.00%|
  2169|         0|            0|            0|  0.00%|            if ufunc.nout == 1:
  2170|         0|            0|            0|  0.00%|                res = array(outputs, copy=False, subok=True, dtype=otypes[0])
  2171|         0|            0|            0|  0.00%|            else:
  2172|         0|            0|            0|  0.00%|                res = tuple([array(x, copy=False, subok=True, dtype=t)
  2173|         0|            0|            0|  0.00%|                             for x, t in zip(outputs, otypes)])
  2174|         0|            0|            0|  0.00%|        return res
  2175|         0|            0|            0|  0.00%|
  2176|         0|            0|            0|  0.00%|    def _vectorize_call_with_signature(self, func, args):
  2177|         0|            0|            0|  0.00%|        """Vectorized call over positional arguments with a signature."""
  2178|         0|            0|            0|  0.00%|        input_core_dims, output_core_dims = self._in_and_out_core_dims
  2179|         0|            0|            0|  0.00%|
  2180|         0|            0|            0|  0.00%|        if len(args) != len(input_core_dims):
  2181|         0|            0|            0|  0.00%|            raise TypeError('wrong number of positional arguments: '
  2182|         0|            0|            0|  0.00%|                            'expected %r, got %r'
  2183|         0|            0|            0|  0.00%|                            % (len(input_core_dims), len(args)))
  2184|         0|            0|            0|  0.00%|        args = tuple(asanyarray(arg) for arg in args)
  2185|         0|            0|            0|  0.00%|
  2186|         0|            0|            0|  0.00%|        broadcast_shape, dim_sizes = _parse_input_dimensions(
  2187|         0|            0|            0|  0.00%|            args, input_core_dims)
  2188|         0|            0|            0|  0.00%|        input_shapes = _calculate_shapes(broadcast_shape, dim_sizes,
  2189|         0|            0|            0|  0.00%|                                         input_core_dims)
  2190|         0|            0|            0|  0.00%|        args = [np.broadcast_to(arg, shape, subok=True)
  2191|         0|            0|            0|  0.00%|                for arg, shape in zip(args, input_shapes)]
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|        outputs = None
  2194|         0|            0|            0|  0.00%|        otypes = self.otypes
  2195|         0|            0|            0|  0.00%|        nout = len(output_core_dims)
  2196|         0|            0|            0|  0.00%|
  2197|         0|            0|            0|  0.00%|        for index in np.ndindex(*broadcast_shape):
  2198|         0|            0|            0|  0.00%|            results = func(*(arg[index] for arg in args))
  2199|         0|            0|            0|  0.00%|
  2200|         0|            0|            0|  0.00%|            n_results = len(results) if isinstance(results, tuple) else 1
  2201|         0|            0|            0|  0.00%|
  2202|         0|            0|            0|  0.00%|            if nout != n_results:
  2203|         0|            0|            0|  0.00%|                raise ValueError(
  2204|         0|            0|            0|  0.00%|                    'wrong number of outputs from pyfunc: expected %r, got %r'
  2205|         0|            0|            0|  0.00%|                    % (nout, n_results))
  2206|         0|            0|            0|  0.00%|
  2207|         0|            0|            0|  0.00%|            if nout == 1:
  2208|         0|            0|            0|  0.00%|                results = (results,)
  2209|         0|            0|            0|  0.00%|
  2210|         0|            0|            0|  0.00%|            if outputs is None:
  2211|         0|            0|            0|  0.00%|                for result, core_dims in zip(results, output_core_dims):
  2212|         0|            0|            0|  0.00%|                    _update_dim_sizes(dim_sizes, result, core_dims)
  2213|         0|            0|            0|  0.00%|
  2214|         0|            0|            0|  0.00%|                if otypes is None:
  2215|         0|            0|            0|  0.00%|                    otypes = [asarray(result).dtype for result in results]
  2216|         0|            0|            0|  0.00%|
  2217|         0|            0|            0|  0.00%|                outputs = _create_arrays(broadcast_shape, dim_sizes,
  2218|         0|            0|            0|  0.00%|                                         output_core_dims, otypes)
  2219|         0|            0|            0|  0.00%|
  2220|         0|            0|            0|  0.00%|            for output, result in zip(outputs, results):
  2221|         0|            0|            0|  0.00%|                output[index] = result
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|        if outputs is None:
  2224|         0|            0|            0|  0.00%|            # did not call the function even once
  2225|         0|            0|            0|  0.00%|            if otypes is None:
  2226|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` on size 0 inputs '
  2227|         0|            0|            0|  0.00%|                                 'unless `otypes` is set')
  2228|         0|            0|            0|  0.00%|            if builtins.any(dim not in dim_sizes
  2229|         0|            0|            0|  0.00%|                            for dims in output_core_dims
  2230|         0|            0|            0|  0.00%|                            for dim in dims):
  2231|         0|            0|            0|  0.00%|                raise ValueError('cannot call `vectorize` with a signature '
  2232|         0|            0|            0|  0.00%|                                 'including new output dimensions on size 0 '
  2233|         0|            0|            0|  0.00%|                                 'inputs')
  2234|         0|            0|            0|  0.00%|            outputs = _create_arrays(broadcast_shape, dim_sizes,
  2235|         0|            0|            0|  0.00%|                                     output_core_dims, otypes)
  2236|         0|            0|            0|  0.00%|
  2237|         0|            0|            0|  0.00%|        return outputs[0] if nout == 1 else outputs
  2238|         0|            0|            0|  0.00%|
  2239|         0|            0|            0|  0.00%|
  2240|         0|            0|            0|  0.00%|def _cov_dispatcher(m, y=None, rowvar=None, bias=None, ddof=None,
  2241|         0|            0|            0|  0.00%|                    fweights=None, aweights=None):
  2242|         0|            0|            0|  0.00%|    return (m, y, fweights, aweights)
  2243|         0|            0|            0|  0.00%|
  2244|         0|            0|            0|  0.00%|
  2245|         0|            0|            0|  0.00%|@array_function_dispatch(_cov_dispatcher)
  2246|         0|            0|            0|  0.00%|def cov(m, y=None, rowvar=True, bias=False, ddof=None, fweights=None,
  2247|         0|            0|            0|  0.00%|        aweights=None):
  2248|         0|            0|            0|  0.00%|    """
  2249|         0|            0|            0|  0.00%|    Estimate a covariance matrix, given data and weights.
  2250|         0|            0|            0|  0.00%|
  2251|         0|            0|            0|  0.00%|    Covariance indicates the level to which two variables vary together.
  2252|         0|            0|            0|  0.00%|    If we examine N-dimensional samples, :math:`X = [x_1, x_2, ... x_N]^T`,
  2253|         0|            0|            0|  0.00%|    then the covariance matrix element :math:`C_{ij}` is the covariance of
  2254|         0|            0|            0|  0.00%|    :math:`x_i` and :math:`x_j`. The element :math:`C_{ii}` is the variance
  2255|         0|            0|            0|  0.00%|    of :math:`x_i`.
  2256|         0|            0|            0|  0.00%|
  2257|         0|            0|            0|  0.00%|    See the notes for an outline of the algorithm.
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|    Parameters
  2260|         0|            0|            0|  0.00%|    ----------
  2261|         0|            0|            0|  0.00%|    m : array_like
  2262|         0|            0|            0|  0.00%|        A 1-D or 2-D array containing multiple variables and observations.
  2263|         0|            0|            0|  0.00%|        Each row of `m` represents a variable, and each column a single
  2264|         0|            0|            0|  0.00%|        observation of all those variables. Also see `rowvar` below.
  2265|         0|            0|            0|  0.00%|    y : array_like, optional
  2266|         0|            0|            0|  0.00%|        An additional set of variables and observations. `y` has the same form
  2267|         0|            0|            0|  0.00%|        as that of `m`.
  2268|         0|            0|            0|  0.00%|    rowvar : bool, optional
  2269|         0|            0|            0|  0.00%|        If `rowvar` is True (default), then each row represents a
  2270|         0|            0|            0|  0.00%|        variable, with observations in the columns. Otherwise, the relationship
  2271|         0|            0|            0|  0.00%|        is transposed: each column represents a variable, while the rows
  2272|         0|            0|            0|  0.00%|        contain observations.
  2273|         0|            0|            0|  0.00%|    bias : bool, optional
  2274|         0|            0|            0|  0.00%|        Default normalization (False) is by ``(N - 1)``, where ``N`` is the
  2275|         0|            0|            0|  0.00%|        number of observations given (unbiased estimate). If `bias` is True,
  2276|         0|            0|            0|  0.00%|        then normalization is by ``N``. These values can be overridden by using
  2277|         0|            0|            0|  0.00%|        the keyword ``ddof`` in numpy versions >= 1.5.
  2278|         0|            0|            0|  0.00%|    ddof : int, optional
  2279|         0|            0|            0|  0.00%|        If not ``None`` the default value implied by `bias` is overridden.
  2280|         0|            0|            0|  0.00%|        Note that ``ddof=1`` will return the unbiased estimate, even if both
  2281|         0|            0|            0|  0.00%|        `fweights` and `aweights` are specified, and ``ddof=0`` will return
  2282|         0|            0|            0|  0.00%|        the simple average. See the notes for the details. The default value
  2283|         0|            0|            0|  0.00%|        is ``None``.
  2284|         0|            0|            0|  0.00%|
  2285|         0|            0|            0|  0.00%|        .. versionadded:: 1.5
  2286|         0|            0|            0|  0.00%|    fweights : array_like, int, optional
  2287|         0|            0|            0|  0.00%|        1-D array of integer frequency weights; the number of times each
  2288|         0|            0|            0|  0.00%|        observation vector should be repeated.
  2289|         0|            0|            0|  0.00%|
  2290|         0|            0|            0|  0.00%|        .. versionadded:: 1.10
  2291|         0|            0|            0|  0.00%|    aweights : array_like, optional
  2292|         0|            0|            0|  0.00%|        1-D array of observation vector weights. These relative weights are
  2293|         0|            0|            0|  0.00%|        typically large for observations considered "important" and smaller for
  2294|         0|            0|            0|  0.00%|        observations considered less "important". If ``ddof=0`` the array of
  2295|         0|            0|            0|  0.00%|        weights can be used to assign probabilities to observation vectors.
  2296|         0|            0|            0|  0.00%|
  2297|         0|            0|            0|  0.00%|        .. versionadded:: 1.10
  2298|         0|            0|            0|  0.00%|
  2299|         0|            0|            0|  0.00%|    Returns
  2300|         0|            0|            0|  0.00%|    -------
  2301|         0|            0|            0|  0.00%|    out : ndarray
  2302|         0|            0|            0|  0.00%|        The covariance matrix of the variables.
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|    See Also
  2305|         0|            0|            0|  0.00%|    --------
  2306|         0|            0|            0|  0.00%|    corrcoef : Normalized covariance matrix
  2307|         0|            0|            0|  0.00%|
  2308|         0|            0|            0|  0.00%|    Notes
  2309|         0|            0|            0|  0.00%|    -----
  2310|         0|            0|            0|  0.00%|    Assume that the observations are in the columns of the observation
  2311|         0|            0|            0|  0.00%|    array `m` and let ``f = fweights`` and ``a = aweights`` for brevity. The
  2312|         0|            0|            0|  0.00%|    steps to compute the weighted covariance are as follows::
  2313|         0|            0|            0|  0.00%|
  2314|         0|            0|            0|  0.00%|        >>> m = np.arange(10, dtype=np.float64)
  2315|         0|            0|            0|  0.00%|        >>> f = np.arange(10) * 2
  2316|         0|            0|            0|  0.00%|        >>> a = np.arange(10) ** 2.
  2317|         0|            0|            0|  0.00%|        >>> ddof = 9 # N - 1
  2318|         0|            0|            0|  0.00%|        >>> w = f * a
  2319|         0|            0|            0|  0.00%|        >>> v1 = np.sum(w)
  2320|         0|            0|            0|  0.00%|        >>> v2 = np.sum(w * a)
  2321|         0|            0|            0|  0.00%|        >>> m -= np.sum(m * w, axis=None, keepdims=True) / v1
  2322|         0|            0|            0|  0.00%|        >>> cov = np.dot(m * w, m.T) * v1 / (v1**2 - ddof * v2)
  2323|         0|            0|            0|  0.00%|
  2324|         0|            0|            0|  0.00%|    Note that when ``a == 1``, the normalization factor
  2325|         0|            0|            0|  0.00%|    ``v1 / (v1**2 - ddof * v2)`` goes over to ``1 / (np.sum(f) - ddof)``
  2326|         0|            0|            0|  0.00%|    as it should.
  2327|         0|            0|            0|  0.00%|
  2328|         0|            0|            0|  0.00%|    Examples
  2329|         0|            0|            0|  0.00%|    --------
  2330|         0|            0|            0|  0.00%|    Consider two variables, :math:`x_0` and :math:`x_1`, which
  2331|         0|            0|            0|  0.00%|    correlate perfectly, but in opposite directions:
  2332|         0|            0|            0|  0.00%|
  2333|         0|            0|            0|  0.00%|    >>> x = np.array([[0, 2], [1, 1], [2, 0]]).T
  2334|         0|            0|            0|  0.00%|    >>> x
  2335|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  2336|         0|            0|            0|  0.00%|           [2, 1, 0]])
  2337|         0|            0|            0|  0.00%|
  2338|         0|            0|            0|  0.00%|    Note how :math:`x_0` increases while :math:`x_1` decreases. The covariance
  2339|         0|            0|            0|  0.00%|    matrix shows this clearly:
  2340|         0|            0|            0|  0.00%|
  2341|         0|            0|            0|  0.00%|    >>> np.cov(x)
  2342|         0|            0|            0|  0.00%|    array([[ 1., -1.],
  2343|         0|            0|            0|  0.00%|           [-1.,  1.]])
  2344|         0|            0|            0|  0.00%|
  2345|         0|            0|            0|  0.00%|    Note that element :math:`C_{0,1}`, which shows the correlation between
  2346|         0|            0|            0|  0.00%|    :math:`x_0` and :math:`x_1`, is negative.
  2347|         0|            0|            0|  0.00%|
  2348|         0|            0|            0|  0.00%|    Further, note how `x` and `y` are combined:
  2349|         0|            0|            0|  0.00%|
  2350|         0|            0|            0|  0.00%|    >>> x = [-2.1, -1,  4.3]
  2351|         0|            0|            0|  0.00%|    >>> y = [3,  1.1,  0.12]
  2352|         0|            0|            0|  0.00%|    >>> X = np.stack((x, y), axis=0)
  2353|         0|            0|            0|  0.00%|    >>> np.cov(X)
  2354|         0|            0|            0|  0.00%|    array([[11.71      , -4.286     ], # may vary
  2355|         0|            0|            0|  0.00%|           [-4.286     ,  2.144133]])
  2356|         0|            0|            0|  0.00%|    >>> np.cov(x, y)
  2357|         0|            0|            0|  0.00%|    array([[11.71      , -4.286     ], # may vary
  2358|         0|            0|            0|  0.00%|           [-4.286     ,  2.144133]])
  2359|         0|            0|            0|  0.00%|    >>> np.cov(x)
  2360|         0|            0|            0|  0.00%|    array(11.71)
  2361|         0|            0|            0|  0.00%|
  2362|         0|            0|            0|  0.00%|    """
  2363|         0|            0|            0|  0.00%|    # Check inputs
  2364|         0|            0|            0|  0.00%|    if ddof is not None and ddof != int(ddof):
  2365|         0|            0|            0|  0.00%|        raise ValueError(
  2366|         0|            0|            0|  0.00%|            "ddof must be integer")
  2367|         0|            0|            0|  0.00%|
  2368|         0|            0|            0|  0.00%|    # Handles complex arrays too
  2369|         0|            0|            0|  0.00%|    m = np.asarray(m)
  2370|         0|            0|            0|  0.00%|    if m.ndim > 2:
  2371|         0|            0|            0|  0.00%|        raise ValueError("m has more than 2 dimensions")
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|    if y is None:
  2374|         0|            0|            0|  0.00%|        dtype = np.result_type(m, np.float64)
  2375|         0|            0|            0|  0.00%|    else:
  2376|         0|            0|            0|  0.00%|        y = np.asarray(y)
  2377|         0|            0|            0|  0.00%|        if y.ndim > 2:
  2378|         0|            0|            0|  0.00%|            raise ValueError("y has more than 2 dimensions")
  2379|         0|            0|            0|  0.00%|        dtype = np.result_type(m, y, np.float64)
  2380|         0|            0|            0|  0.00%|
  2381|         0|            0|            0|  0.00%|    X = array(m, ndmin=2, dtype=dtype)
  2382|         0|            0|            0|  0.00%|    if not rowvar and X.shape[0] != 1:
  2383|         0|            0|            0|  0.00%|        X = X.T
  2384|         0|            0|            0|  0.00%|    if X.shape[0] == 0:
  2385|         0|            0|            0|  0.00%|        return np.array([]).reshape(0, 0)
  2386|         0|            0|            0|  0.00%|    if y is not None:
  2387|         0|            0|            0|  0.00%|        y = array(y, copy=False, ndmin=2, dtype=dtype)
  2388|         0|            0|            0|  0.00%|        if not rowvar and y.shape[0] != 1:
  2389|         0|            0|            0|  0.00%|            y = y.T
  2390|         0|            0|            0|  0.00%|        X = np.concatenate((X, y), axis=0)
  2391|         0|            0|            0|  0.00%|
  2392|         0|            0|            0|  0.00%|    if ddof is None:
  2393|         0|            0|            0|  0.00%|        if bias == 0:
  2394|         0|            0|            0|  0.00%|            ddof = 1
  2395|         0|            0|            0|  0.00%|        else:
  2396|         0|            0|            0|  0.00%|            ddof = 0
  2397|         0|            0|            0|  0.00%|
  2398|         0|            0|            0|  0.00%|    # Get the product of frequencies and weights
  2399|         0|            0|            0|  0.00%|    w = None
  2400|         0|            0|            0|  0.00%|    if fweights is not None:
  2401|         0|            0|            0|  0.00%|        fweights = np.asarray(fweights, dtype=float)
  2402|         0|            0|            0|  0.00%|        if not np.all(fweights == np.around(fweights)):
  2403|         0|            0|            0|  0.00%|            raise TypeError(
  2404|         0|            0|            0|  0.00%|                "fweights must be integer")
  2405|         0|            0|            0|  0.00%|        if fweights.ndim > 1:
  2406|         0|            0|            0|  0.00%|            raise RuntimeError(
  2407|         0|            0|            0|  0.00%|                "cannot handle multidimensional fweights")
  2408|         0|            0|            0|  0.00%|        if fweights.shape[0] != X.shape[1]:
  2409|         0|            0|            0|  0.00%|            raise RuntimeError(
  2410|         0|            0|            0|  0.00%|                "incompatible numbers of samples and fweights")
  2411|         0|            0|            0|  0.00%|        if any(fweights < 0):
  2412|         0|            0|            0|  0.00%|            raise ValueError(
  2413|         0|            0|            0|  0.00%|                "fweights cannot be negative")
  2414|         0|            0|            0|  0.00%|        w = fweights
  2415|         0|            0|            0|  0.00%|    if aweights is not None:
  2416|         0|            0|            0|  0.00%|        aweights = np.asarray(aweights, dtype=float)
  2417|         0|            0|            0|  0.00%|        if aweights.ndim > 1:
  2418|         0|            0|            0|  0.00%|            raise RuntimeError(
  2419|         0|            0|            0|  0.00%|                "cannot handle multidimensional aweights")
  2420|         0|            0|            0|  0.00%|        if aweights.shape[0] != X.shape[1]:
  2421|         0|            0|            0|  0.00%|            raise RuntimeError(
  2422|         0|            0|            0|  0.00%|                "incompatible numbers of samples and aweights")
  2423|         0|            0|            0|  0.00%|        if any(aweights < 0):
  2424|         0|            0|            0|  0.00%|            raise ValueError(
  2425|         0|            0|            0|  0.00%|                "aweights cannot be negative")
  2426|         0|            0|            0|  0.00%|        if w is None:
  2427|         0|            0|            0|  0.00%|            w = aweights
  2428|         0|            0|            0|  0.00%|        else:
  2429|         0|            0|            0|  0.00%|            w *= aweights
  2430|         0|            0|            0|  0.00%|
  2431|         0|            0|            0|  0.00%|    avg, w_sum = average(X, axis=1, weights=w, returned=True)
  2432|         0|            0|            0|  0.00%|    w_sum = w_sum[0]
  2433|         0|            0|            0|  0.00%|
  2434|         0|            0|            0|  0.00%|    # Determine the normalization
  2435|         0|            0|            0|  0.00%|    if w is None:
  2436|         0|            0|            0|  0.00%|        fact = X.shape[1] - ddof
  2437|         0|            0|            0|  0.00%|    elif ddof == 0:
  2438|         0|            0|            0|  0.00%|        fact = w_sum
  2439|         0|            0|            0|  0.00%|    elif aweights is None:
  2440|         0|            0|            0|  0.00%|        fact = w_sum - ddof
  2441|         0|            0|            0|  0.00%|    else:
  2442|         0|            0|            0|  0.00%|        fact = w_sum - ddof*sum(w*aweights)/w_sum
  2443|         0|            0|            0|  0.00%|
  2444|         0|            0|            0|  0.00%|    if fact <= 0:
  2445|         0|            0|            0|  0.00%|        warnings.warn("Degrees of freedom <= 0 for slice",
  2446|         0|            0|            0|  0.00%|                      RuntimeWarning, stacklevel=3)
  2447|         0|            0|            0|  0.00%|        fact = 0.0
  2448|         0|            0|            0|  0.00%|
  2449|         0|            0|            0|  0.00%|    X -= avg[:, None]
  2450|         0|            0|            0|  0.00%|    if w is None:
  2451|         0|            0|            0|  0.00%|        X_T = X.T
  2452|         0|            0|            0|  0.00%|    else:
  2453|         0|            0|            0|  0.00%|        X_T = (X*w).T
  2454|         0|            0|            0|  0.00%|    c = dot(X, X_T.conj())
  2455|         0|            0|            0|  0.00%|    c *= np.true_divide(1, fact)
  2456|         0|            0|            0|  0.00%|    return c.squeeze()
  2457|         0|            0|            0|  0.00%|
  2458|         0|            0|            0|  0.00%|
  2459|         0|            0|            0|  0.00%|def _corrcoef_dispatcher(x, y=None, rowvar=None, bias=None, ddof=None):
  2460|         0|            0|            0|  0.00%|    return (x, y)
  2461|         0|            0|            0|  0.00%|
  2462|         0|            0|            0|  0.00%|
  2463|         0|            0|            0|  0.00%|@array_function_dispatch(_corrcoef_dispatcher)
  2464|         0|            0|            0|  0.00%|def corrcoef(x, y=None, rowvar=True, bias=np._NoValue, ddof=np._NoValue):
  2465|         0|            0|            0|  0.00%|    """
  2466|         0|            0|            0|  0.00%|    Return Pearson product-moment correlation coefficients.
  2467|         0|            0|            0|  0.00%|
  2468|         0|            0|            0|  0.00%|    Please refer to the documentation for `cov` for more detail.  The
  2469|         0|            0|            0|  0.00%|    relationship between the correlation coefficient matrix, `R`, and the
  2470|         0|            0|            0|  0.00%|    covariance matrix, `C`, is
  2471|         0|            0|            0|  0.00%|
  2472|         0|            0|            0|  0.00%|    .. math:: R_{ij} = \\frac{ C_{ij} } { \\sqrt{ C_{ii} * C_{jj} } }
  2473|         0|            0|            0|  0.00%|
  2474|         0|            0|            0|  0.00%|    The values of `R` are between -1 and 1, inclusive.
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|    Parameters
  2477|         0|            0|            0|  0.00%|    ----------
  2478|         0|            0|            0|  0.00%|    x : array_like
  2479|         0|            0|            0|  0.00%|        A 1-D or 2-D array containing multiple variables and observations.
  2480|         0|            0|            0|  0.00%|        Each row of `x` represents a variable, and each column a single
  2481|         0|            0|            0|  0.00%|        observation of all those variables. Also see `rowvar` below.
  2482|         0|            0|            0|  0.00%|    y : array_like, optional
  2483|         0|            0|            0|  0.00%|        An additional set of variables and observations. `y` has the same
  2484|         0|            0|            0|  0.00%|        shape as `x`.
  2485|         0|            0|            0|  0.00%|    rowvar : bool, optional
  2486|         0|            0|            0|  0.00%|        If `rowvar` is True (default), then each row represents a
  2487|         0|            0|            0|  0.00%|        variable, with observations in the columns. Otherwise, the relationship
  2488|         0|            0|            0|  0.00%|        is transposed: each column represents a variable, while the rows
  2489|         0|            0|            0|  0.00%|        contain observations.
  2490|         0|            0|            0|  0.00%|    bias : _NoValue, optional
  2491|         0|            0|            0|  0.00%|        Has no effect, do not use.
  2492|         0|            0|            0|  0.00%|
  2493|         0|            0|            0|  0.00%|        .. deprecated:: 1.10.0
  2494|         0|            0|            0|  0.00%|    ddof : _NoValue, optional
  2495|         0|            0|            0|  0.00%|        Has no effect, do not use.
  2496|         0|            0|            0|  0.00%|
  2497|         0|            0|            0|  0.00%|        .. deprecated:: 1.10.0
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|    Returns
  2500|         0|            0|            0|  0.00%|    -------
  2501|         0|            0|            0|  0.00%|    R : ndarray
  2502|         0|            0|            0|  0.00%|        The correlation coefficient matrix of the variables.
  2503|         0|            0|            0|  0.00%|
  2504|         0|            0|            0|  0.00%|    See Also
  2505|         0|            0|            0|  0.00%|    --------
  2506|         0|            0|            0|  0.00%|    cov : Covariance matrix
  2507|         0|            0|            0|  0.00%|
  2508|         0|            0|            0|  0.00%|    Notes
  2509|         0|            0|            0|  0.00%|    -----
  2510|         0|            0|            0|  0.00%|    Due to floating point rounding the resulting array may not be Hermitian,
  2511|         0|            0|            0|  0.00%|    the diagonal elements may not be 1, and the elements may not satisfy the
  2512|         0|            0|            0|  0.00%|    inequality abs(a) <= 1. The real and imaginary parts are clipped to the
  2513|         0|            0|            0|  0.00%|    interval [-1,  1] in an attempt to improve on that situation but is not
  2514|         0|            0|            0|  0.00%|    much help in the complex case.
  2515|         0|            0|            0|  0.00%|
  2516|         0|            0|            0|  0.00%|    This function accepts but discards arguments `bias` and `ddof`.  This is
  2517|         0|            0|            0|  0.00%|    for backwards compatibility with previous versions of this function.  These
  2518|         0|            0|            0|  0.00%|    arguments had no effect on the return values of the function and can be
  2519|         0|            0|            0|  0.00%|    safely ignored in this and previous versions of numpy.
  2520|         0|            0|            0|  0.00%|
  2521|         0|            0|            0|  0.00%|    """
  2522|         0|            0|            0|  0.00%|    if bias is not np._NoValue or ddof is not np._NoValue:
  2523|         0|            0|            0|  0.00%|        # 2015-03-15, 1.10
  2524|         0|            0|            0|  0.00%|        warnings.warn('bias and ddof have no effect and are deprecated',
  2525|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=3)
  2526|         0|            0|            0|  0.00%|    c = cov(x, y, rowvar)
  2527|         0|            0|            0|  0.00%|    try:
  2528|         0|            0|            0|  0.00%|        d = diag(c)
  2529|         0|            0|            0|  0.00%|    except ValueError:
  2530|         0|            0|            0|  0.00%|        # scalar covariance
  2531|         0|            0|            0|  0.00%|        # nan if incorrect value (nan, inf, 0), 1 otherwise
  2532|         0|            0|            0|  0.00%|        return c / c
  2533|         0|            0|            0|  0.00%|    stddev = sqrt(d.real)
  2534|         0|            0|            0|  0.00%|    c /= stddev[:, None]
  2535|         0|            0|            0|  0.00%|    c /= stddev[None, :]
  2536|         0|            0|            0|  0.00%|
  2537|         0|            0|            0|  0.00%|    # Clip real and imaginary parts to [-1, 1].  This does not guarantee
  2538|         0|            0|            0|  0.00%|    # abs(a[i,j]) <= 1 for complex arrays, but is the best we can do without
  2539|         0|            0|            0|  0.00%|    # excessive work.
  2540|         0|            0|            0|  0.00%|    np.clip(c.real, -1, 1, out=c.real)
  2541|         0|            0|            0|  0.00%|    if np.iscomplexobj(c):
  2542|         0|            0|            0|  0.00%|        np.clip(c.imag, -1, 1, out=c.imag)
  2543|         0|            0|            0|  0.00%|
  2544|         0|            0|            0|  0.00%|    return c
  2545|         0|            0|            0|  0.00%|
  2546|         0|            0|            0|  0.00%|
  2547|         0|            0|            0|  0.00%|@set_module('numpy')
  2548|         0|            0|            0|  0.00%|def blackman(M):
  2549|         0|            0|            0|  0.00%|    """
  2550|         0|            0|            0|  0.00%|    Return the Blackman window.
  2551|         0|            0|            0|  0.00%|
  2552|         0|            0|            0|  0.00%|    The Blackman window is a taper formed by using the first three
  2553|         0|            0|            0|  0.00%|    terms of a summation of cosines. It was designed to have close to the
  2554|         0|            0|            0|  0.00%|    minimal leakage possible.  It is close to optimal, only slightly worse
  2555|         0|            0|            0|  0.00%|    than a Kaiser window.
  2556|         0|            0|            0|  0.00%|
  2557|         0|            0|            0|  0.00%|    Parameters
  2558|         0|            0|            0|  0.00%|    ----------
  2559|         0|            0|            0|  0.00%|    M : int
  2560|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an empty
  2561|         0|            0|            0|  0.00%|        array is returned.
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|    Returns
  2564|         0|            0|            0|  0.00%|    -------
  2565|         0|            0|            0|  0.00%|    out : ndarray
  2566|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value one
  2567|         0|            0|            0|  0.00%|        appears only if the number of samples is odd).
  2568|         0|            0|            0|  0.00%|
  2569|         0|            0|            0|  0.00%|    See Also
  2570|         0|            0|            0|  0.00%|    --------
  2571|         0|            0|            0|  0.00%|    bartlett, hamming, hanning, kaiser
  2572|         0|            0|            0|  0.00%|
  2573|         0|            0|            0|  0.00%|    Notes
  2574|         0|            0|            0|  0.00%|    -----
  2575|         0|            0|            0|  0.00%|    The Blackman window is defined as
  2576|         0|            0|            0|  0.00%|
  2577|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.42 - 0.5 \\cos(2\\pi n/M) + 0.08 \\cos(4\\pi n/M)
  2578|         0|            0|            0|  0.00%|
  2579|         0|            0|            0|  0.00%|    Most references to the Blackman window come from the signal processing
  2580|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  2581|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  2582|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  2583|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function. It is known as a
  2584|         0|            0|            0|  0.00%|    "near optimal" tapering function, almost as good (by some measures)
  2585|         0|            0|            0|  0.00%|    as the kaiser window.
  2586|         0|            0|            0|  0.00%|
  2587|         0|            0|            0|  0.00%|    References
  2588|         0|            0|            0|  0.00%|    ----------
  2589|         0|            0|            0|  0.00%|    Blackman, R.B. and Tukey, J.W., (1958) The measurement of power spectra,
  2590|         0|            0|            0|  0.00%|    Dover Publications, New York.
  2591|         0|            0|            0|  0.00%|
  2592|         0|            0|            0|  0.00%|    Oppenheim, A.V., and R.W. Schafer. Discrete-Time Signal Processing.
  2593|         0|            0|            0|  0.00%|    Upper Saddle River, NJ: Prentice-Hall, 1999, pp. 468-471.
  2594|         0|            0|            0|  0.00%|
  2595|         0|            0|            0|  0.00%|    Examples
  2596|         0|            0|            0|  0.00%|    --------
  2597|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2598|         0|            0|            0|  0.00%|    >>> np.blackman(12)
  2599|         0|            0|            0|  0.00%|    array([-1.38777878e-17,   3.26064346e-02,   1.59903635e-01, # may vary
  2600|         0|            0|            0|  0.00%|            4.14397981e-01,   7.36045180e-01,   9.67046769e-01,
  2601|         0|            0|            0|  0.00%|            9.67046769e-01,   7.36045180e-01,   4.14397981e-01,
  2602|         0|            0|            0|  0.00%|            1.59903635e-01,   3.26064346e-02,  -1.38777878e-17])
  2603|         0|            0|            0|  0.00%|
  2604|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  2605|         0|            0|            0|  0.00%|
  2606|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  2607|         0|            0|            0|  0.00%|    >>> window = np.blackman(51)
  2608|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  2609|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2610|         0|            0|            0|  0.00%|    >>> plt.title("Blackman window")
  2611|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Blackman window')
  2612|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  2613|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  2614|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  2615|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  2616|         0|            0|            0|  0.00%|    >>> plt.show()
  2617|         0|            0|            0|  0.00%|
  2618|         0|            0|            0|  0.00%|    >>> plt.figure()
  2619|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  2620|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  2621|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  2622|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  2623|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  2624|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  2625|         0|            0|            0|  0.00%|    ...
  2626|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  2627|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  2628|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2629|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Blackman window")
  2630|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Blackman window')
  2631|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  2632|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  2633|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  2634|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  2635|         0|            0|            0|  0.00%|    >>> _ = plt.axis('tight')
  2636|         0|            0|            0|  0.00%|    >>> plt.show()
  2637|         0|            0|            0|  0.00%|
  2638|         0|            0|            0|  0.00%|    """
  2639|         0|            0|            0|  0.00%|    if M < 1:
  2640|         0|            0|            0|  0.00%|        return array([])
  2641|         0|            0|            0|  0.00%|    if M == 1:
  2642|         0|            0|            0|  0.00%|        return ones(1, float)
  2643|         0|            0|            0|  0.00%|    n = arange(0, M)
  2644|         0|            0|            0|  0.00%|    return 0.42 - 0.5*cos(2.0*pi*n/(M-1)) + 0.08*cos(4.0*pi*n/(M-1))
  2645|         0|            0|            0|  0.00%|
  2646|         0|            0|            0|  0.00%|
  2647|         0|            0|            0|  0.00%|@set_module('numpy')
  2648|         0|            0|            0|  0.00%|def bartlett(M):
  2649|         0|            0|            0|  0.00%|    """
  2650|         0|            0|            0|  0.00%|    Return the Bartlett window.
  2651|         0|            0|            0|  0.00%|
  2652|         0|            0|            0|  0.00%|    The Bartlett window is very similar to a triangular window, except
  2653|         0|            0|            0|  0.00%|    that the end points are at zero.  It is often used in signal
  2654|         0|            0|            0|  0.00%|    processing for tapering a signal, without generating too much
  2655|         0|            0|            0|  0.00%|    ripple in the frequency domain.
  2656|         0|            0|            0|  0.00%|
  2657|         0|            0|            0|  0.00%|    Parameters
  2658|         0|            0|            0|  0.00%|    ----------
  2659|         0|            0|            0|  0.00%|    M : int
  2660|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  2661|         0|            0|            0|  0.00%|        empty array is returned.
  2662|         0|            0|            0|  0.00%|
  2663|         0|            0|            0|  0.00%|    Returns
  2664|         0|            0|            0|  0.00%|    -------
  2665|         0|            0|            0|  0.00%|    out : array
  2666|         0|            0|            0|  0.00%|        The triangular window, with the maximum value normalized to one
  2667|         0|            0|            0|  0.00%|        (the value one appears only if the number of samples is odd), with
  2668|         0|            0|            0|  0.00%|        the first and last samples equal to zero.
  2669|         0|            0|            0|  0.00%|
  2670|         0|            0|            0|  0.00%|    See Also
  2671|         0|            0|            0|  0.00%|    --------
  2672|         0|            0|            0|  0.00%|    blackman, hamming, hanning, kaiser
  2673|         0|            0|            0|  0.00%|
  2674|         0|            0|            0|  0.00%|    Notes
  2675|         0|            0|            0|  0.00%|    -----
  2676|         0|            0|            0|  0.00%|    The Bartlett window is defined as
  2677|         0|            0|            0|  0.00%|
  2678|         0|            0|            0|  0.00%|    .. math:: w(n) = \\frac{2}{M-1} \\left(
  2679|         0|            0|            0|  0.00%|              \\frac{M-1}{2} - \\left|n - \\frac{M-1}{2}\\right|
  2680|         0|            0|            0|  0.00%|              \\right)
  2681|         0|            0|            0|  0.00%|
  2682|         0|            0|            0|  0.00%|    Most references to the Bartlett window come from the signal
  2683|         0|            0|            0|  0.00%|    processing literature, where it is used as one of many windowing
  2684|         0|            0|            0|  0.00%|    functions for smoothing values.  Note that convolution with this
  2685|         0|            0|            0|  0.00%|    window produces linear interpolation.  It is also known as an
  2686|         0|            0|            0|  0.00%|    apodization (which means"removing the foot", i.e. smoothing
  2687|         0|            0|            0|  0.00%|    discontinuities at the beginning and end of the sampled signal) or
  2688|         0|            0|            0|  0.00%|    tapering function. The fourier transform of the Bartlett is the product
  2689|         0|            0|            0|  0.00%|    of two sinc functions.
  2690|         0|            0|            0|  0.00%|    Note the excellent discussion in Kanasewich.
  2691|         0|            0|            0|  0.00%|
  2692|         0|            0|            0|  0.00%|    References
  2693|         0|            0|            0|  0.00%|    ----------
  2694|         0|            0|            0|  0.00%|    .. [1] M.S. Bartlett, "Periodogram Analysis and Continuous Spectra",
  2695|         0|            0|            0|  0.00%|           Biometrika 37, 1-16, 1950.
  2696|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
  2697|         0|            0|            0|  0.00%|           The University of Alberta Press, 1975, pp. 109-110.
  2698|         0|            0|            0|  0.00%|    .. [3] A.V. Oppenheim and R.W. Schafer, "Discrete-Time Signal
  2699|         0|            0|            0|  0.00%|           Processing", Prentice-Hall, 1999, pp. 468-471.
  2700|         0|            0|            0|  0.00%|    .. [4] Wikipedia, "Window function",
  2701|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  2702|         0|            0|            0|  0.00%|    .. [5] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  2703|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 429.
  2704|         0|            0|            0|  0.00%|
  2705|         0|            0|            0|  0.00%|    Examples
  2706|         0|            0|            0|  0.00%|    --------
  2707|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2708|         0|            0|            0|  0.00%|    >>> np.bartlett(12)
  2709|         0|            0|            0|  0.00%|    array([ 0.        ,  0.18181818,  0.36363636,  0.54545455,  0.72727273, # may vary
  2710|         0|            0|            0|  0.00%|            0.90909091,  0.90909091,  0.72727273,  0.54545455,  0.36363636,
  2711|         0|            0|            0|  0.00%|            0.18181818,  0.        ])
  2712|         0|            0|            0|  0.00%|
  2713|         0|            0|            0|  0.00%|    Plot the window and its frequency response (requires SciPy and matplotlib):
  2714|         0|            0|            0|  0.00%|
  2715|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  2716|         0|            0|            0|  0.00%|    >>> window = np.bartlett(51)
  2717|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  2718|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2719|         0|            0|            0|  0.00%|    >>> plt.title("Bartlett window")
  2720|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Bartlett window')
  2721|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  2722|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  2723|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  2724|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  2725|         0|            0|            0|  0.00%|    >>> plt.show()
  2726|         0|            0|            0|  0.00%|
  2727|         0|            0|            0|  0.00%|    >>> plt.figure()
  2728|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  2729|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  2730|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  2731|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  2732|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  2733|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  2734|         0|            0|            0|  0.00%|    ...
  2735|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  2736|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  2737|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2738|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Bartlett window")
  2739|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Bartlett window')
  2740|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  2741|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  2742|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  2743|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  2744|         0|            0|            0|  0.00%|    >>> _ = plt.axis('tight')
  2745|         0|            0|            0|  0.00%|    >>> plt.show()
  2746|         0|            0|            0|  0.00%|
  2747|         0|            0|            0|  0.00%|    """
  2748|         0|            0|            0|  0.00%|    if M < 1:
  2749|         0|            0|            0|  0.00%|        return array([])
  2750|         0|            0|            0|  0.00%|    if M == 1:
  2751|         0|            0|            0|  0.00%|        return ones(1, float)
  2752|         0|            0|            0|  0.00%|    n = arange(0, M)
  2753|         0|            0|            0|  0.00%|    return where(less_equal(n, (M-1)/2.0), 2.0*n/(M-1), 2.0 - 2.0*n/(M-1))
  2754|         0|            0|            0|  0.00%|
  2755|         0|            0|            0|  0.00%|
  2756|         0|            0|            0|  0.00%|@set_module('numpy')
  2757|         0|            0|            0|  0.00%|def hanning(M):
  2758|         0|            0|            0|  0.00%|    """
  2759|         0|            0|            0|  0.00%|    Return the Hanning window.
  2760|         0|            0|            0|  0.00%|
  2761|         0|            0|            0|  0.00%|    The Hanning window is a taper formed by using a weighted cosine.
  2762|         0|            0|            0|  0.00%|
  2763|         0|            0|            0|  0.00%|    Parameters
  2764|         0|            0|            0|  0.00%|    ----------
  2765|         0|            0|            0|  0.00%|    M : int
  2766|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  2767|         0|            0|            0|  0.00%|        empty array is returned.
  2768|         0|            0|            0|  0.00%|
  2769|         0|            0|            0|  0.00%|    Returns
  2770|         0|            0|            0|  0.00%|    -------
  2771|         0|            0|            0|  0.00%|    out : ndarray, shape(M,)
  2772|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  2773|         0|            0|            0|  0.00%|        one appears only if `M` is odd).
  2774|         0|            0|            0|  0.00%|
  2775|         0|            0|            0|  0.00%|    See Also
  2776|         0|            0|            0|  0.00%|    --------
  2777|         0|            0|            0|  0.00%|    bartlett, blackman, hamming, kaiser
  2778|         0|            0|            0|  0.00%|
  2779|         0|            0|            0|  0.00%|    Notes
  2780|         0|            0|            0|  0.00%|    -----
  2781|         0|            0|            0|  0.00%|    The Hanning window is defined as
  2782|         0|            0|            0|  0.00%|
  2783|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.5 - 0.5cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
  2784|         0|            0|            0|  0.00%|               \\qquad 0 \\leq n \\leq M-1
  2785|         0|            0|            0|  0.00%|
  2786|         0|            0|            0|  0.00%|    The Hanning was named for Julius von Hann, an Austrian meteorologist.
  2787|         0|            0|            0|  0.00%|    It is also known as the Cosine Bell. Some authors prefer that it be
  2788|         0|            0|            0|  0.00%|    called a Hann window, to help avoid confusion with the very similar
  2789|         0|            0|            0|  0.00%|    Hamming window.
  2790|         0|            0|            0|  0.00%|
  2791|         0|            0|            0|  0.00%|    Most references to the Hanning window come from the signal processing
  2792|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  2793|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  2794|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  2795|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  2796|         0|            0|            0|  0.00%|
  2797|         0|            0|            0|  0.00%|    References
  2798|         0|            0|            0|  0.00%|    ----------
  2799|         0|            0|            0|  0.00%|    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
  2800|         0|            0|            0|  0.00%|           spectra, Dover Publications, New York.
  2801|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics",
  2802|         0|            0|            0|  0.00%|           The University of Alberta Press, 1975, pp. 106-108.
  2803|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  2804|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  2805|         0|            0|            0|  0.00%|    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  2806|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 425.
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|    Examples
  2809|         0|            0|            0|  0.00%|    --------
  2810|         0|            0|            0|  0.00%|    >>> np.hanning(12)
  2811|         0|            0|            0|  0.00%|    array([0.        , 0.07937323, 0.29229249, 0.57115742, 0.82743037,
  2812|         0|            0|            0|  0.00%|           0.97974649, 0.97974649, 0.82743037, 0.57115742, 0.29229249,
  2813|         0|            0|            0|  0.00%|           0.07937323, 0.        ])
  2814|         0|            0|            0|  0.00%|
  2815|         0|            0|            0|  0.00%|    Plot the window and its frequency response:
  2816|         0|            0|            0|  0.00%|
  2817|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2818|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  2819|         0|            0|            0|  0.00%|    >>> window = np.hanning(51)
  2820|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  2821|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2822|         0|            0|            0|  0.00%|    >>> plt.title("Hann window")
  2823|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Hann window')
  2824|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  2825|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  2826|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  2827|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  2828|         0|            0|            0|  0.00%|    >>> plt.show()
  2829|         0|            0|            0|  0.00%|
  2830|         0|            0|            0|  0.00%|    >>> plt.figure()
  2831|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  2832|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  2833|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  2834|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  2835|         0|            0|            0|  0.00%|    >>> with np.errstate(divide='ignore', invalid='ignore'):
  2836|         0|            0|            0|  0.00%|    ...     response = 20 * np.log10(mag)
  2837|         0|            0|            0|  0.00%|    ...
  2838|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  2839|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  2840|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2841|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of the Hann window")
  2842|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of the Hann window')
  2843|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  2844|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  2845|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  2846|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  2847|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  2848|         0|            0|            0|  0.00%|    ...
  2849|         0|            0|            0|  0.00%|    >>> plt.show()
  2850|         0|            0|            0|  0.00%|
  2851|         0|            0|            0|  0.00%|    """
  2852|         0|            0|            0|  0.00%|    if M < 1:
  2853|         0|            0|            0|  0.00%|        return array([])
  2854|         0|            0|            0|  0.00%|    if M == 1:
  2855|         0|            0|            0|  0.00%|        return ones(1, float)
  2856|         0|            0|            0|  0.00%|    n = arange(0, M)
  2857|         0|            0|            0|  0.00%|    return 0.5 - 0.5*cos(2.0*pi*n/(M-1))
  2858|         0|            0|            0|  0.00%|
  2859|         0|            0|            0|  0.00%|
  2860|         0|            0|            0|  0.00%|@set_module('numpy')
  2861|         0|            0|            0|  0.00%|def hamming(M):
  2862|         0|            0|            0|  0.00%|    """
  2863|         0|            0|            0|  0.00%|    Return the Hamming window.
  2864|         0|            0|            0|  0.00%|
  2865|         0|            0|            0|  0.00%|    The Hamming window is a taper formed by using a weighted cosine.
  2866|         0|            0|            0|  0.00%|
  2867|         0|            0|            0|  0.00%|    Parameters
  2868|         0|            0|            0|  0.00%|    ----------
  2869|         0|            0|            0|  0.00%|    M : int
  2870|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  2871|         0|            0|            0|  0.00%|        empty array is returned.
  2872|         0|            0|            0|  0.00%|
  2873|         0|            0|            0|  0.00%|    Returns
  2874|         0|            0|            0|  0.00%|    -------
  2875|         0|            0|            0|  0.00%|    out : ndarray
  2876|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  2877|         0|            0|            0|  0.00%|        one appears only if the number of samples is odd).
  2878|         0|            0|            0|  0.00%|
  2879|         0|            0|            0|  0.00%|    See Also
  2880|         0|            0|            0|  0.00%|    --------
  2881|         0|            0|            0|  0.00%|    bartlett, blackman, hanning, kaiser
  2882|         0|            0|            0|  0.00%|
  2883|         0|            0|            0|  0.00%|    Notes
  2884|         0|            0|            0|  0.00%|    -----
  2885|         0|            0|            0|  0.00%|    The Hamming window is defined as
  2886|         0|            0|            0|  0.00%|
  2887|         0|            0|            0|  0.00%|    .. math::  w(n) = 0.54 - 0.46cos\\left(\\frac{2\\pi{n}}{M-1}\\right)
  2888|         0|            0|            0|  0.00%|               \\qquad 0 \\leq n \\leq M-1
  2889|         0|            0|            0|  0.00%|
  2890|         0|            0|            0|  0.00%|    The Hamming was named for R. W. Hamming, an associate of J. W. Tukey
  2891|         0|            0|            0|  0.00%|    and is described in Blackman and Tukey. It was recommended for
  2892|         0|            0|            0|  0.00%|    smoothing the truncated autocovariance function in the time domain.
  2893|         0|            0|            0|  0.00%|    Most references to the Hamming window come from the signal processing
  2894|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  2895|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  2896|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  2897|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  2898|         0|            0|            0|  0.00%|
  2899|         0|            0|            0|  0.00%|    References
  2900|         0|            0|            0|  0.00%|    ----------
  2901|         0|            0|            0|  0.00%|    .. [1] Blackman, R.B. and Tukey, J.W., (1958) The measurement of power
  2902|         0|            0|            0|  0.00%|           spectra, Dover Publications, New York.
  2903|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
  2904|         0|            0|            0|  0.00%|           University of Alberta Press, 1975, pp. 109-110.
  2905|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  2906|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  2907|         0|            0|            0|  0.00%|    .. [4] W.H. Press,  B.P. Flannery, S.A. Teukolsky, and W.T. Vetterling,
  2908|         0|            0|            0|  0.00%|           "Numerical Recipes", Cambridge University Press, 1986, page 425.
  2909|         0|            0|            0|  0.00%|
  2910|         0|            0|            0|  0.00%|    Examples
  2911|         0|            0|            0|  0.00%|    --------
  2912|         0|            0|            0|  0.00%|    >>> np.hamming(12)
  2913|         0|            0|            0|  0.00%|    array([ 0.08      ,  0.15302337,  0.34890909,  0.60546483,  0.84123594, # may vary
  2914|         0|            0|            0|  0.00%|            0.98136677,  0.98136677,  0.84123594,  0.60546483,  0.34890909,
  2915|         0|            0|            0|  0.00%|            0.15302337,  0.08      ])
  2916|         0|            0|            0|  0.00%|
  2917|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  2918|         0|            0|            0|  0.00%|
  2919|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  2920|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  2921|         0|            0|            0|  0.00%|    >>> window = np.hamming(51)
  2922|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  2923|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2924|         0|            0|            0|  0.00%|    >>> plt.title("Hamming window")
  2925|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Hamming window')
  2926|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  2927|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  2928|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  2929|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  2930|         0|            0|            0|  0.00%|    >>> plt.show()
  2931|         0|            0|            0|  0.00%|
  2932|         0|            0|            0|  0.00%|    >>> plt.figure()
  2933|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  2934|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  2935|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  2936|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  2937|         0|            0|            0|  0.00%|    >>> response = 20 * np.log10(mag)
  2938|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  2939|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  2940|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  2941|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Hamming window")
  2942|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Hamming window')
  2943|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  2944|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  2945|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  2946|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  2947|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  2948|         0|            0|            0|  0.00%|    ...
  2949|         0|            0|            0|  0.00%|    >>> plt.show()
  2950|         0|            0|            0|  0.00%|
  2951|         0|            0|            0|  0.00%|    """
  2952|         0|            0|            0|  0.00%|    if M < 1:
  2953|         0|            0|            0|  0.00%|        return array([])
  2954|         0|            0|            0|  0.00%|    if M == 1:
  2955|         0|            0|            0|  0.00%|        return ones(1, float)
  2956|         0|            0|            0|  0.00%|    n = arange(0, M)
  2957|         0|            0|            0|  0.00%|    return 0.54 - 0.46*cos(2.0*pi*n/(M-1))
  2958|         0|            0|            0|  0.00%|
  2959|         0|            0|            0|  0.00%|## Code from cephes for i0
  2960|         0|            0|            0|  0.00%|
  2961|         0|            0|            0|  0.00%|_i0A = [
  2962|         0|            0|            0|  0.00%|    -4.41534164647933937950E-18,
  2963|         0|            0|            0|  0.00%|    3.33079451882223809783E-17,
  2964|         0|            0|            0|  0.00%|    -2.43127984654795469359E-16,
  2965|         0|            0|            0|  0.00%|    1.71539128555513303061E-15,
  2966|         0|            0|            0|  0.00%|    -1.16853328779934516808E-14,
  2967|         0|            0|            0|  0.00%|    7.67618549860493561688E-14,
  2968|         0|            0|            0|  0.00%|    -4.85644678311192946090E-13,
  2969|         0|            0|            0|  0.00%|    2.95505266312963983461E-12,
  2970|         0|            0|            0|  0.00%|    -1.72682629144155570723E-11,
  2971|         0|            0|            0|  0.00%|    9.67580903537323691224E-11,
  2972|         0|            0|            0|  0.00%|    -5.18979560163526290666E-10,
  2973|         0|            0|            0|  0.00%|    2.65982372468238665035E-9,
  2974|         0|            0|            0|  0.00%|    -1.30002500998624804212E-8,
  2975|         0|            0|            0|  0.00%|    6.04699502254191894932E-8,
  2976|         0|            0|            0|  0.00%|    -2.67079385394061173391E-7,
  2977|         0|            0|            0|  0.00%|    1.11738753912010371815E-6,
  2978|         0|            0|            0|  0.00%|    -4.41673835845875056359E-6,
  2979|         0|            0|            0|  0.00%|    1.64484480707288970893E-5,
  2980|         0|            0|            0|  0.00%|    -5.75419501008210370398E-5,
  2981|         0|            0|            0|  0.00%|    1.88502885095841655729E-4,
  2982|         0|            0|            0|  0.00%|    -5.76375574538582365885E-4,
  2983|         0|            0|            0|  0.00%|    1.63947561694133579842E-3,
  2984|         0|            0|            0|  0.00%|    -4.32430999505057594430E-3,
  2985|         0|            0|            0|  0.00%|    1.05464603945949983183E-2,
  2986|         0|            0|            0|  0.00%|    -2.37374148058994688156E-2,
  2987|         0|            0|            0|  0.00%|    4.93052842396707084878E-2,
  2988|         0|            0|            0|  0.00%|    -9.49010970480476444210E-2,
  2989|         0|            0|            0|  0.00%|    1.71620901522208775349E-1,
  2990|         0|            0|            0|  0.00%|    -3.04682672343198398683E-1,
  2991|         0|            0|            0|  0.00%|    6.76795274409476084995E-1
  2992|         0|            0|            0|  0.00%|    ]
  2993|         0|            0|            0|  0.00%|
  2994|         0|            0|            0|  0.00%|_i0B = [
  2995|         0|            0|            0|  0.00%|    -7.23318048787475395456E-18,
  2996|         0|            0|            0|  0.00%|    -4.83050448594418207126E-18,
  2997|         0|            0|            0|  0.00%|    4.46562142029675999901E-17,
  2998|         0|            0|            0|  0.00%|    3.46122286769746109310E-17,
  2999|         0|            0|            0|  0.00%|    -2.82762398051658348494E-16,
  3000|         0|            0|            0|  0.00%|    -3.42548561967721913462E-16,
  3001|         0|            0|            0|  0.00%|    1.77256013305652638360E-15,
  3002|         0|            0|            0|  0.00%|    3.81168066935262242075E-15,
  3003|         0|            0|            0|  0.00%|    -9.55484669882830764870E-15,
  3004|         0|            0|            0|  0.00%|    -4.15056934728722208663E-14,
  3005|         0|            0|            0|  0.00%|    1.54008621752140982691E-14,
  3006|         0|            0|            0|  0.00%|    3.85277838274214270114E-13,
  3007|         0|            0|            0|  0.00%|    7.18012445138366623367E-13,
  3008|         0|            0|            0|  0.00%|    -1.79417853150680611778E-12,
  3009|         0|            0|            0|  0.00%|    -1.32158118404477131188E-11,
  3010|         0|            0|            0|  0.00%|    -3.14991652796324136454E-11,
  3011|         0|            0|            0|  0.00%|    1.18891471078464383424E-11,
  3012|         0|            0|            0|  0.00%|    4.94060238822496958910E-10,
  3013|         0|            0|            0|  0.00%|    3.39623202570838634515E-9,
  3014|         0|            0|            0|  0.00%|    2.26666899049817806459E-8,
  3015|         0|            0|            0|  0.00%|    2.04891858946906374183E-7,
  3016|         0|            0|            0|  0.00%|    2.89137052083475648297E-6,
  3017|         0|            0|            0|  0.00%|    6.88975834691682398426E-5,
  3018|         0|            0|            0|  0.00%|    3.36911647825569408990E-3,
  3019|         0|            0|            0|  0.00%|    8.04490411014108831608E-1
  3020|         0|            0|            0|  0.00%|    ]
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|
  3023|         0|            0|            0|  0.00%|def _chbevl(x, vals):
  3024|         0|            0|            0|  0.00%|    b0 = vals[0]
  3025|         0|            0|            0|  0.00%|    b1 = 0.0
  3026|         0|            0|            0|  0.00%|
  3027|         0|            0|            0|  0.00%|    for i in range(1, len(vals)):
  3028|         0|            0|            0|  0.00%|        b2 = b1
  3029|         0|            0|            0|  0.00%|        b1 = b0
  3030|         0|            0|            0|  0.00%|        b0 = x*b1 - b2 + vals[i]
  3031|         0|            0|            0|  0.00%|
  3032|         0|            0|            0|  0.00%|    return 0.5*(b0 - b2)
  3033|         0|            0|            0|  0.00%|
  3034|         0|            0|            0|  0.00%|
  3035|         0|            0|            0|  0.00%|def _i0_1(x):
  3036|         0|            0|            0|  0.00%|    return exp(x) * _chbevl(x/2.0-2, _i0A)
  3037|         0|            0|            0|  0.00%|
  3038|         0|            0|            0|  0.00%|
  3039|         0|            0|            0|  0.00%|def _i0_2(x):
  3040|         0|            0|            0|  0.00%|    return exp(x) * _chbevl(32.0/x - 2.0, _i0B) / sqrt(x)
  3041|         0|            0|            0|  0.00%|
  3042|         0|            0|            0|  0.00%|
  3043|         0|            0|            0|  0.00%|def _i0_dispatcher(x):
  3044|         0|            0|            0|  0.00%|    return (x,)
  3045|         0|            0|            0|  0.00%|
  3046|         0|            0|            0|  0.00%|
  3047|         0|            0|            0|  0.00%|@array_function_dispatch(_i0_dispatcher)
  3048|         0|            0|            0|  0.00%|def i0(x):
  3049|         0|            0|            0|  0.00%|    """
  3050|         0|            0|            0|  0.00%|    Modified Bessel function of the first kind, order 0.
  3051|         0|            0|            0|  0.00%|
  3052|         0|            0|            0|  0.00%|    Usually denoted :math:`I_0`.  This function does broadcast, but will *not*
  3053|         0|            0|            0|  0.00%|    "up-cast" int dtype arguments unless accompanied by at least one float or
  3054|         0|            0|            0|  0.00%|    complex dtype argument (see Raises below).
  3055|         0|            0|            0|  0.00%|
  3056|         0|            0|            0|  0.00%|    Parameters
  3057|         0|            0|            0|  0.00%|    ----------
  3058|         0|            0|            0|  0.00%|    x : array_like, dtype float or complex
  3059|         0|            0|            0|  0.00%|        Argument of the Bessel function.
  3060|         0|            0|            0|  0.00%|
  3061|         0|            0|            0|  0.00%|    Returns
  3062|         0|            0|            0|  0.00%|    -------
  3063|         0|            0|            0|  0.00%|    out : ndarray, shape = x.shape, dtype = x.dtype
  3064|         0|            0|            0|  0.00%|        The modified Bessel function evaluated at each of the elements of `x`.
  3065|         0|            0|            0|  0.00%|
  3066|         0|            0|            0|  0.00%|    Raises
  3067|         0|            0|            0|  0.00%|    ------
  3068|         0|            0|            0|  0.00%|    TypeError: array cannot be safely cast to required type
  3069|         0|            0|            0|  0.00%|        If argument consists exclusively of int dtypes.
  3070|         0|            0|            0|  0.00%|
  3071|         0|            0|            0|  0.00%|    See Also
  3072|         0|            0|            0|  0.00%|    --------
  3073|         0|            0|            0|  0.00%|    scipy.special.i0, scipy.special.iv, scipy.special.ive
  3074|         0|            0|            0|  0.00%|
  3075|         0|            0|            0|  0.00%|    Notes
  3076|         0|            0|            0|  0.00%|    -----
  3077|         0|            0|            0|  0.00%|    The scipy implementation is recommended over this function: it is a
  3078|         0|            0|            0|  0.00%|    proper ufunc written in C, and more than an order of magnitude faster.
  3079|         0|            0|            0|  0.00%|
  3080|         0|            0|            0|  0.00%|    We use the algorithm published by Clenshaw [1]_ and referenced by
  3081|         0|            0|            0|  0.00%|    Abramowitz and Stegun [2]_, for which the function domain is
  3082|         0|            0|            0|  0.00%|    partitioned into the two intervals [0,8] and (8,inf), and Chebyshev
  3083|         0|            0|            0|  0.00%|    polynomial expansions are employed in each interval. Relative error on
  3084|         0|            0|            0|  0.00%|    the domain [0,30] using IEEE arithmetic is documented [3]_ as having a
  3085|         0|            0|            0|  0.00%|    peak of 5.8e-16 with an rms of 1.4e-16 (n = 30000).
  3086|         0|            0|            0|  0.00%|
  3087|         0|            0|            0|  0.00%|    References
  3088|         0|            0|            0|  0.00%|    ----------
  3089|         0|            0|            0|  0.00%|    .. [1] C. W. Clenshaw, "Chebyshev series for mathematical functions", in
  3090|         0|            0|            0|  0.00%|           *National Physical Laboratory Mathematical Tables*, vol. 5, London:
  3091|         0|            0|            0|  0.00%|           Her Majesty's Stationery Office, 1962.
  3092|         0|            0|            0|  0.00%|    .. [2] M. Abramowitz and I. A. Stegun, *Handbook of Mathematical
  3093|         0|            0|            0|  0.00%|           Functions*, 10th printing, New York: Dover, 1964, pp. 379.
  3094|         0|            0|            0|  0.00%|           http://www.math.sfu.ca/~cbm/aands/page_379.htm
  3095|         0|            0|            0|  0.00%|    .. [3] http://kobesearch.cpan.org/htdocs/Math-Cephes/Math/Cephes.html
  3096|         0|            0|            0|  0.00%|
  3097|         0|            0|            0|  0.00%|    Examples
  3098|         0|            0|            0|  0.00%|    --------
  3099|         0|            0|            0|  0.00%|    >>> np.i0(0.)
  3100|         0|            0|            0|  0.00%|    array(1.0)  # may vary
  3101|         0|            0|            0|  0.00%|    >>> np.i0([0., 1. + 2j])
  3102|         0|            0|            0|  0.00%|    array([ 1.00000000+0.j        ,  0.18785373+0.64616944j])  # may vary
  3103|         0|            0|            0|  0.00%|
  3104|         0|            0|            0|  0.00%|    """
  3105|         0|            0|            0|  0.00%|    x = np.asanyarray(x)
  3106|         0|            0|            0|  0.00%|    x = np.abs(x)
  3107|         0|            0|            0|  0.00%|    return piecewise(x, [x <= 8.0], [_i0_1, _i0_2])
  3108|         0|            0|            0|  0.00%|
  3109|         0|            0|            0|  0.00%|## End of cephes code for i0
  3110|         0|            0|            0|  0.00%|
  3111|         0|            0|            0|  0.00%|
  3112|         0|            0|            0|  0.00%|@set_module('numpy')
  3113|         0|            0|            0|  0.00%|def kaiser(M, beta):
  3114|         0|            0|            0|  0.00%|    """
  3115|         0|            0|            0|  0.00%|    Return the Kaiser window.
  3116|         0|            0|            0|  0.00%|
  3117|         0|            0|            0|  0.00%|    The Kaiser window is a taper formed by using a Bessel function.
  3118|         0|            0|            0|  0.00%|
  3119|         0|            0|            0|  0.00%|    Parameters
  3120|         0|            0|            0|  0.00%|    ----------
  3121|         0|            0|            0|  0.00%|    M : int
  3122|         0|            0|            0|  0.00%|        Number of points in the output window. If zero or less, an
  3123|         0|            0|            0|  0.00%|        empty array is returned.
  3124|         0|            0|            0|  0.00%|    beta : float
  3125|         0|            0|            0|  0.00%|        Shape parameter for window.
  3126|         0|            0|            0|  0.00%|
  3127|         0|            0|            0|  0.00%|    Returns
  3128|         0|            0|            0|  0.00%|    -------
  3129|         0|            0|            0|  0.00%|    out : array
  3130|         0|            0|            0|  0.00%|        The window, with the maximum value normalized to one (the value
  3131|         0|            0|            0|  0.00%|        one appears only if the number of samples is odd).
  3132|         0|            0|            0|  0.00%|
  3133|         0|            0|            0|  0.00%|    See Also
  3134|         0|            0|            0|  0.00%|    --------
  3135|         0|            0|            0|  0.00%|    bartlett, blackman, hamming, hanning
  3136|         0|            0|            0|  0.00%|
  3137|         0|            0|            0|  0.00%|    Notes
  3138|         0|            0|            0|  0.00%|    -----
  3139|         0|            0|            0|  0.00%|    The Kaiser window is defined as
  3140|         0|            0|            0|  0.00%|
  3141|         0|            0|            0|  0.00%|    .. math::  w(n) = I_0\\left( \\beta \\sqrt{1-\\frac{4n^2}{(M-1)^2}}
  3142|         0|            0|            0|  0.00%|               \\right)/I_0(\\beta)
  3143|         0|            0|            0|  0.00%|
  3144|         0|            0|            0|  0.00%|    with
  3145|         0|            0|            0|  0.00%|
  3146|         0|            0|            0|  0.00%|    .. math:: \\quad -\\frac{M-1}{2} \\leq n \\leq \\frac{M-1}{2},
  3147|         0|            0|            0|  0.00%|
  3148|         0|            0|            0|  0.00%|    where :math:`I_0` is the modified zeroth-order Bessel function.
  3149|         0|            0|            0|  0.00%|
  3150|         0|            0|            0|  0.00%|    The Kaiser was named for Jim Kaiser, who discovered a simple
  3151|         0|            0|            0|  0.00%|    approximation to the DPSS window based on Bessel functions.  The Kaiser
  3152|         0|            0|            0|  0.00%|    window is a very good approximation to the Digital Prolate Spheroidal
  3153|         0|            0|            0|  0.00%|    Sequence, or Slepian window, which is the transform which maximizes the
  3154|         0|            0|            0|  0.00%|    energy in the main lobe of the window relative to total energy.
  3155|         0|            0|            0|  0.00%|
  3156|         0|            0|            0|  0.00%|    The Kaiser can approximate many other windows by varying the beta
  3157|         0|            0|            0|  0.00%|    parameter.
  3158|         0|            0|            0|  0.00%|
  3159|         0|            0|            0|  0.00%|    ====  =======================
  3160|         0|            0|            0|  0.00%|    beta  Window shape
  3161|         0|            0|            0|  0.00%|    ====  =======================
  3162|         0|            0|            0|  0.00%|    0     Rectangular
  3163|         0|            0|            0|  0.00%|    5     Similar to a Hamming
  3164|         0|            0|            0|  0.00%|    6     Similar to a Hanning
  3165|         0|            0|            0|  0.00%|    8.6   Similar to a Blackman
  3166|         0|            0|            0|  0.00%|    ====  =======================
  3167|         0|            0|            0|  0.00%|
  3168|         0|            0|            0|  0.00%|    A beta value of 14 is probably a good starting point. Note that as beta
  3169|         0|            0|            0|  0.00%|    gets large, the window narrows, and so the number of samples needs to be
  3170|         0|            0|            0|  0.00%|    large enough to sample the increasingly narrow spike, otherwise NaNs will
  3171|         0|            0|            0|  0.00%|    get returned.
  3172|         0|            0|            0|  0.00%|
  3173|         0|            0|            0|  0.00%|    Most references to the Kaiser window come from the signal processing
  3174|         0|            0|            0|  0.00%|    literature, where it is used as one of many windowing functions for
  3175|         0|            0|            0|  0.00%|    smoothing values.  It is also known as an apodization (which means
  3176|         0|            0|            0|  0.00%|    "removing the foot", i.e. smoothing discontinuities at the beginning
  3177|         0|            0|            0|  0.00%|    and end of the sampled signal) or tapering function.
  3178|         0|            0|            0|  0.00%|
  3179|         0|            0|            0|  0.00%|    References
  3180|         0|            0|            0|  0.00%|    ----------
  3181|         0|            0|            0|  0.00%|    .. [1] J. F. Kaiser, "Digital Filters" - Ch 7 in "Systems analysis by
  3182|         0|            0|            0|  0.00%|           digital computer", Editors: F.F. Kuo and J.F. Kaiser, p 218-285.
  3183|         0|            0|            0|  0.00%|           John Wiley and Sons, New York, (1966).
  3184|         0|            0|            0|  0.00%|    .. [2] E.R. Kanasewich, "Time Sequence Analysis in Geophysics", The
  3185|         0|            0|            0|  0.00%|           University of Alberta Press, 1975, pp. 177-178.
  3186|         0|            0|            0|  0.00%|    .. [3] Wikipedia, "Window function",
  3187|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Window_function
  3188|         0|            0|            0|  0.00%|
  3189|         0|            0|            0|  0.00%|    Examples
  3190|         0|            0|            0|  0.00%|    --------
  3191|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3192|         0|            0|            0|  0.00%|    >>> np.kaiser(12, 14)
  3193|         0|            0|            0|  0.00%|     array([7.72686684e-06, 3.46009194e-03, 4.65200189e-02, # may vary
  3194|         0|            0|            0|  0.00%|            2.29737120e-01, 5.99885316e-01, 9.45674898e-01,
  3195|         0|            0|            0|  0.00%|            9.45674898e-01, 5.99885316e-01, 2.29737120e-01,
  3196|         0|            0|            0|  0.00%|            4.65200189e-02, 3.46009194e-03, 7.72686684e-06])
  3197|         0|            0|            0|  0.00%|
  3198|         0|            0|            0|  0.00%|
  3199|         0|            0|            0|  0.00%|    Plot the window and the frequency response:
  3200|         0|            0|            0|  0.00%|
  3201|         0|            0|            0|  0.00%|    >>> from numpy.fft import fft, fftshift
  3202|         0|            0|            0|  0.00%|    >>> window = np.kaiser(51, 14)
  3203|         0|            0|            0|  0.00%|    >>> plt.plot(window)
  3204|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3205|         0|            0|            0|  0.00%|    >>> plt.title("Kaiser window")
  3206|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Kaiser window')
  3207|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3208|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3209|         0|            0|            0|  0.00%|    >>> plt.xlabel("Sample")
  3210|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Sample')
  3211|         0|            0|            0|  0.00%|    >>> plt.show()
  3212|         0|            0|            0|  0.00%|
  3213|         0|            0|            0|  0.00%|    >>> plt.figure()
  3214|         0|            0|            0|  0.00%|    <Figure size 640x480 with 0 Axes>
  3215|         0|            0|            0|  0.00%|    >>> A = fft(window, 2048) / 25.5
  3216|         0|            0|            0|  0.00%|    >>> mag = np.abs(fftshift(A))
  3217|         0|            0|            0|  0.00%|    >>> freq = np.linspace(-0.5, 0.5, len(A))
  3218|         0|            0|            0|  0.00%|    >>> response = 20 * np.log10(mag)
  3219|         0|            0|            0|  0.00%|    >>> response = np.clip(response, -100, 100)
  3220|         0|            0|            0|  0.00%|    >>> plt.plot(freq, response)
  3221|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3222|         0|            0|            0|  0.00%|    >>> plt.title("Frequency response of Kaiser window")
  3223|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Frequency response of Kaiser window')
  3224|         0|            0|            0|  0.00%|    >>> plt.ylabel("Magnitude [dB]")
  3225|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Magnitude [dB]')
  3226|         0|            0|            0|  0.00%|    >>> plt.xlabel("Normalized frequency [cycles per sample]")
  3227|         0|            0|            0|  0.00%|    Text(0.5, 0, 'Normalized frequency [cycles per sample]')
  3228|         0|            0|            0|  0.00%|    >>> plt.axis('tight')
  3229|         0|            0|            0|  0.00%|    (-0.5, 0.5, -100.0, ...) # may vary
  3230|         0|            0|            0|  0.00%|    >>> plt.show()
  3231|         0|            0|            0|  0.00%|
  3232|         0|            0|            0|  0.00%|    """
  3233|         0|            0|            0|  0.00%|    from numpy.dual import i0
  3234|         0|            0|            0|  0.00%|    if M == 1:
  3235|         0|            0|            0|  0.00%|        return np.array([1.])
  3236|         0|            0|            0|  0.00%|    n = arange(0, M)
  3237|         0|            0|            0|  0.00%|    alpha = (M-1)/2.0
  3238|         0|            0|            0|  0.00%|    return i0(beta * sqrt(1-((n-alpha)/alpha)**2.0))/i0(float(beta))
  3239|         0|            0|            0|  0.00%|
  3240|         0|            0|            0|  0.00%|
  3241|         0|            0|            0|  0.00%|def _sinc_dispatcher(x):
  3242|         0|            0|            0|  0.00%|    return (x,)
  3243|         0|            0|            0|  0.00%|
  3244|         0|            0|            0|  0.00%|
  3245|         0|            0|            0|  0.00%|@array_function_dispatch(_sinc_dispatcher)
  3246|         0|            0|            0|  0.00%|def sinc(x):
  3247|         0|            0|            0|  0.00%|    """
  3248|         0|            0|            0|  0.00%|    Return the sinc function.
  3249|         0|            0|            0|  0.00%|
  3250|         0|            0|            0|  0.00%|    The sinc function is :math:`\\sin(\\pi x)/(\\pi x)`.
  3251|         0|            0|            0|  0.00%|
  3252|         0|            0|            0|  0.00%|    Parameters
  3253|         0|            0|            0|  0.00%|    ----------
  3254|         0|            0|            0|  0.00%|    x : ndarray
  3255|         0|            0|            0|  0.00%|        Array (possibly multi-dimensional) of values for which to to
  3256|         0|            0|            0|  0.00%|        calculate ``sinc(x)``.
  3257|         0|            0|            0|  0.00%|
  3258|         0|            0|            0|  0.00%|    Returns
  3259|         0|            0|            0|  0.00%|    -------
  3260|         0|            0|            0|  0.00%|    out : ndarray
  3261|         0|            0|            0|  0.00%|        ``sinc(x)``, which has the same shape as the input.
  3262|         0|            0|            0|  0.00%|
  3263|         0|            0|            0|  0.00%|    Notes
  3264|         0|            0|            0|  0.00%|    -----
  3265|         0|            0|            0|  0.00%|    ``sinc(0)`` is the limit value 1.
  3266|         0|            0|            0|  0.00%|
  3267|         0|            0|            0|  0.00%|    The name sinc is short for "sine cardinal" or "sinus cardinalis".
  3268|         0|            0|            0|  0.00%|
  3269|         0|            0|            0|  0.00%|    The sinc function is used in various signal processing applications,
  3270|         0|            0|            0|  0.00%|    including in anti-aliasing, in the construction of a Lanczos resampling
  3271|         0|            0|            0|  0.00%|    filter, and in interpolation.
  3272|         0|            0|            0|  0.00%|
  3273|         0|            0|            0|  0.00%|    For bandlimited interpolation of discrete-time signals, the ideal
  3274|         0|            0|            0|  0.00%|    interpolation kernel is proportional to the sinc function.
  3275|         0|            0|            0|  0.00%|
  3276|         0|            0|            0|  0.00%|    References
  3277|         0|            0|            0|  0.00%|    ----------
  3278|         0|            0|            0|  0.00%|    .. [1] Weisstein, Eric W. "Sinc Function." From MathWorld--A Wolfram Web
  3279|         0|            0|            0|  0.00%|           Resource. http://mathworld.wolfram.com/SincFunction.html
  3280|         0|            0|            0|  0.00%|    .. [2] Wikipedia, "Sinc function",
  3281|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/Sinc_function
  3282|         0|            0|            0|  0.00%|
  3283|         0|            0|            0|  0.00%|    Examples
  3284|         0|            0|            0|  0.00%|    --------
  3285|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  3286|         0|            0|            0|  0.00%|    >>> x = np.linspace(-4, 4, 41)
  3287|         0|            0|            0|  0.00%|    >>> np.sinc(x)
  3288|         0|            0|            0|  0.00%|     array([-3.89804309e-17,  -4.92362781e-02,  -8.40918587e-02, # may vary
  3289|         0|            0|            0|  0.00%|            -8.90384387e-02,  -5.84680802e-02,   3.89804309e-17,
  3290|         0|            0|            0|  0.00%|            6.68206631e-02,   1.16434881e-01,   1.26137788e-01,
  3291|         0|            0|            0|  0.00%|            8.50444803e-02,  -3.89804309e-17,  -1.03943254e-01,
  3292|         0|            0|            0|  0.00%|            -1.89206682e-01,  -2.16236208e-01,  -1.55914881e-01,
  3293|         0|            0|            0|  0.00%|            3.89804309e-17,   2.33872321e-01,   5.04551152e-01,
  3294|         0|            0|            0|  0.00%|            7.56826729e-01,   9.35489284e-01,   1.00000000e+00,
  3295|         0|            0|            0|  0.00%|            9.35489284e-01,   7.56826729e-01,   5.04551152e-01,
  3296|         0|            0|            0|  0.00%|            2.33872321e-01,   3.89804309e-17,  -1.55914881e-01,
  3297|         0|            0|            0|  0.00%|           -2.16236208e-01,  -1.89206682e-01,  -1.03943254e-01,
  3298|         0|            0|            0|  0.00%|           -3.89804309e-17,   8.50444803e-02,   1.26137788e-01,
  3299|         0|            0|            0|  0.00%|            1.16434881e-01,   6.68206631e-02,   3.89804309e-17,
  3300|         0|            0|            0|  0.00%|            -5.84680802e-02,  -8.90384387e-02,  -8.40918587e-02,
  3301|         0|            0|            0|  0.00%|            -4.92362781e-02,  -3.89804309e-17])
  3302|         0|            0|            0|  0.00%|
  3303|         0|            0|            0|  0.00%|    >>> plt.plot(x, np.sinc(x))
  3304|         0|            0|            0|  0.00%|    [<matplotlib.lines.Line2D object at 0x...>]
  3305|         0|            0|            0|  0.00%|    >>> plt.title("Sinc Function")
  3306|         0|            0|            0|  0.00%|    Text(0.5, 1.0, 'Sinc Function')
  3307|         0|            0|            0|  0.00%|    >>> plt.ylabel("Amplitude")
  3308|         0|            0|            0|  0.00%|    Text(0, 0.5, 'Amplitude')
  3309|         0|            0|            0|  0.00%|    >>> plt.xlabel("X")
  3310|         0|            0|            0|  0.00%|    Text(0.5, 0, 'X')
  3311|         0|            0|            0|  0.00%|    >>> plt.show()
  3312|         0|            0|            0|  0.00%|
  3313|         0|            0|            0|  0.00%|    It works in 2-D as well:
  3314|         0|            0|            0|  0.00%|
  3315|         0|            0|            0|  0.00%|    >>> x = np.linspace(-4, 4, 401)
  3316|         0|            0|            0|  0.00%|    >>> xx = np.outer(x, x)
  3317|         0|            0|            0|  0.00%|    >>> plt.imshow(np.sinc(xx))
  3318|         0|            0|            0|  0.00%|    <matplotlib.image.AxesImage object at 0x...>
  3319|         0|            0|            0|  0.00%|
  3320|         0|            0|            0|  0.00%|    """
  3321|         0|            0|            0|  0.00%|    x = np.asanyarray(x)
  3322|         0|            0|            0|  0.00%|    y = pi * where(x == 0, 1.0e-20, x)
  3323|         0|            0|            0|  0.00%|    return sin(y)/y
  3324|         0|            0|            0|  0.00%|
  3325|         0|            0|            0|  0.00%|
  3326|         0|            0|            0|  0.00%|def _msort_dispatcher(a):
  3327|         0|            0|            0|  0.00%|    return (a,)
  3328|         0|            0|            0|  0.00%|
  3329|         0|            0|            0|  0.00%|
  3330|         0|            0|            0|  0.00%|@array_function_dispatch(_msort_dispatcher)
  3331|         0|            0|            0|  0.00%|def msort(a):
  3332|         0|            0|            0|  0.00%|    """
  3333|         0|            0|            0|  0.00%|    Return a copy of an array sorted along the first axis.
  3334|         0|            0|            0|  0.00%|
  3335|         0|            0|            0|  0.00%|    Parameters
  3336|         0|            0|            0|  0.00%|    ----------
  3337|         0|            0|            0|  0.00%|    a : array_like
  3338|         0|            0|            0|  0.00%|        Array to be sorted.
  3339|         0|            0|            0|  0.00%|
  3340|         0|            0|            0|  0.00%|    Returns
  3341|         0|            0|            0|  0.00%|    -------
  3342|         0|            0|            0|  0.00%|    sorted_array : ndarray
  3343|         0|            0|            0|  0.00%|        Array of the same type and shape as `a`.
  3344|         0|            0|            0|  0.00%|
  3345|         0|            0|            0|  0.00%|    See Also
  3346|         0|            0|            0|  0.00%|    --------
  3347|         0|            0|            0|  0.00%|    sort
  3348|         0|            0|            0|  0.00%|
  3349|         0|            0|            0|  0.00%|    Notes
  3350|         0|            0|            0|  0.00%|    -----
  3351|         0|            0|            0|  0.00%|    ``np.msort(a)`` is equivalent to  ``np.sort(a, axis=0)``.
  3352|         0|            0|            0|  0.00%|
  3353|         0|            0|            0|  0.00%|    """
  3354|         0|            0|            0|  0.00%|    b = array(a, subok=True, copy=True)
  3355|         0|            0|            0|  0.00%|    b.sort(0)
  3356|         0|            0|            0|  0.00%|    return b
  3357|         0|            0|            0|  0.00%|
  3358|         0|            0|            0|  0.00%|
  3359|         1|  7.39098e-06|  7.39098e-06|  0.00%|def _ureduce(a, func, **kwargs):
  3360|         0|            0|            0|  0.00%|    """
  3361|         0|            0|            0|  0.00%|    Internal Function.
  3362|         0|            0|            0|  0.00%|    Call `func` with `a` as first argument swapping the axes to use extended
  3363|         0|            0|            0|  0.00%|    axis on functions that don't support it natively.
  3364|         0|            0|            0|  0.00%|
  3365|         0|            0|            0|  0.00%|    Returns result and a.shape with axis dims set to 1.
  3366|         0|            0|            0|  0.00%|
  3367|         0|            0|            0|  0.00%|    Parameters
  3368|         0|            0|            0|  0.00%|    ----------
  3369|         0|            0|            0|  0.00%|    a : array_like
  3370|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3371|         0|            0|            0|  0.00%|    func : callable
  3372|         0|            0|            0|  0.00%|        Reduction function capable of receiving a single axis argument.
  3373|         0|            0|            0|  0.00%|        It is called with `a` as first argument followed by `kwargs`.
  3374|         0|            0|            0|  0.00%|    kwargs : keyword arguments
  3375|         0|            0|            0|  0.00%|        additional keyword arguments to pass to `func`.
  3376|         0|            0|            0|  0.00%|
  3377|         0|            0|            0|  0.00%|    Returns
  3378|         0|            0|            0|  0.00%|    -------
  3379|         0|            0|            0|  0.00%|    result : tuple
  3380|         0|            0|            0|  0.00%|        Result of func(a, **kwargs) and a.shape with axis dims set to 1
  3381|         0|            0|            0|  0.00%|        which can be used to reshape the result to the same shape a ufunc with
  3382|         0|            0|            0|  0.00%|        keepdims=True would produce.
  3383|         0|            0|            0|  0.00%|
  3384|         0|            0|            0|  0.00%|    """
  3385|         1|  1.95503e-05|  1.95503e-05|  0.00%|    a = np.asanyarray(a)
(call)|         1|   6.4373e-06|   6.4373e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
  3386|         1|  5.48363e-06|  5.48363e-06|  0.00%|    axis = kwargs.get('axis', None)
  3387|         1|  4.76837e-06|  4.76837e-06|  0.00%|    if axis is not None:
  3388|         0|            0|            0|  0.00%|        keepdim = list(a.shape)
  3389|         0|            0|            0|  0.00%|        nd = a.ndim
  3390|         0|            0|            0|  0.00%|        axis = _nx.normalize_axis_tuple(axis, nd)
  3391|         0|            0|            0|  0.00%|
  3392|         0|            0|            0|  0.00%|        for ax in axis:
  3393|         0|            0|            0|  0.00%|            keepdim[ax] = 1
  3394|         0|            0|            0|  0.00%|
  3395|         0|            0|            0|  0.00%|        if len(axis) == 1:
  3396|         0|            0|            0|  0.00%|            kwargs['axis'] = axis[0]
  3397|         0|            0|            0|  0.00%|        else:
  3398|         0|            0|            0|  0.00%|            keep = set(range(nd)) - set(axis)
  3399|         0|            0|            0|  0.00%|            nkeep = len(keep)
  3400|         0|            0|            0|  0.00%|            # swap axis that should not be reduced to front
  3401|         0|            0|            0|  0.00%|            for i, s in enumerate(sorted(keep)):
  3402|         0|            0|            0|  0.00%|                a = a.swapaxes(i, s)
  3403|         0|            0|            0|  0.00%|            # merge reduced axis
  3404|         0|            0|            0|  0.00%|            a = a.reshape(a.shape[:nkeep] + (-1,))
  3405|         0|            0|            0|  0.00%|            kwargs['axis'] = -1
  3406|         0|            0|            0|  0.00%|        keepdim = tuple(keepdim)
  3407|         0|            0|            0|  0.00%|    else:
  3408|         1|  7.15256e-06|  7.15256e-06|  0.00%|        keepdim = (1,) * a.ndim
  3409|         0|            0|            0|  0.00%|
  3410|         1|  1.62125e-05|  1.62125e-05|  0.00%|    r = func(a, **kwargs)
(call)|         1|   0.00100422|   0.00100422|  0.02%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:3508 _median
  3411|         1|  5.24521e-06|  5.24521e-06|  0.00%|    return r, keepdim
  3412|         0|            0|            0|  0.00%|
  3413|         0|            0|            0|  0.00%|
  3414|         1|   3.8147e-06|   3.8147e-06|  0.00%|def _median_dispatcher(
  3415|         0|            0|            0|  0.00%|        a, axis=None, out=None, overwrite_input=None, keepdims=None):
  3416|         1|   3.8147e-06|   3.8147e-06|  0.00%|    return (a, out)
  3417|         0|            0|            0|  0.00%|
  3418|         0|            0|            0|  0.00%|
  3419|         1|  7.39098e-06|  7.39098e-06|  0.00%|@array_function_dispatch(_median_dispatcher)
  3420|         0|            0|            0|  0.00%|def median(a, axis=None, out=None, overwrite_input=False, keepdims=False):
  3421|         0|            0|            0|  0.00%|    """
  3422|         0|            0|            0|  0.00%|    Compute the median along the specified axis.
  3423|         0|            0|            0|  0.00%|
  3424|         0|            0|            0|  0.00%|    Returns the median of the array elements.
  3425|         0|            0|            0|  0.00%|
  3426|         0|            0|            0|  0.00%|    Parameters
  3427|         0|            0|            0|  0.00%|    ----------
  3428|         0|            0|            0|  0.00%|    a : array_like
  3429|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3430|         0|            0|            0|  0.00%|    axis : {int, sequence of int, None}, optional
  3431|         0|            0|            0|  0.00%|        Axis or axes along which the medians are computed. The default
  3432|         0|            0|            0|  0.00%|        is to compute the median along a flattened version of the array.
  3433|         0|            0|            0|  0.00%|        A sequence of axes is supported since version 1.9.0.
  3434|         0|            0|            0|  0.00%|    out : ndarray, optional
  3435|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3436|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  3437|         0|            0|            0|  0.00%|        but the type (of the output) will be cast if necessary.
  3438|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  3439|         0|            0|            0|  0.00%|       If True, then allow use of memory of input array `a` for
  3440|         0|            0|            0|  0.00%|       calculations. The input array will be modified by the call to
  3441|         0|            0|            0|  0.00%|       `median`. This will save memory when you do not need to preserve
  3442|         0|            0|            0|  0.00%|       the contents of the input array. Treat the input as undefined,
  3443|         0|            0|            0|  0.00%|       but it will probably be fully or partially sorted. Default is
  3444|         0|            0|            0|  0.00%|       False. If `overwrite_input` is ``True`` and `a` is not already an
  3445|         0|            0|            0|  0.00%|       `ndarray`, an error will be raised.
  3446|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3447|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left
  3448|         0|            0|            0|  0.00%|        in the result as dimensions with size one. With this option,
  3449|         0|            0|            0|  0.00%|        the result will broadcast correctly against the original `arr`.
  3450|         0|            0|            0|  0.00%|
  3451|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  3452|         0|            0|            0|  0.00%|
  3453|         0|            0|            0|  0.00%|    Returns
  3454|         0|            0|            0|  0.00%|    -------
  3455|         0|            0|            0|  0.00%|    median : ndarray
  3456|         0|            0|            0|  0.00%|        A new array holding the result. If the input contains integers
  3457|         0|            0|            0|  0.00%|        or floats smaller than ``float64``, then the output data-type is
  3458|         0|            0|            0|  0.00%|        ``np.float64``.  Otherwise, the data-type of the output is the
  3459|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  3460|         0|            0|            0|  0.00%|        returned instead.
  3461|         0|            0|            0|  0.00%|
  3462|         0|            0|            0|  0.00%|    See Also
  3463|         0|            0|            0|  0.00%|    --------
  3464|         0|            0|            0|  0.00%|    mean, percentile
  3465|         0|            0|            0|  0.00%|
  3466|         0|            0|            0|  0.00%|    Notes
  3467|         0|            0|            0|  0.00%|    -----
  3468|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the median of ``V`` is the
  3469|         0|            0|            0|  0.00%|    middle value of a sorted copy of ``V``, ``V_sorted`` - i
  3470|         0|            0|            0|  0.00%|    e., ``V_sorted[(N-1)/2]``, when ``N`` is odd, and the average of the
  3471|         0|            0|            0|  0.00%|    two middle values of ``V_sorted`` when ``N`` is even.
  3472|         0|            0|            0|  0.00%|
  3473|         0|            0|            0|  0.00%|    Examples
  3474|         0|            0|            0|  0.00%|    --------
  3475|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  3476|         0|            0|            0|  0.00%|    >>> a
  3477|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  3478|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  3479|         0|            0|            0|  0.00%|    >>> np.median(a)
  3480|         0|            0|            0|  0.00%|    3.5
  3481|         0|            0|            0|  0.00%|    >>> np.median(a, axis=0)
  3482|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3483|         0|            0|            0|  0.00%|    >>> np.median(a, axis=1)
  3484|         0|            0|            0|  0.00%|    array([7.,  2.])
  3485|         0|            0|            0|  0.00%|    >>> m = np.median(a, axis=0)
  3486|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  3487|         0|            0|            0|  0.00%|    >>> np.median(a, axis=0, out=m)
  3488|         0|            0|            0|  0.00%|    array([6.5,  4.5,  2.5])
  3489|         0|            0|            0|  0.00%|    >>> m
  3490|         0|            0|            0|  0.00%|    array([6.5,  4.5,  2.5])
  3491|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3492|         0|            0|            0|  0.00%|    >>> np.median(b, axis=1, overwrite_input=True)
  3493|         0|            0|            0|  0.00%|    array([7.,  2.])
  3494|         0|            0|            0|  0.00%|    >>> assert not np.all(a==b)
  3495|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3496|         0|            0|            0|  0.00%|    >>> np.median(b, axis=None, overwrite_input=True)
  3497|         0|            0|            0|  0.00%|    3.5
  3498|         0|            0|            0|  0.00%|    >>> assert not np.all(a==b)
  3499|         0|            0|            0|  0.00%|
  3500|         0|            0|            0|  0.00%|    """
  3501|         1|  5.48363e-06|  5.48363e-06|  0.00%|    r, k = _ureduce(a, func=_median, axis=axis, out=out,
  3502|         1|  1.50204e-05|  1.50204e-05|  0.00%|                    overwrite_input=overwrite_input)
(call)|         1|   0.00107646|   0.00107646|  0.02%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:3359 _ureduce
  3503|         1|   3.8147e-06|   3.8147e-06|  0.00%|    if keepdims:
  3504|         0|            0|            0|  0.00%|        return r.reshape(k)
  3505|         0|            0|            0|  0.00%|    else:
  3506|         1|  5.72205e-06|  5.72205e-06|  0.00%|        return r
  3507|         0|            0|            0|  0.00%|
  3508|         1|  5.72205e-06|  5.72205e-06|  0.00%|def _median(a, axis=None, out=None, overwrite_input=False):
  3509|         0|            0|            0|  0.00%|    # can't be reasonably be implemented in terms of percentile as we have to
  3510|         0|            0|            0|  0.00%|    # call mean to not break astropy
  3511|         1|  1.12057e-05|  1.12057e-05|  0.00%|    a = np.asanyarray(a)
(call)|         1|  5.72205e-06|  5.72205e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
  3512|         0|            0|            0|  0.00%|
  3513|         0|            0|            0|  0.00%|    # Set the partition indexes
  3514|         1|  5.96046e-06|  5.96046e-06|  0.00%|    if axis is None:
  3515|         1|  5.72205e-06|  5.72205e-06|  0.00%|        sz = a.size
  3516|         0|            0|            0|  0.00%|    else:
  3517|         0|            0|            0|  0.00%|        sz = a.shape[axis]
  3518|         1|  4.76837e-06|  4.76837e-06|  0.00%|    if sz % 2 == 0:
  3519|         0|            0|            0|  0.00%|        szh = sz // 2
  3520|         0|            0|            0|  0.00%|        kth = [szh - 1, szh]
  3521|         0|            0|            0|  0.00%|    else:
  3522|         1|  5.00679e-06|  5.00679e-06|  0.00%|        kth = [(sz - 1) // 2]
  3523|         0|            0|            0|  0.00%|    # Check if the array contains any nan's
  3524|         1|  1.62125e-05|  1.62125e-05|  0.00%|    if np.issubdtype(a.dtype, np.inexact):
(call)|         1|  8.60691e-05|  8.60691e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numerictypes.py:365 issubdtype
  3525|         1|  5.24521e-06|  5.24521e-06|  0.00%|        kth.append(-1)
  3526|         0|            0|            0|  0.00%|
  3527|         1|  4.29153e-06|  4.29153e-06|  0.00%|    if overwrite_input:
  3528|         0|            0|            0|  0.00%|        if axis is None:
  3529|         0|            0|            0|  0.00%|            part = a.ravel()
  3530|         0|            0|            0|  0.00%|            part.partition(kth)
  3531|         0|            0|            0|  0.00%|        else:
  3532|         0|            0|            0|  0.00%|            a.partition(kth, axis=axis)
  3533|         0|            0|            0|  0.00%|            part = a
  3534|         0|            0|            0|  0.00%|    else:
  3535|         1|  1.40667e-05|  1.40667e-05|  0.00%|        part = partition(a, kth, axis=axis)
(call)|         1|  0.000118017|  0.000118017|  0.00%|# <__array_function__ internals>_5:2 partition
  3536|         0|            0|            0|  0.00%|
  3537|         1|   6.4373e-06|   6.4373e-06|  0.00%|    if part.shape == ():
  3538|         0|            0|            0|  0.00%|        # make 0-D arrays work
  3539|         0|            0|            0|  0.00%|        return part.item()
  3540|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if axis is None:
  3541|         1|  4.05312e-06|  4.05312e-06|  0.00%|        axis = 0
  3542|         0|            0|            0|  0.00%|
  3543|         1|  5.24521e-06|  5.24521e-06|  0.00%|    indexer = [slice(None)] * part.ndim
  3544|         1|  4.52995e-06|  4.52995e-06|  0.00%|    index = part.shape[axis] // 2
  3545|         1|  4.76837e-06|  4.76837e-06|  0.00%|    if part.shape[axis] % 2 == 1:
  3546|         0|            0|            0|  0.00%|        # index with slice to allow mean (below) to work
  3547|         1|  4.52995e-06|  4.52995e-06|  0.00%|        indexer[axis] = slice(index, index+1)
  3548|         0|            0|            0|  0.00%|    else:
  3549|         0|            0|            0|  0.00%|        indexer[axis] = slice(index-1, index+1)
  3550|         1|  4.29153e-06|  4.29153e-06|  0.00%|    indexer = tuple(indexer)
  3551|         0|            0|            0|  0.00%|
  3552|         0|            0|            0|  0.00%|    # Check if the array contains any nan's
  3553|         1|  1.23978e-05|  1.23978e-05|  0.00%|    if np.issubdtype(a.dtype, np.inexact) and sz > 0:
(call)|         1|  4.50611e-05|  4.50611e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numerictypes.py:365 issubdtype
  3554|         0|            0|            0|  0.00%|        # warn and return nans like mean would
  3555|         1|  1.54972e-05|  1.54972e-05|  0.00%|        rout = mean(part[indexer], axis=axis, out=out)
(call)|         1|  0.000222445|  0.000222445|  0.00%|# <__array_function__ internals>_6:2 mean
  3556|         1|  1.83582e-05|  1.83582e-05|  0.00%|        return np.lib.utils._median_nancheck(part, rout, axis, out)
(call)|         1|  0.000364065|  0.000364065|  0.01%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/utils.py:1142 _median_nancheck
  3557|         0|            0|            0|  0.00%|    else:
  3558|         0|            0|            0|  0.00%|        # if there are no nans
  3559|         0|            0|            0|  0.00%|        # Use mean in odd and even case to coerce data type
  3560|         0|            0|            0|  0.00%|        # and check, use out array.
  3561|         0|            0|            0|  0.00%|        return mean(part[indexer], axis=axis, out=out)
  3562|         0|            0|            0|  0.00%|
  3563|         0|            0|            0|  0.00%|
  3564|         0|            0|            0|  0.00%|def _percentile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
  3565|         0|            0|            0|  0.00%|                           interpolation=None, keepdims=None):
  3566|         0|            0|            0|  0.00%|    return (a, q, out)
  3567|         0|            0|            0|  0.00%|
  3568|         0|            0|            0|  0.00%|
  3569|         0|            0|            0|  0.00%|@array_function_dispatch(_percentile_dispatcher)
  3570|         0|            0|            0|  0.00%|def percentile(a, q, axis=None, out=None,
  3571|         0|            0|            0|  0.00%|               overwrite_input=False, interpolation='linear', keepdims=False):
  3572|         0|            0|            0|  0.00%|    """
  3573|         0|            0|            0|  0.00%|    Compute the q-th percentile of the data along the specified axis.
  3574|         0|            0|            0|  0.00%|
  3575|         0|            0|            0|  0.00%|    Returns the q-th percentile(s) of the array elements.
  3576|         0|            0|            0|  0.00%|
  3577|         0|            0|            0|  0.00%|    Parameters
  3578|         0|            0|            0|  0.00%|    ----------
  3579|         0|            0|            0|  0.00%|    a : array_like
  3580|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3581|         0|            0|            0|  0.00%|    q : array_like of float
  3582|         0|            0|            0|  0.00%|        Percentile or sequence of percentiles to compute, which must be between
  3583|         0|            0|            0|  0.00%|        0 and 100 inclusive.
  3584|         0|            0|            0|  0.00%|    axis : {int, tuple of int, None}, optional
  3585|         0|            0|            0|  0.00%|        Axis or axes along which the percentiles are computed. The
  3586|         0|            0|            0|  0.00%|        default is to compute the percentile(s) along a flattened
  3587|         0|            0|            0|  0.00%|        version of the array.
  3588|         0|            0|            0|  0.00%|
  3589|         0|            0|            0|  0.00%|        .. versionchanged:: 1.9.0
  3590|         0|            0|            0|  0.00%|            A tuple of axes is supported
  3591|         0|            0|            0|  0.00%|    out : ndarray, optional
  3592|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3593|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  3594|         0|            0|            0|  0.00%|        but the type (of the output) will be cast if necessary.
  3595|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  3596|         0|            0|            0|  0.00%|        If True, then allow the input array `a` to be modified by intermediate
  3597|         0|            0|            0|  0.00%|        calculations, to save memory. In this case, the contents of the input
  3598|         0|            0|            0|  0.00%|        `a` after this function completes is undefined.
  3599|         0|            0|            0|  0.00%|
  3600|         0|            0|            0|  0.00%|    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
  3601|         0|            0|            0|  0.00%|        This optional parameter specifies the interpolation method to
  3602|         0|            0|            0|  0.00%|        use when the desired percentile lies between two data points
  3603|         0|            0|            0|  0.00%|        ``i < j``:
  3604|         0|            0|            0|  0.00%|
  3605|         0|            0|            0|  0.00%|        * 'linear': ``i + (j - i) * fraction``, where ``fraction``
  3606|         0|            0|            0|  0.00%|          is the fractional part of the index surrounded by ``i``
  3607|         0|            0|            0|  0.00%|          and ``j``.
  3608|         0|            0|            0|  0.00%|        * 'lower': ``i``.
  3609|         0|            0|            0|  0.00%|        * 'higher': ``j``.
  3610|         0|            0|            0|  0.00%|        * 'nearest': ``i`` or ``j``, whichever is nearest.
  3611|         0|            0|            0|  0.00%|        * 'midpoint': ``(i + j) / 2``.
  3612|         0|            0|            0|  0.00%|
  3613|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  3614|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3615|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in
  3616|         0|            0|            0|  0.00%|        the result as dimensions with size one. With this option, the
  3617|         0|            0|            0|  0.00%|        result will broadcast correctly against the original array `a`.
  3618|         0|            0|            0|  0.00%|
  3619|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  3620|         0|            0|            0|  0.00%|
  3621|         0|            0|            0|  0.00%|    Returns
  3622|         0|            0|            0|  0.00%|    -------
  3623|         0|            0|            0|  0.00%|    percentile : scalar or ndarray
  3624|         0|            0|            0|  0.00%|        If `q` is a single percentile and `axis=None`, then the result
  3625|         0|            0|            0|  0.00%|        is a scalar. If multiple percentiles are given, first axis of
  3626|         0|            0|            0|  0.00%|        the result corresponds to the percentiles. The other axes are
  3627|         0|            0|            0|  0.00%|        the axes that remain after the reduction of `a`. If the input
  3628|         0|            0|            0|  0.00%|        contains integers or floats smaller than ``float64``, the output
  3629|         0|            0|            0|  0.00%|        data-type is ``float64``. Otherwise, the output data-type is the
  3630|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  3631|         0|            0|            0|  0.00%|        returned instead.
  3632|         0|            0|            0|  0.00%|
  3633|         0|            0|            0|  0.00%|    See Also
  3634|         0|            0|            0|  0.00%|    --------
  3635|         0|            0|            0|  0.00%|    mean
  3636|         0|            0|            0|  0.00%|    median : equivalent to ``percentile(..., 50)``
  3637|         0|            0|            0|  0.00%|    nanpercentile
  3638|         0|            0|            0|  0.00%|    quantile : equivalent to percentile, except with q in the range [0, 1].
  3639|         0|            0|            0|  0.00%|
  3640|         0|            0|            0|  0.00%|    Notes
  3641|         0|            0|            0|  0.00%|    -----
  3642|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the q-th percentile of
  3643|         0|            0|            0|  0.00%|    ``V`` is the value ``q/100`` of the way from the minimum to the
  3644|         0|            0|            0|  0.00%|    maximum in a sorted copy of ``V``. The values and distances of
  3645|         0|            0|            0|  0.00%|    the two nearest neighbors as well as the `interpolation` parameter
  3646|         0|            0|            0|  0.00%|    will determine the percentile if the normalized ranking does not
  3647|         0|            0|            0|  0.00%|    match the location of ``q`` exactly. This function is the same as
  3648|         0|            0|            0|  0.00%|    the median if ``q=50``, the same as the minimum if ``q=0`` and the
  3649|         0|            0|            0|  0.00%|    same as the maximum if ``q=100``.
  3650|         0|            0|            0|  0.00%|
  3651|         0|            0|            0|  0.00%|    Examples
  3652|         0|            0|            0|  0.00%|    --------
  3653|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  3654|         0|            0|            0|  0.00%|    >>> a
  3655|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  3656|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  3657|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50)
  3658|         0|            0|            0|  0.00%|    3.5
  3659|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=0)
  3660|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3661|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=1)
  3662|         0|            0|            0|  0.00%|    array([7.,  2.])
  3663|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=1, keepdims=True)
  3664|         0|            0|            0|  0.00%|    array([[7.],
  3665|         0|            0|            0|  0.00%|           [2.]])
  3666|         0|            0|            0|  0.00%|
  3667|         0|            0|            0|  0.00%|    >>> m = np.percentile(a, 50, axis=0)
  3668|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  3669|         0|            0|            0|  0.00%|    >>> np.percentile(a, 50, axis=0, out=out)
  3670|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3671|         0|            0|            0|  0.00%|    >>> m
  3672|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3673|         0|            0|            0|  0.00%|
  3674|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3675|         0|            0|            0|  0.00%|    >>> np.percentile(b, 50, axis=1, overwrite_input=True)
  3676|         0|            0|            0|  0.00%|    array([7.,  2.])
  3677|         0|            0|            0|  0.00%|    >>> assert not np.all(a == b)
  3678|         0|            0|            0|  0.00%|
  3679|         0|            0|            0|  0.00%|    The different types of interpolation can be visualized graphically:
  3680|         0|            0|            0|  0.00%|
  3681|         0|            0|            0|  0.00%|    .. plot::
  3682|         0|            0|            0|  0.00%|
  3683|         0|            0|            0|  0.00%|        import matplotlib.pyplot as plt
  3684|         0|            0|            0|  0.00%|
  3685|         0|            0|            0|  0.00%|        a = np.arange(4)
  3686|         0|            0|            0|  0.00%|        p = np.linspace(0, 100, 6001)
  3687|         0|            0|            0|  0.00%|        ax = plt.gca()
  3688|         0|            0|            0|  0.00%|        lines = [
  3689|         0|            0|            0|  0.00%|            ('linear', None),
  3690|         0|            0|            0|  0.00%|            ('higher', '--'),
  3691|         0|            0|            0|  0.00%|            ('lower', '--'),
  3692|         0|            0|            0|  0.00%|            ('nearest', '-.'),
  3693|         0|            0|            0|  0.00%|            ('midpoint', '-.'),
  3694|         0|            0|            0|  0.00%|        ]
  3695|         0|            0|            0|  0.00%|        for interpolation, style in lines:
  3696|         0|            0|            0|  0.00%|            ax.plot(
  3697|         0|            0|            0|  0.00%|                p, np.percentile(a, p, interpolation=interpolation),
  3698|         0|            0|            0|  0.00%|                label=interpolation, linestyle=style)
  3699|         0|            0|            0|  0.00%|        ax.set(
  3700|         0|            0|            0|  0.00%|            title='Interpolation methods for list: ' + str(a),
  3701|         0|            0|            0|  0.00%|            xlabel='Percentile',
  3702|         0|            0|            0|  0.00%|            ylabel='List item returned',
  3703|         0|            0|            0|  0.00%|            yticks=a)
  3704|         0|            0|            0|  0.00%|        ax.legend()
  3705|         0|            0|            0|  0.00%|        plt.show()
  3706|         0|            0|            0|  0.00%|
  3707|         0|            0|            0|  0.00%|    """
  3708|         0|            0|            0|  0.00%|    q = np.true_divide(q, 100)
  3709|         0|            0|            0|  0.00%|    q = asanyarray(q)  # undo any decay that the ufunc performed (see gh-13105)
  3710|         0|            0|            0|  0.00%|    if not _quantile_is_valid(q):
  3711|         0|            0|            0|  0.00%|        raise ValueError("Percentiles must be in the range [0, 100]")
  3712|         0|            0|            0|  0.00%|    return _quantile_unchecked(
  3713|         0|            0|            0|  0.00%|        a, q, axis, out, overwrite_input, interpolation, keepdims)
  3714|         0|            0|            0|  0.00%|
  3715|         0|            0|            0|  0.00%|
  3716|         0|            0|            0|  0.00%|def _quantile_dispatcher(a, q, axis=None, out=None, overwrite_input=None,
  3717|         0|            0|            0|  0.00%|                         interpolation=None, keepdims=None):
  3718|         0|            0|            0|  0.00%|    return (a, q, out)
  3719|         0|            0|            0|  0.00%|
  3720|         0|            0|            0|  0.00%|
  3721|         0|            0|            0|  0.00%|@array_function_dispatch(_quantile_dispatcher)
  3722|         0|            0|            0|  0.00%|def quantile(a, q, axis=None, out=None,
  3723|         0|            0|            0|  0.00%|             overwrite_input=False, interpolation='linear', keepdims=False):
  3724|         0|            0|            0|  0.00%|    """
  3725|         0|            0|            0|  0.00%|    Compute the q-th quantile of the data along the specified axis.
  3726|         0|            0|            0|  0.00%|
  3727|         0|            0|            0|  0.00%|    .. versionadded:: 1.15.0
  3728|         0|            0|            0|  0.00%|
  3729|         0|            0|            0|  0.00%|    Parameters
  3730|         0|            0|            0|  0.00%|    ----------
  3731|         0|            0|            0|  0.00%|    a : array_like
  3732|         0|            0|            0|  0.00%|        Input array or object that can be converted to an array.
  3733|         0|            0|            0|  0.00%|    q : array_like of float
  3734|         0|            0|            0|  0.00%|        Quantile or sequence of quantiles to compute, which must be between
  3735|         0|            0|            0|  0.00%|        0 and 1 inclusive.
  3736|         0|            0|            0|  0.00%|    axis : {int, tuple of int, None}, optional
  3737|         0|            0|            0|  0.00%|        Axis or axes along which the quantiles are computed. The
  3738|         0|            0|            0|  0.00%|        default is to compute the quantile(s) along a flattened
  3739|         0|            0|            0|  0.00%|        version of the array.
  3740|         0|            0|            0|  0.00%|    out : ndarray, optional
  3741|         0|            0|            0|  0.00%|        Alternative output array in which to place the result. It must
  3742|         0|            0|            0|  0.00%|        have the same shape and buffer length as the expected output,
  3743|         0|            0|            0|  0.00%|        but the type (of the output) will be cast if necessary.
  3744|         0|            0|            0|  0.00%|    overwrite_input : bool, optional
  3745|         0|            0|            0|  0.00%|        If True, then allow the input array `a` to be modified by intermediate
  3746|         0|            0|            0|  0.00%|        calculations, to save memory. In this case, the contents of the input
  3747|         0|            0|            0|  0.00%|        `a` after this function completes is undefined.
  3748|         0|            0|            0|  0.00%|    interpolation : {'linear', 'lower', 'higher', 'midpoint', 'nearest'}
  3749|         0|            0|            0|  0.00%|        This optional parameter specifies the interpolation method to
  3750|         0|            0|            0|  0.00%|        use when the desired quantile lies between two data points
  3751|         0|            0|            0|  0.00%|        ``i < j``:
  3752|         0|            0|            0|  0.00%|
  3753|         0|            0|            0|  0.00%|            * linear: ``i + (j - i) * fraction``, where ``fraction``
  3754|         0|            0|            0|  0.00%|              is the fractional part of the index surrounded by ``i``
  3755|         0|            0|            0|  0.00%|              and ``j``.
  3756|         0|            0|            0|  0.00%|            * lower: ``i``.
  3757|         0|            0|            0|  0.00%|            * higher: ``j``.
  3758|         0|            0|            0|  0.00%|            * nearest: ``i`` or ``j``, whichever is nearest.
  3759|         0|            0|            0|  0.00%|            * midpoint: ``(i + j) / 2``.
  3760|         0|            0|            0|  0.00%|    keepdims : bool, optional
  3761|         0|            0|            0|  0.00%|        If this is set to True, the axes which are reduced are left in
  3762|         0|            0|            0|  0.00%|        the result as dimensions with size one. With this option, the
  3763|         0|            0|            0|  0.00%|        result will broadcast correctly against the original array `a`.
  3764|         0|            0|            0|  0.00%|
  3765|         0|            0|            0|  0.00%|    Returns
  3766|         0|            0|            0|  0.00%|    -------
  3767|         0|            0|            0|  0.00%|    quantile : scalar or ndarray
  3768|         0|            0|            0|  0.00%|        If `q` is a single quantile and `axis=None`, then the result
  3769|         0|            0|            0|  0.00%|        is a scalar. If multiple quantiles are given, first axis of
  3770|         0|            0|            0|  0.00%|        the result corresponds to the quantiles. The other axes are
  3771|         0|            0|            0|  0.00%|        the axes that remain after the reduction of `a`. If the input
  3772|         0|            0|            0|  0.00%|        contains integers or floats smaller than ``float64``, the output
  3773|         0|            0|            0|  0.00%|        data-type is ``float64``. Otherwise, the output data-type is the
  3774|         0|            0|            0|  0.00%|        same as that of the input. If `out` is specified, that array is
  3775|         0|            0|            0|  0.00%|        returned instead.
  3776|         0|            0|            0|  0.00%|
  3777|         0|            0|            0|  0.00%|    See Also
  3778|         0|            0|            0|  0.00%|    --------
  3779|         0|            0|            0|  0.00%|    mean
  3780|         0|            0|            0|  0.00%|    percentile : equivalent to quantile, but with q in the range [0, 100].
  3781|         0|            0|            0|  0.00%|    median : equivalent to ``quantile(..., 0.5)``
  3782|         0|            0|            0|  0.00%|    nanquantile
  3783|         0|            0|            0|  0.00%|
  3784|         0|            0|            0|  0.00%|    Notes
  3785|         0|            0|            0|  0.00%|    -----
  3786|         0|            0|            0|  0.00%|    Given a vector ``V`` of length ``N``, the q-th quantile of
  3787|         0|            0|            0|  0.00%|    ``V`` is the value ``q`` of the way from the minimum to the
  3788|         0|            0|            0|  0.00%|    maximum in a sorted copy of ``V``. The values and distances of
  3789|         0|            0|            0|  0.00%|    the two nearest neighbors as well as the `interpolation` parameter
  3790|         0|            0|            0|  0.00%|    will determine the quantile if the normalized ranking does not
  3791|         0|            0|            0|  0.00%|    match the location of ``q`` exactly. This function is the same as
  3792|         0|            0|            0|  0.00%|    the median if ``q=0.5``, the same as the minimum if ``q=0.0`` and the
  3793|         0|            0|            0|  0.00%|    same as the maximum if ``q=1.0``.
  3794|         0|            0|            0|  0.00%|
  3795|         0|            0|            0|  0.00%|    Examples
  3796|         0|            0|            0|  0.00%|    --------
  3797|         0|            0|            0|  0.00%|    >>> a = np.array([[10, 7, 4], [3, 2, 1]])
  3798|         0|            0|            0|  0.00%|    >>> a
  3799|         0|            0|            0|  0.00%|    array([[10,  7,  4],
  3800|         0|            0|            0|  0.00%|           [ 3,  2,  1]])
  3801|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5)
  3802|         0|            0|            0|  0.00%|    3.5
  3803|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=0)
  3804|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3805|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=1)
  3806|         0|            0|            0|  0.00%|    array([7.,  2.])
  3807|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=1, keepdims=True)
  3808|         0|            0|            0|  0.00%|    array([[7.],
  3809|         0|            0|            0|  0.00%|           [2.]])
  3810|         0|            0|            0|  0.00%|    >>> m = np.quantile(a, 0.5, axis=0)
  3811|         0|            0|            0|  0.00%|    >>> out = np.zeros_like(m)
  3812|         0|            0|            0|  0.00%|    >>> np.quantile(a, 0.5, axis=0, out=out)
  3813|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3814|         0|            0|            0|  0.00%|    >>> m
  3815|         0|            0|            0|  0.00%|    array([6.5, 4.5, 2.5])
  3816|         0|            0|            0|  0.00%|    >>> b = a.copy()
  3817|         0|            0|            0|  0.00%|    >>> np.quantile(b, 0.5, axis=1, overwrite_input=True)
  3818|         0|            0|            0|  0.00%|    array([7.,  2.])
  3819|         0|            0|            0|  0.00%|    >>> assert not np.all(a == b)
  3820|         0|            0|            0|  0.00%|    """
  3821|         0|            0|            0|  0.00%|    q = np.asanyarray(q)
  3822|         0|            0|            0|  0.00%|    if not _quantile_is_valid(q):
  3823|         0|            0|            0|  0.00%|        raise ValueError("Quantiles must be in the range [0, 1]")
  3824|         0|            0|            0|  0.00%|    return _quantile_unchecked(
  3825|         0|            0|            0|  0.00%|        a, q, axis, out, overwrite_input, interpolation, keepdims)
  3826|         0|            0|            0|  0.00%|
  3827|         0|            0|            0|  0.00%|
  3828|         0|            0|            0|  0.00%|def _quantile_unchecked(a, q, axis=None, out=None, overwrite_input=False,
  3829|         0|            0|            0|  0.00%|                        interpolation='linear', keepdims=False):
  3830|         0|            0|            0|  0.00%|    """Assumes that q is in [0, 1], and is an ndarray"""
  3831|         0|            0|            0|  0.00%|    r, k = _ureduce(a, func=_quantile_ureduce_func, q=q, axis=axis, out=out,
  3832|         0|            0|            0|  0.00%|                    overwrite_input=overwrite_input,
  3833|         0|            0|            0|  0.00%|                    interpolation=interpolation)
  3834|         0|            0|            0|  0.00%|    if keepdims:
  3835|         0|            0|            0|  0.00%|        return r.reshape(q.shape + k)
  3836|         0|            0|            0|  0.00%|    else:
  3837|         0|            0|            0|  0.00%|        return r
  3838|         0|            0|            0|  0.00%|
  3839|         0|            0|            0|  0.00%|
  3840|         0|            0|            0|  0.00%|def _quantile_is_valid(q):
  3841|         0|            0|            0|  0.00%|    # avoid expensive reductions, relevant for arrays with < O(1000) elements
  3842|         0|            0|            0|  0.00%|    if q.ndim == 1 and q.size < 10:
  3843|         0|            0|            0|  0.00%|        for i in range(q.size):
  3844|         0|            0|            0|  0.00%|            if q[i] < 0.0 or q[i] > 1.0:
  3845|         0|            0|            0|  0.00%|                return False
  3846|         0|            0|            0|  0.00%|    else:
  3847|         0|            0|            0|  0.00%|        # faster than any()
  3848|         0|            0|            0|  0.00%|        if np.count_nonzero(q < 0.0) or np.count_nonzero(q > 1.0):
  3849|         0|            0|            0|  0.00%|            return False
  3850|         0|            0|            0|  0.00%|    return True
  3851|         0|            0|            0|  0.00%|
  3852|         0|            0|            0|  0.00%|
  3853|         0|            0|            0|  0.00%|def _quantile_ureduce_func(a, q, axis=None, out=None, overwrite_input=False,
  3854|         0|            0|            0|  0.00%|                           interpolation='linear', keepdims=False):
  3855|         0|            0|            0|  0.00%|    a = asarray(a)
  3856|         0|            0|            0|  0.00%|    if q.ndim == 0:
  3857|         0|            0|            0|  0.00%|        # Do not allow 0-d arrays because following code fails for scalar
  3858|         0|            0|            0|  0.00%|        zerod = True
  3859|         0|            0|            0|  0.00%|        q = q[None]
  3860|         0|            0|            0|  0.00%|    else:
  3861|         0|            0|            0|  0.00%|        zerod = False
  3862|         0|            0|            0|  0.00%|
  3863|         0|            0|            0|  0.00%|    # prepare a for partitioning
  3864|         0|            0|            0|  0.00%|    if overwrite_input:
  3865|         0|            0|            0|  0.00%|        if axis is None:
  3866|         0|            0|            0|  0.00%|            ap = a.ravel()
  3867|         0|            0|            0|  0.00%|        else:
  3868|         0|            0|            0|  0.00%|            ap = a
  3869|         0|            0|            0|  0.00%|    else:
  3870|         0|            0|            0|  0.00%|        if axis is None:
  3871|         0|            0|            0|  0.00%|            ap = a.flatten()
  3872|         0|            0|            0|  0.00%|        else:
  3873|         0|            0|            0|  0.00%|            ap = a.copy()
  3874|         0|            0|            0|  0.00%|
  3875|         0|            0|            0|  0.00%|    if axis is None:
  3876|         0|            0|            0|  0.00%|        axis = 0
  3877|         0|            0|            0|  0.00%|
  3878|         0|            0|            0|  0.00%|    Nx = ap.shape[axis]
  3879|         0|            0|            0|  0.00%|    indices = q * (Nx - 1)
  3880|         0|            0|            0|  0.00%|
  3881|         0|            0|            0|  0.00%|    # round fractional indices according to interpolation method
  3882|         0|            0|            0|  0.00%|    if interpolation == 'lower':
  3883|         0|            0|            0|  0.00%|        indices = floor(indices).astype(intp)
  3884|         0|            0|            0|  0.00%|    elif interpolation == 'higher':
  3885|         0|            0|            0|  0.00%|        indices = ceil(indices).astype(intp)
  3886|         0|            0|            0|  0.00%|    elif interpolation == 'midpoint':
  3887|         0|            0|            0|  0.00%|        indices = 0.5 * (floor(indices) + ceil(indices))
  3888|         0|            0|            0|  0.00%|    elif interpolation == 'nearest':
  3889|         0|            0|            0|  0.00%|        indices = around(indices).astype(intp)
  3890|         0|            0|            0|  0.00%|    elif interpolation == 'linear':
  3891|         0|            0|            0|  0.00%|        pass  # keep index as fraction and interpolate
  3892|         0|            0|            0|  0.00%|    else:
  3893|         0|            0|            0|  0.00%|        raise ValueError(
  3894|         0|            0|            0|  0.00%|            "interpolation can only be 'linear', 'lower' 'higher', "
  3895|         0|            0|            0|  0.00%|            "'midpoint', or 'nearest'")
  3896|         0|            0|            0|  0.00%|
  3897|         0|            0|            0|  0.00%|    n = np.array(False, dtype=bool) # check for nan's flag
  3898|         0|            0|            0|  0.00%|    if indices.dtype == intp:  # take the points along axis
  3899|         0|            0|            0|  0.00%|        # Check if the array contains any nan's
  3900|         0|            0|            0|  0.00%|        if np.issubdtype(a.dtype, np.inexact):
  3901|         0|            0|            0|  0.00%|            indices = concatenate((indices, [-1]))
  3902|         0|            0|            0|  0.00%|
  3903|         0|            0|            0|  0.00%|        ap.partition(indices, axis=axis)
  3904|         0|            0|            0|  0.00%|        # ensure axis with q-th is first
  3905|         0|            0|            0|  0.00%|        ap = np.moveaxis(ap, axis, 0)
  3906|         0|            0|            0|  0.00%|        axis = 0
  3907|         0|            0|            0|  0.00%|
  3908|         0|            0|            0|  0.00%|        # Check if the array contains any nan's
  3909|         0|            0|            0|  0.00%|        if np.issubdtype(a.dtype, np.inexact):
  3910|         0|            0|            0|  0.00%|            indices = indices[:-1]
  3911|         0|            0|            0|  0.00%|            n = np.isnan(ap[-1:, ...])
  3912|         0|            0|            0|  0.00%|
  3913|         0|            0|            0|  0.00%|        if zerod:
  3914|         0|            0|            0|  0.00%|            indices = indices[0]
  3915|         0|            0|            0|  0.00%|        r = take(ap, indices, axis=axis, out=out)
  3916|         0|            0|            0|  0.00%|
  3917|         0|            0|            0|  0.00%|
  3918|         0|            0|            0|  0.00%|    else:  # weight the points above and below the indices
  3919|         0|            0|            0|  0.00%|        indices_below = floor(indices).astype(intp)
  3920|         0|            0|            0|  0.00%|        indices_above = indices_below + 1
  3921|         0|            0|            0|  0.00%|        indices_above[indices_above > Nx - 1] = Nx - 1
  3922|         0|            0|            0|  0.00%|
  3923|         0|            0|            0|  0.00%|        # Check if the array contains any nan's
  3924|         0|            0|            0|  0.00%|        if np.issubdtype(a.dtype, np.inexact):
  3925|         0|            0|            0|  0.00%|            indices_above = concatenate((indices_above, [-1]))
  3926|         0|            0|            0|  0.00%|
  3927|         0|            0|            0|  0.00%|        weights_above = indices - indices_below
  3928|         0|            0|            0|  0.00%|        weights_below = 1 - weights_above
  3929|         0|            0|            0|  0.00%|
  3930|         0|            0|            0|  0.00%|        weights_shape = [1, ] * ap.ndim
  3931|         0|            0|            0|  0.00%|        weights_shape[axis] = len(indices)
  3932|         0|            0|            0|  0.00%|        weights_below.shape = weights_shape
  3933|         0|            0|            0|  0.00%|        weights_above.shape = weights_shape
  3934|         0|            0|            0|  0.00%|
  3935|         0|            0|            0|  0.00%|        ap.partition(concatenate((indices_below, indices_above)), axis=axis)
  3936|         0|            0|            0|  0.00%|
  3937|         0|            0|            0|  0.00%|        # ensure axis with q-th is first
  3938|         0|            0|            0|  0.00%|        ap = np.moveaxis(ap, axis, 0)
  3939|         0|            0|            0|  0.00%|        weights_below = np.moveaxis(weights_below, axis, 0)
  3940|         0|            0|            0|  0.00%|        weights_above = np.moveaxis(weights_above, axis, 0)
  3941|         0|            0|            0|  0.00%|        axis = 0
  3942|         0|            0|            0|  0.00%|
  3943|         0|            0|            0|  0.00%|        # Check if the array contains any nan's
  3944|         0|            0|            0|  0.00%|        if np.issubdtype(a.dtype, np.inexact):
  3945|         0|            0|            0|  0.00%|            indices_above = indices_above[:-1]
  3946|         0|            0|            0|  0.00%|            n = np.isnan(ap[-1:, ...])
  3947|         0|            0|            0|  0.00%|
  3948|         0|            0|            0|  0.00%|        x1 = take(ap, indices_below, axis=axis) * weights_below
  3949|         0|            0|            0|  0.00%|        x2 = take(ap, indices_above, axis=axis) * weights_above
  3950|         0|            0|            0|  0.00%|
  3951|         0|            0|            0|  0.00%|        # ensure axis with q-th is first
  3952|         0|            0|            0|  0.00%|        x1 = np.moveaxis(x1, axis, 0)
  3953|         0|            0|            0|  0.00%|        x2 = np.moveaxis(x2, axis, 0)
  3954|         0|            0|            0|  0.00%|
  3955|         0|            0|            0|  0.00%|        if zerod:
  3956|         0|            0|            0|  0.00%|            x1 = x1.squeeze(0)
  3957|         0|            0|            0|  0.00%|            x2 = x2.squeeze(0)
  3958|         0|            0|            0|  0.00%|
  3959|         0|            0|            0|  0.00%|        if out is not None:
  3960|         0|            0|            0|  0.00%|            r = add(x1, x2, out=out)
  3961|         0|            0|            0|  0.00%|        else:
  3962|         0|            0|            0|  0.00%|            r = add(x1, x2)
  3963|         0|            0|            0|  0.00%|
  3964|         0|            0|            0|  0.00%|    if np.any(n):
  3965|         0|            0|            0|  0.00%|        if zerod:
  3966|         0|            0|            0|  0.00%|            if ap.ndim == 1:
  3967|         0|            0|            0|  0.00%|                if out is not None:
  3968|         0|            0|            0|  0.00%|                    out[...] = a.dtype.type(np.nan)
  3969|         0|            0|            0|  0.00%|                    r = out
  3970|         0|            0|            0|  0.00%|                else:
  3971|         0|            0|            0|  0.00%|                    r = a.dtype.type(np.nan)
  3972|         0|            0|            0|  0.00%|            else:
  3973|         0|            0|            0|  0.00%|                r[..., n.squeeze(0)] = a.dtype.type(np.nan)
  3974|         0|            0|            0|  0.00%|        else:
  3975|         0|            0|            0|  0.00%|            if r.ndim == 1:
  3976|         0|            0|            0|  0.00%|                r[:] = a.dtype.type(np.nan)
  3977|         0|            0|            0|  0.00%|            else:
  3978|         0|            0|            0|  0.00%|                r[..., n.repeat(q.size, 0)] = a.dtype.type(np.nan)
  3979|         0|            0|            0|  0.00%|
  3980|         0|            0|            0|  0.00%|    return r
  3981|         0|            0|            0|  0.00%|
  3982|         0|            0|            0|  0.00%|
  3983|         0|            0|            0|  0.00%|def _trapz_dispatcher(y, x=None, dx=None, axis=None):
  3984|         0|            0|            0|  0.00%|    return (y, x)
  3985|         0|            0|            0|  0.00%|
  3986|         0|            0|            0|  0.00%|
  3987|         0|            0|            0|  0.00%|@array_function_dispatch(_trapz_dispatcher)
  3988|         0|            0|            0|  0.00%|def trapz(y, x=None, dx=1.0, axis=-1):
  3989|         0|            0|            0|  0.00%|    """
  3990|         0|            0|            0|  0.00%|    Integrate along the given axis using the composite trapezoidal rule.
  3991|         0|            0|            0|  0.00%|
  3992|         0|            0|            0|  0.00%|    Integrate `y` (`x`) along given axis.
  3993|         0|            0|            0|  0.00%|
  3994|         0|            0|            0|  0.00%|    Parameters
  3995|         0|            0|            0|  0.00%|    ----------
  3996|         0|            0|            0|  0.00%|    y : array_like
  3997|         0|            0|            0|  0.00%|        Input array to integrate.
  3998|         0|            0|            0|  0.00%|    x : array_like, optional
  3999|         0|            0|            0|  0.00%|        The sample points corresponding to the `y` values. If `x` is None,
  4000|         0|            0|            0|  0.00%|        the sample points are assumed to be evenly spaced `dx` apart. The
  4001|         0|            0|            0|  0.00%|        default is None.
  4002|         0|            0|            0|  0.00%|    dx : scalar, optional
  4003|         0|            0|            0|  0.00%|        The spacing between sample points when `x` is None. The default is 1.
  4004|         0|            0|            0|  0.00%|    axis : int, optional
  4005|         0|            0|            0|  0.00%|        The axis along which to integrate.
  4006|         0|            0|            0|  0.00%|
  4007|         0|            0|            0|  0.00%|    Returns
  4008|         0|            0|            0|  0.00%|    -------
  4009|         0|            0|            0|  0.00%|    trapz : float
  4010|         0|            0|            0|  0.00%|        Definite integral as approximated by trapezoidal rule.
  4011|         0|            0|            0|  0.00%|
  4012|         0|            0|            0|  0.00%|    See Also
  4013|         0|            0|            0|  0.00%|    --------
  4014|         0|            0|            0|  0.00%|    sum, cumsum
  4015|         0|            0|            0|  0.00%|
  4016|         0|            0|            0|  0.00%|    Notes
  4017|         0|            0|            0|  0.00%|    -----
  4018|         0|            0|            0|  0.00%|    Image [2]_ illustrates trapezoidal rule -- y-axis locations of points
  4019|         0|            0|            0|  0.00%|    will be taken from `y` array, by default x-axis distances between
  4020|         0|            0|            0|  0.00%|    points will be 1.0, alternatively they can be provided with `x` array
  4021|         0|            0|            0|  0.00%|    or with `dx` scalar.  Return value will be equal to combined area under
  4022|         0|            0|            0|  0.00%|    the red lines.
  4023|         0|            0|            0|  0.00%|
  4024|         0|            0|            0|  0.00%|
  4025|         0|            0|            0|  0.00%|    References
  4026|         0|            0|            0|  0.00%|    ----------
  4027|         0|            0|            0|  0.00%|    .. [1] Wikipedia page: https://en.wikipedia.org/wiki/Trapezoidal_rule
  4028|         0|            0|            0|  0.00%|
  4029|         0|            0|            0|  0.00%|    .. [2] Illustration image:
  4030|         0|            0|            0|  0.00%|           https://en.wikipedia.org/wiki/File:Composite_trapezoidal_rule_illustration.png
  4031|         0|            0|            0|  0.00%|
  4032|         0|            0|            0|  0.00%|    Examples
  4033|         0|            0|            0|  0.00%|    --------
  4034|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3])
  4035|         0|            0|            0|  0.00%|    4.0
  4036|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3], x=[4,6,8])
  4037|         0|            0|            0|  0.00%|    8.0
  4038|         0|            0|            0|  0.00%|    >>> np.trapz([1,2,3], dx=2)
  4039|         0|            0|            0|  0.00%|    8.0
  4040|         0|            0|            0|  0.00%|    >>> a = np.arange(6).reshape(2, 3)
  4041|         0|            0|            0|  0.00%|    >>> a
  4042|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  4043|         0|            0|            0|  0.00%|           [3, 4, 5]])
  4044|         0|            0|            0|  0.00%|    >>> np.trapz(a, axis=0)
  4045|         0|            0|            0|  0.00%|    array([1.5, 2.5, 3.5])
  4046|         0|            0|            0|  0.00%|    >>> np.trapz(a, axis=1)
  4047|         0|            0|            0|  0.00%|    array([2.,  8.])
  4048|         0|            0|            0|  0.00%|
  4049|         0|            0|            0|  0.00%|    """
  4050|         0|            0|            0|  0.00%|    y = asanyarray(y)
  4051|         0|            0|            0|  0.00%|    if x is None:
  4052|         0|            0|            0|  0.00%|        d = dx
  4053|         0|            0|            0|  0.00%|    else:
  4054|         0|            0|            0|  0.00%|        x = asanyarray(x)
  4055|         0|            0|            0|  0.00%|        if x.ndim == 1:
  4056|         0|            0|            0|  0.00%|            d = diff(x)
  4057|         0|            0|            0|  0.00%|            # reshape to correct shape
  4058|         0|            0|            0|  0.00%|            shape = [1]*y.ndim
  4059|         0|            0|            0|  0.00%|            shape[axis] = d.shape[0]
  4060|         0|            0|            0|  0.00%|            d = d.reshape(shape)
  4061|         0|            0|            0|  0.00%|        else:
  4062|         0|            0|            0|  0.00%|            d = diff(x, axis=axis)
  4063|         0|            0|            0|  0.00%|    nd = y.ndim
  4064|         0|            0|            0|  0.00%|    slice1 = [slice(None)]*nd
  4065|         0|            0|            0|  0.00%|    slice2 = [slice(None)]*nd
  4066|         0|            0|            0|  0.00%|    slice1[axis] = slice(1, None)
  4067|         0|            0|            0|  0.00%|    slice2[axis] = slice(None, -1)
  4068|         0|            0|            0|  0.00%|    try:
  4069|         0|            0|            0|  0.00%|        ret = (d * (y[tuple(slice1)] + y[tuple(slice2)]) / 2.0).sum(axis)
  4070|         0|            0|            0|  0.00%|    except ValueError:
  4071|         0|            0|            0|  0.00%|        # Operations didn't work, cast to ndarray
  4072|         0|            0|            0|  0.00%|        d = np.asarray(d)
  4073|         0|            0|            0|  0.00%|        y = np.asarray(y)
  4074|         0|            0|            0|  0.00%|        ret = add.reduce(d * (y[tuple(slice1)]+y[tuple(slice2)])/2.0, axis)
  4075|         0|            0|            0|  0.00%|    return ret
  4076|         0|            0|            0|  0.00%|
  4077|         0|            0|            0|  0.00%|
  4078|         0|            0|            0|  0.00%|def _meshgrid_dispatcher(*xi, **kwargs):
  4079|         0|            0|            0|  0.00%|    return xi
  4080|         0|            0|            0|  0.00%|
  4081|         0|            0|            0|  0.00%|
  4082|         0|            0|            0|  0.00%|# Based on scitools meshgrid
  4083|         0|            0|            0|  0.00%|@array_function_dispatch(_meshgrid_dispatcher)
  4084|         0|            0|            0|  0.00%|def meshgrid(*xi, **kwargs):
  4085|         0|            0|            0|  0.00%|    """
  4086|         0|            0|            0|  0.00%|    Return coordinate matrices from coordinate vectors.
  4087|         0|            0|            0|  0.00%|
  4088|         0|            0|            0|  0.00%|    Make N-D coordinate arrays for vectorized evaluations of
  4089|         0|            0|            0|  0.00%|    N-D scalar/vector fields over N-D grids, given
  4090|         0|            0|            0|  0.00%|    one-dimensional coordinate arrays x1, x2,..., xn.
  4091|         0|            0|            0|  0.00%|
  4092|         0|            0|            0|  0.00%|    .. versionchanged:: 1.9
  4093|         0|            0|            0|  0.00%|       1-D and 0-D cases are allowed.
  4094|         0|            0|            0|  0.00%|
  4095|         0|            0|            0|  0.00%|    Parameters
  4096|         0|            0|            0|  0.00%|    ----------
  4097|         0|            0|            0|  0.00%|    x1, x2,..., xn : array_like
  4098|         0|            0|            0|  0.00%|        1-D arrays representing the coordinates of a grid.
  4099|         0|            0|            0|  0.00%|    indexing : {'xy', 'ij'}, optional
  4100|         0|            0|            0|  0.00%|        Cartesian ('xy', default) or matrix ('ij') indexing of output.
  4101|         0|            0|            0|  0.00%|        See Notes for more details.
  4102|         0|            0|            0|  0.00%|
  4103|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4104|         0|            0|            0|  0.00%|    sparse : bool, optional
  4105|         0|            0|            0|  0.00%|        If True a sparse grid is returned in order to conserve memory.
  4106|         0|            0|            0|  0.00%|        Default is False.
  4107|         0|            0|            0|  0.00%|
  4108|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4109|         0|            0|            0|  0.00%|    copy : bool, optional
  4110|         0|            0|            0|  0.00%|        If False, a view into the original arrays are returned in order to
  4111|         0|            0|            0|  0.00%|        conserve memory.  Default is True.  Please note that
  4112|         0|            0|            0|  0.00%|        ``sparse=False, copy=False`` will likely return non-contiguous
  4113|         0|            0|            0|  0.00%|        arrays.  Furthermore, more than one element of a broadcast array
  4114|         0|            0|            0|  0.00%|        may refer to a single memory location.  If you need to write to the
  4115|         0|            0|            0|  0.00%|        arrays, make copies first.
  4116|         0|            0|            0|  0.00%|
  4117|         0|            0|            0|  0.00%|        .. versionadded:: 1.7.0
  4118|         0|            0|            0|  0.00%|
  4119|         0|            0|            0|  0.00%|    Returns
  4120|         0|            0|            0|  0.00%|    -------
  4121|         0|            0|            0|  0.00%|    X1, X2,..., XN : ndarray
  4122|         0|            0|            0|  0.00%|        For vectors `x1`, `x2`,..., 'xn' with lengths ``Ni=len(xi)`` ,
  4123|         0|            0|            0|  0.00%|        return ``(N1, N2, N3,...Nn)`` shaped arrays if indexing='ij'
  4124|         0|            0|            0|  0.00%|        or ``(N2, N1, N3,...Nn)`` shaped arrays if indexing='xy'
  4125|         0|            0|            0|  0.00%|        with the elements of `xi` repeated to fill the matrix along
  4126|         0|            0|            0|  0.00%|        the first dimension for `x1`, the second for `x2` and so on.
  4127|         0|            0|            0|  0.00%|
  4128|         0|            0|            0|  0.00%|    Notes
  4129|         0|            0|            0|  0.00%|    -----
  4130|         0|            0|            0|  0.00%|    This function supports both indexing conventions through the indexing
  4131|         0|            0|            0|  0.00%|    keyword argument.  Giving the string 'ij' returns a meshgrid with
  4132|         0|            0|            0|  0.00%|    matrix indexing, while 'xy' returns a meshgrid with Cartesian indexing.
  4133|         0|            0|            0|  0.00%|    In the 2-D case with inputs of length M and N, the outputs are of shape
  4134|         0|            0|            0|  0.00%|    (N, M) for 'xy' indexing and (M, N) for 'ij' indexing.  In the 3-D case
  4135|         0|            0|            0|  0.00%|    with inputs of length M, N and P, outputs are of shape (N, M, P) for
  4136|         0|            0|            0|  0.00%|    'xy' indexing and (M, N, P) for 'ij' indexing.  The difference is
  4137|         0|            0|            0|  0.00%|    illustrated by the following code snippet::
  4138|         0|            0|            0|  0.00%|
  4139|         0|            0|            0|  0.00%|        xv, yv = np.meshgrid(x, y, sparse=False, indexing='ij')
  4140|         0|            0|            0|  0.00%|        for i in range(nx):
  4141|         0|            0|            0|  0.00%|            for j in range(ny):
  4142|         0|            0|            0|  0.00%|                # treat xv[i,j], yv[i,j]
  4143|         0|            0|            0|  0.00%|
  4144|         0|            0|            0|  0.00%|        xv, yv = np.meshgrid(x, y, sparse=False, indexing='xy')
  4145|         0|            0|            0|  0.00%|        for i in range(nx):
  4146|         0|            0|            0|  0.00%|            for j in range(ny):
  4147|         0|            0|            0|  0.00%|                # treat xv[j,i], yv[j,i]
  4148|         0|            0|            0|  0.00%|
  4149|         0|            0|            0|  0.00%|    In the 1-D and 0-D case, the indexing and sparse keywords have no effect.
  4150|         0|            0|            0|  0.00%|
  4151|         0|            0|            0|  0.00%|    See Also
  4152|         0|            0|            0|  0.00%|    --------
  4153|         0|            0|            0|  0.00%|    index_tricks.mgrid : Construct a multi-dimensional "meshgrid"
  4154|         0|            0|            0|  0.00%|                     using indexing notation.
  4155|         0|            0|            0|  0.00%|    index_tricks.ogrid : Construct an open multi-dimensional "meshgrid"
  4156|         0|            0|            0|  0.00%|                     using indexing notation.
  4157|         0|            0|            0|  0.00%|
  4158|         0|            0|            0|  0.00%|    Examples
  4159|         0|            0|            0|  0.00%|    --------
  4160|         0|            0|            0|  0.00%|    >>> nx, ny = (3, 2)
  4161|         0|            0|            0|  0.00%|    >>> x = np.linspace(0, 1, nx)
  4162|         0|            0|            0|  0.00%|    >>> y = np.linspace(0, 1, ny)
  4163|         0|            0|            0|  0.00%|    >>> xv, yv = np.meshgrid(x, y)
  4164|         0|            0|            0|  0.00%|    >>> xv
  4165|         0|            0|            0|  0.00%|    array([[0. , 0.5, 1. ],
  4166|         0|            0|            0|  0.00%|           [0. , 0.5, 1. ]])
  4167|         0|            0|            0|  0.00%|    >>> yv
  4168|         0|            0|            0|  0.00%|    array([[0.,  0.,  0.],
  4169|         0|            0|            0|  0.00%|           [1.,  1.,  1.]])
  4170|         0|            0|            0|  0.00%|    >>> xv, yv = np.meshgrid(x, y, sparse=True)  # make sparse output arrays
  4171|         0|            0|            0|  0.00%|    >>> xv
  4172|         0|            0|            0|  0.00%|    array([[0. ,  0.5,  1. ]])
  4173|         0|            0|            0|  0.00%|    >>> yv
  4174|         0|            0|            0|  0.00%|    array([[0.],
  4175|         0|            0|            0|  0.00%|           [1.]])
  4176|         0|            0|            0|  0.00%|
  4177|         0|            0|            0|  0.00%|    `meshgrid` is very useful to evaluate functions on a grid.
  4178|         0|            0|            0|  0.00%|
  4179|         0|            0|            0|  0.00%|    >>> import matplotlib.pyplot as plt
  4180|         0|            0|            0|  0.00%|    >>> x = np.arange(-5, 5, 0.1)
  4181|         0|            0|            0|  0.00%|    >>> y = np.arange(-5, 5, 0.1)
  4182|         0|            0|            0|  0.00%|    >>> xx, yy = np.meshgrid(x, y, sparse=True)
  4183|         0|            0|            0|  0.00%|    >>> z = np.sin(xx**2 + yy**2) / (xx**2 + yy**2)
  4184|         0|            0|            0|  0.00%|    >>> h = plt.contourf(x,y,z)
  4185|         0|            0|            0|  0.00%|    >>> plt.show()
  4186|         0|            0|            0|  0.00%|
  4187|         0|            0|            0|  0.00%|    """
  4188|         0|            0|            0|  0.00%|    ndim = len(xi)
  4189|         0|            0|            0|  0.00%|
  4190|         0|            0|            0|  0.00%|    copy_ = kwargs.pop('copy', True)
  4191|         0|            0|            0|  0.00%|    sparse = kwargs.pop('sparse', False)
  4192|         0|            0|            0|  0.00%|    indexing = kwargs.pop('indexing', 'xy')
  4193|         0|            0|            0|  0.00%|
  4194|         0|            0|            0|  0.00%|    if kwargs:
  4195|         0|            0|            0|  0.00%|        raise TypeError("meshgrid() got an unexpected keyword argument '%s'"
  4196|         0|            0|            0|  0.00%|                        % (list(kwargs)[0],))
  4197|         0|            0|            0|  0.00%|
  4198|         0|            0|            0|  0.00%|    if indexing not in ['xy', 'ij']:
  4199|         0|            0|            0|  0.00%|        raise ValueError(
  4200|         0|            0|            0|  0.00%|            "Valid values for `indexing` are 'xy' and 'ij'.")
  4201|         0|            0|            0|  0.00%|
  4202|         0|            0|            0|  0.00%|    s0 = (1,) * ndim
  4203|         0|            0|            0|  0.00%|    output = [np.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:])
  4204|         0|            0|            0|  0.00%|              for i, x in enumerate(xi)]
  4205|         0|            0|            0|  0.00%|
  4206|         0|            0|            0|  0.00%|    if indexing == 'xy' and ndim > 1:
  4207|         0|            0|            0|  0.00%|        # switch first and second axis
  4208|         0|            0|            0|  0.00%|        output[0].shape = (1, -1) + s0[2:]
  4209|         0|            0|            0|  0.00%|        output[1].shape = (-1, 1) + s0[2:]
  4210|         0|            0|            0|  0.00%|
  4211|         0|            0|            0|  0.00%|    if not sparse:
  4212|         0|            0|            0|  0.00%|        # Return the full N-D matrix (not only the 1-D vector)
  4213|         0|            0|            0|  0.00%|        output = np.broadcast_arrays(*output, subok=True)
  4214|         0|            0|            0|  0.00%|
  4215|         0|            0|            0|  0.00%|    if copy_:
  4216|         0|            0|            0|  0.00%|        output = [x.copy() for x in output]
  4217|         0|            0|            0|  0.00%|
  4218|         0|            0|            0|  0.00%|    return output
  4219|         0|            0|            0|  0.00%|
  4220|         0|            0|            0|  0.00%|
  4221|         0|            0|            0|  0.00%|def _delete_dispatcher(arr, obj, axis=None):
  4222|         0|            0|            0|  0.00%|    return (arr, obj)
  4223|         0|            0|            0|  0.00%|
  4224|         0|            0|            0|  0.00%|
  4225|         0|            0|            0|  0.00%|@array_function_dispatch(_delete_dispatcher)
  4226|         0|            0|            0|  0.00%|def delete(arr, obj, axis=None):
  4227|         0|            0|            0|  0.00%|    """
  4228|         0|            0|            0|  0.00%|    Return a new array with sub-arrays along an axis deleted. For a one
  4229|         0|            0|            0|  0.00%|    dimensional array, this returns those entries not returned by
  4230|         0|            0|            0|  0.00%|    `arr[obj]`.
  4231|         0|            0|            0|  0.00%|
  4232|         0|            0|            0|  0.00%|    Parameters
  4233|         0|            0|            0|  0.00%|    ----------
  4234|         0|            0|            0|  0.00%|    arr : array_like
  4235|         0|            0|            0|  0.00%|      Input array.
  4236|         0|            0|            0|  0.00%|    obj : slice, int or array of ints
  4237|         0|            0|            0|  0.00%|      Indicate indices of sub-arrays to remove along the specified axis.
  4238|         0|            0|            0|  0.00%|    axis : int, optional
  4239|         0|            0|            0|  0.00%|      The axis along which to delete the subarray defined by `obj`.
  4240|         0|            0|            0|  0.00%|      If `axis` is None, `obj` is applied to the flattened array.
  4241|         0|            0|            0|  0.00%|
  4242|         0|            0|            0|  0.00%|    Returns
  4243|         0|            0|            0|  0.00%|    -------
  4244|         0|            0|            0|  0.00%|    out : ndarray
  4245|         0|            0|            0|  0.00%|        A copy of `arr` with the elements specified by `obj` removed. Note
  4246|         0|            0|            0|  0.00%|        that `delete` does not occur in-place. If `axis` is None, `out` is
  4247|         0|            0|            0|  0.00%|        a flattened array.
  4248|         0|            0|            0|  0.00%|
  4249|         0|            0|            0|  0.00%|    See Also
  4250|         0|            0|            0|  0.00%|    --------
  4251|         0|            0|            0|  0.00%|    insert : Insert elements into an array.
  4252|         0|            0|            0|  0.00%|    append : Append elements at the end of an array.
  4253|         0|            0|            0|  0.00%|
  4254|         0|            0|            0|  0.00%|    Notes
  4255|         0|            0|            0|  0.00%|    -----
  4256|         0|            0|            0|  0.00%|    Often it is preferable to use a boolean mask. For example:
  4257|         0|            0|            0|  0.00%|
  4258|         0|            0|            0|  0.00%|    >>> arr = np.arange(12) + 1
  4259|         0|            0|            0|  0.00%|    >>> mask = np.ones(len(arr), dtype=bool)
  4260|         0|            0|            0|  0.00%|    >>> mask[[0,2,4]] = False
  4261|         0|            0|            0|  0.00%|    >>> result = arr[mask,...]
  4262|         0|            0|            0|  0.00%|
  4263|         0|            0|            0|  0.00%|    Is equivalent to `np.delete(arr, [0,2,4], axis=0)`, but allows further
  4264|         0|            0|            0|  0.00%|    use of `mask`.
  4265|         0|            0|            0|  0.00%|
  4266|         0|            0|            0|  0.00%|    Examples
  4267|         0|            0|            0|  0.00%|    --------
  4268|         0|            0|            0|  0.00%|    >>> arr = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])
  4269|         0|            0|            0|  0.00%|    >>> arr
  4270|         0|            0|            0|  0.00%|    array([[ 1,  2,  3,  4],
  4271|         0|            0|            0|  0.00%|           [ 5,  6,  7,  8],
  4272|         0|            0|            0|  0.00%|           [ 9, 10, 11, 12]])
  4273|         0|            0|            0|  0.00%|    >>> np.delete(arr, 1, 0)
  4274|         0|            0|            0|  0.00%|    array([[ 1,  2,  3,  4],
  4275|         0|            0|            0|  0.00%|           [ 9, 10, 11, 12]])
  4276|         0|            0|            0|  0.00%|
  4277|         0|            0|            0|  0.00%|    >>> np.delete(arr, np.s_[::2], 1)
  4278|         0|            0|            0|  0.00%|    array([[ 2,  4],
  4279|         0|            0|            0|  0.00%|           [ 6,  8],
  4280|         0|            0|            0|  0.00%|           [10, 12]])
  4281|         0|            0|            0|  0.00%|    >>> np.delete(arr, [1,3,5], None)
  4282|         0|            0|            0|  0.00%|    array([ 1,  3,  5,  7,  8,  9, 10, 11, 12])
  4283|         0|            0|            0|  0.00%|
  4284|         0|            0|            0|  0.00%|    """
  4285|         0|            0|            0|  0.00%|    wrap = None
  4286|         0|            0|            0|  0.00%|    if type(arr) is not ndarray:
  4287|         0|            0|            0|  0.00%|        try:
  4288|         0|            0|            0|  0.00%|            wrap = arr.__array_wrap__
  4289|         0|            0|            0|  0.00%|        except AttributeError:
  4290|         0|            0|            0|  0.00%|            pass
  4291|         0|            0|            0|  0.00%|
  4292|         0|            0|            0|  0.00%|    arr = asarray(arr)
  4293|         0|            0|            0|  0.00%|    ndim = arr.ndim
  4294|         0|            0|            0|  0.00%|    arrorder = 'F' if arr.flags.fnc else 'C'
  4295|         0|            0|            0|  0.00%|    if axis is None:
  4296|         0|            0|            0|  0.00%|        if ndim != 1:
  4297|         0|            0|            0|  0.00%|            arr = arr.ravel()
  4298|         0|            0|            0|  0.00%|        ndim = arr.ndim
  4299|         0|            0|            0|  0.00%|        axis = -1
  4300|         0|            0|            0|  0.00%|
  4301|         0|            0|            0|  0.00%|    if ndim == 0:
  4302|         0|            0|            0|  0.00%|        # 2013-09-24, 1.9
  4303|         0|            0|            0|  0.00%|        warnings.warn(
  4304|         0|            0|            0|  0.00%|            "in the future the special handling of scalars will be removed "
  4305|         0|            0|            0|  0.00%|            "from delete and raise an error", DeprecationWarning, stacklevel=3)
  4306|         0|            0|            0|  0.00%|        if wrap:
  4307|         0|            0|            0|  0.00%|            return wrap(arr)
  4308|         0|            0|            0|  0.00%|        else:
  4309|         0|            0|            0|  0.00%|            return arr.copy(order=arrorder)
  4310|         0|            0|            0|  0.00%|
  4311|         0|            0|            0|  0.00%|    axis = normalize_axis_index(axis, ndim)
  4312|         0|            0|            0|  0.00%|
  4313|         0|            0|            0|  0.00%|    slobj = [slice(None)]*ndim
  4314|         0|            0|            0|  0.00%|    N = arr.shape[axis]
  4315|         0|            0|            0|  0.00%|    newshape = list(arr.shape)
  4316|         0|            0|            0|  0.00%|
  4317|         0|            0|            0|  0.00%|    if isinstance(obj, slice):
  4318|         0|            0|            0|  0.00%|        start, stop, step = obj.indices(N)
  4319|         0|            0|            0|  0.00%|        xr = range(start, stop, step)
  4320|         0|            0|            0|  0.00%|        numtodel = len(xr)
  4321|         0|            0|            0|  0.00%|
  4322|         0|            0|            0|  0.00%|        if numtodel <= 0:
  4323|         0|            0|            0|  0.00%|            if wrap:
  4324|         0|            0|            0|  0.00%|                return wrap(arr.copy(order=arrorder))
  4325|         0|            0|            0|  0.00%|            else:
  4326|         0|            0|            0|  0.00%|                return arr.copy(order=arrorder)
  4327|         0|            0|            0|  0.00%|
  4328|         0|            0|            0|  0.00%|        # Invert if step is negative:
  4329|         0|            0|            0|  0.00%|        if step < 0:
  4330|         0|            0|            0|  0.00%|            step = -step
  4331|         0|            0|            0|  0.00%|            start = xr[-1]
  4332|         0|            0|            0|  0.00%|            stop = xr[0] + 1
  4333|         0|            0|            0|  0.00%|
  4334|         0|            0|            0|  0.00%|        newshape[axis] -= numtodel
  4335|         0|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  4336|         0|            0|            0|  0.00%|        # copy initial chunk
  4337|         0|            0|            0|  0.00%|        if start == 0:
  4338|         0|            0|            0|  0.00%|            pass
  4339|         0|            0|            0|  0.00%|        else:
  4340|         0|            0|            0|  0.00%|            slobj[axis] = slice(None, start)
  4341|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj)]
  4342|         0|            0|            0|  0.00%|        # copy end chunk
  4343|         0|            0|            0|  0.00%|        if stop == N:
  4344|         0|            0|            0|  0.00%|            pass
  4345|         0|            0|            0|  0.00%|        else:
  4346|         0|            0|            0|  0.00%|            slobj[axis] = slice(stop-numtodel, None)
  4347|         0|            0|            0|  0.00%|            slobj2 = [slice(None)]*ndim
  4348|         0|            0|            0|  0.00%|            slobj2[axis] = slice(stop, None)
  4349|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj2)]
  4350|         0|            0|            0|  0.00%|        # copy middle pieces
  4351|         0|            0|            0|  0.00%|        if step == 1:
  4352|         0|            0|            0|  0.00%|            pass
  4353|         0|            0|            0|  0.00%|        else:  # use array indexing.
  4354|         0|            0|            0|  0.00%|            keep = ones(stop-start, dtype=bool)
  4355|         0|            0|            0|  0.00%|            keep[:stop-start:step] = False
  4356|         0|            0|            0|  0.00%|            slobj[axis] = slice(start, stop-numtodel)
  4357|         0|            0|            0|  0.00%|            slobj2 = [slice(None)]*ndim
  4358|         0|            0|            0|  0.00%|            slobj2[axis] = slice(start, stop)
  4359|         0|            0|            0|  0.00%|            arr = arr[tuple(slobj2)]
  4360|         0|            0|            0|  0.00%|            slobj2[axis] = keep
  4361|         0|            0|            0|  0.00%|            new[tuple(slobj)] = arr[tuple(slobj2)]
  4362|         0|            0|            0|  0.00%|        if wrap:
  4363|         0|            0|            0|  0.00%|            return wrap(new)
  4364|         0|            0|            0|  0.00%|        else:
  4365|         0|            0|            0|  0.00%|            return new
  4366|         0|            0|            0|  0.00%|
  4367|         0|            0|            0|  0.00%|    _obj = obj
  4368|         0|            0|            0|  0.00%|    obj = np.asarray(obj)
  4369|         0|            0|            0|  0.00%|    # After removing the special handling of booleans and out of
  4370|         0|            0|            0|  0.00%|    # bounds values, the conversion to the array can be removed.
  4371|         0|            0|            0|  0.00%|    if obj.dtype == bool:
  4372|         0|            0|            0|  0.00%|        warnings.warn("in the future insert will treat boolean arrays and "
  4373|         0|            0|            0|  0.00%|                      "array-likes as boolean index instead of casting it "
  4374|         0|            0|            0|  0.00%|                      "to integer", FutureWarning, stacklevel=3)
  4375|         0|            0|            0|  0.00%|        obj = obj.astype(intp)
  4376|         0|            0|            0|  0.00%|    if isinstance(_obj, (int, long, integer)):
  4377|         0|            0|            0|  0.00%|        # optimization for a single value
  4378|         0|            0|            0|  0.00%|        obj = obj.item()
  4379|         0|            0|            0|  0.00%|        if (obj < -N or obj >= N):
  4380|         0|            0|            0|  0.00%|            raise IndexError(
  4381|         0|            0|            0|  0.00%|                "index %i is out of bounds for axis %i with "
  4382|         0|            0|            0|  0.00%|                "size %i" % (obj, axis, N))
  4383|         0|            0|            0|  0.00%|        if (obj < 0):
  4384|         0|            0|            0|  0.00%|            obj += N
  4385|         0|            0|            0|  0.00%|        newshape[axis] -= 1
  4386|         0|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  4387|         0|            0|            0|  0.00%|        slobj[axis] = slice(None, obj)
  4388|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj)]
  4389|         0|            0|            0|  0.00%|        slobj[axis] = slice(obj, None)
  4390|         0|            0|            0|  0.00%|        slobj2 = [slice(None)]*ndim
  4391|         0|            0|            0|  0.00%|        slobj2[axis] = slice(obj+1, None)
  4392|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj2)]
  4393|         0|            0|            0|  0.00%|    else:
  4394|         0|            0|            0|  0.00%|        if obj.size == 0 and not isinstance(_obj, np.ndarray):
  4395|         0|            0|            0|  0.00%|            obj = obj.astype(intp)
  4396|         0|            0|            0|  0.00%|        if not np.can_cast(obj, intp, 'same_kind'):
  4397|         0|            0|            0|  0.00%|            # obj.size = 1 special case always failed and would just
  4398|         0|            0|            0|  0.00%|            # give superfluous warnings.
  4399|         0|            0|            0|  0.00%|            # 2013-09-24, 1.9
  4400|         0|            0|            0|  0.00%|            warnings.warn(
  4401|         0|            0|            0|  0.00%|                "using a non-integer array as obj in delete will result in an "
  4402|         0|            0|            0|  0.00%|                "error in the future", DeprecationWarning, stacklevel=3)
  4403|         0|            0|            0|  0.00%|            obj = obj.astype(intp)
  4404|         0|            0|            0|  0.00%|        keep = ones(N, dtype=bool)
  4405|         0|            0|            0|  0.00%|
  4406|         0|            0|            0|  0.00%|        # Test if there are out of bound indices, this is deprecated
  4407|         0|            0|            0|  0.00%|        inside_bounds = (obj < N) & (obj >= -N)
  4408|         0|            0|            0|  0.00%|        if not inside_bounds.all():
  4409|         0|            0|            0|  0.00%|            # 2013-09-24, 1.9
  4410|         0|            0|            0|  0.00%|            warnings.warn(
  4411|         0|            0|            0|  0.00%|                "in the future out of bounds indices will raise an error "
  4412|         0|            0|            0|  0.00%|                "instead of being ignored by `numpy.delete`.",
  4413|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=3)
  4414|         0|            0|            0|  0.00%|            obj = obj[inside_bounds]
  4415|         0|            0|            0|  0.00%|        positive_indices = obj >= 0
  4416|         0|            0|            0|  0.00%|        if not positive_indices.all():
  4417|         0|            0|            0|  0.00%|            warnings.warn(
  4418|         0|            0|            0|  0.00%|                "in the future negative indices will not be ignored by "
  4419|         0|            0|            0|  0.00%|                "`numpy.delete`.", FutureWarning, stacklevel=3)
  4420|         0|            0|            0|  0.00%|            obj = obj[positive_indices]
  4421|         0|            0|            0|  0.00%|
  4422|         0|            0|            0|  0.00%|        keep[obj, ] = False
  4423|         0|            0|            0|  0.00%|        slobj[axis] = keep
  4424|         0|            0|            0|  0.00%|        new = arr[tuple(slobj)]
  4425|         0|            0|            0|  0.00%|
  4426|         0|            0|            0|  0.00%|    if wrap:
  4427|         0|            0|            0|  0.00%|        return wrap(new)
  4428|         0|            0|            0|  0.00%|    else:
  4429|         0|            0|            0|  0.00%|        return new
  4430|         0|            0|            0|  0.00%|
  4431|         0|            0|            0|  0.00%|
  4432|         0|            0|            0|  0.00%|def _insert_dispatcher(arr, obj, values, axis=None):
  4433|         0|            0|            0|  0.00%|    return (arr, obj, values)
  4434|         0|            0|            0|  0.00%|
  4435|         0|            0|            0|  0.00%|
  4436|         0|            0|            0|  0.00%|@array_function_dispatch(_insert_dispatcher)
  4437|         0|            0|            0|  0.00%|def insert(arr, obj, values, axis=None):
  4438|         0|            0|            0|  0.00%|    """
  4439|         0|            0|            0|  0.00%|    Insert values along the given axis before the given indices.
  4440|         0|            0|            0|  0.00%|
  4441|         0|            0|            0|  0.00%|    Parameters
  4442|         0|            0|            0|  0.00%|    ----------
  4443|         0|            0|            0|  0.00%|    arr : array_like
  4444|         0|            0|            0|  0.00%|        Input array.
  4445|         0|            0|            0|  0.00%|    obj : int, slice or sequence of ints
  4446|         0|            0|            0|  0.00%|        Object that defines the index or indices before which `values` is
  4447|         0|            0|            0|  0.00%|        inserted.
  4448|         0|            0|            0|  0.00%|
  4449|         0|            0|            0|  0.00%|        .. versionadded:: 1.8.0
  4450|         0|            0|            0|  0.00%|
  4451|         0|            0|            0|  0.00%|        Support for multiple insertions when `obj` is a single scalar or a
  4452|         0|            0|            0|  0.00%|        sequence with one element (similar to calling insert multiple
  4453|         0|            0|            0|  0.00%|        times).
  4454|         0|            0|            0|  0.00%|    values : array_like
  4455|         0|            0|            0|  0.00%|        Values to insert into `arr`. If the type of `values` is different
  4456|         0|            0|            0|  0.00%|        from that of `arr`, `values` is converted to the type of `arr`.
  4457|         0|            0|            0|  0.00%|        `values` should be shaped so that ``arr[...,obj,...] = values``
  4458|         0|            0|            0|  0.00%|        is legal.
  4459|         0|            0|            0|  0.00%|    axis : int, optional
  4460|         0|            0|            0|  0.00%|        Axis along which to insert `values`.  If `axis` is None then `arr`
  4461|         0|            0|            0|  0.00%|        is flattened first.
  4462|         0|            0|            0|  0.00%|
  4463|         0|            0|            0|  0.00%|    Returns
  4464|         0|            0|            0|  0.00%|    -------
  4465|         0|            0|            0|  0.00%|    out : ndarray
  4466|         0|            0|            0|  0.00%|        A copy of `arr` with `values` inserted.  Note that `insert`
  4467|         0|            0|            0|  0.00%|        does not occur in-place: a new array is returned. If
  4468|         0|            0|            0|  0.00%|        `axis` is None, `out` is a flattened array.
  4469|         0|            0|            0|  0.00%|
  4470|         0|            0|            0|  0.00%|    See Also
  4471|         0|            0|            0|  0.00%|    --------
  4472|         0|            0|            0|  0.00%|    append : Append elements at the end of an array.
  4473|         0|            0|            0|  0.00%|    concatenate : Join a sequence of arrays along an existing axis.
  4474|         0|            0|            0|  0.00%|    delete : Delete elements from an array.
  4475|         0|            0|            0|  0.00%|
  4476|         0|            0|            0|  0.00%|    Notes
  4477|         0|            0|            0|  0.00%|    -----
  4478|         0|            0|            0|  0.00%|    Note that for higher dimensional inserts `obj=0` behaves very different
  4479|         0|            0|            0|  0.00%|    from `obj=[0]` just like `arr[:,0,:] = values` is different from
  4480|         0|            0|            0|  0.00%|    `arr[:,[0],:] = values`.
  4481|         0|            0|            0|  0.00%|
  4482|         0|            0|            0|  0.00%|    Examples
  4483|         0|            0|            0|  0.00%|    --------
  4484|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 1], [2, 2], [3, 3]])
  4485|         0|            0|            0|  0.00%|    >>> a
  4486|         0|            0|            0|  0.00%|    array([[1, 1],
  4487|         0|            0|            0|  0.00%|           [2, 2],
  4488|         0|            0|            0|  0.00%|           [3, 3]])
  4489|         0|            0|            0|  0.00%|    >>> np.insert(a, 1, 5)
  4490|         0|            0|            0|  0.00%|    array([1, 5, 1, ..., 2, 3, 3])
  4491|         0|            0|            0|  0.00%|    >>> np.insert(a, 1, 5, axis=1)
  4492|         0|            0|            0|  0.00%|    array([[1, 5, 1],
  4493|         0|            0|            0|  0.00%|           [2, 5, 2],
  4494|         0|            0|            0|  0.00%|           [3, 5, 3]])
  4495|         0|            0|            0|  0.00%|
  4496|         0|            0|            0|  0.00%|    Difference between sequence and scalars:
  4497|         0|            0|            0|  0.00%|
  4498|         0|            0|            0|  0.00%|    >>> np.insert(a, [1], [[1],[2],[3]], axis=1)
  4499|         0|            0|            0|  0.00%|    array([[1, 1, 1],
  4500|         0|            0|            0|  0.00%|           [2, 2, 2],
  4501|         0|            0|            0|  0.00%|           [3, 3, 3]])
  4502|         0|            0|            0|  0.00%|    >>> np.array_equal(np.insert(a, 1, [1, 2, 3], axis=1),
  4503|         0|            0|            0|  0.00%|    ...                np.insert(a, [1], [[1],[2],[3]], axis=1))
  4504|         0|            0|            0|  0.00%|    True
  4505|         0|            0|            0|  0.00%|
  4506|         0|            0|            0|  0.00%|    >>> b = a.flatten()
  4507|         0|            0|            0|  0.00%|    >>> b
  4508|         0|            0|            0|  0.00%|    array([1, 1, 2, 2, 3, 3])
  4509|         0|            0|            0|  0.00%|    >>> np.insert(b, [2, 2], [5, 6])
  4510|         0|            0|            0|  0.00%|    array([1, 1, 5, ..., 2, 3, 3])
  4511|         0|            0|            0|  0.00%|
  4512|         0|            0|            0|  0.00%|    >>> np.insert(b, slice(2, 4), [5, 6])
  4513|         0|            0|            0|  0.00%|    array([1, 1, 5, ..., 2, 3, 3])
  4514|         0|            0|            0|  0.00%|
  4515|         0|            0|            0|  0.00%|    >>> np.insert(b, [2, 2], [7.13, False]) # type casting
  4516|         0|            0|            0|  0.00%|    array([1, 1, 7, ..., 2, 3, 3])
  4517|         0|            0|            0|  0.00%|
  4518|         0|            0|            0|  0.00%|    >>> x = np.arange(8).reshape(2, 4)
  4519|         0|            0|            0|  0.00%|    >>> idx = (1, 3)
  4520|         0|            0|            0|  0.00%|    >>> np.insert(x, idx, 999, axis=1)
  4521|         0|            0|            0|  0.00%|    array([[  0, 999,   1,   2, 999,   3],
  4522|         0|            0|            0|  0.00%|           [  4, 999,   5,   6, 999,   7]])
  4523|         0|            0|            0|  0.00%|
  4524|         0|            0|            0|  0.00%|    """
  4525|         0|            0|            0|  0.00%|    wrap = None
  4526|         0|            0|            0|  0.00%|    if type(arr) is not ndarray:
  4527|         0|            0|            0|  0.00%|        try:
  4528|         0|            0|            0|  0.00%|            wrap = arr.__array_wrap__
  4529|         0|            0|            0|  0.00%|        except AttributeError:
  4530|         0|            0|            0|  0.00%|            pass
  4531|         0|            0|            0|  0.00%|
  4532|         0|            0|            0|  0.00%|    arr = asarray(arr)
  4533|         0|            0|            0|  0.00%|    ndim = arr.ndim
  4534|         0|            0|            0|  0.00%|    arrorder = 'F' if arr.flags.fnc else 'C'
  4535|         0|            0|            0|  0.00%|    if axis is None:
  4536|         0|            0|            0|  0.00%|        if ndim != 1:
  4537|         0|            0|            0|  0.00%|            arr = arr.ravel()
  4538|         0|            0|            0|  0.00%|        ndim = arr.ndim
  4539|         0|            0|            0|  0.00%|        axis = ndim - 1
  4540|         0|            0|            0|  0.00%|    elif ndim == 0:
  4541|         0|            0|            0|  0.00%|        # 2013-09-24, 1.9
  4542|         0|            0|            0|  0.00%|        warnings.warn(
  4543|         0|            0|            0|  0.00%|            "in the future the special handling of scalars will be removed "
  4544|         0|            0|            0|  0.00%|            "from insert and raise an error", DeprecationWarning, stacklevel=3)
  4545|         0|            0|            0|  0.00%|        arr = arr.copy(order=arrorder)
  4546|         0|            0|            0|  0.00%|        arr[...] = values
  4547|         0|            0|            0|  0.00%|        if wrap:
  4548|         0|            0|            0|  0.00%|            return wrap(arr)
  4549|         0|            0|            0|  0.00%|        else:
  4550|         0|            0|            0|  0.00%|            return arr
  4551|         0|            0|            0|  0.00%|    else:
  4552|         0|            0|            0|  0.00%|        axis = normalize_axis_index(axis, ndim)
  4553|         0|            0|            0|  0.00%|    slobj = [slice(None)]*ndim
  4554|         0|            0|            0|  0.00%|    N = arr.shape[axis]
  4555|         0|            0|            0|  0.00%|    newshape = list(arr.shape)
  4556|         0|            0|            0|  0.00%|
  4557|         0|            0|            0|  0.00%|    if isinstance(obj, slice):
  4558|         0|            0|            0|  0.00%|        # turn it into a range object
  4559|         0|            0|            0|  0.00%|        indices = arange(*obj.indices(N), **{'dtype': intp})
  4560|         0|            0|            0|  0.00%|    else:
  4561|         0|            0|            0|  0.00%|        # need to copy obj, because indices will be changed in-place
  4562|         0|            0|            0|  0.00%|        indices = np.array(obj)
  4563|         0|            0|            0|  0.00%|        if indices.dtype == bool:
  4564|         0|            0|            0|  0.00%|            # See also delete
  4565|         0|            0|            0|  0.00%|            warnings.warn(
  4566|         0|            0|            0|  0.00%|                "in the future insert will treat boolean arrays and "
  4567|         0|            0|            0|  0.00%|                "array-likes as a boolean index instead of casting it to "
  4568|         0|            0|            0|  0.00%|                "integer", FutureWarning, stacklevel=3)
  4569|         0|            0|            0|  0.00%|            indices = indices.astype(intp)
  4570|         0|            0|            0|  0.00%|            # Code after warning period:
  4571|         0|            0|            0|  0.00%|            #if obj.ndim != 1:
  4572|         0|            0|            0|  0.00%|            #    raise ValueError('boolean array argument obj to insert '
  4573|         0|            0|            0|  0.00%|            #                     'must be one dimensional')
  4574|         0|            0|            0|  0.00%|            #indices = np.flatnonzero(obj)
  4575|         0|            0|            0|  0.00%|        elif indices.ndim > 1:
  4576|         0|            0|            0|  0.00%|            raise ValueError(
  4577|         0|            0|            0|  0.00%|                "index array argument obj to insert must be one dimensional "
  4578|         0|            0|            0|  0.00%|                "or scalar")
  4579|         0|            0|            0|  0.00%|    if indices.size == 1:
  4580|         0|            0|            0|  0.00%|        index = indices.item()
  4581|         0|            0|            0|  0.00%|        if index < -N or index > N:
  4582|         0|            0|            0|  0.00%|            raise IndexError(
  4583|         0|            0|            0|  0.00%|                "index %i is out of bounds for axis %i with "
  4584|         0|            0|            0|  0.00%|                "size %i" % (obj, axis, N))
  4585|         0|            0|            0|  0.00%|        if (index < 0):
  4586|         0|            0|            0|  0.00%|            index += N
  4587|         0|            0|            0|  0.00%|
  4588|         0|            0|            0|  0.00%|        # There are some object array corner cases here, but we cannot avoid
  4589|         0|            0|            0|  0.00%|        # that:
  4590|         0|            0|            0|  0.00%|        values = array(values, copy=False, ndmin=arr.ndim, dtype=arr.dtype)
  4591|         0|            0|            0|  0.00%|        if indices.ndim == 0:
  4592|         0|            0|            0|  0.00%|            # broadcasting is very different here, since a[:,0,:] = ... behaves
  4593|         0|            0|            0|  0.00%|            # very different from a[:,[0],:] = ...! This changes values so that
  4594|         0|            0|            0|  0.00%|            # it works likes the second case. (here a[:,0:1,:])
  4595|         0|            0|            0|  0.00%|            values = np.moveaxis(values, 0, axis)
  4596|         0|            0|            0|  0.00%|        numnew = values.shape[axis]
  4597|         0|            0|            0|  0.00%|        newshape[axis] += numnew
  4598|         0|            0|            0|  0.00%|        new = empty(newshape, arr.dtype, arrorder)
  4599|         0|            0|            0|  0.00%|        slobj[axis] = slice(None, index)
  4600|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj)]
  4601|         0|            0|            0|  0.00%|        slobj[axis] = slice(index, index+numnew)
  4602|         0|            0|            0|  0.00%|        new[tuple(slobj)] = values
  4603|         0|            0|            0|  0.00%|        slobj[axis] = slice(index+numnew, None)
  4604|         0|            0|            0|  0.00%|        slobj2 = [slice(None)] * ndim
  4605|         0|            0|            0|  0.00%|        slobj2[axis] = slice(index, None)
  4606|         0|            0|            0|  0.00%|        new[tuple(slobj)] = arr[tuple(slobj2)]
  4607|         0|            0|            0|  0.00%|        if wrap:
  4608|         0|            0|            0|  0.00%|            return wrap(new)
  4609|         0|            0|            0|  0.00%|        return new
  4610|         0|            0|            0|  0.00%|    elif indices.size == 0 and not isinstance(obj, np.ndarray):
  4611|         0|            0|            0|  0.00%|        # Can safely cast the empty list to intp
  4612|         0|            0|            0|  0.00%|        indices = indices.astype(intp)
  4613|         0|            0|            0|  0.00%|
  4614|         0|            0|            0|  0.00%|    if not np.can_cast(indices, intp, 'same_kind'):
  4615|         0|            0|            0|  0.00%|        # 2013-09-24, 1.9
  4616|         0|            0|            0|  0.00%|        warnings.warn(
  4617|         0|            0|            0|  0.00%|            "using a non-integer array as obj in insert will result in an "
  4618|         0|            0|            0|  0.00%|            "error in the future", DeprecationWarning, stacklevel=3)
  4619|         0|            0|            0|  0.00%|        indices = indices.astype(intp)
  4620|         0|            0|            0|  0.00%|
  4621|         0|            0|            0|  0.00%|    indices[indices < 0] += N
  4622|         0|            0|            0|  0.00%|
  4623|         0|            0|            0|  0.00%|    numnew = len(indices)
  4624|         0|            0|            0|  0.00%|    order = indices.argsort(kind='mergesort')   # stable sort
  4625|         0|            0|            0|  0.00%|    indices[order] += np.arange(numnew)
  4626|         0|            0|            0|  0.00%|
  4627|         0|            0|            0|  0.00%|    newshape[axis] += numnew
  4628|         0|            0|            0|  0.00%|    old_mask = ones(newshape[axis], dtype=bool)
  4629|         0|            0|            0|  0.00%|    old_mask[indices] = False
  4630|         0|            0|            0|  0.00%|
  4631|         0|            0|            0|  0.00%|    new = empty(newshape, arr.dtype, arrorder)
  4632|         0|            0|            0|  0.00%|    slobj2 = [slice(None)]*ndim
  4633|         0|            0|            0|  0.00%|    slobj[axis] = indices
  4634|         0|            0|            0|  0.00%|    slobj2[axis] = old_mask
  4635|         0|            0|            0|  0.00%|    new[tuple(slobj)] = values
  4636|         0|            0|            0|  0.00%|    new[tuple(slobj2)] = arr
  4637|         0|            0|            0|  0.00%|
  4638|         0|            0|            0|  0.00%|    if wrap:
  4639|         0|            0|            0|  0.00%|        return wrap(new)
  4640|         0|            0|            0|  0.00%|    return new
  4641|         0|            0|            0|  0.00%|
  4642|         0|            0|            0|  0.00%|
  4643|         0|            0|            0|  0.00%|def _append_dispatcher(arr, values, axis=None):
  4644|         0|            0|            0|  0.00%|    return (arr, values)
  4645|         0|            0|            0|  0.00%|
  4646|         0|            0|            0|  0.00%|
  4647|         0|            0|            0|  0.00%|@array_function_dispatch(_append_dispatcher)
  4648|         0|            0|            0|  0.00%|def append(arr, values, axis=None):
  4649|         0|            0|            0|  0.00%|    """
  4650|         0|            0|            0|  0.00%|    Append values to the end of an array.
  4651|         0|            0|            0|  0.00%|
  4652|         0|            0|            0|  0.00%|    Parameters
  4653|         0|            0|            0|  0.00%|    ----------
  4654|         0|            0|            0|  0.00%|    arr : array_like
  4655|         0|            0|            0|  0.00%|        Values are appended to a copy of this array.
  4656|         0|            0|            0|  0.00%|    values : array_like
  4657|         0|            0|            0|  0.00%|        These values are appended to a copy of `arr`.  It must be of the
  4658|         0|            0|            0|  0.00%|        correct shape (the same shape as `arr`, excluding `axis`).  If
  4659|         0|            0|            0|  0.00%|        `axis` is not specified, `values` can be any shape and will be
  4660|         0|            0|            0|  0.00%|        flattened before use.
  4661|         0|            0|            0|  0.00%|    axis : int, optional
  4662|         0|            0|            0|  0.00%|        The axis along which `values` are appended.  If `axis` is not
  4663|         0|            0|            0|  0.00%|        given, both `arr` and `values` are flattened before use.
  4664|         0|            0|            0|  0.00%|
  4665|         0|            0|            0|  0.00%|    Returns
  4666|         0|            0|            0|  0.00%|    -------
  4667|         0|            0|            0|  0.00%|    append : ndarray
  4668|         0|            0|            0|  0.00%|        A copy of `arr` with `values` appended to `axis`.  Note that
  4669|         0|            0|            0|  0.00%|        `append` does not occur in-place: a new array is allocated and
  4670|         0|            0|            0|  0.00%|        filled.  If `axis` is None, `out` is a flattened array.
  4671|         0|            0|            0|  0.00%|
  4672|         0|            0|            0|  0.00%|    See Also
  4673|         0|            0|            0|  0.00%|    --------
  4674|         0|            0|            0|  0.00%|    insert : Insert elements into an array.
  4675|         0|            0|            0|  0.00%|    delete : Delete elements from an array.
  4676|         0|            0|            0|  0.00%|
  4677|         0|            0|            0|  0.00%|    Examples
  4678|         0|            0|            0|  0.00%|    --------
  4679|         0|            0|            0|  0.00%|    >>> np.append([1, 2, 3], [[4, 5, 6], [7, 8, 9]])
  4680|         0|            0|            0|  0.00%|    array([1, 2, 3, ..., 7, 8, 9])
  4681|         0|            0|            0|  0.00%|
  4682|         0|            0|            0|  0.00%|    When `axis` is specified, `values` must have the correct shape.
  4683|         0|            0|            0|  0.00%|
  4684|         0|            0|            0|  0.00%|    >>> np.append([[1, 2, 3], [4, 5, 6]], [[7, 8, 9]], axis=0)
  4685|         0|            0|            0|  0.00%|    array([[1, 2, 3],
  4686|         0|            0|            0|  0.00%|           [4, 5, 6],
  4687|         0|            0|            0|  0.00%|           [7, 8, 9]])
  4688|         0|            0|            0|  0.00%|    >>> np.append([[1, 2, 3], [4, 5, 6]], [7, 8, 9], axis=0)
  4689|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  4690|         0|            0|            0|  0.00%|        ...
  4691|         0|            0|            0|  0.00%|    ValueError: all the input arrays must have same number of dimensions
  4692|         0|            0|            0|  0.00%|
  4693|         0|            0|            0|  0.00%|    """
  4694|         0|            0|            0|  0.00%|    arr = asanyarray(arr)
  4695|         0|            0|            0|  0.00%|    if axis is None:
  4696|         0|            0|            0|  0.00%|        if arr.ndim != 1:
  4697|         0|            0|            0|  0.00%|            arr = arr.ravel()
  4698|         0|            0|            0|  0.00%|        values = ravel(values)
  4699|         0|            0|            0|  0.00%|        axis = arr.ndim-1
  4700|         0|            0|            0|  0.00%|    return concatenate((arr, values), axis=axis)
  4701|         0|            0|            0|  0.00%|
  4702|         0|            0|            0|  0.00%|
  4703|         0|            0|            0|  0.00%|def _digitize_dispatcher(x, bins, right=None):
  4704|         0|            0|            0|  0.00%|    return (x, bins)
  4705|         0|            0|            0|  0.00%|
  4706|         0|            0|            0|  0.00%|
  4707|         0|            0|            0|  0.00%|@array_function_dispatch(_digitize_dispatcher)
  4708|         0|            0|            0|  0.00%|def digitize(x, bins, right=False):
  4709|         0|            0|            0|  0.00%|    """
  4710|         0|            0|            0|  0.00%|    Return the indices of the bins to which each value in input array belongs.
  4711|         0|            0|            0|  0.00%|
  4712|         0|            0|            0|  0.00%|    =========  =============  ============================
  4713|         0|            0|            0|  0.00%|    `right`    order of bins  returned index `i` satisfies
  4714|         0|            0|            0|  0.00%|    =========  =============  ============================
  4715|         0|            0|            0|  0.00%|    ``False``  increasing     ``bins[i-1] <= x < bins[i]``
  4716|         0|            0|            0|  0.00%|    ``True``   increasing     ``bins[i-1] < x <= bins[i]``
  4717|         0|            0|            0|  0.00%|    ``False``  decreasing     ``bins[i-1] > x >= bins[i]``
  4718|         0|            0|            0|  0.00%|    ``True``   decreasing     ``bins[i-1] >= x > bins[i]``
  4719|         0|            0|            0|  0.00%|    =========  =============  ============================
  4720|         0|            0|            0|  0.00%|
  4721|         0|            0|            0|  0.00%|    If values in `x` are beyond the bounds of `bins`, 0 or ``len(bins)`` is
  4722|         0|            0|            0|  0.00%|    returned as appropriate.
  4723|         0|            0|            0|  0.00%|
  4724|         0|            0|            0|  0.00%|    Parameters
  4725|         0|            0|            0|  0.00%|    ----------
  4726|         0|            0|            0|  0.00%|    x : array_like
  4727|         0|            0|            0|  0.00%|        Input array to be binned. Prior to NumPy 1.10.0, this array had to
  4728|         0|            0|            0|  0.00%|        be 1-dimensional, but can now have any shape.
  4729|         0|            0|            0|  0.00%|    bins : array_like
  4730|         0|            0|            0|  0.00%|        Array of bins. It has to be 1-dimensional and monotonic.
  4731|         0|            0|            0|  0.00%|    right : bool, optional
  4732|         0|            0|            0|  0.00%|        Indicating whether the intervals include the right or the left bin
  4733|         0|            0|            0|  0.00%|        edge. Default behavior is (right==False) indicating that the interval
  4734|         0|            0|            0|  0.00%|        does not include the right edge. The left bin end is open in this
  4735|         0|            0|            0|  0.00%|        case, i.e., bins[i-1] <= x < bins[i] is the default behavior for
  4736|         0|            0|            0|  0.00%|        monotonically increasing bins.
  4737|         0|            0|            0|  0.00%|
  4738|         0|            0|            0|  0.00%|    Returns
  4739|         0|            0|            0|  0.00%|    -------
  4740|         0|            0|            0|  0.00%|    indices : ndarray of ints
  4741|         0|            0|            0|  0.00%|        Output array of indices, of same shape as `x`.
  4742|         0|            0|            0|  0.00%|
  4743|         0|            0|            0|  0.00%|    Raises
  4744|         0|            0|            0|  0.00%|    ------
  4745|         0|            0|            0|  0.00%|    ValueError
  4746|         0|            0|            0|  0.00%|        If `bins` is not monotonic.
  4747|         0|            0|            0|  0.00%|    TypeError
  4748|         0|            0|            0|  0.00%|        If the type of the input is complex.
  4749|         0|            0|            0|  0.00%|
  4750|         0|            0|            0|  0.00%|    See Also
  4751|         0|            0|            0|  0.00%|    --------
  4752|         0|            0|            0|  0.00%|    bincount, histogram, unique, searchsorted
  4753|         0|            0|            0|  0.00%|
  4754|         0|            0|            0|  0.00%|    Notes
  4755|         0|            0|            0|  0.00%|    -----
  4756|         0|            0|            0|  0.00%|    If values in `x` are such that they fall outside the bin range,
  4757|         0|            0|            0|  0.00%|    attempting to index `bins` with the indices that `digitize` returns
  4758|         0|            0|            0|  0.00%|    will result in an IndexError.
  4759|         0|            0|            0|  0.00%|
  4760|         0|            0|            0|  0.00%|    .. versionadded:: 1.10.0
  4761|         0|            0|            0|  0.00%|
  4762|         0|            0|            0|  0.00%|    `np.digitize` is  implemented in terms of `np.searchsorted`. This means
  4763|         0|            0|            0|  0.00%|    that a binary search is used to bin the values, which scales much better
  4764|         0|            0|            0|  0.00%|    for larger number of bins than the previous linear search. It also removes
  4765|         0|            0|            0|  0.00%|    the requirement for the input array to be 1-dimensional.
  4766|         0|            0|            0|  0.00%|
  4767|         0|            0|            0|  0.00%|    For monotonically _increasing_ `bins`, the following are equivalent::
  4768|         0|            0|            0|  0.00%|
  4769|         0|            0|            0|  0.00%|        np.digitize(x, bins, right=True)
  4770|         0|            0|            0|  0.00%|        np.searchsorted(bins, x, side='left')
  4771|         0|            0|            0|  0.00%|
  4772|         0|            0|            0|  0.00%|    Note that as the order of the arguments are reversed, the side must be too.
  4773|         0|            0|            0|  0.00%|    The `searchsorted` call is marginally faster, as it does not do any
  4774|         0|            0|            0|  0.00%|    monotonicity checks. Perhaps more importantly, it supports all dtypes.
  4775|         0|            0|            0|  0.00%|
  4776|         0|            0|            0|  0.00%|    Examples
  4777|         0|            0|            0|  0.00%|    --------
  4778|         0|            0|            0|  0.00%|    >>> x = np.array([0.2, 6.4, 3.0, 1.6])
  4779|         0|            0|            0|  0.00%|    >>> bins = np.array([0.0, 1.0, 2.5, 4.0, 10.0])
  4780|         0|            0|            0|  0.00%|    >>> inds = np.digitize(x, bins)
  4781|         0|            0|            0|  0.00%|    >>> inds
  4782|         0|            0|            0|  0.00%|    array([1, 4, 3, 2])
  4783|         0|            0|            0|  0.00%|    >>> for n in range(x.size):
  4784|         0|            0|            0|  0.00%|    ...   print(bins[inds[n]-1], "<=", x[n], "<", bins[inds[n]])
  4785|         0|            0|            0|  0.00%|    ...
  4786|         0|            0|            0|  0.00%|    0.0 <= 0.2 < 1.0
  4787|         0|            0|            0|  0.00%|    4.0 <= 6.4 < 10.0
  4788|         0|            0|            0|  0.00%|    2.5 <= 3.0 < 4.0
  4789|         0|            0|            0|  0.00%|    1.0 <= 1.6 < 2.5
  4790|         0|            0|            0|  0.00%|
  4791|         0|            0|            0|  0.00%|    >>> x = np.array([1.2, 10.0, 12.4, 15.5, 20.])
  4792|         0|            0|            0|  0.00%|    >>> bins = np.array([0, 5, 10, 15, 20])
  4793|         0|            0|            0|  0.00%|    >>> np.digitize(x,bins,right=True)
  4794|         0|            0|            0|  0.00%|    array([1, 2, 3, 4, 4])
  4795|         0|            0|            0|  0.00%|    >>> np.digitize(x,bins,right=False)
  4796|         0|            0|            0|  0.00%|    array([1, 3, 3, 4, 5])
  4797|         0|            0|            0|  0.00%|    """
  4798|         0|            0|            0|  0.00%|    x = _nx.asarray(x)
  4799|         0|            0|            0|  0.00%|    bins = _nx.asarray(bins)
  4800|         0|            0|            0|  0.00%|
  4801|         0|            0|            0|  0.00%|    # here for compatibility, searchsorted below is happy to take this
  4802|         0|            0|            0|  0.00%|    if np.issubdtype(x.dtype, _nx.complexfloating):
  4803|         0|            0|            0|  0.00%|        raise TypeError("x may not be complex")
  4804|         0|            0|            0|  0.00%|
  4805|         0|            0|            0|  0.00%|    mono = _monotonicity(bins)
  4806|         0|            0|            0|  0.00%|    if mono == 0:
  4807|         0|            0|            0|  0.00%|        raise ValueError("bins must be monotonically increasing or decreasing")
  4808|         0|            0|            0|  0.00%|
  4809|         0|            0|            0|  0.00%|    # this is backwards because the arguments below are swapped
  4810|         0|            0|            0|  0.00%|    side = 'left' if right else 'right'
  4811|         0|            0|            0|  0.00%|    if mono == -1:
  4812|         0|            0|            0|  0.00%|        # reverse the bins, and invert the results
  4813|         0|            0|            0|  0.00%|        return len(bins) - _nx.searchsorted(bins[::-1], x, side=side)
  4814|         0|            0|            0|  0.00%|    else:
  4815|         0|            0|            0|  0.00%|        return _nx.searchsorted(bins, x, side=side)
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py
File duration: 0.000239611s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import functools
     4|         0|            0|            0|  0.00%|import itertools
     5|         0|            0|            0|  0.00%|import operator
     6|         0|            0|            0|  0.00%|import sys
     7|         0|            0|            0|  0.00%|import warnings
     8|         0|            0|            0|  0.00%|import numbers
     9|         0|            0|            0|  0.00%|import contextlib
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|import numpy as np
    12|         0|            0|            0|  0.00%|from numpy.compat import pickle, basestring
    13|         0|            0|            0|  0.00%|from . import multiarray
    14|         0|            0|            0|  0.00%|from .multiarray import (
    15|         0|            0|            0|  0.00%|    _fastCopyAndTranspose as fastCopyAndTranspose, ALLOW_THREADS,
    16|         0|            0|            0|  0.00%|    BUFSIZE, CLIP, MAXDIMS, MAY_SHARE_BOUNDS, MAY_SHARE_EXACT, RAISE,
    17|         0|            0|            0|  0.00%|    WRAP, arange, array, broadcast, can_cast, compare_chararrays,
    18|         0|            0|            0|  0.00%|    concatenate, copyto, dot, dtype, empty,
    19|         0|            0|            0|  0.00%|    empty_like, flatiter, frombuffer, fromfile, fromiter, fromstring,
    20|         0|            0|            0|  0.00%|    inner, int_asbuffer, lexsort, matmul, may_share_memory,
    21|         0|            0|            0|  0.00%|    min_scalar_type, ndarray, nditer, nested_iters, promote_types,
    22|         0|            0|            0|  0.00%|    putmask, result_type, set_numeric_ops, shares_memory, vdot, where,
    23|         0|            0|            0|  0.00%|    zeros, normalize_axis_index)
    24|         0|            0|            0|  0.00%|if sys.version_info[0] < 3:
    25|         0|            0|            0|  0.00%|    from .multiarray import newbuffer, getbuffer
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|from . import overrides
    28|         0|            0|            0|  0.00%|from . import umath
    29|         0|            0|            0|  0.00%|from .overrides import set_module
    30|         0|            0|            0|  0.00%|from .umath import (multiply, invert, sin, PINF, NAN)
    31|         0|            0|            0|  0.00%|from . import numerictypes
    32|         0|            0|            0|  0.00%|from .numerictypes import longlong, intc, int_, float_, complex_, bool_
    33|         0|            0|            0|  0.00%|from ._exceptions import TooHardError, AxisError
    34|         0|            0|            0|  0.00%|from ._asarray import asarray, asanyarray
    35|         0|            0|            0|  0.00%|from ._ufunc_config import errstate
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|bitwise_not = invert
    38|         0|            0|            0|  0.00%|ufunc = type(sin)
    39|         0|            0|            0|  0.00%|newaxis = None
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|if sys.version_info[0] >= 3:
    42|         0|            0|            0|  0.00%|    import builtins
    43|         0|            0|            0|  0.00%|else:
    44|         0|            0|            0|  0.00%|    import __builtin__ as builtins
    45|         0|            0|            0|  0.00%|
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|array_function_dispatch = functools.partial(
    48|         0|            0|            0|  0.00%|    overrides.array_function_dispatch, module='numpy')
    49|         0|            0|            0|  0.00%|
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|def loads(*args, **kwargs):
    52|         0|            0|            0|  0.00%|    # NumPy 1.15.0, 2017-12-10
    53|         0|            0|            0|  0.00%|    warnings.warn(
    54|         0|            0|            0|  0.00%|        "np.core.numeric.loads is deprecated, use pickle.loads instead",
    55|         0|            0|            0|  0.00%|        DeprecationWarning, stacklevel=2)
    56|         0|            0|            0|  0.00%|    return pickle.loads(*args, **kwargs)
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|__all__ = [
    60|         0|            0|            0|  0.00%|    'newaxis', 'ndarray', 'flatiter', 'nditer', 'nested_iters', 'ufunc',
    61|         0|            0|            0|  0.00%|    'arange', 'array', 'zeros', 'count_nonzero', 'empty', 'broadcast', 'dtype',
    62|         0|            0|            0|  0.00%|    'fromstring', 'fromfile', 'frombuffer', 'int_asbuffer', 'where',
    63|         0|            0|            0|  0.00%|    'argwhere', 'copyto', 'concatenate', 'fastCopyAndTranspose', 'lexsort',
    64|         0|            0|            0|  0.00%|    'set_numeric_ops', 'can_cast', 'promote_types', 'min_scalar_type',
    65|         0|            0|            0|  0.00%|    'result_type', 'isfortran', 'empty_like', 'zeros_like', 'ones_like',
    66|         0|            0|            0|  0.00%|    'correlate', 'convolve', 'inner', 'dot', 'outer', 'vdot', 'roll',
    67|         0|            0|            0|  0.00%|    'rollaxis', 'moveaxis', 'cross', 'tensordot', 'little_endian',
    68|         0|            0|            0|  0.00%|    'fromiter', 'array_equal', 'array_equiv', 'indices', 'fromfunction',
    69|         0|            0|            0|  0.00%|    'isclose', 'load', 'loads', 'isscalar', 'binary_repr', 'base_repr', 'ones',
    70|         0|            0|            0|  0.00%|    'identity', 'allclose', 'compare_chararrays', 'putmask',
    71|         0|            0|            0|  0.00%|    'flatnonzero', 'Inf', 'inf', 'infty', 'Infinity', 'nan', 'NaN',
    72|         0|            0|            0|  0.00%|    'False_', 'True_', 'bitwise_not', 'CLIP', 'RAISE', 'WRAP', 'MAXDIMS',
    73|         0|            0|            0|  0.00%|    'BUFSIZE', 'ALLOW_THREADS', 'ComplexWarning', 'full', 'full_like',
    74|         0|            0|            0|  0.00%|    'matmul', 'shares_memory', 'may_share_memory', 'MAY_SHARE_BOUNDS',
    75|         0|            0|            0|  0.00%|    'MAY_SHARE_EXACT', 'TooHardError', 'AxisError']
    76|         0|            0|            0|  0.00%|
    77|         0|            0|            0|  0.00%|if sys.version_info[0] < 3:
    78|         0|            0|            0|  0.00%|    __all__.extend(['getbuffer', 'newbuffer'])
    79|         0|            0|            0|  0.00%|
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|@set_module('numpy')
    82|         0|            0|            0|  0.00%|class ComplexWarning(RuntimeWarning):
    83|         0|            0|            0|  0.00%|    """
    84|         0|            0|            0|  0.00%|    The warning raised when casting a complex dtype to a real dtype.
    85|         0|            0|            0|  0.00%|
    86|         0|            0|            0|  0.00%|    As implemented, casting a complex number to a real discards its imaginary
    87|         0|            0|            0|  0.00%|    part, but this behavior may not be what the user actually wants.
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|    """
    90|         0|            0|            0|  0.00%|    pass
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|
    93|         0|            0|            0|  0.00%|def _zeros_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):
    94|         0|            0|            0|  0.00%|    return (a,)
    95|         0|            0|            0|  0.00%|
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|@array_function_dispatch(_zeros_like_dispatcher)
    98|         0|            0|            0|  0.00%|def zeros_like(a, dtype=None, order='K', subok=True, shape=None):
    99|         0|            0|            0|  0.00%|    """
   100|         0|            0|            0|  0.00%|    Return an array of zeros with the same shape and type as a given array.
   101|         0|            0|            0|  0.00%|
   102|         0|            0|            0|  0.00%|    Parameters
   103|         0|            0|            0|  0.00%|    ----------
   104|         0|            0|            0|  0.00%|    a : array_like
   105|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
   106|         0|            0|            0|  0.00%|        the returned array.
   107|         0|            0|            0|  0.00%|    dtype : data-type, optional
   108|         0|            0|            0|  0.00%|        Overrides the data type of the result.
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   111|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
   112|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
   113|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   114|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   115|         0|            0|            0|  0.00%|        as possible.
   116|         0|            0|            0|  0.00%|
   117|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   118|         0|            0|            0|  0.00%|    subok : bool, optional.
   119|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   120|         0|            0|            0|  0.00%|        type of 'a', otherwise it will be a base-class array. Defaults
   121|         0|            0|            0|  0.00%|        to True.
   122|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   123|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   124|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   125|         0|            0|            0|  0.00%|        order='C' is implied.
   126|         0|            0|            0|  0.00%|
   127|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   128|         0|            0|            0|  0.00%|
   129|         0|            0|            0|  0.00%|    Returns
   130|         0|            0|            0|  0.00%|    -------
   131|         0|            0|            0|  0.00%|    out : ndarray
   132|         0|            0|            0|  0.00%|        Array of zeros with the same shape and type as `a`.
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    See Also
   135|         0|            0|            0|  0.00%|    --------
   136|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   137|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   138|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   139|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   140|         0|            0|            0|  0.00%|
   141|         0|            0|            0|  0.00%|    Examples
   142|         0|            0|            0|  0.00%|    --------
   143|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
   144|         0|            0|            0|  0.00%|    >>> x = x.reshape((2, 3))
   145|         0|            0|            0|  0.00%|    >>> x
   146|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   147|         0|            0|            0|  0.00%|           [3, 4, 5]])
   148|         0|            0|            0|  0.00%|    >>> np.zeros_like(x)
   149|         0|            0|            0|  0.00%|    array([[0, 0, 0],
   150|         0|            0|            0|  0.00%|           [0, 0, 0]])
   151|         0|            0|            0|  0.00%|
   152|         0|            0|            0|  0.00%|    >>> y = np.arange(3, dtype=float)
   153|         0|            0|            0|  0.00%|    >>> y
   154|         0|            0|            0|  0.00%|    array([0., 1., 2.])
   155|         0|            0|            0|  0.00%|    >>> np.zeros_like(y)
   156|         0|            0|            0|  0.00%|    array([0.,  0.,  0.])
   157|         0|            0|            0|  0.00%|
   158|         0|            0|            0|  0.00%|    """
   159|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   160|         0|            0|            0|  0.00%|    # needed instead of a 0 to get same result as zeros for for string dtypes
   161|         0|            0|            0|  0.00%|    z = zeros(1, dtype=res.dtype)
   162|         0|            0|            0|  0.00%|    multiarray.copyto(res, z, casting='unsafe')
   163|         0|            0|            0|  0.00%|    return res
   164|         0|            0|            0|  0.00%|
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|@set_module('numpy')
   167|         0|            0|            0|  0.00%|def ones(shape, dtype=None, order='C'):
   168|         0|            0|            0|  0.00%|    """
   169|         0|            0|            0|  0.00%|    Return a new array of given shape and type, filled with ones.
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    Parameters
   172|         0|            0|            0|  0.00%|    ----------
   173|         0|            0|            0|  0.00%|    shape : int or sequence of ints
   174|         0|            0|            0|  0.00%|        Shape of the new array, e.g., ``(2, 3)`` or ``2``.
   175|         0|            0|            0|  0.00%|    dtype : data-type, optional
   176|         0|            0|            0|  0.00%|        The desired data-type for the array, e.g., `numpy.int8`.  Default is
   177|         0|            0|            0|  0.00%|        `numpy.float64`.
   178|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional, default: C
   179|         0|            0|            0|  0.00%|        Whether to store multi-dimensional data in row-major
   180|         0|            0|            0|  0.00%|        (C-style) or column-major (Fortran-style) order in
   181|         0|            0|            0|  0.00%|        memory.
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|    Returns
   184|         0|            0|            0|  0.00%|    -------
   185|         0|            0|            0|  0.00%|    out : ndarray
   186|         0|            0|            0|  0.00%|        Array of ones with the given shape, dtype, and order.
   187|         0|            0|            0|  0.00%|
   188|         0|            0|            0|  0.00%|    See Also
   189|         0|            0|            0|  0.00%|    --------
   190|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   191|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   192|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   193|         0|            0|            0|  0.00%|    full : Return a new array of given shape filled with value.
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|
   196|         0|            0|            0|  0.00%|    Examples
   197|         0|            0|            0|  0.00%|    --------
   198|         0|            0|            0|  0.00%|    >>> np.ones(5)
   199|         0|            0|            0|  0.00%|    array([1., 1., 1., 1., 1.])
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    >>> np.ones((5,), dtype=int)
   202|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1])
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    >>> np.ones((2, 1))
   205|         0|            0|            0|  0.00%|    array([[1.],
   206|         0|            0|            0|  0.00%|           [1.]])
   207|         0|            0|            0|  0.00%|
   208|         0|            0|            0|  0.00%|    >>> s = (2,2)
   209|         0|            0|            0|  0.00%|    >>> np.ones(s)
   210|         0|            0|            0|  0.00%|    array([[1.,  1.],
   211|         0|            0|            0|  0.00%|           [1.,  1.]])
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    """
   214|         0|            0|            0|  0.00%|    a = empty(shape, dtype, order)
   215|         0|            0|            0|  0.00%|    multiarray.copyto(a, 1, casting='unsafe')
   216|         0|            0|            0|  0.00%|    return a
   217|         0|            0|            0|  0.00%|
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|def _ones_like_dispatcher(a, dtype=None, order=None, subok=None, shape=None):
   220|         0|            0|            0|  0.00%|    return (a,)
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|
   223|         0|            0|            0|  0.00%|@array_function_dispatch(_ones_like_dispatcher)
   224|         0|            0|            0|  0.00%|def ones_like(a, dtype=None, order='K', subok=True, shape=None):
   225|         0|            0|            0|  0.00%|    """
   226|         0|            0|            0|  0.00%|    Return an array of ones with the same shape and type as a given array.
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|    Parameters
   229|         0|            0|            0|  0.00%|    ----------
   230|         0|            0|            0|  0.00%|    a : array_like
   231|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
   232|         0|            0|            0|  0.00%|        the returned array.
   233|         0|            0|            0|  0.00%|    dtype : data-type, optional
   234|         0|            0|            0|  0.00%|        Overrides the data type of the result.
   235|         0|            0|            0|  0.00%|
   236|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   237|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
   238|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
   239|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   240|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   241|         0|            0|            0|  0.00%|        as possible.
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|        .. versionadded:: 1.6.0
   244|         0|            0|            0|  0.00%|    subok : bool, optional.
   245|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   246|         0|            0|            0|  0.00%|        type of 'a', otherwise it will be a base-class array. Defaults
   247|         0|            0|            0|  0.00%|        to True.
   248|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   249|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   250|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   251|         0|            0|            0|  0.00%|        order='C' is implied.
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   254|         0|            0|            0|  0.00%|
   255|         0|            0|            0|  0.00%|    Returns
   256|         0|            0|            0|  0.00%|    -------
   257|         0|            0|            0|  0.00%|    out : ndarray
   258|         0|            0|            0|  0.00%|        Array of ones with the same shape and type as `a`.
   259|         0|            0|            0|  0.00%|
   260|         0|            0|            0|  0.00%|    See Also
   261|         0|            0|            0|  0.00%|    --------
   262|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   263|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   264|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   265|         0|            0|            0|  0.00%|    ones : Return a new array setting values to one.
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    Examples
   268|         0|            0|            0|  0.00%|    --------
   269|         0|            0|            0|  0.00%|    >>> x = np.arange(6)
   270|         0|            0|            0|  0.00%|    >>> x = x.reshape((2, 3))
   271|         0|            0|            0|  0.00%|    >>> x
   272|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   273|         0|            0|            0|  0.00%|           [3, 4, 5]])
   274|         0|            0|            0|  0.00%|    >>> np.ones_like(x)
   275|         0|            0|            0|  0.00%|    array([[1, 1, 1],
   276|         0|            0|            0|  0.00%|           [1, 1, 1]])
   277|         0|            0|            0|  0.00%|
   278|         0|            0|            0|  0.00%|    >>> y = np.arange(3, dtype=float)
   279|         0|            0|            0|  0.00%|    >>> y
   280|         0|            0|            0|  0.00%|    array([0., 1., 2.])
   281|         0|            0|            0|  0.00%|    >>> np.ones_like(y)
   282|         0|            0|            0|  0.00%|    array([1.,  1.,  1.])
   283|         0|            0|            0|  0.00%|
   284|         0|            0|            0|  0.00%|    """
   285|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   286|         0|            0|            0|  0.00%|    multiarray.copyto(res, 1, casting='unsafe')
   287|         0|            0|            0|  0.00%|    return res
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|@set_module('numpy')
   291|         0|            0|            0|  0.00%|def full(shape, fill_value, dtype=None, order='C'):
   292|         0|            0|            0|  0.00%|    """
   293|         0|            0|            0|  0.00%|    Return a new array of given shape and type, filled with `fill_value`.
   294|         0|            0|            0|  0.00%|
   295|         0|            0|            0|  0.00%|    Parameters
   296|         0|            0|            0|  0.00%|    ----------
   297|         0|            0|            0|  0.00%|    shape : int or sequence of ints
   298|         0|            0|            0|  0.00%|        Shape of the new array, e.g., ``(2, 3)`` or ``2``.
   299|         0|            0|            0|  0.00%|    fill_value : scalar
   300|         0|            0|            0|  0.00%|        Fill value.
   301|         0|            0|            0|  0.00%|    dtype : data-type, optional
   302|         0|            0|            0|  0.00%|        The desired data-type for the array  The default, `None`, means
   303|         0|            0|            0|  0.00%|         `np.array(fill_value).dtype`.
   304|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
   305|         0|            0|            0|  0.00%|        Whether to store multidimensional data in C- or Fortran-contiguous
   306|         0|            0|            0|  0.00%|        (row- or column-wise) order in memory.
   307|         0|            0|            0|  0.00%|
   308|         0|            0|            0|  0.00%|    Returns
   309|         0|            0|            0|  0.00%|    -------
   310|         0|            0|            0|  0.00%|    out : ndarray
   311|         0|            0|            0|  0.00%|        Array of `fill_value` with the given shape, dtype, and order.
   312|         0|            0|            0|  0.00%|
   313|         0|            0|            0|  0.00%|    See Also
   314|         0|            0|            0|  0.00%|    --------
   315|         0|            0|            0|  0.00%|    full_like : Return a new array with shape of input filled with value.
   316|         0|            0|            0|  0.00%|    empty : Return a new uninitialized array.
   317|         0|            0|            0|  0.00%|    ones : Return a new array setting values to one.
   318|         0|            0|            0|  0.00%|    zeros : Return a new array setting values to zero.
   319|         0|            0|            0|  0.00%|
   320|         0|            0|            0|  0.00%|    Examples
   321|         0|            0|            0|  0.00%|    --------
   322|         0|            0|            0|  0.00%|    >>> np.full((2, 2), np.inf)
   323|         0|            0|            0|  0.00%|    array([[inf, inf],
   324|         0|            0|            0|  0.00%|           [inf, inf]])
   325|         0|            0|            0|  0.00%|    >>> np.full((2, 2), 10)
   326|         0|            0|            0|  0.00%|    array([[10, 10],
   327|         0|            0|            0|  0.00%|           [10, 10]])
   328|         0|            0|            0|  0.00%|
   329|         0|            0|            0|  0.00%|    """
   330|         0|            0|            0|  0.00%|    if dtype is None:
   331|         0|            0|            0|  0.00%|        dtype = array(fill_value).dtype
   332|         0|            0|            0|  0.00%|    a = empty(shape, dtype, order)
   333|         0|            0|            0|  0.00%|    multiarray.copyto(a, fill_value, casting='unsafe')
   334|         0|            0|            0|  0.00%|    return a
   335|         0|            0|            0|  0.00%|
   336|         0|            0|            0|  0.00%|
   337|         0|            0|            0|  0.00%|def _full_like_dispatcher(a, fill_value, dtype=None, order=None, subok=None, shape=None):
   338|         0|            0|            0|  0.00%|    return (a,)
   339|         0|            0|            0|  0.00%|
   340|         0|            0|            0|  0.00%|
   341|         0|            0|            0|  0.00%|@array_function_dispatch(_full_like_dispatcher)
   342|         0|            0|            0|  0.00%|def full_like(a, fill_value, dtype=None, order='K', subok=True, shape=None):
   343|         0|            0|            0|  0.00%|    """
   344|         0|            0|            0|  0.00%|    Return a full array with the same shape and type as a given array.
   345|         0|            0|            0|  0.00%|
   346|         0|            0|            0|  0.00%|    Parameters
   347|         0|            0|            0|  0.00%|    ----------
   348|         0|            0|            0|  0.00%|    a : array_like
   349|         0|            0|            0|  0.00%|        The shape and data-type of `a` define these same attributes of
   350|         0|            0|            0|  0.00%|        the returned array.
   351|         0|            0|            0|  0.00%|    fill_value : scalar
   352|         0|            0|            0|  0.00%|        Fill value.
   353|         0|            0|            0|  0.00%|    dtype : data-type, optional
   354|         0|            0|            0|  0.00%|        Overrides the data type of the result.
   355|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A', or 'K'}, optional
   356|         0|            0|            0|  0.00%|        Overrides the memory layout of the result. 'C' means C-order,
   357|         0|            0|            0|  0.00%|        'F' means F-order, 'A' means 'F' if `a` is Fortran contiguous,
   358|         0|            0|            0|  0.00%|        'C' otherwise. 'K' means match the layout of `a` as closely
   359|         0|            0|            0|  0.00%|        as possible.
   360|         0|            0|            0|  0.00%|    subok : bool, optional.
   361|         0|            0|            0|  0.00%|        If True, then the newly created array will use the sub-class
   362|         0|            0|            0|  0.00%|        type of 'a', otherwise it will be a base-class array. Defaults
   363|         0|            0|            0|  0.00%|        to True.
   364|         0|            0|            0|  0.00%|    shape : int or sequence of ints, optional.
   365|         0|            0|            0|  0.00%|        Overrides the shape of the result. If order='K' and the number of
   366|         0|            0|            0|  0.00%|        dimensions is unchanged, will try to keep order, otherwise,
   367|         0|            0|            0|  0.00%|        order='C' is implied.
   368|         0|            0|            0|  0.00%|
   369|         0|            0|            0|  0.00%|        .. versionadded:: 1.17.0
   370|         0|            0|            0|  0.00%|
   371|         0|            0|            0|  0.00%|    Returns
   372|         0|            0|            0|  0.00%|    -------
   373|         0|            0|            0|  0.00%|    out : ndarray
   374|         0|            0|            0|  0.00%|        Array of `fill_value` with the same shape and type as `a`.
   375|         0|            0|            0|  0.00%|
   376|         0|            0|            0|  0.00%|    See Also
   377|         0|            0|            0|  0.00%|    --------
   378|         0|            0|            0|  0.00%|    empty_like : Return an empty array with shape and type of input.
   379|         0|            0|            0|  0.00%|    ones_like : Return an array of ones with shape and type of input.
   380|         0|            0|            0|  0.00%|    zeros_like : Return an array of zeros with shape and type of input.
   381|         0|            0|            0|  0.00%|    full : Return a new array of given shape filled with value.
   382|         0|            0|            0|  0.00%|
   383|         0|            0|            0|  0.00%|    Examples
   384|         0|            0|            0|  0.00%|    --------
   385|         0|            0|            0|  0.00%|    >>> x = np.arange(6, dtype=int)
   386|         0|            0|            0|  0.00%|    >>> np.full_like(x, 1)
   387|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1, 1])
   388|         0|            0|            0|  0.00%|    >>> np.full_like(x, 0.1)
   389|         0|            0|            0|  0.00%|    array([0, 0, 0, 0, 0, 0])
   390|         0|            0|            0|  0.00%|    >>> np.full_like(x, 0.1, dtype=np.double)
   391|         0|            0|            0|  0.00%|    array([0.1, 0.1, 0.1, 0.1, 0.1, 0.1])
   392|         0|            0|            0|  0.00%|    >>> np.full_like(x, np.nan, dtype=np.double)
   393|         0|            0|            0|  0.00%|    array([nan, nan, nan, nan, nan, nan])
   394|         0|            0|            0|  0.00%|
   395|         0|            0|            0|  0.00%|    >>> y = np.arange(6, dtype=np.double)
   396|         0|            0|            0|  0.00%|    >>> np.full_like(y, 0.1)
   397|         0|            0|            0|  0.00%|    array([0.1,  0.1,  0.1,  0.1,  0.1,  0.1])
   398|         0|            0|            0|  0.00%|
   399|         0|            0|            0|  0.00%|    """
   400|         0|            0|            0|  0.00%|    res = empty_like(a, dtype=dtype, order=order, subok=subok, shape=shape)
   401|         0|            0|            0|  0.00%|    multiarray.copyto(res, fill_value, casting='unsafe')
   402|         0|            0|            0|  0.00%|    return res
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|
   405|         0|            0|            0|  0.00%|def _count_nonzero_dispatcher(a, axis=None):
   406|         0|            0|            0|  0.00%|    return (a,)
   407|         0|            0|            0|  0.00%|
   408|         0|            0|            0|  0.00%|
   409|         0|            0|            0|  0.00%|@array_function_dispatch(_count_nonzero_dispatcher)
   410|         0|            0|            0|  0.00%|def count_nonzero(a, axis=None):
   411|         0|            0|            0|  0.00%|    """
   412|         0|            0|            0|  0.00%|    Counts the number of non-zero values in the array ``a``.
   413|         0|            0|            0|  0.00%|
   414|         0|            0|            0|  0.00%|    The word "non-zero" is in reference to the Python 2.x
   415|         0|            0|            0|  0.00%|    built-in method ``__nonzero__()`` (renamed ``__bool__()``
   416|         0|            0|            0|  0.00%|    in Python 3.x) of Python objects that tests an object's
   417|         0|            0|            0|  0.00%|    "truthfulness". For example, any number is considered
   418|         0|            0|            0|  0.00%|    truthful if it is nonzero, whereas any string is considered
   419|         0|            0|            0|  0.00%|    truthful if it is not the empty string. Thus, this function
   420|         0|            0|            0|  0.00%|    (recursively) counts how many elements in ``a`` (and in
   421|         0|            0|            0|  0.00%|    sub-arrays thereof) have their ``__nonzero__()`` or ``__bool__()``
   422|         0|            0|            0|  0.00%|    method evaluated to ``True``.
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    Parameters
   425|         0|            0|            0|  0.00%|    ----------
   426|         0|            0|            0|  0.00%|    a : array_like
   427|         0|            0|            0|  0.00%|        The array for which to count non-zeros.
   428|         0|            0|            0|  0.00%|    axis : int or tuple, optional
   429|         0|            0|            0|  0.00%|        Axis or tuple of axes along which to count non-zeros.
   430|         0|            0|            0|  0.00%|        Default is None, meaning that non-zeros will be counted
   431|         0|            0|            0|  0.00%|        along a flattened version of ``a``.
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|        .. versionadded:: 1.12.0
   434|         0|            0|            0|  0.00%|
   435|         0|            0|            0|  0.00%|    Returns
   436|         0|            0|            0|  0.00%|    -------
   437|         0|            0|            0|  0.00%|    count : int or array of int
   438|         0|            0|            0|  0.00%|        Number of non-zero values in the array along a given axis.
   439|         0|            0|            0|  0.00%|        Otherwise, the total number of non-zero values in the array
   440|         0|            0|            0|  0.00%|        is returned.
   441|         0|            0|            0|  0.00%|
   442|         0|            0|            0|  0.00%|    See Also
   443|         0|            0|            0|  0.00%|    --------
   444|         0|            0|            0|  0.00%|    nonzero : Return the coordinates of all the non-zero values.
   445|         0|            0|            0|  0.00%|
   446|         0|            0|            0|  0.00%|    Examples
   447|         0|            0|            0|  0.00%|    --------
   448|         0|            0|            0|  0.00%|    >>> np.count_nonzero(np.eye(4))
   449|         0|            0|            0|  0.00%|    4
   450|         0|            0|            0|  0.00%|    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]])
   451|         0|            0|            0|  0.00%|    5
   452|         0|            0|            0|  0.00%|    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=0)
   453|         0|            0|            0|  0.00%|    array([1, 1, 1, 1, 1])
   454|         0|            0|            0|  0.00%|    >>> np.count_nonzero([[0,1,7,0,0],[3,0,0,2,19]], axis=1)
   455|         0|            0|            0|  0.00%|    array([2, 3])
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|    """
   458|         0|            0|            0|  0.00%|    if axis is None:
   459|         0|            0|            0|  0.00%|        return multiarray.count_nonzero(a)
   460|         0|            0|            0|  0.00%|
   461|         0|            0|            0|  0.00%|    a = asanyarray(a)
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|    # TODO: this works around .astype(bool) not working properly (gh-9847)
   464|         0|            0|            0|  0.00%|    if np.issubdtype(a.dtype, np.character):
   465|         0|            0|            0|  0.00%|        a_bool = a != a.dtype.type()
   466|         0|            0|            0|  0.00%|    else:
   467|         0|            0|            0|  0.00%|        a_bool = a.astype(np.bool_, copy=False)
   468|         0|            0|            0|  0.00%|
   469|         0|            0|            0|  0.00%|    return a_bool.sum(axis=axis, dtype=np.intp)
   470|         0|            0|            0|  0.00%|
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|@set_module('numpy')
   473|         0|            0|            0|  0.00%|def isfortran(a):
   474|         0|            0|            0|  0.00%|    """
   475|         0|            0|            0|  0.00%|    Check if the array is Fortran contiguous but *not* C contiguous.
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    This function is obsolete and, because of changes due to relaxed stride
   478|         0|            0|            0|  0.00%|    checking, its return value for the same array may differ for versions
   479|         0|            0|            0|  0.00%|    of NumPy >= 1.10.0 and previous versions. If you only want to check if an
   480|         0|            0|            0|  0.00%|    array is Fortran contiguous use ``a.flags.f_contiguous`` instead.
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    Parameters
   483|         0|            0|            0|  0.00%|    ----------
   484|         0|            0|            0|  0.00%|    a : ndarray
   485|         0|            0|            0|  0.00%|        Input array.
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|    Returns
   488|         0|            0|            0|  0.00%|    -------
   489|         0|            0|            0|  0.00%|    isfortran : bool
   490|         0|            0|            0|  0.00%|        Returns True if the array is Fortran contiguous but *not* C contiguous.
   491|         0|            0|            0|  0.00%|
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    Examples
   494|         0|            0|            0|  0.00%|    --------
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    np.array allows to specify whether the array is written in C-contiguous
   497|         0|            0|            0|  0.00%|    order (last index varies the fastest), or FORTRAN-contiguous order in
   498|         0|            0|            0|  0.00%|    memory (first index varies the fastest).
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
   501|         0|            0|            0|  0.00%|    >>> a
   502|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   503|         0|            0|            0|  0.00%|           [4, 5, 6]])
   504|         0|            0|            0|  0.00%|    >>> np.isfortran(a)
   505|         0|            0|            0|  0.00%|    False
   506|         0|            0|            0|  0.00%|
   507|         0|            0|            0|  0.00%|    >>> b = np.array([[1, 2, 3], [4, 5, 6]], order='F')
   508|         0|            0|            0|  0.00%|    >>> b
   509|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   510|         0|            0|            0|  0.00%|           [4, 5, 6]])
   511|         0|            0|            0|  0.00%|    >>> np.isfortran(b)
   512|         0|            0|            0|  0.00%|    True
   513|         0|            0|            0|  0.00%|
   514|         0|            0|            0|  0.00%|
   515|         0|            0|            0|  0.00%|    The transpose of a C-ordered array is a FORTRAN-ordered array.
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2, 3], [4, 5, 6]], order='C')
   518|         0|            0|            0|  0.00%|    >>> a
   519|         0|            0|            0|  0.00%|    array([[1, 2, 3],
   520|         0|            0|            0|  0.00%|           [4, 5, 6]])
   521|         0|            0|            0|  0.00%|    >>> np.isfortran(a)
   522|         0|            0|            0|  0.00%|    False
   523|         0|            0|            0|  0.00%|    >>> b = a.T
   524|         0|            0|            0|  0.00%|    >>> b
   525|         0|            0|            0|  0.00%|    array([[1, 4],
   526|         0|            0|            0|  0.00%|           [2, 5],
   527|         0|            0|            0|  0.00%|           [3, 6]])
   528|         0|            0|            0|  0.00%|    >>> np.isfortran(b)
   529|         0|            0|            0|  0.00%|    True
   530|         0|            0|            0|  0.00%|
   531|         0|            0|            0|  0.00%|    C-ordered arrays evaluate as False even if they are also FORTRAN-ordered.
   532|         0|            0|            0|  0.00%|
   533|         0|            0|            0|  0.00%|    >>> np.isfortran(np.array([1, 2], order='FORTRAN'))
   534|         0|            0|            0|  0.00%|    False
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|    """
   537|         0|            0|            0|  0.00%|    return a.flags.fnc
   538|         0|            0|            0|  0.00%|
   539|         0|            0|            0|  0.00%|
   540|         0|            0|            0|  0.00%|def _argwhere_dispatcher(a):
   541|         0|            0|            0|  0.00%|    return (a,)
   542|         0|            0|            0|  0.00%|
   543|         0|            0|            0|  0.00%|
   544|         0|            0|            0|  0.00%|@array_function_dispatch(_argwhere_dispatcher)
   545|         0|            0|            0|  0.00%|def argwhere(a):
   546|         0|            0|            0|  0.00%|    """
   547|         0|            0|            0|  0.00%|    Find the indices of array elements that are non-zero, grouped by element.
   548|         0|            0|            0|  0.00%|
   549|         0|            0|            0|  0.00%|    Parameters
   550|         0|            0|            0|  0.00%|    ----------
   551|         0|            0|            0|  0.00%|    a : array_like
   552|         0|            0|            0|  0.00%|        Input data.
   553|         0|            0|            0|  0.00%|
   554|         0|            0|            0|  0.00%|    Returns
   555|         0|            0|            0|  0.00%|    -------
   556|         0|            0|            0|  0.00%|    index_array : ndarray
   557|         0|            0|            0|  0.00%|        Indices of elements that are non-zero. Indices are grouped by element.
   558|         0|            0|            0|  0.00%|
   559|         0|            0|            0|  0.00%|    See Also
   560|         0|            0|            0|  0.00%|    --------
   561|         0|            0|            0|  0.00%|    where, nonzero
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|    Notes
   564|         0|            0|            0|  0.00%|    -----
   565|         0|            0|            0|  0.00%|    ``np.argwhere(a)`` is the same as ``np.transpose(np.nonzero(a))``.
   566|         0|            0|            0|  0.00%|
   567|         0|            0|            0|  0.00%|    The output of ``argwhere`` is not suitable for indexing arrays.
   568|         0|            0|            0|  0.00%|    For this purpose use ``nonzero(a)`` instead.
   569|         0|            0|            0|  0.00%|
   570|         0|            0|            0|  0.00%|    Examples
   571|         0|            0|            0|  0.00%|    --------
   572|         0|            0|            0|  0.00%|    >>> x = np.arange(6).reshape(2,3)
   573|         0|            0|            0|  0.00%|    >>> x
   574|         0|            0|            0|  0.00%|    array([[0, 1, 2],
   575|         0|            0|            0|  0.00%|           [3, 4, 5]])
   576|         0|            0|            0|  0.00%|    >>> np.argwhere(x>1)
   577|         0|            0|            0|  0.00%|    array([[0, 2],
   578|         0|            0|            0|  0.00%|           [1, 0],
   579|         0|            0|            0|  0.00%|           [1, 1],
   580|         0|            0|            0|  0.00%|           [1, 2]])
   581|         0|            0|            0|  0.00%|
   582|         0|            0|            0|  0.00%|    """
   583|         0|            0|            0|  0.00%|    return transpose(nonzero(a))
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|
   586|         0|            0|            0|  0.00%|def _flatnonzero_dispatcher(a):
   587|         0|            0|            0|  0.00%|    return (a,)
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|
   590|         0|            0|            0|  0.00%|@array_function_dispatch(_flatnonzero_dispatcher)
   591|         0|            0|            0|  0.00%|def flatnonzero(a):
   592|         0|            0|            0|  0.00%|    """
   593|         0|            0|            0|  0.00%|    Return indices that are non-zero in the flattened version of a.
   594|         0|            0|            0|  0.00%|
   595|         0|            0|            0|  0.00%|    This is equivalent to np.nonzero(np.ravel(a))[0].
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    Parameters
   598|         0|            0|            0|  0.00%|    ----------
   599|         0|            0|            0|  0.00%|    a : array_like
   600|         0|            0|            0|  0.00%|        Input data.
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|    Returns
   603|         0|            0|            0|  0.00%|    -------
   604|         0|            0|            0|  0.00%|    res : ndarray
   605|         0|            0|            0|  0.00%|        Output array, containing the indices of the elements of `a.ravel()`
   606|         0|            0|            0|  0.00%|        that are non-zero.
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    See Also
   609|         0|            0|            0|  0.00%|    --------
   610|         0|            0|            0|  0.00%|    nonzero : Return the indices of the non-zero elements of the input array.
   611|         0|            0|            0|  0.00%|    ravel : Return a 1-D array containing the elements of the input array.
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|    Examples
   614|         0|            0|            0|  0.00%|    --------
   615|         0|            0|            0|  0.00%|    >>> x = np.arange(-2, 3)
   616|         0|            0|            0|  0.00%|    >>> x
   617|         0|            0|            0|  0.00%|    array([-2, -1,  0,  1,  2])
   618|         0|            0|            0|  0.00%|    >>> np.flatnonzero(x)
   619|         0|            0|            0|  0.00%|    array([0, 1, 3, 4])
   620|         0|            0|            0|  0.00%|
   621|         0|            0|            0|  0.00%|    Use the indices of the non-zero elements as an index array to extract
   622|         0|            0|            0|  0.00%|    these elements:
   623|         0|            0|            0|  0.00%|
   624|         0|            0|            0|  0.00%|    >>> x.ravel()[np.flatnonzero(x)]
   625|         0|            0|            0|  0.00%|    array([-2, -1,  1,  2])
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    """
   628|         0|            0|            0|  0.00%|    return np.nonzero(np.ravel(a))[0]
   629|         0|            0|            0|  0.00%|
   630|         0|            0|            0|  0.00%|
   631|         0|            0|            0|  0.00%|_mode_from_name_dict = {'v': 0,
   632|         0|            0|            0|  0.00%|                        's': 1,
   633|         0|            0|            0|  0.00%|                        'f': 2}
   634|         0|            0|            0|  0.00%|
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|def _mode_from_name(mode):
   637|         0|            0|            0|  0.00%|    if isinstance(mode, basestring):
   638|         0|            0|            0|  0.00%|        return _mode_from_name_dict[mode.lower()[0]]
   639|         0|            0|            0|  0.00%|    return mode
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|def _correlate_dispatcher(a, v, mode=None):
   643|         0|            0|            0|  0.00%|    return (a, v)
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|
   646|         0|            0|            0|  0.00%|@array_function_dispatch(_correlate_dispatcher)
   647|         0|            0|            0|  0.00%|def correlate(a, v, mode='valid'):
   648|         0|            0|            0|  0.00%|    """
   649|         0|            0|            0|  0.00%|    Cross-correlation of two 1-dimensional sequences.
   650|         0|            0|            0|  0.00%|
   651|         0|            0|            0|  0.00%|    This function computes the correlation as generally defined in signal
   652|         0|            0|            0|  0.00%|    processing texts::
   653|         0|            0|            0|  0.00%|
   654|         0|            0|            0|  0.00%|        c_{av}[k] = sum_n a[n+k] * conj(v[n])
   655|         0|            0|            0|  0.00%|
   656|         0|            0|            0|  0.00%|    with a and v sequences being zero-padded where necessary and conj being
   657|         0|            0|            0|  0.00%|    the conjugate.
   658|         0|            0|            0|  0.00%|
   659|         0|            0|            0|  0.00%|    Parameters
   660|         0|            0|            0|  0.00%|    ----------
   661|         0|            0|            0|  0.00%|    a, v : array_like
   662|         0|            0|            0|  0.00%|        Input sequences.
   663|         0|            0|            0|  0.00%|    mode : {'valid', 'same', 'full'}, optional
   664|         0|            0|            0|  0.00%|        Refer to the `convolve` docstring.  Note that the default
   665|         0|            0|            0|  0.00%|        is 'valid', unlike `convolve`, which uses 'full'.
   666|         0|            0|            0|  0.00%|    old_behavior : bool
   667|         0|            0|            0|  0.00%|        `old_behavior` was removed in NumPy 1.10. If you need the old
   668|         0|            0|            0|  0.00%|        behavior, use `multiarray.correlate`.
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|    Returns
   671|         0|            0|            0|  0.00%|    -------
   672|         0|            0|            0|  0.00%|    out : ndarray
   673|         0|            0|            0|  0.00%|        Discrete cross-correlation of `a` and `v`.
   674|         0|            0|            0|  0.00%|
   675|         0|            0|            0|  0.00%|    See Also
   676|         0|            0|            0|  0.00%|    --------
   677|         0|            0|            0|  0.00%|    convolve : Discrete, linear convolution of two one-dimensional sequences.
   678|         0|            0|            0|  0.00%|    multiarray.correlate : Old, no conjugate, version of correlate.
   679|         0|            0|            0|  0.00%|
   680|         0|            0|            0|  0.00%|    Notes
   681|         0|            0|            0|  0.00%|    -----
   682|         0|            0|            0|  0.00%|    The definition of correlation above is not unique and sometimes correlation
   683|         0|            0|            0|  0.00%|    may be defined differently. Another common definition is::
   684|         0|            0|            0|  0.00%|
   685|         0|            0|            0|  0.00%|        c'_{av}[k] = sum_n a[n] conj(v[n+k])
   686|         0|            0|            0|  0.00%|
   687|         0|            0|            0|  0.00%|    which is related to ``c_{av}[k]`` by ``c'_{av}[k] = c_{av}[-k]``.
   688|         0|            0|            0|  0.00%|
   689|         0|            0|            0|  0.00%|    Examples
   690|         0|            0|            0|  0.00%|    --------
   691|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5])
   692|         0|            0|            0|  0.00%|    array([3.5])
   693|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5], "same")
   694|         0|            0|            0|  0.00%|    array([2. ,  3.5,  3. ])
   695|         0|            0|            0|  0.00%|    >>> np.correlate([1, 2, 3], [0, 1, 0.5], "full")
   696|         0|            0|            0|  0.00%|    array([0.5,  2. ,  3.5,  3. ,  0. ])
   697|         0|            0|            0|  0.00%|
   698|         0|            0|            0|  0.00%|    Using complex sequences:
   699|         0|            0|            0|  0.00%|
   700|         0|            0|            0|  0.00%|    >>> np.correlate([1+1j, 2, 3-1j], [0, 1, 0.5j], 'full')
   701|         0|            0|            0|  0.00%|    array([ 0.5-0.5j,  1.0+0.j ,  1.5-1.5j,  3.0-1.j ,  0.0+0.j ])
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    Note that you get the time reversed, complex conjugated result
   704|         0|            0|            0|  0.00%|    when the two input sequences change places, i.e.,
   705|         0|            0|            0|  0.00%|    ``c_{va}[k] = c^{*}_{av}[-k]``:
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    >>> np.correlate([0, 1, 0.5j], [1+1j, 2, 3-1j], 'full')
   708|         0|            0|            0|  0.00%|    array([ 0.0+0.j ,  3.0+1.j ,  1.5+1.5j,  1.0+0.j ,  0.5+0.5j])
   709|         0|            0|            0|  0.00%|
   710|         0|            0|            0|  0.00%|    """
   711|         0|            0|            0|  0.00%|    mode = _mode_from_name(mode)
   712|         0|            0|            0|  0.00%|    return multiarray.correlate2(a, v, mode)
   713|         0|            0|            0|  0.00%|
   714|         0|            0|            0|  0.00%|
   715|         0|            0|            0|  0.00%|def _convolve_dispatcher(a, v, mode=None):
   716|         0|            0|            0|  0.00%|    return (a, v)
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|@array_function_dispatch(_convolve_dispatcher)
   720|         0|            0|            0|  0.00%|def convolve(a, v, mode='full'):
   721|         0|            0|            0|  0.00%|    """
   722|         0|            0|            0|  0.00%|    Returns the discrete, linear convolution of two one-dimensional sequences.
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|    The convolution operator is often seen in signal processing, where it
   725|         0|            0|            0|  0.00%|    models the effect of a linear time-invariant system on a signal [1]_.  In
   726|         0|            0|            0|  0.00%|    probability theory, the sum of two independent random variables is
   727|         0|            0|            0|  0.00%|    distributed according to the convolution of their individual
   728|         0|            0|            0|  0.00%|    distributions.
   729|         0|            0|            0|  0.00%|
   730|         0|            0|            0|  0.00%|    If `v` is longer than `a`, the arrays are swapped before computation.
   731|         0|            0|            0|  0.00%|
   732|         0|            0|            0|  0.00%|    Parameters
   733|         0|            0|            0|  0.00%|    ----------
   734|         0|            0|            0|  0.00%|    a : (N,) array_like
   735|         0|            0|            0|  0.00%|        First one-dimensional input array.
   736|         0|            0|            0|  0.00%|    v : (M,) array_like
   737|         0|            0|            0|  0.00%|        Second one-dimensional input array.
   738|         0|            0|            0|  0.00%|    mode : {'full', 'valid', 'same'}, optional
   739|         0|            0|            0|  0.00%|        'full':
   740|         0|            0|            0|  0.00%|          By default, mode is 'full'.  This returns the convolution
   741|         0|            0|            0|  0.00%|          at each point of overlap, with an output shape of (N+M-1,). At
   742|         0|            0|            0|  0.00%|          the end-points of the convolution, the signals do not overlap
   743|         0|            0|            0|  0.00%|          completely, and boundary effects may be seen.
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|        'same':
   746|         0|            0|            0|  0.00%|          Mode 'same' returns output of length ``max(M, N)``.  Boundary
   747|         0|            0|            0|  0.00%|          effects are still visible.
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|        'valid':
   750|         0|            0|            0|  0.00%|          Mode 'valid' returns output of length
   751|         0|            0|            0|  0.00%|          ``max(M, N) - min(M, N) + 1``.  The convolution product is only given
   752|         0|            0|            0|  0.00%|          for points where the signals overlap completely.  Values outside
   753|         0|            0|            0|  0.00%|          the signal boundary have no effect.
   754|         0|            0|            0|  0.00%|
   755|         0|            0|            0|  0.00%|    Returns
   756|         0|            0|            0|  0.00%|    -------
   757|         0|            0|            0|  0.00%|    out : ndarray
   758|         0|            0|            0|  0.00%|        Discrete, linear convolution of `a` and `v`.
   759|         0|            0|            0|  0.00%|
   760|         0|            0|            0|  0.00%|    See Also
   761|         0|            0|            0|  0.00%|    --------
   762|         0|            0|            0|  0.00%|    scipy.signal.fftconvolve : Convolve two arrays using the Fast Fourier
   763|         0|            0|            0|  0.00%|                               Transform.
   764|         0|            0|            0|  0.00%|    scipy.linalg.toeplitz : Used to construct the convolution operator.
   765|         0|            0|            0|  0.00%|    polymul : Polynomial multiplication. Same output as convolve, but also
   766|         0|            0|            0|  0.00%|              accepts poly1d objects as input.
   767|         0|            0|            0|  0.00%|
   768|         0|            0|            0|  0.00%|    Notes
   769|         0|            0|            0|  0.00%|    -----
   770|         0|            0|            0|  0.00%|    The discrete convolution operation is defined as
   771|         0|            0|            0|  0.00%|
   772|         0|            0|            0|  0.00%|    .. math:: (a * v)[n] = \\sum_{m = -\\infty}^{\\infty} a[m] v[n - m]
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    It can be shown that a convolution :math:`x(t) * y(t)` in time/space
   775|         0|            0|            0|  0.00%|    is equivalent to the multiplication :math:`X(f) Y(f)` in the Fourier
   776|         0|            0|            0|  0.00%|    domain, after appropriate padding (padding is necessary to prevent
   777|         0|            0|            0|  0.00%|    circular convolution).  Since multiplication is more efficient (faster)
   778|         0|            0|            0|  0.00%|    than convolution, the function `scipy.signal.fftconvolve` exploits the
   779|         0|            0|            0|  0.00%|    FFT to calculate the convolution of large data-sets.
   780|         0|            0|            0|  0.00%|
   781|         0|            0|            0|  0.00%|    References
   782|         0|            0|            0|  0.00%|    ----------
   783|         0|            0|            0|  0.00%|    .. [1] Wikipedia, "Convolution",
   784|         0|            0|            0|  0.00%|        https://en.wikipedia.org/wiki/Convolution
   785|         0|            0|            0|  0.00%|
   786|         0|            0|            0|  0.00%|    Examples
   787|         0|            0|            0|  0.00%|    --------
   788|         0|            0|            0|  0.00%|    Note how the convolution operator flips the second array
   789|         0|            0|            0|  0.00%|    before "sliding" the two across one another:
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|    >>> np.convolve([1, 2, 3], [0, 1, 0.5])
   792|         0|            0|            0|  0.00%|    array([0. , 1. , 2.5, 4. , 1.5])
   793|         0|            0|            0|  0.00%|
   794|         0|            0|            0|  0.00%|    Only return the middle values of the convolution.
   795|         0|            0|            0|  0.00%|    Contains boundary effects, where zeros are taken
   796|         0|            0|            0|  0.00%|    into account:
   797|         0|            0|            0|  0.00%|
   798|         0|            0|            0|  0.00%|    >>> np.convolve([1,2,3],[0,1,0.5], 'same')
   799|         0|            0|            0|  0.00%|    array([1. ,  2.5,  4. ])
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    The two arrays are of the same length, so there
   802|         0|            0|            0|  0.00%|    is only one position where they completely overlap:
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|    >>> np.convolve([1,2,3],[0,1,0.5], 'valid')
   805|         0|            0|            0|  0.00%|    array([2.5])
   806|         0|            0|            0|  0.00%|
   807|         0|            0|            0|  0.00%|    """
   808|         0|            0|            0|  0.00%|    a, v = array(a, copy=False, ndmin=1), array(v, copy=False, ndmin=1)
   809|         0|            0|            0|  0.00%|    if (len(v) > len(a)):
   810|         0|            0|            0|  0.00%|        a, v = v, a
   811|         0|            0|            0|  0.00%|    if len(a) == 0:
   812|         0|            0|            0|  0.00%|        raise ValueError('a cannot be empty')
   813|         0|            0|            0|  0.00%|    if len(v) == 0:
   814|         0|            0|            0|  0.00%|        raise ValueError('v cannot be empty')
   815|         0|            0|            0|  0.00%|    mode = _mode_from_name(mode)
   816|         0|            0|            0|  0.00%|    return multiarray.correlate(a, v[::-1], mode)
   817|         0|            0|            0|  0.00%|
   818|         0|            0|            0|  0.00%|
   819|         0|            0|            0|  0.00%|def _outer_dispatcher(a, b, out=None):
   820|         0|            0|            0|  0.00%|    return (a, b, out)
   821|         0|            0|            0|  0.00%|
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|@array_function_dispatch(_outer_dispatcher)
   824|         0|            0|            0|  0.00%|def outer(a, b, out=None):
   825|         0|            0|            0|  0.00%|    """
   826|         0|            0|            0|  0.00%|    Compute the outer product of two vectors.
   827|         0|            0|            0|  0.00%|
   828|         0|            0|            0|  0.00%|    Given two vectors, ``a = [a0, a1, ..., aM]`` and
   829|         0|            0|            0|  0.00%|    ``b = [b0, b1, ..., bN]``,
   830|         0|            0|            0|  0.00%|    the outer product [1]_ is::
   831|         0|            0|            0|  0.00%|
   832|         0|            0|            0|  0.00%|      [[a0*b0  a0*b1 ... a0*bN ]
   833|         0|            0|            0|  0.00%|       [a1*b0    .
   834|         0|            0|            0|  0.00%|       [ ...          .
   835|         0|            0|            0|  0.00%|       [aM*b0            aM*bN ]]
   836|         0|            0|            0|  0.00%|
   837|         0|            0|            0|  0.00%|    Parameters
   838|         0|            0|            0|  0.00%|    ----------
   839|         0|            0|            0|  0.00%|    a : (M,) array_like
   840|         0|            0|            0|  0.00%|        First input vector.  Input is flattened if
   841|         0|            0|            0|  0.00%|        not already 1-dimensional.
   842|         0|            0|            0|  0.00%|    b : (N,) array_like
   843|         0|            0|            0|  0.00%|        Second input vector.  Input is flattened if
   844|         0|            0|            0|  0.00%|        not already 1-dimensional.
   845|         0|            0|            0|  0.00%|    out : (M, N) ndarray, optional
   846|         0|            0|            0|  0.00%|        A location where the result is stored
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
   849|         0|            0|            0|  0.00%|
   850|         0|            0|            0|  0.00%|    Returns
   851|         0|            0|            0|  0.00%|    -------
   852|         0|            0|            0|  0.00%|    out : (M, N) ndarray
   853|         0|            0|            0|  0.00%|        ``out[i, j] = a[i] * b[j]``
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|    See also
   856|         0|            0|            0|  0.00%|    --------
   857|         0|            0|            0|  0.00%|    inner
   858|         0|            0|            0|  0.00%|    einsum : ``einsum('i,j->ij', a.ravel(), b.ravel())`` is the equivalent.
   859|         0|            0|            0|  0.00%|    ufunc.outer : A generalization to N dimensions and other operations.
   860|         0|            0|            0|  0.00%|                  ``np.multiply.outer(a.ravel(), b.ravel())`` is the equivalent.
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|    References
   863|         0|            0|            0|  0.00%|    ----------
   864|         0|            0|            0|  0.00%|    .. [1] : G. H. Golub and C. F. Van Loan, *Matrix Computations*, 3rd
   865|         0|            0|            0|  0.00%|             ed., Baltimore, MD, Johns Hopkins University Press, 1996,
   866|         0|            0|            0|  0.00%|             pg. 8.
   867|         0|            0|            0|  0.00%|
   868|         0|            0|            0|  0.00%|    Examples
   869|         0|            0|            0|  0.00%|    --------
   870|         0|            0|            0|  0.00%|    Make a (*very* coarse) grid for computing a Mandelbrot set:
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|    >>> rl = np.outer(np.ones((5,)), np.linspace(-2, 2, 5))
   873|         0|            0|            0|  0.00%|    >>> rl
   874|         0|            0|            0|  0.00%|    array([[-2., -1.,  0.,  1.,  2.],
   875|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   876|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   877|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.],
   878|         0|            0|            0|  0.00%|           [-2., -1.,  0.,  1.,  2.]])
   879|         0|            0|            0|  0.00%|    >>> im = np.outer(1j*np.linspace(2, -2, 5), np.ones((5,)))
   880|         0|            0|            0|  0.00%|    >>> im
   881|         0|            0|            0|  0.00%|    array([[0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j, 0.+2.j],
   882|         0|            0|            0|  0.00%|           [0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j, 0.+1.j],
   883|         0|            0|            0|  0.00%|           [0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j],
   884|         0|            0|            0|  0.00%|           [0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j, 0.-1.j],
   885|         0|            0|            0|  0.00%|           [0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j, 0.-2.j]])
   886|         0|            0|            0|  0.00%|    >>> grid = rl + im
   887|         0|            0|            0|  0.00%|    >>> grid
   888|         0|            0|            0|  0.00%|    array([[-2.+2.j, -1.+2.j,  0.+2.j,  1.+2.j,  2.+2.j],
   889|         0|            0|            0|  0.00%|           [-2.+1.j, -1.+1.j,  0.+1.j,  1.+1.j,  2.+1.j],
   890|         0|            0|            0|  0.00%|           [-2.+0.j, -1.+0.j,  0.+0.j,  1.+0.j,  2.+0.j],
   891|         0|            0|            0|  0.00%|           [-2.-1.j, -1.-1.j,  0.-1.j,  1.-1.j,  2.-1.j],
   892|         0|            0|            0|  0.00%|           [-2.-2.j, -1.-2.j,  0.-2.j,  1.-2.j,  2.-2.j]])
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    An example using a "vector" of letters:
   895|         0|            0|            0|  0.00%|
   896|         0|            0|            0|  0.00%|    >>> x = np.array(['a', 'b', 'c'], dtype=object)
   897|         0|            0|            0|  0.00%|    >>> np.outer(x, [1, 2, 3])
   898|         0|            0|            0|  0.00%|    array([['a', 'aa', 'aaa'],
   899|         0|            0|            0|  0.00%|           ['b', 'bb', 'bbb'],
   900|         0|            0|            0|  0.00%|           ['c', 'cc', 'ccc']], dtype=object)
   901|         0|            0|            0|  0.00%|
   902|         0|            0|            0|  0.00%|    """
   903|         0|            0|            0|  0.00%|    a = asarray(a)
   904|         0|            0|            0|  0.00%|    b = asarray(b)
   905|         0|            0|            0|  0.00%|    return multiply(a.ravel()[:, newaxis], b.ravel()[newaxis, :], out)
   906|         0|            0|            0|  0.00%|
   907|         0|            0|            0|  0.00%|
   908|         0|            0|            0|  0.00%|def _tensordot_dispatcher(a, b, axes=None):
   909|         0|            0|            0|  0.00%|    return (a, b)
   910|         0|            0|            0|  0.00%|
   911|         0|            0|            0|  0.00%|
   912|         0|            0|            0|  0.00%|@array_function_dispatch(_tensordot_dispatcher)
   913|         0|            0|            0|  0.00%|def tensordot(a, b, axes=2):
   914|         0|            0|            0|  0.00%|    """
   915|         0|            0|            0|  0.00%|    Compute tensor dot product along specified axes.
   916|         0|            0|            0|  0.00%|
   917|         0|            0|            0|  0.00%|    Given two tensors, `a` and `b`, and an array_like object containing
   918|         0|            0|            0|  0.00%|    two array_like objects, ``(a_axes, b_axes)``, sum the products of
   919|         0|            0|            0|  0.00%|    `a`'s and `b`'s elements (components) over the axes specified by
   920|         0|            0|            0|  0.00%|    ``a_axes`` and ``b_axes``. The third argument can be a single non-negative
   921|         0|            0|            0|  0.00%|    integer_like scalar, ``N``; if it is such, then the last ``N`` dimensions
   922|         0|            0|            0|  0.00%|    of `a` and the first ``N`` dimensions of `b` are summed over.
   923|         0|            0|            0|  0.00%|
   924|         0|            0|            0|  0.00%|    Parameters
   925|         0|            0|            0|  0.00%|    ----------
   926|         0|            0|            0|  0.00%|    a, b : array_like
   927|         0|            0|            0|  0.00%|        Tensors to "dot".
   928|         0|            0|            0|  0.00%|
   929|         0|            0|            0|  0.00%|    axes : int or (2,) array_like
   930|         0|            0|            0|  0.00%|        * integer_like
   931|         0|            0|            0|  0.00%|          If an int N, sum over the last N axes of `a` and the first N axes
   932|         0|            0|            0|  0.00%|          of `b` in order. The sizes of the corresponding axes must match.
   933|         0|            0|            0|  0.00%|        * (2,) array_like
   934|         0|            0|            0|  0.00%|          Or, a list of axes to be summed over, first sequence applying to `a`,
   935|         0|            0|            0|  0.00%|          second to `b`. Both elements array_like must be of the same length.
   936|         0|            0|            0|  0.00%|
   937|         0|            0|            0|  0.00%|    Returns
   938|         0|            0|            0|  0.00%|    -------
   939|         0|            0|            0|  0.00%|    output : ndarray
   940|         0|            0|            0|  0.00%|        The tensor dot product of the input.
   941|         0|            0|            0|  0.00%|
   942|         0|            0|            0|  0.00%|    See Also
   943|         0|            0|            0|  0.00%|    --------
   944|         0|            0|            0|  0.00%|    dot, einsum
   945|         0|            0|            0|  0.00%|
   946|         0|            0|            0|  0.00%|    Notes
   947|         0|            0|            0|  0.00%|    -----
   948|         0|            0|            0|  0.00%|    Three common use cases are:
   949|         0|            0|            0|  0.00%|        * ``axes = 0`` : tensor product :math:`a\\otimes b`
   950|         0|            0|            0|  0.00%|        * ``axes = 1`` : tensor dot product :math:`a\\cdot b`
   951|         0|            0|            0|  0.00%|        * ``axes = 2`` : (default) tensor double contraction :math:`a:b`
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|    When `axes` is integer_like, the sequence for evaluation will be: first
   954|         0|            0|            0|  0.00%|    the -Nth axis in `a` and 0th axis in `b`, and the -1th axis in `a` and
   955|         0|            0|            0|  0.00%|    Nth axis in `b` last.
   956|         0|            0|            0|  0.00%|
   957|         0|            0|            0|  0.00%|    When there is more than one axis to sum over - and they are not the last
   958|         0|            0|            0|  0.00%|    (first) axes of `a` (`b`) - the argument `axes` should consist of
   959|         0|            0|            0|  0.00%|    two sequences of the same length, with the first axis to sum over given
   960|         0|            0|            0|  0.00%|    first in both sequences, the second axis second, and so forth.
   961|         0|            0|            0|  0.00%|
   962|         0|            0|            0|  0.00%|    Examples
   963|         0|            0|            0|  0.00%|    --------
   964|         0|            0|            0|  0.00%|    A "traditional" example:
   965|         0|            0|            0|  0.00%|
   966|         0|            0|            0|  0.00%|    >>> a = np.arange(60.).reshape(3,4,5)
   967|         0|            0|            0|  0.00%|    >>> b = np.arange(24.).reshape(4,3,2)
   968|         0|            0|            0|  0.00%|    >>> c = np.tensordot(a,b, axes=([1,0],[0,1]))
   969|         0|            0|            0|  0.00%|    >>> c.shape
   970|         0|            0|            0|  0.00%|    (5, 2)
   971|         0|            0|            0|  0.00%|    >>> c
   972|         0|            0|            0|  0.00%|    array([[4400., 4730.],
   973|         0|            0|            0|  0.00%|           [4532., 4874.],
   974|         0|            0|            0|  0.00%|           [4664., 5018.],
   975|         0|            0|            0|  0.00%|           [4796., 5162.],
   976|         0|            0|            0|  0.00%|           [4928., 5306.]])
   977|         0|            0|            0|  0.00%|    >>> # A slower but equivalent way of computing the same...
   978|         0|            0|            0|  0.00%|    >>> d = np.zeros((5,2))
   979|         0|            0|            0|  0.00%|    >>> for i in range(5):
   980|         0|            0|            0|  0.00%|    ...   for j in range(2):
   981|         0|            0|            0|  0.00%|    ...     for k in range(3):
   982|         0|            0|            0|  0.00%|    ...       for n in range(4):
   983|         0|            0|            0|  0.00%|    ...         d[i,j] += a[k,n,i] * b[n,k,j]
   984|         0|            0|            0|  0.00%|    >>> c == d
   985|         0|            0|            0|  0.00%|    array([[ True,  True],
   986|         0|            0|            0|  0.00%|           [ True,  True],
   987|         0|            0|            0|  0.00%|           [ True,  True],
   988|         0|            0|            0|  0.00%|           [ True,  True],
   989|         0|            0|            0|  0.00%|           [ True,  True]])
   990|         0|            0|            0|  0.00%|
   991|         0|            0|            0|  0.00%|    An extended example taking advantage of the overloading of + and \\*:
   992|         0|            0|            0|  0.00%|
   993|         0|            0|            0|  0.00%|    >>> a = np.array(range(1, 9))
   994|         0|            0|            0|  0.00%|    >>> a.shape = (2, 2, 2)
   995|         0|            0|            0|  0.00%|    >>> A = np.array(('a', 'b', 'c', 'd'), dtype=object)
   996|         0|            0|            0|  0.00%|    >>> A.shape = (2, 2)
   997|         0|            0|            0|  0.00%|    >>> a; A
   998|         0|            0|            0|  0.00%|    array([[[1, 2],
   999|         0|            0|            0|  0.00%|            [3, 4]],
  1000|         0|            0|            0|  0.00%|           [[5, 6],
  1001|         0|            0|            0|  0.00%|            [7, 8]]])
  1002|         0|            0|            0|  0.00%|    array([['a', 'b'],
  1003|         0|            0|            0|  0.00%|           ['c', 'd']], dtype=object)
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A) # third argument default is 2 for double-contraction
  1006|         0|            0|            0|  0.00%|    array(['abbcccdddd', 'aaaaabbbbbbcccccccdddddddd'], dtype=object)
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, 1)
  1009|         0|            0|            0|  0.00%|    array([[['acc', 'bdd'],
  1010|         0|            0|            0|  0.00%|            ['aaacccc', 'bbbdddd']],
  1011|         0|            0|            0|  0.00%|           [['aaaaacccccc', 'bbbbbdddddd'],
  1012|         0|            0|            0|  0.00%|            ['aaaaaaacccccccc', 'bbbbbbbdddddddd']]], dtype=object)
  1013|         0|            0|            0|  0.00%|
  1014|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, 0) # tensor product (result too long to incl.)
  1015|         0|            0|            0|  0.00%|    array([[[[['a', 'b'],
  1016|         0|            0|            0|  0.00%|              ['c', 'd']],
  1017|         0|            0|            0|  0.00%|              ...
  1018|         0|            0|            0|  0.00%|
  1019|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, (0, 1))
  1020|         0|            0|            0|  0.00%|    array([[['abbbbb', 'cddddd'],
  1021|         0|            0|            0|  0.00%|            ['aabbbbbb', 'ccdddddd']],
  1022|         0|            0|            0|  0.00%|           [['aaabbbbbbb', 'cccddddddd'],
  1023|         0|            0|            0|  0.00%|            ['aaaabbbbbbbb', 'ccccdddddddd']]], dtype=object)
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, (2, 1))
  1026|         0|            0|            0|  0.00%|    array([[['abb', 'cdd'],
  1027|         0|            0|            0|  0.00%|            ['aaabbbb', 'cccdddd']],
  1028|         0|            0|            0|  0.00%|           [['aaaaabbbbbb', 'cccccdddddd'],
  1029|         0|            0|            0|  0.00%|            ['aaaaaaabbbbbbbb', 'cccccccdddddddd']]], dtype=object)
  1030|         0|            0|            0|  0.00%|
  1031|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, ((0, 1), (0, 1)))
  1032|         0|            0|            0|  0.00%|    array(['abbbcccccddddddd', 'aabbbbccccccdddddddd'], dtype=object)
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|    >>> np.tensordot(a, A, ((2, 1), (1, 0)))
  1035|         0|            0|            0|  0.00%|    array(['acccbbdddd', 'aaaaacccccccbbbbbbdddddddd'], dtype=object)
  1036|         0|            0|            0|  0.00%|
  1037|         0|            0|            0|  0.00%|    """
  1038|         0|            0|            0|  0.00%|    try:
  1039|         0|            0|            0|  0.00%|        iter(axes)
  1040|         0|            0|            0|  0.00%|    except Exception:
  1041|         0|            0|            0|  0.00%|        axes_a = list(range(-axes, 0))
  1042|         0|            0|            0|  0.00%|        axes_b = list(range(0, axes))
  1043|         0|            0|            0|  0.00%|    else:
  1044|         0|            0|            0|  0.00%|        axes_a, axes_b = axes
  1045|         0|            0|            0|  0.00%|    try:
  1046|         0|            0|            0|  0.00%|        na = len(axes_a)
  1047|         0|            0|            0|  0.00%|        axes_a = list(axes_a)
  1048|         0|            0|            0|  0.00%|    except TypeError:
  1049|         0|            0|            0|  0.00%|        axes_a = [axes_a]
  1050|         0|            0|            0|  0.00%|        na = 1
  1051|         0|            0|            0|  0.00%|    try:
  1052|         0|            0|            0|  0.00%|        nb = len(axes_b)
  1053|         0|            0|            0|  0.00%|        axes_b = list(axes_b)
  1054|         0|            0|            0|  0.00%|    except TypeError:
  1055|         0|            0|            0|  0.00%|        axes_b = [axes_b]
  1056|         0|            0|            0|  0.00%|        nb = 1
  1057|         0|            0|            0|  0.00%|
  1058|         0|            0|            0|  0.00%|    a, b = asarray(a), asarray(b)
  1059|         0|            0|            0|  0.00%|    as_ = a.shape
  1060|         0|            0|            0|  0.00%|    nda = a.ndim
  1061|         0|            0|            0|  0.00%|    bs = b.shape
  1062|         0|            0|            0|  0.00%|    ndb = b.ndim
  1063|         0|            0|            0|  0.00%|    equal = True
  1064|         0|            0|            0|  0.00%|    if na != nb:
  1065|         0|            0|            0|  0.00%|        equal = False
  1066|         0|            0|            0|  0.00%|    else:
  1067|         0|            0|            0|  0.00%|        for k in range(na):
  1068|         0|            0|            0|  0.00%|            if as_[axes_a[k]] != bs[axes_b[k]]:
  1069|         0|            0|            0|  0.00%|                equal = False
  1070|         0|            0|            0|  0.00%|                break
  1071|         0|            0|            0|  0.00%|            if axes_a[k] < 0:
  1072|         0|            0|            0|  0.00%|                axes_a[k] += nda
  1073|         0|            0|            0|  0.00%|            if axes_b[k] < 0:
  1074|         0|            0|            0|  0.00%|                axes_b[k] += ndb
  1075|         0|            0|            0|  0.00%|    if not equal:
  1076|         0|            0|            0|  0.00%|        raise ValueError("shape-mismatch for sum")
  1077|         0|            0|            0|  0.00%|
  1078|         0|            0|            0|  0.00%|    # Move the axes to sum over to the end of "a"
  1079|         0|            0|            0|  0.00%|    # and to the front of "b"
  1080|         0|            0|            0|  0.00%|    notin = [k for k in range(nda) if k not in axes_a]
  1081|         0|            0|            0|  0.00%|    newaxes_a = notin + axes_a
  1082|         0|            0|            0|  0.00%|    N2 = 1
  1083|         0|            0|            0|  0.00%|    for axis in axes_a:
  1084|         0|            0|            0|  0.00%|        N2 *= as_[axis]
  1085|         0|            0|            0|  0.00%|    newshape_a = (int(multiply.reduce([as_[ax] for ax in notin])), N2)
  1086|         0|            0|            0|  0.00%|    olda = [as_[axis] for axis in notin]
  1087|         0|            0|            0|  0.00%|
  1088|         0|            0|            0|  0.00%|    notin = [k for k in range(ndb) if k not in axes_b]
  1089|         0|            0|            0|  0.00%|    newaxes_b = axes_b + notin
  1090|         0|            0|            0|  0.00%|    N2 = 1
  1091|         0|            0|            0|  0.00%|    for axis in axes_b:
  1092|         0|            0|            0|  0.00%|        N2 *= bs[axis]
  1093|         0|            0|            0|  0.00%|    newshape_b = (N2, int(multiply.reduce([bs[ax] for ax in notin])))
  1094|         0|            0|            0|  0.00%|    oldb = [bs[axis] for axis in notin]
  1095|         0|            0|            0|  0.00%|
  1096|         0|            0|            0|  0.00%|    at = a.transpose(newaxes_a).reshape(newshape_a)
  1097|         0|            0|            0|  0.00%|    bt = b.transpose(newaxes_b).reshape(newshape_b)
  1098|         0|            0|            0|  0.00%|    res = dot(at, bt)
  1099|         0|            0|            0|  0.00%|    return res.reshape(olda + oldb)
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|
  1102|         0|            0|            0|  0.00%|def _roll_dispatcher(a, shift, axis=None):
  1103|         0|            0|            0|  0.00%|    return (a,)
  1104|         0|            0|            0|  0.00%|
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|@array_function_dispatch(_roll_dispatcher)
  1107|         0|            0|            0|  0.00%|def roll(a, shift, axis=None):
  1108|         0|            0|            0|  0.00%|    """
  1109|         0|            0|            0|  0.00%|    Roll array elements along a given axis.
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|    Elements that roll beyond the last position are re-introduced at
  1112|         0|            0|            0|  0.00%|    the first.
  1113|         0|            0|            0|  0.00%|
  1114|         0|            0|            0|  0.00%|    Parameters
  1115|         0|            0|            0|  0.00%|    ----------
  1116|         0|            0|            0|  0.00%|    a : array_like
  1117|         0|            0|            0|  0.00%|        Input array.
  1118|         0|            0|            0|  0.00%|    shift : int or tuple of ints
  1119|         0|            0|            0|  0.00%|        The number of places by which elements are shifted.  If a tuple,
  1120|         0|            0|            0|  0.00%|        then `axis` must be a tuple of the same size, and each of the
  1121|         0|            0|            0|  0.00%|        given axes is shifted by the corresponding number.  If an int
  1122|         0|            0|            0|  0.00%|        while `axis` is a tuple of ints, then the same value is used for
  1123|         0|            0|            0|  0.00%|        all given axes.
  1124|         0|            0|            0|  0.00%|    axis : int or tuple of ints, optional
  1125|         0|            0|            0|  0.00%|        Axis or axes along which elements are shifted.  By default, the
  1126|         0|            0|            0|  0.00%|        array is flattened before shifting, after which the original
  1127|         0|            0|            0|  0.00%|        shape is restored.
  1128|         0|            0|            0|  0.00%|
  1129|         0|            0|            0|  0.00%|    Returns
  1130|         0|            0|            0|  0.00%|    -------
  1131|         0|            0|            0|  0.00%|    res : ndarray
  1132|         0|            0|            0|  0.00%|        Output array, with the same shape as `a`.
  1133|         0|            0|            0|  0.00%|
  1134|         0|            0|            0|  0.00%|    See Also
  1135|         0|            0|            0|  0.00%|    --------
  1136|         0|            0|            0|  0.00%|    rollaxis : Roll the specified axis backwards, until it lies in a
  1137|         0|            0|            0|  0.00%|               given position.
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    Notes
  1140|         0|            0|            0|  0.00%|    -----
  1141|         0|            0|            0|  0.00%|    .. versionadded:: 1.12.0
  1142|         0|            0|            0|  0.00%|
  1143|         0|            0|            0|  0.00%|    Supports rolling over multiple dimensions simultaneously.
  1144|         0|            0|            0|  0.00%|
  1145|         0|            0|            0|  0.00%|    Examples
  1146|         0|            0|            0|  0.00%|    --------
  1147|         0|            0|            0|  0.00%|    >>> x = np.arange(10)
  1148|         0|            0|            0|  0.00%|    >>> np.roll(x, 2)
  1149|         0|            0|            0|  0.00%|    array([8, 9, 0, 1, 2, 3, 4, 5, 6, 7])
  1150|         0|            0|            0|  0.00%|    >>> np.roll(x, -2)
  1151|         0|            0|            0|  0.00%|    array([2, 3, 4, 5, 6, 7, 8, 9, 0, 1])
  1152|         0|            0|            0|  0.00%|
  1153|         0|            0|            0|  0.00%|    >>> x2 = np.reshape(x, (2,5))
  1154|         0|            0|            0|  0.00%|    >>> x2
  1155|         0|            0|            0|  0.00%|    array([[0, 1, 2, 3, 4],
  1156|         0|            0|            0|  0.00%|           [5, 6, 7, 8, 9]])
  1157|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1)
  1158|         0|            0|            0|  0.00%|    array([[9, 0, 1, 2, 3],
  1159|         0|            0|            0|  0.00%|           [4, 5, 6, 7, 8]])
  1160|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1)
  1161|         0|            0|            0|  0.00%|    array([[1, 2, 3, 4, 5],
  1162|         0|            0|            0|  0.00%|           [6, 7, 8, 9, 0]])
  1163|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1, axis=0)
  1164|         0|            0|            0|  0.00%|    array([[5, 6, 7, 8, 9],
  1165|         0|            0|            0|  0.00%|           [0, 1, 2, 3, 4]])
  1166|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1, axis=0)
  1167|         0|            0|            0|  0.00%|    array([[5, 6, 7, 8, 9],
  1168|         0|            0|            0|  0.00%|           [0, 1, 2, 3, 4]])
  1169|         0|            0|            0|  0.00%|    >>> np.roll(x2, 1, axis=1)
  1170|         0|            0|            0|  0.00%|    array([[4, 0, 1, 2, 3],
  1171|         0|            0|            0|  0.00%|           [9, 5, 6, 7, 8]])
  1172|         0|            0|            0|  0.00%|    >>> np.roll(x2, -1, axis=1)
  1173|         0|            0|            0|  0.00%|    array([[1, 2, 3, 4, 0],
  1174|         0|            0|            0|  0.00%|           [6, 7, 8, 9, 5]])
  1175|         0|            0|            0|  0.00%|
  1176|         0|            0|            0|  0.00%|    """
  1177|         0|            0|            0|  0.00%|    a = asanyarray(a)
  1178|         0|            0|            0|  0.00%|    if axis is None:
  1179|         0|            0|            0|  0.00%|        return roll(a.ravel(), shift, 0).reshape(a.shape)
  1180|         0|            0|            0|  0.00%|
  1181|         0|            0|            0|  0.00%|    else:
  1182|         0|            0|            0|  0.00%|        axis = normalize_axis_tuple(axis, a.ndim, allow_duplicate=True)
  1183|         0|            0|            0|  0.00%|        broadcasted = broadcast(shift, axis)
  1184|         0|            0|            0|  0.00%|        if broadcasted.ndim > 1:
  1185|         0|            0|            0|  0.00%|            raise ValueError(
  1186|         0|            0|            0|  0.00%|                "'shift' and 'axis' should be scalars or 1D sequences")
  1187|         0|            0|            0|  0.00%|        shifts = {ax: 0 for ax in range(a.ndim)}
  1188|         0|            0|            0|  0.00%|        for sh, ax in broadcasted:
  1189|         0|            0|            0|  0.00%|            shifts[ax] += sh
  1190|         0|            0|            0|  0.00%|
  1191|         0|            0|            0|  0.00%|        rolls = [((slice(None), slice(None)),)] * a.ndim
  1192|         0|            0|            0|  0.00%|        for ax, offset in shifts.items():
  1193|         0|            0|            0|  0.00%|            offset %= a.shape[ax] or 1  # If `a` is empty, nothing matters.
  1194|         0|            0|            0|  0.00%|            if offset:
  1195|         0|            0|            0|  0.00%|                # (original, result), (original, result)
  1196|         0|            0|            0|  0.00%|                rolls[ax] = ((slice(None, -offset), slice(offset, None)),
  1197|         0|            0|            0|  0.00%|                             (slice(-offset, None), slice(None, offset)))
  1198|         0|            0|            0|  0.00%|
  1199|         0|            0|            0|  0.00%|        result = empty_like(a)
  1200|         0|            0|            0|  0.00%|        for indices in itertools.product(*rolls):
  1201|         0|            0|            0|  0.00%|            arr_index, res_index = zip(*indices)
  1202|         0|            0|            0|  0.00%|            result[res_index] = a[arr_index]
  1203|         0|            0|            0|  0.00%|
  1204|         0|            0|            0|  0.00%|        return result
  1205|         0|            0|            0|  0.00%|
  1206|         0|            0|            0|  0.00%|
  1207|         0|            0|            0|  0.00%|def _rollaxis_dispatcher(a, axis, start=None):
  1208|         0|            0|            0|  0.00%|    return (a,)
  1209|         0|            0|            0|  0.00%|
  1210|         0|            0|            0|  0.00%|
  1211|         0|            0|            0|  0.00%|@array_function_dispatch(_rollaxis_dispatcher)
  1212|         0|            0|            0|  0.00%|def rollaxis(a, axis, start=0):
  1213|         0|            0|            0|  0.00%|    """
  1214|         0|            0|            0|  0.00%|    Roll the specified axis backwards, until it lies in a given position.
  1215|         0|            0|            0|  0.00%|
  1216|         0|            0|            0|  0.00%|    This function continues to be supported for backward compatibility, but you
  1217|         0|            0|            0|  0.00%|    should prefer `moveaxis`. The `moveaxis` function was added in NumPy
  1218|         0|            0|            0|  0.00%|    1.11.
  1219|         0|            0|            0|  0.00%|
  1220|         0|            0|            0|  0.00%|    Parameters
  1221|         0|            0|            0|  0.00%|    ----------
  1222|         0|            0|            0|  0.00%|    a : ndarray
  1223|         0|            0|            0|  0.00%|        Input array.
  1224|         0|            0|            0|  0.00%|    axis : int
  1225|         0|            0|            0|  0.00%|        The axis to roll backwards.  The positions of the other axes do not
  1226|         0|            0|            0|  0.00%|        change relative to one another.
  1227|         0|            0|            0|  0.00%|    start : int, optional
  1228|         0|            0|            0|  0.00%|        The axis is rolled until it lies before this position.  The default,
  1229|         0|            0|            0|  0.00%|        0, results in a "complete" roll.
  1230|         0|            0|            0|  0.00%|
  1231|         0|            0|            0|  0.00%|    Returns
  1232|         0|            0|            0|  0.00%|    -------
  1233|         0|            0|            0|  0.00%|    res : ndarray
  1234|         0|            0|            0|  0.00%|        For NumPy >= 1.10.0 a view of `a` is always returned. For earlier
  1235|         0|            0|            0|  0.00%|        NumPy versions a view of `a` is returned only if the order of the
  1236|         0|            0|            0|  0.00%|        axes is changed, otherwise the input array is returned.
  1237|         0|            0|            0|  0.00%|
  1238|         0|            0|            0|  0.00%|    See Also
  1239|         0|            0|            0|  0.00%|    --------
  1240|         0|            0|            0|  0.00%|    moveaxis : Move array axes to new positions.
  1241|         0|            0|            0|  0.00%|    roll : Roll the elements of an array by a number of positions along a
  1242|         0|            0|            0|  0.00%|        given axis.
  1243|         0|            0|            0|  0.00%|
  1244|         0|            0|            0|  0.00%|    Examples
  1245|         0|            0|            0|  0.00%|    --------
  1246|         0|            0|            0|  0.00%|    >>> a = np.ones((3,4,5,6))
  1247|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 3, 1).shape
  1248|         0|            0|            0|  0.00%|    (3, 6, 4, 5)
  1249|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 2).shape
  1250|         0|            0|            0|  0.00%|    (5, 3, 4, 6)
  1251|         0|            0|            0|  0.00%|    >>> np.rollaxis(a, 1, 4).shape
  1252|         0|            0|            0|  0.00%|    (3, 5, 6, 4)
  1253|         0|            0|            0|  0.00%|
  1254|         0|            0|            0|  0.00%|    """
  1255|         0|            0|            0|  0.00%|    n = a.ndim
  1256|         0|            0|            0|  0.00%|    axis = normalize_axis_index(axis, n)
  1257|         0|            0|            0|  0.00%|    if start < 0:
  1258|         0|            0|            0|  0.00%|        start += n
  1259|         0|            0|            0|  0.00%|    msg = "'%s' arg requires %d <= %s < %d, but %d was passed in"
  1260|         0|            0|            0|  0.00%|    if not (0 <= start < n + 1):
  1261|         0|            0|            0|  0.00%|        raise AxisError(msg % ('start', -n, 'start', n + 1, start))
  1262|         0|            0|            0|  0.00%|    if axis < start:
  1263|         0|            0|            0|  0.00%|        # it's been removed
  1264|         0|            0|            0|  0.00%|        start -= 1
  1265|         0|            0|            0|  0.00%|    if axis == start:
  1266|         0|            0|            0|  0.00%|        return a[...]
  1267|         0|            0|            0|  0.00%|    axes = list(range(0, n))
  1268|         0|            0|            0|  0.00%|    axes.remove(axis)
  1269|         0|            0|            0|  0.00%|    axes.insert(start, axis)
  1270|         0|            0|            0|  0.00%|    return a.transpose(axes)
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|
  1273|         2|  9.53674e-06|  4.76837e-06|  0.00%|def normalize_axis_tuple(axis, ndim, argname=None, allow_duplicate=False):
  1274|         0|            0|            0|  0.00%|    """
  1275|         0|            0|            0|  0.00%|    Normalizes an axis argument into a tuple of non-negative integer axes.
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|    This handles shorthands such as ``1`` and converts them to ``(1,)``,
  1278|         0|            0|            0|  0.00%|    as well as performing the handling of negative indices covered by
  1279|         0|            0|            0|  0.00%|    `normalize_axis_index`.
  1280|         0|            0|            0|  0.00%|
  1281|         0|            0|            0|  0.00%|    By default, this forbids axes from being specified multiple times.
  1282|         0|            0|            0|  0.00%|
  1283|         0|            0|            0|  0.00%|    Used internally by multi-axis-checking logic.
  1284|         0|            0|            0|  0.00%|
  1285|         0|            0|            0|  0.00%|    .. versionadded:: 1.13.0
  1286|         0|            0|            0|  0.00%|
  1287|         0|            0|            0|  0.00%|    Parameters
  1288|         0|            0|            0|  0.00%|    ----------
  1289|         0|            0|            0|  0.00%|    axis : int, iterable of int
  1290|         0|            0|            0|  0.00%|        The un-normalized index or indices of the axis.
  1291|         0|            0|            0|  0.00%|    ndim : int
  1292|         0|            0|            0|  0.00%|        The number of dimensions of the array that `axis` should be normalized
  1293|         0|            0|            0|  0.00%|        against.
  1294|         0|            0|            0|  0.00%|    argname : str, optional
  1295|         0|            0|            0|  0.00%|        A prefix to put before the error message, typically the name of the
  1296|         0|            0|            0|  0.00%|        argument.
  1297|         0|            0|            0|  0.00%|    allow_duplicate : bool, optional
  1298|         0|            0|            0|  0.00%|        If False, the default, disallow an axis from being specified twice.
  1299|         0|            0|            0|  0.00%|
  1300|         0|            0|            0|  0.00%|    Returns
  1301|         0|            0|            0|  0.00%|    -------
  1302|         0|            0|            0|  0.00%|    normalized_axes : tuple of int
  1303|         0|            0|            0|  0.00%|        The normalized axis index, such that `0 <= normalized_axis < ndim`
  1304|         0|            0|            0|  0.00%|
  1305|         0|            0|            0|  0.00%|    Raises
  1306|         0|            0|            0|  0.00%|    ------
  1307|         0|            0|            0|  0.00%|    AxisError
  1308|         0|            0|            0|  0.00%|        If any axis provided is out of range
  1309|         0|            0|            0|  0.00%|    ValueError
  1310|         0|            0|            0|  0.00%|        If an axis is repeated
  1311|         0|            0|            0|  0.00%|
  1312|         0|            0|            0|  0.00%|    See also
  1313|         0|            0|            0|  0.00%|    --------
  1314|         0|            0|            0|  0.00%|    normalize_axis_index : normalizing a single scalar axis
  1315|         0|            0|            0|  0.00%|    """
  1316|         0|            0|            0|  0.00%|    # Optimization to speed-up the most common cases.
  1317|         2|   1.0252e-05|    5.126e-06|  0.00%|    if type(axis) not in (tuple, list):
  1318|         2|  6.67572e-06|  3.33786e-06|  0.00%|        try:
  1319|         2|  4.17233e-05|  2.08616e-05|  0.00%|            axis = [operator.index(axis)]
  1320|         0|            0|            0|  0.00%|        except TypeError:
  1321|         0|            0|            0|  0.00%|            pass
  1322|         0|            0|            0|  0.00%|    # Going via an iterator directly is slower than via list comprehension.
  1323|         8|   3.8147e-05|  4.76837e-06|  0.00%|    axis = tuple([normalize_axis_index(ax, ndim, argname) for ax in axis])
(call)|         2|  1.81198e-05|  9.05991e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1323 <listcomp>
  1324|         2|  7.86781e-06|  3.93391e-06|  0.00%|    if not allow_duplicate and len(set(axis)) != len(axis):
  1325|         0|            0|            0|  0.00%|        if argname:
  1326|         0|            0|            0|  0.00%|            raise ValueError('repeated axis in `{}` argument'.format(argname))
  1327|         0|            0|            0|  0.00%|        else:
  1328|         0|            0|            0|  0.00%|            raise ValueError('repeated axis')
  1329|         2|  6.91414e-06|  3.45707e-06|  0.00%|    return axis
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|
  1332|         1|  4.05312e-06|  4.05312e-06|  0.00%|def _moveaxis_dispatcher(a, source, destination):
  1333|         1|   3.8147e-06|   3.8147e-06|  0.00%|    return (a,)
  1334|         0|            0|            0|  0.00%|
  1335|         0|            0|            0|  0.00%|
  1336|         1|  7.62939e-06|  7.62939e-06|  0.00%|@array_function_dispatch(_moveaxis_dispatcher)
  1337|         0|            0|            0|  0.00%|def moveaxis(a, source, destination):
  1338|         0|            0|            0|  0.00%|    """
  1339|         0|            0|            0|  0.00%|    Move axes of an array to new positions.
  1340|         0|            0|            0|  0.00%|
  1341|         0|            0|            0|  0.00%|    Other axes remain in their original order.
  1342|         0|            0|            0|  0.00%|
  1343|         0|            0|            0|  0.00%|    .. versionadded:: 1.11.0
  1344|         0|            0|            0|  0.00%|
  1345|         0|            0|            0|  0.00%|    Parameters
  1346|         0|            0|            0|  0.00%|    ----------
  1347|         0|            0|            0|  0.00%|    a : np.ndarray
  1348|         0|            0|            0|  0.00%|        The array whose axes should be reordered.
  1349|         0|            0|            0|  0.00%|    source : int or sequence of int
  1350|         0|            0|            0|  0.00%|        Original positions of the axes to move. These must be unique.
  1351|         0|            0|            0|  0.00%|    destination : int or sequence of int
  1352|         0|            0|            0|  0.00%|        Destination positions for each of the original axes. These must also be
  1353|         0|            0|            0|  0.00%|        unique.
  1354|         0|            0|            0|  0.00%|
  1355|         0|            0|            0|  0.00%|    Returns
  1356|         0|            0|            0|  0.00%|    -------
  1357|         0|            0|            0|  0.00%|    result : np.ndarray
  1358|         0|            0|            0|  0.00%|        Array with moved axes. This array is a view of the input array.
  1359|         0|            0|            0|  0.00%|
  1360|         0|            0|            0|  0.00%|    See Also
  1361|         0|            0|            0|  0.00%|    --------
  1362|         0|            0|            0|  0.00%|    transpose: Permute the dimensions of an array.
  1363|         0|            0|            0|  0.00%|    swapaxes: Interchange two axes of an array.
  1364|         0|            0|            0|  0.00%|
  1365|         0|            0|            0|  0.00%|    Examples
  1366|         0|            0|            0|  0.00%|    --------
  1367|         0|            0|            0|  0.00%|
  1368|         0|            0|            0|  0.00%|    >>> x = np.zeros((3, 4, 5))
  1369|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, 0, -1).shape
  1370|         0|            0|            0|  0.00%|    (4, 5, 3)
  1371|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, -1, 0).shape
  1372|         0|            0|            0|  0.00%|    (5, 3, 4)
  1373|         0|            0|            0|  0.00%|
  1374|         0|            0|            0|  0.00%|    These all achieve the same result:
  1375|         0|            0|            0|  0.00%|
  1376|         0|            0|            0|  0.00%|    >>> np.transpose(x).shape
  1377|         0|            0|            0|  0.00%|    (5, 4, 3)
  1378|         0|            0|            0|  0.00%|    >>> np.swapaxes(x, 0, -1).shape
  1379|         0|            0|            0|  0.00%|    (5, 4, 3)
  1380|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, [0, 1], [-1, -2]).shape
  1381|         0|            0|            0|  0.00%|    (5, 4, 3)
  1382|         0|            0|            0|  0.00%|    >>> np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape
  1383|         0|            0|            0|  0.00%|    (5, 4, 3)
  1384|         0|            0|            0|  0.00%|
  1385|         0|            0|            0|  0.00%|    """
  1386|         1|  4.76837e-06|  4.76837e-06|  0.00%|    try:
  1387|         0|            0|            0|  0.00%|        # allow duck-array types if they define transpose
  1388|         1|  5.00679e-06|  5.00679e-06|  0.00%|        transpose = a.transpose
  1389|         0|            0|            0|  0.00%|    except AttributeError:
  1390|         0|            0|            0|  0.00%|        a = asarray(a)
  1391|         0|            0|            0|  0.00%|        transpose = a.transpose
  1392|         0|            0|            0|  0.00%|
  1393|         1|  1.33514e-05|  1.33514e-05|  0.00%|    source = normalize_axis_tuple(source, a.ndim, 'source')
(call)|         1|  8.89301e-05|  8.89301e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1273 normalize_axis_tuple
  1394|         1|  1.33514e-05|  1.33514e-05|  0.00%|    destination = normalize_axis_tuple(destination, a.ndim, 'destination')
(call)|         1|  3.21865e-05|  3.21865e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1273 normalize_axis_tuple
  1395|         1|  4.52995e-06|  4.52995e-06|  0.00%|    if len(source) != len(destination):
  1396|         0|            0|            0|  0.00%|        raise ValueError('`source` and `destination` arguments must have '
  1397|         0|            0|            0|  0.00%|                         'the same number of elements')
  1398|         0|            0|            0|  0.00%|
  1399|         4|  2.07424e-05|   5.1856e-06|  0.00%|    order = [n for n in range(a.ndim) if n not in source]
(call)|         1|  9.29832e-06|  9.29832e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1399 <listcomp>
  1400|         0|            0|            0|  0.00%|
  1401|         2|  1.07288e-05|  5.36442e-06|  0.00%|    for dest, src in sorted(zip(destination, source)):
  1402|         1|  5.00679e-06|  5.00679e-06|  0.00%|        order.insert(dest, src)
  1403|         0|            0|            0|  0.00%|
  1404|         1|  4.05312e-06|  4.05312e-06|  0.00%|    result = transpose(order)
  1405|         1|  4.05312e-06|  4.05312e-06|  0.00%|    return result
  1406|         0|            0|            0|  0.00%|
  1407|         0|            0|            0|  0.00%|
  1408|         0|            0|            0|  0.00%|# fix hack in scipy which imports this function
  1409|         0|            0|            0|  0.00%|def _move_axis_to_0(a, axis):
  1410|         0|            0|            0|  0.00%|    return moveaxis(a, axis, 0)
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|
  1413|         0|            0|            0|  0.00%|def _cross_dispatcher(a, b, axisa=None, axisb=None, axisc=None, axis=None):
  1414|         0|            0|            0|  0.00%|    return (a, b)
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|
  1417|         0|            0|            0|  0.00%|@array_function_dispatch(_cross_dispatcher)
  1418|         0|            0|            0|  0.00%|def cross(a, b, axisa=-1, axisb=-1, axisc=-1, axis=None):
  1419|         0|            0|            0|  0.00%|    """
  1420|         0|            0|            0|  0.00%|    Return the cross product of two (arrays of) vectors.
  1421|         0|            0|            0|  0.00%|
  1422|         0|            0|            0|  0.00%|    The cross product of `a` and `b` in :math:`R^3` is a vector perpendicular
  1423|         0|            0|            0|  0.00%|    to both `a` and `b`.  If `a` and `b` are arrays of vectors, the vectors
  1424|         0|            0|            0|  0.00%|    are defined by the last axis of `a` and `b` by default, and these axes
  1425|         0|            0|            0|  0.00%|    can have dimensions 2 or 3.  Where the dimension of either `a` or `b` is
  1426|         0|            0|            0|  0.00%|    2, the third component of the input vector is assumed to be zero and the
  1427|         0|            0|            0|  0.00%|    cross product calculated accordingly.  In cases where both input vectors
  1428|         0|            0|            0|  0.00%|    have dimension 2, the z-component of the cross product is returned.
  1429|         0|            0|            0|  0.00%|
  1430|         0|            0|            0|  0.00%|    Parameters
  1431|         0|            0|            0|  0.00%|    ----------
  1432|         0|            0|            0|  0.00%|    a : array_like
  1433|         0|            0|            0|  0.00%|        Components of the first vector(s).
  1434|         0|            0|            0|  0.00%|    b : array_like
  1435|         0|            0|            0|  0.00%|        Components of the second vector(s).
  1436|         0|            0|            0|  0.00%|    axisa : int, optional
  1437|         0|            0|            0|  0.00%|        Axis of `a` that defines the vector(s).  By default, the last axis.
  1438|         0|            0|            0|  0.00%|    axisb : int, optional
  1439|         0|            0|            0|  0.00%|        Axis of `b` that defines the vector(s).  By default, the last axis.
  1440|         0|            0|            0|  0.00%|    axisc : int, optional
  1441|         0|            0|            0|  0.00%|        Axis of `c` containing the cross product vector(s).  Ignored if
  1442|         0|            0|            0|  0.00%|        both input vectors have dimension 2, as the return is scalar.
  1443|         0|            0|            0|  0.00%|        By default, the last axis.
  1444|         0|            0|            0|  0.00%|    axis : int, optional
  1445|         0|            0|            0|  0.00%|        If defined, the axis of `a`, `b` and `c` that defines the vector(s)
  1446|         0|            0|            0|  0.00%|        and cross product(s).  Overrides `axisa`, `axisb` and `axisc`.
  1447|         0|            0|            0|  0.00%|
  1448|         0|            0|            0|  0.00%|    Returns
  1449|         0|            0|            0|  0.00%|    -------
  1450|         0|            0|            0|  0.00%|    c : ndarray
  1451|         0|            0|            0|  0.00%|        Vector cross product(s).
  1452|         0|            0|            0|  0.00%|
  1453|         0|            0|            0|  0.00%|    Raises
  1454|         0|            0|            0|  0.00%|    ------
  1455|         0|            0|            0|  0.00%|    ValueError
  1456|         0|            0|            0|  0.00%|        When the dimension of the vector(s) in `a` and/or `b` does not
  1457|         0|            0|            0|  0.00%|        equal 2 or 3.
  1458|         0|            0|            0|  0.00%|
  1459|         0|            0|            0|  0.00%|    See Also
  1460|         0|            0|            0|  0.00%|    --------
  1461|         0|            0|            0|  0.00%|    inner : Inner product
  1462|         0|            0|            0|  0.00%|    outer : Outer product.
  1463|         0|            0|            0|  0.00%|    ix_ : Construct index arrays.
  1464|         0|            0|            0|  0.00%|
  1465|         0|            0|            0|  0.00%|    Notes
  1466|         0|            0|            0|  0.00%|    -----
  1467|         0|            0|            0|  0.00%|    .. versionadded:: 1.9.0
  1468|         0|            0|            0|  0.00%|
  1469|         0|            0|            0|  0.00%|    Supports full broadcasting of the inputs.
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|    Examples
  1472|         0|            0|            0|  0.00%|    --------
  1473|         0|            0|            0|  0.00%|    Vector cross-product.
  1474|         0|            0|            0|  0.00%|
  1475|         0|            0|            0|  0.00%|    >>> x = [1, 2, 3]
  1476|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1477|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1478|         0|            0|            0|  0.00%|    array([-3,  6, -3])
  1479|         0|            0|            0|  0.00%|
  1480|         0|            0|            0|  0.00%|    One vector with dimension 2.
  1481|         0|            0|            0|  0.00%|
  1482|         0|            0|            0|  0.00%|    >>> x = [1, 2]
  1483|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1484|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1485|         0|            0|            0|  0.00%|    array([12, -6, -3])
  1486|         0|            0|            0|  0.00%|
  1487|         0|            0|            0|  0.00%|    Equivalently:
  1488|         0|            0|            0|  0.00%|
  1489|         0|            0|            0|  0.00%|    >>> x = [1, 2, 0]
  1490|         0|            0|            0|  0.00%|    >>> y = [4, 5, 6]
  1491|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1492|         0|            0|            0|  0.00%|    array([12, -6, -3])
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    Both vectors with dimension 2.
  1495|         0|            0|            0|  0.00%|
  1496|         0|            0|            0|  0.00%|    >>> x = [1,2]
  1497|         0|            0|            0|  0.00%|    >>> y = [4,5]
  1498|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1499|         0|            0|            0|  0.00%|    array(-3)
  1500|         0|            0|            0|  0.00%|
  1501|         0|            0|            0|  0.00%|    Multiple vector cross-products. Note that the direction of the cross
  1502|         0|            0|            0|  0.00%|    product vector is defined by the `right-hand rule`.
  1503|         0|            0|            0|  0.00%|
  1504|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3], [4,5,6]])
  1505|         0|            0|            0|  0.00%|    >>> y = np.array([[4,5,6], [1,2,3]])
  1506|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1507|         0|            0|            0|  0.00%|    array([[-3,  6, -3],
  1508|         0|            0|            0|  0.00%|           [ 3, -6,  3]])
  1509|         0|            0|            0|  0.00%|
  1510|         0|            0|            0|  0.00%|    The orientation of `c` can be changed using the `axisc` keyword.
  1511|         0|            0|            0|  0.00%|
  1512|         0|            0|            0|  0.00%|    >>> np.cross(x, y, axisc=0)
  1513|         0|            0|            0|  0.00%|    array([[-3,  3],
  1514|         0|            0|            0|  0.00%|           [ 6, -6],
  1515|         0|            0|            0|  0.00%|           [-3,  3]])
  1516|         0|            0|            0|  0.00%|
  1517|         0|            0|            0|  0.00%|    Change the vector definition of `x` and `y` using `axisa` and `axisb`.
  1518|         0|            0|            0|  0.00%|
  1519|         0|            0|            0|  0.00%|    >>> x = np.array([[1,2,3], [4,5,6], [7, 8, 9]])
  1520|         0|            0|            0|  0.00%|    >>> y = np.array([[7, 8, 9], [4,5,6], [1,2,3]])
  1521|         0|            0|            0|  0.00%|    >>> np.cross(x, y)
  1522|         0|            0|            0|  0.00%|    array([[ -6,  12,  -6],
  1523|         0|            0|            0|  0.00%|           [  0,   0,   0],
  1524|         0|            0|            0|  0.00%|           [  6, -12,   6]])
  1525|         0|            0|            0|  0.00%|    >>> np.cross(x, y, axisa=0, axisb=0)
  1526|         0|            0|            0|  0.00%|    array([[-24,  48, -24],
  1527|         0|            0|            0|  0.00%|           [-30,  60, -30],
  1528|         0|            0|            0|  0.00%|           [-36,  72, -36]])
  1529|         0|            0|            0|  0.00%|
  1530|         0|            0|            0|  0.00%|    """
  1531|         0|            0|            0|  0.00%|    if axis is not None:
  1532|         0|            0|            0|  0.00%|        axisa, axisb, axisc = (axis,) * 3
  1533|         0|            0|            0|  0.00%|    a = asarray(a)
  1534|         0|            0|            0|  0.00%|    b = asarray(b)
  1535|         0|            0|            0|  0.00%|    # Check axisa and axisb are within bounds
  1536|         0|            0|            0|  0.00%|    axisa = normalize_axis_index(axisa, a.ndim, msg_prefix='axisa')
  1537|         0|            0|            0|  0.00%|    axisb = normalize_axis_index(axisb, b.ndim, msg_prefix='axisb')
  1538|         0|            0|            0|  0.00%|
  1539|         0|            0|            0|  0.00%|    # Move working axis to the end of the shape
  1540|         0|            0|            0|  0.00%|    a = moveaxis(a, axisa, -1)
  1541|         0|            0|            0|  0.00%|    b = moveaxis(b, axisb, -1)
  1542|         0|            0|            0|  0.00%|    msg = ("incompatible dimensions for cross product\n"
  1543|         0|            0|            0|  0.00%|           "(dimension must be 2 or 3)")
  1544|         0|            0|            0|  0.00%|    if a.shape[-1] not in (2, 3) or b.shape[-1] not in (2, 3):
  1545|         0|            0|            0|  0.00%|        raise ValueError(msg)
  1546|         0|            0|            0|  0.00%|
  1547|         0|            0|            0|  0.00%|    # Create the output array
  1548|         0|            0|            0|  0.00%|    shape = broadcast(a[..., 0], b[..., 0]).shape
  1549|         0|            0|            0|  0.00%|    if a.shape[-1] == 3 or b.shape[-1] == 3:
  1550|         0|            0|            0|  0.00%|        shape += (3,)
  1551|         0|            0|            0|  0.00%|        # Check axisc is within bounds
  1552|         0|            0|            0|  0.00%|        axisc = normalize_axis_index(axisc, len(shape), msg_prefix='axisc')
  1553|         0|            0|            0|  0.00%|    dtype = promote_types(a.dtype, b.dtype)
  1554|         0|            0|            0|  0.00%|    cp = empty(shape, dtype)
  1555|         0|            0|            0|  0.00%|
  1556|         0|            0|            0|  0.00%|    # create local aliases for readability
  1557|         0|            0|            0|  0.00%|    a0 = a[..., 0]
  1558|         0|            0|            0|  0.00%|    a1 = a[..., 1]
  1559|         0|            0|            0|  0.00%|    if a.shape[-1] == 3:
  1560|         0|            0|            0|  0.00%|        a2 = a[..., 2]
  1561|         0|            0|            0|  0.00%|    b0 = b[..., 0]
  1562|         0|            0|            0|  0.00%|    b1 = b[..., 1]
  1563|         0|            0|            0|  0.00%|    if b.shape[-1] == 3:
  1564|         0|            0|            0|  0.00%|        b2 = b[..., 2]
  1565|         0|            0|            0|  0.00%|    if cp.ndim != 0 and cp.shape[-1] == 3:
  1566|         0|            0|            0|  0.00%|        cp0 = cp[..., 0]
  1567|         0|            0|            0|  0.00%|        cp1 = cp[..., 1]
  1568|         0|            0|            0|  0.00%|        cp2 = cp[..., 2]
  1569|         0|            0|            0|  0.00%|
  1570|         0|            0|            0|  0.00%|    if a.shape[-1] == 2:
  1571|         0|            0|            0|  0.00%|        if b.shape[-1] == 2:
  1572|         0|            0|            0|  0.00%|            # a0 * b1 - a1 * b0
  1573|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp)
  1574|         0|            0|            0|  0.00%|            cp -= a1 * b0
  1575|         0|            0|            0|  0.00%|            return cp
  1576|         0|            0|            0|  0.00%|        else:
  1577|         0|            0|            0|  0.00%|            assert b.shape[-1] == 3
  1578|         0|            0|            0|  0.00%|            # cp0 = a1 * b2 - 0  (a2 = 0)
  1579|         0|            0|            0|  0.00%|            # cp1 = 0 - a0 * b2  (a2 = 0)
  1580|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1581|         0|            0|            0|  0.00%|            multiply(a1, b2, out=cp0)
  1582|         0|            0|            0|  0.00%|            multiply(a0, b2, out=cp1)
  1583|         0|            0|            0|  0.00%|            negative(cp1, out=cp1)
  1584|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1585|         0|            0|            0|  0.00%|            cp2 -= a1 * b0
  1586|         0|            0|            0|  0.00%|    else:
  1587|         0|            0|            0|  0.00%|        assert a.shape[-1] == 3
  1588|         0|            0|            0|  0.00%|        if b.shape[-1] == 3:
  1589|         0|            0|            0|  0.00%|            # cp0 = a1 * b2 - a2 * b1
  1590|         0|            0|            0|  0.00%|            # cp1 = a2 * b0 - a0 * b2
  1591|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1592|         0|            0|            0|  0.00%|            multiply(a1, b2, out=cp0)
  1593|         0|            0|            0|  0.00%|            tmp = array(a2 * b1)
  1594|         0|            0|            0|  0.00%|            cp0 -= tmp
  1595|         0|            0|            0|  0.00%|            multiply(a2, b0, out=cp1)
  1596|         0|            0|            0|  0.00%|            multiply(a0, b2, out=tmp)
  1597|         0|            0|            0|  0.00%|            cp1 -= tmp
  1598|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1599|         0|            0|            0|  0.00%|            multiply(a1, b0, out=tmp)
  1600|         0|            0|            0|  0.00%|            cp2 -= tmp
  1601|         0|            0|            0|  0.00%|        else:
  1602|         0|            0|            0|  0.00%|            assert b.shape[-1] == 2
  1603|         0|            0|            0|  0.00%|            # cp0 = 0 - a2 * b1  (b2 = 0)
  1604|         0|            0|            0|  0.00%|            # cp1 = a2 * b0 - 0  (b2 = 0)
  1605|         0|            0|            0|  0.00%|            # cp2 = a0 * b1 - a1 * b0
  1606|         0|            0|            0|  0.00%|            multiply(a2, b1, out=cp0)
  1607|         0|            0|            0|  0.00%|            negative(cp0, out=cp0)
  1608|         0|            0|            0|  0.00%|            multiply(a2, b0, out=cp1)
  1609|         0|            0|            0|  0.00%|            multiply(a0, b1, out=cp2)
  1610|         0|            0|            0|  0.00%|            cp2 -= a1 * b0
  1611|         0|            0|            0|  0.00%|
  1612|         0|            0|            0|  0.00%|    return moveaxis(cp, -1, axisc)
  1613|         0|            0|            0|  0.00%|
  1614|         0|            0|            0|  0.00%|
  1615|         0|            0|            0|  0.00%|little_endian = (sys.byteorder == 'little')
  1616|         0|            0|            0|  0.00%|
  1617|         0|            0|            0|  0.00%|
  1618|         0|            0|            0|  0.00%|@set_module('numpy')
  1619|         0|            0|            0|  0.00%|def indices(dimensions, dtype=int, sparse=False):
  1620|         0|            0|            0|  0.00%|    """
  1621|         0|            0|            0|  0.00%|    Return an array representing the indices of a grid.
  1622|         0|            0|            0|  0.00%|
  1623|         0|            0|            0|  0.00%|    Compute an array where the subarrays contain index values 0, 1, ...
  1624|         0|            0|            0|  0.00%|    varying only along the corresponding axis.
  1625|         0|            0|            0|  0.00%|
  1626|         0|            0|            0|  0.00%|    Parameters
  1627|         0|            0|            0|  0.00%|    ----------
  1628|         0|            0|            0|  0.00%|    dimensions : sequence of ints
  1629|         0|            0|            0|  0.00%|        The shape of the grid.
  1630|         0|            0|            0|  0.00%|    dtype : dtype, optional
  1631|         0|            0|            0|  0.00%|        Data type of the result.
  1632|         0|            0|            0|  0.00%|    sparse : boolean, optional
  1633|         0|            0|            0|  0.00%|        Return a sparse representation of the grid instead of a dense
  1634|         0|            0|            0|  0.00%|        representation. Default is False.
  1635|         0|            0|            0|  0.00%|
  1636|         0|            0|            0|  0.00%|        .. versionadded:: 1.17
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|    Returns
  1639|         0|            0|            0|  0.00%|    -------
  1640|         0|            0|            0|  0.00%|    grid : one ndarray or tuple of ndarrays
  1641|         0|            0|            0|  0.00%|        If sparse is False:
  1642|         0|            0|            0|  0.00%|            Returns one array of grid indices,
  1643|         0|            0|            0|  0.00%|            ``grid.shape = (len(dimensions),) + tuple(dimensions)``.
  1644|         0|            0|            0|  0.00%|        If sparse is True:
  1645|         0|            0|            0|  0.00%|            Returns a tuple of arrays, with
  1646|         0|            0|            0|  0.00%|            ``grid[i].shape = (1, ..., 1, dimensions[i], 1, ..., 1)`` with
  1647|         0|            0|            0|  0.00%|            dimensions[i] in the ith place
  1648|         0|            0|            0|  0.00%|
  1649|         0|            0|            0|  0.00%|    See Also
  1650|         0|            0|            0|  0.00%|    --------
  1651|         0|            0|            0|  0.00%|    mgrid, ogrid, meshgrid
  1652|         0|            0|            0|  0.00%|
  1653|         0|            0|            0|  0.00%|    Notes
  1654|         0|            0|            0|  0.00%|    -----
  1655|         0|            0|            0|  0.00%|    The output shape in the dense case is obtained by prepending the number
  1656|         0|            0|            0|  0.00%|    of dimensions in front of the tuple of dimensions, i.e. if `dimensions`
  1657|         0|            0|            0|  0.00%|    is a tuple ``(r0, ..., rN-1)`` of length ``N``, the output shape is
  1658|         0|            0|            0|  0.00%|    ``(N, r0, ..., rN-1)``.
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|    The subarrays ``grid[k]`` contains the N-D array of indices along the
  1661|         0|            0|            0|  0.00%|    ``k-th`` axis. Explicitly::
  1662|         0|            0|            0|  0.00%|
  1663|         0|            0|            0|  0.00%|        grid[k, i0, i1, ..., iN-1] = ik
  1664|         0|            0|            0|  0.00%|
  1665|         0|            0|            0|  0.00%|    Examples
  1666|         0|            0|            0|  0.00%|    --------
  1667|         0|            0|            0|  0.00%|    >>> grid = np.indices((2, 3))
  1668|         0|            0|            0|  0.00%|    >>> grid.shape
  1669|         0|            0|            0|  0.00%|    (2, 2, 3)
  1670|         0|            0|            0|  0.00%|    >>> grid[0]        # row indices
  1671|         0|            0|            0|  0.00%|    array([[0, 0, 0],
  1672|         0|            0|            0|  0.00%|           [1, 1, 1]])
  1673|         0|            0|            0|  0.00%|    >>> grid[1]        # column indices
  1674|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1675|         0|            0|            0|  0.00%|           [0, 1, 2]])
  1676|         0|            0|            0|  0.00%|
  1677|         0|            0|            0|  0.00%|    The indices can be used as an index into an array.
  1678|         0|            0|            0|  0.00%|
  1679|         0|            0|            0|  0.00%|    >>> x = np.arange(20).reshape(5, 4)
  1680|         0|            0|            0|  0.00%|    >>> row, col = np.indices((2, 3))
  1681|         0|            0|            0|  0.00%|    >>> x[row, col]
  1682|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1683|         0|            0|            0|  0.00%|           [4, 5, 6]])
  1684|         0|            0|            0|  0.00%|
  1685|         0|            0|            0|  0.00%|    Note that it would be more straightforward in the above example to
  1686|         0|            0|            0|  0.00%|    extract the required elements directly with ``x[:2, :3]``.
  1687|         0|            0|            0|  0.00%|
  1688|         0|            0|            0|  0.00%|    If sparse is set to true, the grid will be returned in a sparse
  1689|         0|            0|            0|  0.00%|    representation.
  1690|         0|            0|            0|  0.00%|
  1691|         0|            0|            0|  0.00%|    >>> i, j = np.indices((2, 3), sparse=True)
  1692|         0|            0|            0|  0.00%|    >>> i.shape
  1693|         0|            0|            0|  0.00%|    (2, 1)
  1694|         0|            0|            0|  0.00%|    >>> j.shape
  1695|         0|            0|            0|  0.00%|    (1, 3)
  1696|         0|            0|            0|  0.00%|    >>> i        # row indices
  1697|         0|            0|            0|  0.00%|    array([[0],
  1698|         0|            0|            0|  0.00%|           [1]])
  1699|         0|            0|            0|  0.00%|    >>> j        # column indices
  1700|         0|            0|            0|  0.00%|    array([[0, 1, 2]])
  1701|         0|            0|            0|  0.00%|
  1702|         0|            0|            0|  0.00%|    """
  1703|         0|            0|            0|  0.00%|    dimensions = tuple(dimensions)
  1704|         0|            0|            0|  0.00%|    N = len(dimensions)
  1705|         0|            0|            0|  0.00%|    shape = (1,)*N
  1706|         0|            0|            0|  0.00%|    if sparse:
  1707|         0|            0|            0|  0.00%|        res = tuple()
  1708|         0|            0|            0|  0.00%|    else:
  1709|         0|            0|            0|  0.00%|        res = empty((N,)+dimensions, dtype=dtype)
  1710|         0|            0|            0|  0.00%|    for i, dim in enumerate(dimensions):
  1711|         0|            0|            0|  0.00%|        idx = arange(dim, dtype=dtype).reshape(
  1712|         0|            0|            0|  0.00%|            shape[:i] + (dim,) + shape[i+1:]
  1713|         0|            0|            0|  0.00%|        )
  1714|         0|            0|            0|  0.00%|        if sparse:
  1715|         0|            0|            0|  0.00%|            res = res + (idx,)
  1716|         0|            0|            0|  0.00%|        else:
  1717|         0|            0|            0|  0.00%|            res[i] = idx
  1718|         0|            0|            0|  0.00%|    return res
  1719|         0|            0|            0|  0.00%|
  1720|         0|            0|            0|  0.00%|
  1721|         0|            0|            0|  0.00%|@set_module('numpy')
  1722|         0|            0|            0|  0.00%|def fromfunction(function, shape, **kwargs):
  1723|         0|            0|            0|  0.00%|    """
  1724|         0|            0|            0|  0.00%|    Construct an array by executing a function over each coordinate.
  1725|         0|            0|            0|  0.00%|
  1726|         0|            0|            0|  0.00%|    The resulting array therefore has a value ``fn(x, y, z)`` at
  1727|         0|            0|            0|  0.00%|    coordinate ``(x, y, z)``.
  1728|         0|            0|            0|  0.00%|
  1729|         0|            0|            0|  0.00%|    Parameters
  1730|         0|            0|            0|  0.00%|    ----------
  1731|         0|            0|            0|  0.00%|    function : callable
  1732|         0|            0|            0|  0.00%|        The function is called with N parameters, where N is the rank of
  1733|         0|            0|            0|  0.00%|        `shape`.  Each parameter represents the coordinates of the array
  1734|         0|            0|            0|  0.00%|        varying along a specific axis.  For example, if `shape`
  1735|         0|            0|            0|  0.00%|        were ``(2, 2)``, then the parameters would be
  1736|         0|            0|            0|  0.00%|        ``array([[0, 0], [1, 1]])`` and ``array([[0, 1], [0, 1]])``
  1737|         0|            0|            0|  0.00%|    shape : (N,) tuple of ints
  1738|         0|            0|            0|  0.00%|        Shape of the output array, which also determines the shape of
  1739|         0|            0|            0|  0.00%|        the coordinate arrays passed to `function`.
  1740|         0|            0|            0|  0.00%|    dtype : data-type, optional
  1741|         0|            0|            0|  0.00%|        Data-type of the coordinate arrays passed to `function`.
  1742|         0|            0|            0|  0.00%|        By default, `dtype` is float.
  1743|         0|            0|            0|  0.00%|
  1744|         0|            0|            0|  0.00%|    Returns
  1745|         0|            0|            0|  0.00%|    -------
  1746|         0|            0|            0|  0.00%|    fromfunction : any
  1747|         0|            0|            0|  0.00%|        The result of the call to `function` is passed back directly.
  1748|         0|            0|            0|  0.00%|        Therefore the shape of `fromfunction` is completely determined by
  1749|         0|            0|            0|  0.00%|        `function`.  If `function` returns a scalar value, the shape of
  1750|         0|            0|            0|  0.00%|        `fromfunction` would not match the `shape` parameter.
  1751|         0|            0|            0|  0.00%|
  1752|         0|            0|            0|  0.00%|    See Also
  1753|         0|            0|            0|  0.00%|    --------
  1754|         0|            0|            0|  0.00%|    indices, meshgrid
  1755|         0|            0|            0|  0.00%|
  1756|         0|            0|            0|  0.00%|    Notes
  1757|         0|            0|            0|  0.00%|    -----
  1758|         0|            0|            0|  0.00%|    Keywords other than `dtype` are passed to `function`.
  1759|         0|            0|            0|  0.00%|
  1760|         0|            0|            0|  0.00%|    Examples
  1761|         0|            0|            0|  0.00%|    --------
  1762|         0|            0|            0|  0.00%|    >>> np.fromfunction(lambda i, j: i == j, (3, 3), dtype=int)
  1763|         0|            0|            0|  0.00%|    array([[ True, False, False],
  1764|         0|            0|            0|  0.00%|           [False,  True, False],
  1765|         0|            0|            0|  0.00%|           [False, False,  True]])
  1766|         0|            0|            0|  0.00%|
  1767|         0|            0|            0|  0.00%|    >>> np.fromfunction(lambda i, j: i + j, (3, 3), dtype=int)
  1768|         0|            0|            0|  0.00%|    array([[0, 1, 2],
  1769|         0|            0|            0|  0.00%|           [1, 2, 3],
  1770|         0|            0|            0|  0.00%|           [2, 3, 4]])
  1771|         0|            0|            0|  0.00%|
  1772|         0|            0|            0|  0.00%|    """
  1773|         0|            0|            0|  0.00%|    dtype = kwargs.pop('dtype', float)
  1774|         0|            0|            0|  0.00%|    args = indices(shape, dtype=dtype)
  1775|         0|            0|            0|  0.00%|    return function(*args, **kwargs)
  1776|         0|            0|            0|  0.00%|
  1777|         0|            0|            0|  0.00%|
  1778|         0|            0|            0|  0.00%|def _frombuffer(buf, dtype, shape, order):
  1779|         0|            0|            0|  0.00%|    return frombuffer(buf, dtype=dtype).reshape(shape, order=order)
  1780|         0|            0|            0|  0.00%|
  1781|         0|            0|            0|  0.00%|
  1782|         1|  7.39098e-06|  7.39098e-06|  0.00%|@set_module('numpy')
  1783|         0|            0|            0|  0.00%|def isscalar(num):
  1784|         0|            0|            0|  0.00%|    """
  1785|         0|            0|            0|  0.00%|    Returns True if the type of `num` is a scalar type.
  1786|         0|            0|            0|  0.00%|
  1787|         0|            0|            0|  0.00%|    Parameters
  1788|         0|            0|            0|  0.00%|    ----------
  1789|         0|            0|            0|  0.00%|    num : any
  1790|         0|            0|            0|  0.00%|        Input argument, can be of any type and shape.
  1791|         0|            0|            0|  0.00%|
  1792|         0|            0|            0|  0.00%|    Returns
  1793|         0|            0|            0|  0.00%|    -------
  1794|         0|            0|            0|  0.00%|    val : bool
  1795|         0|            0|            0|  0.00%|        True if `num` is a scalar type, False if it is not.
  1796|         0|            0|            0|  0.00%|
  1797|         0|            0|            0|  0.00%|    See Also
  1798|         0|            0|            0|  0.00%|    --------
  1799|         0|            0|            0|  0.00%|    ndim : Get the number of dimensions of an array
  1800|         0|            0|            0|  0.00%|
  1801|         0|            0|            0|  0.00%|    Notes
  1802|         0|            0|            0|  0.00%|    -----
  1803|         0|            0|            0|  0.00%|    In almost all cases ``np.ndim(x) == 0`` should be used instead of this
  1804|         0|            0|            0|  0.00%|    function, as that will also return true for 0d arrays. This is how
  1805|         0|            0|            0|  0.00%|    numpy overloads functions in the style of the ``dx`` arguments to `gradient`
  1806|         0|            0|            0|  0.00%|    and the ``bins`` argument to `histogram`. Some key differences:
  1807|         0|            0|            0|  0.00%|
  1808|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1809|         0|            0|            0|  0.00%|    | x                                    |``isscalar(x)``|``np.ndim(x) == 0``|
  1810|         0|            0|            0|  0.00%|    +======================================+===============+===================+
  1811|         0|            0|            0|  0.00%|    | PEP 3141 numeric objects (including  | ``True``      | ``True``          |
  1812|         0|            0|            0|  0.00%|    | builtins)                            |               |                   |
  1813|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1814|         0|            0|            0|  0.00%|    | builtin string and buffer objects    | ``True``      | ``True``          |
  1815|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1816|         0|            0|            0|  0.00%|    | other builtin objects, like          | ``False``     | ``True``          |
  1817|         0|            0|            0|  0.00%|    | `pathlib.Path`, `Exception`,         |               |                   |
  1818|         0|            0|            0|  0.00%|    | the result of `re.compile`           |               |                   |
  1819|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1820|         0|            0|            0|  0.00%|    | third-party objects like             | ``False``     | ``True``          |
  1821|         0|            0|            0|  0.00%|    | `matplotlib.figure.Figure`           |               |                   |
  1822|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1823|         0|            0|            0|  0.00%|    | zero-dimensional numpy arrays        | ``False``     | ``True``          |
  1824|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1825|         0|            0|            0|  0.00%|    | other numpy arrays                   | ``False``     | ``False``         |
  1826|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1827|         0|            0|            0|  0.00%|    | `list`, `tuple`, and other sequence  | ``False``     | ``False``         |
  1828|         0|            0|            0|  0.00%|    | objects                              |               |                   |
  1829|         0|            0|            0|  0.00%|    +--------------------------------------+---------------+-------------------+
  1830|         0|            0|            0|  0.00%|
  1831|         0|            0|            0|  0.00%|    Examples
  1832|         0|            0|            0|  0.00%|    --------
  1833|         0|            0|            0|  0.00%|    >>> np.isscalar(3.1)
  1834|         0|            0|            0|  0.00%|    True
  1835|         0|            0|            0|  0.00%|    >>> np.isscalar(np.array(3.1))
  1836|         0|            0|            0|  0.00%|    False
  1837|         0|            0|            0|  0.00%|    >>> np.isscalar([3.1])
  1838|         0|            0|            0|  0.00%|    False
  1839|         0|            0|            0|  0.00%|    >>> np.isscalar(False)
  1840|         0|            0|            0|  0.00%|    True
  1841|         0|            0|            0|  0.00%|    >>> np.isscalar('numpy')
  1842|         0|            0|            0|  0.00%|    True
  1843|         0|            0|            0|  0.00%|
  1844|         0|            0|            0|  0.00%|    NumPy supports PEP 3141 numbers:
  1845|         0|            0|            0|  0.00%|
  1846|         0|            0|            0|  0.00%|    >>> from fractions import Fraction
  1847|         0|            0|            0|  0.00%|    >>> np.isscalar(Fraction(5, 17))
  1848|         0|            0|            0|  0.00%|    True
  1849|         0|            0|            0|  0.00%|    >>> from numbers import Number
  1850|         0|            0|            0|  0.00%|    >>> np.isscalar(Number())
  1851|         0|            0|            0|  0.00%|    True
  1852|         0|            0|            0|  0.00%|
  1853|         0|            0|            0|  0.00%|    """
  1854|         1|  1.00136e-05|  1.00136e-05|  0.00%|    return (isinstance(num, generic)
  1855|         0|            0|            0|  0.00%|            or type(num) in ScalarType
  1856|         0|            0|            0|  0.00%|            or isinstance(num, numbers.Number))
  1857|         0|            0|            0|  0.00%|
  1858|         0|            0|            0|  0.00%|
  1859|         0|            0|            0|  0.00%|@set_module('numpy')
  1860|         0|            0|            0|  0.00%|def binary_repr(num, width=None):
  1861|         0|            0|            0|  0.00%|    """
  1862|         0|            0|            0|  0.00%|    Return the binary representation of the input number as a string.
  1863|         0|            0|            0|  0.00%|
  1864|         0|            0|            0|  0.00%|    For negative numbers, if width is not given, a minus sign is added to the
  1865|         0|            0|            0|  0.00%|    front. If width is given, the two's complement of the number is
  1866|         0|            0|            0|  0.00%|    returned, with respect to that width.
  1867|         0|            0|            0|  0.00%|
  1868|         0|            0|            0|  0.00%|    In a two's-complement system negative numbers are represented by the two's
  1869|         0|            0|            0|  0.00%|    complement of the absolute value. This is the most common method of
  1870|         0|            0|            0|  0.00%|    representing signed integers on computers [1]_. A N-bit two's-complement
  1871|         0|            0|            0|  0.00%|    system can represent every integer in the range
  1872|         0|            0|            0|  0.00%|    :math:`-2^{N-1}` to :math:`+2^{N-1}-1`.
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|    Parameters
  1875|         0|            0|            0|  0.00%|    ----------
  1876|         0|            0|            0|  0.00%|    num : int
  1877|         0|            0|            0|  0.00%|        Only an integer decimal number can be used.
  1878|         0|            0|            0|  0.00%|    width : int, optional
  1879|         0|            0|            0|  0.00%|        The length of the returned string if `num` is positive, or the length
  1880|         0|            0|            0|  0.00%|        of the two's complement if `num` is negative, provided that `width` is
  1881|         0|            0|            0|  0.00%|        at least a sufficient number of bits for `num` to be represented in the
  1882|         0|            0|            0|  0.00%|        designated form.
  1883|         0|            0|            0|  0.00%|
  1884|         0|            0|            0|  0.00%|        If the `width` value is insufficient, it will be ignored, and `num` will
  1885|         0|            0|            0|  0.00%|        be returned in binary (`num` > 0) or two's complement (`num` < 0) form
  1886|         0|            0|            0|  0.00%|        with its width equal to the minimum number of bits needed to represent
  1887|         0|            0|            0|  0.00%|        the number in the designated form. This behavior is deprecated and will
  1888|         0|            0|            0|  0.00%|        later raise an error.
  1889|         0|            0|            0|  0.00%|
  1890|         0|            0|            0|  0.00%|        .. deprecated:: 1.12.0
  1891|         0|            0|            0|  0.00%|
  1892|         0|            0|            0|  0.00%|    Returns
  1893|         0|            0|            0|  0.00%|    -------
  1894|         0|            0|            0|  0.00%|    bin : str
  1895|         0|            0|            0|  0.00%|        Binary representation of `num` or two's complement of `num`.
  1896|         0|            0|            0|  0.00%|
  1897|         0|            0|            0|  0.00%|    See Also
  1898|         0|            0|            0|  0.00%|    --------
  1899|         0|            0|            0|  0.00%|    base_repr: Return a string representation of a number in the given base
  1900|         0|            0|            0|  0.00%|               system.
  1901|         0|            0|            0|  0.00%|    bin: Python's built-in binary representation generator of an integer.
  1902|         0|            0|            0|  0.00%|
  1903|         0|            0|            0|  0.00%|    Notes
  1904|         0|            0|            0|  0.00%|    -----
  1905|         0|            0|            0|  0.00%|    `binary_repr` is equivalent to using `base_repr` with base 2, but about 25x
  1906|         0|            0|            0|  0.00%|    faster.
  1907|         0|            0|            0|  0.00%|
  1908|         0|            0|            0|  0.00%|    References
  1909|         0|            0|            0|  0.00%|    ----------
  1910|         0|            0|            0|  0.00%|    .. [1] Wikipedia, "Two's complement",
  1911|         0|            0|            0|  0.00%|        https://en.wikipedia.org/wiki/Two's_complement
  1912|         0|            0|            0|  0.00%|
  1913|         0|            0|            0|  0.00%|    Examples
  1914|         0|            0|            0|  0.00%|    --------
  1915|         0|            0|            0|  0.00%|    >>> np.binary_repr(3)
  1916|         0|            0|            0|  0.00%|    '11'
  1917|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3)
  1918|         0|            0|            0|  0.00%|    '-11'
  1919|         0|            0|            0|  0.00%|    >>> np.binary_repr(3, width=4)
  1920|         0|            0|            0|  0.00%|    '0011'
  1921|         0|            0|            0|  0.00%|
  1922|         0|            0|            0|  0.00%|    The two's complement is returned when the input number is negative and
  1923|         0|            0|            0|  0.00%|    width is specified:
  1924|         0|            0|            0|  0.00%|
  1925|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3, width=3)
  1926|         0|            0|            0|  0.00%|    '101'
  1927|         0|            0|            0|  0.00%|    >>> np.binary_repr(-3, width=5)
  1928|         0|            0|            0|  0.00%|    '11101'
  1929|         0|            0|            0|  0.00%|
  1930|         0|            0|            0|  0.00%|    """
  1931|         0|            0|            0|  0.00%|    def warn_if_insufficient(width, binwidth):
  1932|         0|            0|            0|  0.00%|        if width is not None and width < binwidth:
  1933|         0|            0|            0|  0.00%|            warnings.warn(
  1934|         0|            0|            0|  0.00%|                "Insufficient bit width provided. This behavior "
  1935|         0|            0|            0|  0.00%|                "will raise an error in the future.", DeprecationWarning,
  1936|         0|            0|            0|  0.00%|                stacklevel=3)
  1937|         0|            0|            0|  0.00%|
  1938|         0|            0|            0|  0.00%|    if num == 0:
  1939|         0|            0|            0|  0.00%|        return '0' * (width or 1)
  1940|         0|            0|            0|  0.00%|
  1941|         0|            0|            0|  0.00%|    elif num > 0:
  1942|         0|            0|            0|  0.00%|        binary = bin(num)[2:]
  1943|         0|            0|            0|  0.00%|        binwidth = len(binary)
  1944|         0|            0|            0|  0.00%|        outwidth = (binwidth if width is None
  1945|         0|            0|            0|  0.00%|                    else max(binwidth, width))
  1946|         0|            0|            0|  0.00%|        warn_if_insufficient(width, binwidth)
  1947|         0|            0|            0|  0.00%|        return binary.zfill(outwidth)
  1948|         0|            0|            0|  0.00%|
  1949|         0|            0|            0|  0.00%|    else:
  1950|         0|            0|            0|  0.00%|        if width is None:
  1951|         0|            0|            0|  0.00%|            return '-' + bin(-num)[2:]
  1952|         0|            0|            0|  0.00%|
  1953|         0|            0|            0|  0.00%|        else:
  1954|         0|            0|            0|  0.00%|            poswidth = len(bin(-num)[2:])
  1955|         0|            0|            0|  0.00%|
  1956|         0|            0|            0|  0.00%|            # See gh-8679: remove extra digit
  1957|         0|            0|            0|  0.00%|            # for numbers at boundaries.
  1958|         0|            0|            0|  0.00%|            if 2**(poswidth - 1) == -num:
  1959|         0|            0|            0|  0.00%|                poswidth -= 1
  1960|         0|            0|            0|  0.00%|
  1961|         0|            0|            0|  0.00%|            twocomp = 2**(poswidth + 1) + num
  1962|         0|            0|            0|  0.00%|            binary = bin(twocomp)[2:]
  1963|         0|            0|            0|  0.00%|            binwidth = len(binary)
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|            outwidth = max(binwidth, width)
  1966|         0|            0|            0|  0.00%|            warn_if_insufficient(width, binwidth)
  1967|         0|            0|            0|  0.00%|            return '1' * (outwidth - binwidth) + binary
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|
  1970|         0|            0|            0|  0.00%|@set_module('numpy')
  1971|         0|            0|            0|  0.00%|def base_repr(number, base=2, padding=0):
  1972|         0|            0|            0|  0.00%|    """
  1973|         0|            0|            0|  0.00%|    Return a string representation of a number in the given base system.
  1974|         0|            0|            0|  0.00%|
  1975|         0|            0|            0|  0.00%|    Parameters
  1976|         0|            0|            0|  0.00%|    ----------
  1977|         0|            0|            0|  0.00%|    number : int
  1978|         0|            0|            0|  0.00%|        The value to convert. Positive and negative values are handled.
  1979|         0|            0|            0|  0.00%|    base : int, optional
  1980|         0|            0|            0|  0.00%|        Convert `number` to the `base` number system. The valid range is 2-36,
  1981|         0|            0|            0|  0.00%|        the default value is 2.
  1982|         0|            0|            0|  0.00%|    padding : int, optional
  1983|         0|            0|            0|  0.00%|        Number of zeros padded on the left. Default is 0 (no padding).
  1984|         0|            0|            0|  0.00%|
  1985|         0|            0|            0|  0.00%|    Returns
  1986|         0|            0|            0|  0.00%|    -------
  1987|         0|            0|            0|  0.00%|    out : str
  1988|         0|            0|            0|  0.00%|        String representation of `number` in `base` system.
  1989|         0|            0|            0|  0.00%|
  1990|         0|            0|            0|  0.00%|    See Also
  1991|         0|            0|            0|  0.00%|    --------
  1992|         0|            0|            0|  0.00%|    binary_repr : Faster version of `base_repr` for base 2.
  1993|         0|            0|            0|  0.00%|
  1994|         0|            0|            0|  0.00%|    Examples
  1995|         0|            0|            0|  0.00%|    --------
  1996|         0|            0|            0|  0.00%|    >>> np.base_repr(5)
  1997|         0|            0|            0|  0.00%|    '101'
  1998|         0|            0|            0|  0.00%|    >>> np.base_repr(6, 5)
  1999|         0|            0|            0|  0.00%|    '11'
  2000|         0|            0|            0|  0.00%|    >>> np.base_repr(7, base=5, padding=3)
  2001|         0|            0|            0|  0.00%|    '00012'
  2002|         0|            0|            0|  0.00%|
  2003|         0|            0|            0|  0.00%|    >>> np.base_repr(10, base=16)
  2004|         0|            0|            0|  0.00%|    'A'
  2005|         0|            0|            0|  0.00%|    >>> np.base_repr(32, base=16)
  2006|         0|            0|            0|  0.00%|    '20'
  2007|         0|            0|            0|  0.00%|
  2008|         0|            0|            0|  0.00%|    """
  2009|         0|            0|            0|  0.00%|    digits = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ'
  2010|         0|            0|            0|  0.00%|    if base > len(digits):
  2011|         0|            0|            0|  0.00%|        raise ValueError("Bases greater than 36 not handled in base_repr.")
  2012|         0|            0|            0|  0.00%|    elif base < 2:
  2013|         0|            0|            0|  0.00%|        raise ValueError("Bases less than 2 not handled in base_repr.")
  2014|         0|            0|            0|  0.00%|
  2015|         0|            0|            0|  0.00%|    num = abs(number)
  2016|         0|            0|            0|  0.00%|    res = []
  2017|         0|            0|            0|  0.00%|    while num:
  2018|         0|            0|            0|  0.00%|        res.append(digits[num % base])
  2019|         0|            0|            0|  0.00%|        num //= base
  2020|         0|            0|            0|  0.00%|    if padding:
  2021|         0|            0|            0|  0.00%|        res.append('0' * padding)
  2022|         0|            0|            0|  0.00%|    if number < 0:
  2023|         0|            0|            0|  0.00%|        res.append('-')
  2024|         0|            0|            0|  0.00%|    return ''.join(reversed(res or '0'))
  2025|         0|            0|            0|  0.00%|
  2026|         0|            0|            0|  0.00%|
  2027|         0|            0|            0|  0.00%|def load(file):
  2028|         0|            0|            0|  0.00%|    """
  2029|         0|            0|            0|  0.00%|    Wrapper around cPickle.load which accepts either a file-like object or
  2030|         0|            0|            0|  0.00%|    a filename.
  2031|         0|            0|            0|  0.00%|
  2032|         0|            0|            0|  0.00%|    Note that the NumPy binary format is not based on pickle/cPickle anymore.
  2033|         0|            0|            0|  0.00%|    For details on the preferred way of loading and saving files, see `load`
  2034|         0|            0|            0|  0.00%|    and `save`.
  2035|         0|            0|            0|  0.00%|
  2036|         0|            0|            0|  0.00%|    See Also
  2037|         0|            0|            0|  0.00%|    --------
  2038|         0|            0|            0|  0.00%|    load, save
  2039|         0|            0|            0|  0.00%|
  2040|         0|            0|            0|  0.00%|    """
  2041|         0|            0|            0|  0.00%|    # NumPy 1.15.0, 2017-12-10
  2042|         0|            0|            0|  0.00%|    warnings.warn(
  2043|         0|            0|            0|  0.00%|        "np.core.numeric.load is deprecated, use pickle.load instead",
  2044|         0|            0|            0|  0.00%|        DeprecationWarning, stacklevel=2)
  2045|         0|            0|            0|  0.00%|    if isinstance(file, type("")):
  2046|         0|            0|            0|  0.00%|        with open(file, "rb") as file_pointer:
  2047|         0|            0|            0|  0.00%|            return pickle.load(file_pointer)
  2048|         0|            0|            0|  0.00%|    return pickle.load(file)
  2049|         0|            0|            0|  0.00%|
  2050|         0|            0|            0|  0.00%|
  2051|         0|            0|            0|  0.00%|# These are all essentially abbreviations
  2052|         0|            0|            0|  0.00%|# These might wind up in a special abbreviations module
  2053|         0|            0|            0|  0.00%|
  2054|         0|            0|            0|  0.00%|
  2055|         0|            0|            0|  0.00%|def _maketup(descr, val):
  2056|         0|            0|            0|  0.00%|    dt = dtype(descr)
  2057|         0|            0|            0|  0.00%|    # Place val in all scalar tuples:
  2058|         0|            0|            0|  0.00%|    fields = dt.fields
  2059|         0|            0|            0|  0.00%|    if fields is None:
  2060|         0|            0|            0|  0.00%|        return val
  2061|         0|            0|            0|  0.00%|    else:
  2062|         0|            0|            0|  0.00%|        res = [_maketup(fields[name][0], val) for name in dt.names]
  2063|         0|            0|            0|  0.00%|        return tuple(res)
  2064|         0|            0|            0|  0.00%|
  2065|         0|            0|            0|  0.00%|
  2066|         0|            0|            0|  0.00%|@set_module('numpy')
  2067|         0|            0|            0|  0.00%|def identity(n, dtype=None):
  2068|         0|            0|            0|  0.00%|    """
  2069|         0|            0|            0|  0.00%|    Return the identity array.
  2070|         0|            0|            0|  0.00%|
  2071|         0|            0|            0|  0.00%|    The identity array is a square array with ones on
  2072|         0|            0|            0|  0.00%|    the main diagonal.
  2073|         0|            0|            0|  0.00%|
  2074|         0|            0|            0|  0.00%|    Parameters
  2075|         0|            0|            0|  0.00%|    ----------
  2076|         0|            0|            0|  0.00%|    n : int
  2077|         0|            0|            0|  0.00%|        Number of rows (and columns) in `n` x `n` output.
  2078|         0|            0|            0|  0.00%|    dtype : data-type, optional
  2079|         0|            0|            0|  0.00%|        Data-type of the output.  Defaults to ``float``.
  2080|         0|            0|            0|  0.00%|
  2081|         0|            0|            0|  0.00%|    Returns
  2082|         0|            0|            0|  0.00%|    -------
  2083|         0|            0|            0|  0.00%|    out : ndarray
  2084|         0|            0|            0|  0.00%|        `n` x `n` array with its main diagonal set to one,
  2085|         0|            0|            0|  0.00%|        and all other elements 0.
  2086|         0|            0|            0|  0.00%|
  2087|         0|            0|            0|  0.00%|    Examples
  2088|         0|            0|            0|  0.00%|    --------
  2089|         0|            0|            0|  0.00%|    >>> np.identity(3)
  2090|         0|            0|            0|  0.00%|    array([[1.,  0.,  0.],
  2091|         0|            0|            0|  0.00%|           [0.,  1.,  0.],
  2092|         0|            0|            0|  0.00%|           [0.,  0.,  1.]])
  2093|         0|            0|            0|  0.00%|
  2094|         0|            0|            0|  0.00%|    """
  2095|         0|            0|            0|  0.00%|    from numpy import eye
  2096|         0|            0|            0|  0.00%|    return eye(n, dtype=dtype)
  2097|         0|            0|            0|  0.00%|
  2098|         0|            0|            0|  0.00%|
  2099|         0|            0|            0|  0.00%|def _allclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
  2100|         0|            0|            0|  0.00%|    return (a, b)
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|
  2103|         0|            0|            0|  0.00%|@array_function_dispatch(_allclose_dispatcher)
  2104|         0|            0|            0|  0.00%|def allclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
  2105|         0|            0|            0|  0.00%|    """
  2106|         0|            0|            0|  0.00%|    Returns True if two arrays are element-wise equal within a tolerance.
  2107|         0|            0|            0|  0.00%|
  2108|         0|            0|            0|  0.00%|    The tolerance values are positive, typically very small numbers.  The
  2109|         0|            0|            0|  0.00%|    relative difference (`rtol` * abs(`b`)) and the absolute difference
  2110|         0|            0|            0|  0.00%|    `atol` are added together to compare against the absolute difference
  2111|         0|            0|            0|  0.00%|    between `a` and `b`.
  2112|         0|            0|            0|  0.00%|
  2113|         0|            0|            0|  0.00%|    If either array contains one or more NaNs, False is returned.
  2114|         0|            0|            0|  0.00%|    Infs are treated as equal if they are in the same place and of the same
  2115|         0|            0|            0|  0.00%|    sign in both arrays.
  2116|         0|            0|            0|  0.00%|
  2117|         0|            0|            0|  0.00%|    Parameters
  2118|         0|            0|            0|  0.00%|    ----------
  2119|         0|            0|            0|  0.00%|    a, b : array_like
  2120|         0|            0|            0|  0.00%|        Input arrays to compare.
  2121|         0|            0|            0|  0.00%|    rtol : float
  2122|         0|            0|            0|  0.00%|        The relative tolerance parameter (see Notes).
  2123|         0|            0|            0|  0.00%|    atol : float
  2124|         0|            0|            0|  0.00%|        The absolute tolerance parameter (see Notes).
  2125|         0|            0|            0|  0.00%|    equal_nan : bool
  2126|         0|            0|            0|  0.00%|        Whether to compare NaN's as equal.  If True, NaN's in `a` will be
  2127|         0|            0|            0|  0.00%|        considered equal to NaN's in `b` in the output array.
  2128|         0|            0|            0|  0.00%|
  2129|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  2130|         0|            0|            0|  0.00%|
  2131|         0|            0|            0|  0.00%|    Returns
  2132|         0|            0|            0|  0.00%|    -------
  2133|         0|            0|            0|  0.00%|    allclose : bool
  2134|         0|            0|            0|  0.00%|        Returns True if the two arrays are equal within the given
  2135|         0|            0|            0|  0.00%|        tolerance; False otherwise.
  2136|         0|            0|            0|  0.00%|
  2137|         0|            0|            0|  0.00%|    See Also
  2138|         0|            0|            0|  0.00%|    --------
  2139|         0|            0|            0|  0.00%|    isclose, all, any, equal
  2140|         0|            0|            0|  0.00%|
  2141|         0|            0|            0|  0.00%|    Notes
  2142|         0|            0|            0|  0.00%|    -----
  2143|         0|            0|            0|  0.00%|    If the following equation is element-wise True, then allclose returns
  2144|         0|            0|            0|  0.00%|    True.
  2145|         0|            0|            0|  0.00%|
  2146|         0|            0|            0|  0.00%|     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
  2147|         0|            0|            0|  0.00%|
  2148|         0|            0|            0|  0.00%|    The above equation is not symmetric in `a` and `b`, so that
  2149|         0|            0|            0|  0.00%|    ``allclose(a, b)`` might be different from ``allclose(b, a)`` in
  2150|         0|            0|            0|  0.00%|    some rare cases.
  2151|         0|            0|            0|  0.00%|
  2152|         0|            0|            0|  0.00%|    The comparison of `a` and `b` uses standard broadcasting, which
  2153|         0|            0|            0|  0.00%|    means that `a` and `b` need not have the same shape in order for
  2154|         0|            0|            0|  0.00%|    ``allclose(a, b)`` to evaluate to True.  The same is true for
  2155|         0|            0|            0|  0.00%|    `equal` but not `array_equal`.
  2156|         0|            0|            0|  0.00%|
  2157|         0|            0|            0|  0.00%|    Examples
  2158|         0|            0|            0|  0.00%|    --------
  2159|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-7], [1.00001e10,1e-8])
  2160|         0|            0|            0|  0.00%|    False
  2161|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-8], [1.00001e10,1e-9])
  2162|         0|            0|            0|  0.00%|    True
  2163|         0|            0|            0|  0.00%|    >>> np.allclose([1e10,1e-8], [1.0001e10,1e-9])
  2164|         0|            0|            0|  0.00%|    False
  2165|         0|            0|            0|  0.00%|    >>> np.allclose([1.0, np.nan], [1.0, np.nan])
  2166|         0|            0|            0|  0.00%|    False
  2167|         0|            0|            0|  0.00%|    >>> np.allclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
  2168|         0|            0|            0|  0.00%|    True
  2169|         0|            0|            0|  0.00%|
  2170|         0|            0|            0|  0.00%|    """
  2171|         0|            0|            0|  0.00%|    res = all(isclose(a, b, rtol=rtol, atol=atol, equal_nan=equal_nan))
  2172|         0|            0|            0|  0.00%|    return bool(res)
  2173|         0|            0|            0|  0.00%|
  2174|         0|            0|            0|  0.00%|
  2175|         0|            0|            0|  0.00%|def _isclose_dispatcher(a, b, rtol=None, atol=None, equal_nan=None):
  2176|         0|            0|            0|  0.00%|    return (a, b)
  2177|         0|            0|            0|  0.00%|
  2178|         0|            0|            0|  0.00%|
  2179|         0|            0|            0|  0.00%|@array_function_dispatch(_isclose_dispatcher)
  2180|         0|            0|            0|  0.00%|def isclose(a, b, rtol=1.e-5, atol=1.e-8, equal_nan=False):
  2181|         0|            0|            0|  0.00%|    """
  2182|         0|            0|            0|  0.00%|    Returns a boolean array where two arrays are element-wise equal within a
  2183|         0|            0|            0|  0.00%|    tolerance.
  2184|         0|            0|            0|  0.00%|
  2185|         0|            0|            0|  0.00%|    The tolerance values are positive, typically very small numbers.  The
  2186|         0|            0|            0|  0.00%|    relative difference (`rtol` * abs(`b`)) and the absolute difference
  2187|         0|            0|            0|  0.00%|    `atol` are added together to compare against the absolute difference
  2188|         0|            0|            0|  0.00%|    between `a` and `b`.
  2189|         0|            0|            0|  0.00%|
  2190|         0|            0|            0|  0.00%|    .. warning:: The default `atol` is not appropriate for comparing numbers
  2191|         0|            0|            0|  0.00%|                 that are much smaller than one (see Notes).
  2192|         0|            0|            0|  0.00%|
  2193|         0|            0|            0|  0.00%|    Parameters
  2194|         0|            0|            0|  0.00%|    ----------
  2195|         0|            0|            0|  0.00%|    a, b : array_like
  2196|         0|            0|            0|  0.00%|        Input arrays to compare.
  2197|         0|            0|            0|  0.00%|    rtol : float
  2198|         0|            0|            0|  0.00%|        The relative tolerance parameter (see Notes).
  2199|         0|            0|            0|  0.00%|    atol : float
  2200|         0|            0|            0|  0.00%|        The absolute tolerance parameter (see Notes).
  2201|         0|            0|            0|  0.00%|    equal_nan : bool
  2202|         0|            0|            0|  0.00%|        Whether to compare NaN's as equal.  If True, NaN's in `a` will be
  2203|         0|            0|            0|  0.00%|        considered equal to NaN's in `b` in the output array.
  2204|         0|            0|            0|  0.00%|
  2205|         0|            0|            0|  0.00%|    Returns
  2206|         0|            0|            0|  0.00%|    -------
  2207|         0|            0|            0|  0.00%|    y : array_like
  2208|         0|            0|            0|  0.00%|        Returns a boolean array of where `a` and `b` are equal within the
  2209|         0|            0|            0|  0.00%|        given tolerance. If both `a` and `b` are scalars, returns a single
  2210|         0|            0|            0|  0.00%|        boolean value.
  2211|         0|            0|            0|  0.00%|
  2212|         0|            0|            0|  0.00%|    See Also
  2213|         0|            0|            0|  0.00%|    --------
  2214|         0|            0|            0|  0.00%|    allclose
  2215|         0|            0|            0|  0.00%|
  2216|         0|            0|            0|  0.00%|    Notes
  2217|         0|            0|            0|  0.00%|    -----
  2218|         0|            0|            0|  0.00%|    .. versionadded:: 1.7.0
  2219|         0|            0|            0|  0.00%|
  2220|         0|            0|            0|  0.00%|    For finite values, isclose uses the following equation to test whether
  2221|         0|            0|            0|  0.00%|    two floating point values are equivalent.
  2222|         0|            0|            0|  0.00%|
  2223|         0|            0|            0|  0.00%|     absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
  2224|         0|            0|            0|  0.00%|
  2225|         0|            0|            0|  0.00%|    Unlike the built-in `math.isclose`, the above equation is not symmetric
  2226|         0|            0|            0|  0.00%|    in `a` and `b` -- it assumes `b` is the reference value -- so that
  2227|         0|            0|            0|  0.00%|    `isclose(a, b)` might be different from `isclose(b, a)`. Furthermore,
  2228|         0|            0|            0|  0.00%|    the default value of atol is not zero, and is used to determine what
  2229|         0|            0|            0|  0.00%|    small values should be considered close to zero. The default value is
  2230|         0|            0|            0|  0.00%|    appropriate for expected values of order unity: if the expected values
  2231|         0|            0|            0|  0.00%|    are significantly smaller than one, it can result in false positives.
  2232|         0|            0|            0|  0.00%|    `atol` should be carefully selected for the use case at hand. A zero value
  2233|         0|            0|            0|  0.00%|    for `atol` will result in `False` if either `a` or `b` is zero.
  2234|         0|            0|            0|  0.00%|
  2235|         0|            0|            0|  0.00%|    Examples
  2236|         0|            0|            0|  0.00%|    --------
  2237|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-7], [1.00001e10,1e-8])
  2238|         0|            0|            0|  0.00%|    array([ True, False])
  2239|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-8], [1.00001e10,1e-9])
  2240|         0|            0|            0|  0.00%|    array([ True, True])
  2241|         0|            0|            0|  0.00%|    >>> np.isclose([1e10,1e-8], [1.0001e10,1e-9])
  2242|         0|            0|            0|  0.00%|    array([False,  True])
  2243|         0|            0|            0|  0.00%|    >>> np.isclose([1.0, np.nan], [1.0, np.nan])
  2244|         0|            0|            0|  0.00%|    array([ True, False])
  2245|         0|            0|            0|  0.00%|    >>> np.isclose([1.0, np.nan], [1.0, np.nan], equal_nan=True)
  2246|         0|            0|            0|  0.00%|    array([ True, True])
  2247|         0|            0|            0|  0.00%|    >>> np.isclose([1e-8, 1e-7], [0.0, 0.0])
  2248|         0|            0|            0|  0.00%|    array([ True, False])
  2249|         0|            0|            0|  0.00%|    >>> np.isclose([1e-100, 1e-7], [0.0, 0.0], atol=0.0)
  2250|         0|            0|            0|  0.00%|    array([False, False])
  2251|         0|            0|            0|  0.00%|    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.0])
  2252|         0|            0|            0|  0.00%|    array([ True,  True])
  2253|         0|            0|            0|  0.00%|    >>> np.isclose([1e-10, 1e-10], [1e-20, 0.999999e-10], atol=0.0)
  2254|         0|            0|            0|  0.00%|    array([False,  True])
  2255|         0|            0|            0|  0.00%|    """
  2256|         0|            0|            0|  0.00%|    def within_tol(x, y, atol, rtol):
  2257|         0|            0|            0|  0.00%|        with errstate(invalid='ignore'):
  2258|         0|            0|            0|  0.00%|            return less_equal(abs(x-y), atol + rtol * abs(y))
  2259|         0|            0|            0|  0.00%|
  2260|         0|            0|            0|  0.00%|    x = asanyarray(a)
  2261|         0|            0|            0|  0.00%|    y = asanyarray(b)
  2262|         0|            0|            0|  0.00%|
  2263|         0|            0|            0|  0.00%|    # Make sure y is an inexact type to avoid bad behavior on abs(MIN_INT).
  2264|         0|            0|            0|  0.00%|    # This will cause casting of x later. Also, make sure to allow subclasses
  2265|         0|            0|            0|  0.00%|    # (e.g., for numpy.ma).
  2266|         0|            0|            0|  0.00%|    dt = multiarray.result_type(y, 1.)
  2267|         0|            0|            0|  0.00%|    y = array(y, dtype=dt, copy=False, subok=True)
  2268|         0|            0|            0|  0.00%|
  2269|         0|            0|            0|  0.00%|    xfin = isfinite(x)
  2270|         0|            0|            0|  0.00%|    yfin = isfinite(y)
  2271|         0|            0|            0|  0.00%|    if all(xfin) and all(yfin):
  2272|         0|            0|            0|  0.00%|        return within_tol(x, y, atol, rtol)
  2273|         0|            0|            0|  0.00%|    else:
  2274|         0|            0|            0|  0.00%|        finite = xfin & yfin
  2275|         0|            0|            0|  0.00%|        cond = zeros_like(finite, subok=True)
  2276|         0|            0|            0|  0.00%|        # Because we're using boolean indexing, x & y must be the same shape.
  2277|         0|            0|            0|  0.00%|        # Ideally, we'd just do x, y = broadcast_arrays(x, y). It's in
  2278|         0|            0|            0|  0.00%|        # lib.stride_tricks, though, so we can't import it here.
  2279|         0|            0|            0|  0.00%|        x = x * ones_like(cond)
  2280|         0|            0|            0|  0.00%|        y = y * ones_like(cond)
  2281|         0|            0|            0|  0.00%|        # Avoid subtraction with infinite/nan values...
  2282|         0|            0|            0|  0.00%|        cond[finite] = within_tol(x[finite], y[finite], atol, rtol)
  2283|         0|            0|            0|  0.00%|        # Check for equality of infinite values...
  2284|         0|            0|            0|  0.00%|        cond[~finite] = (x[~finite] == y[~finite])
  2285|         0|            0|            0|  0.00%|        if equal_nan:
  2286|         0|            0|            0|  0.00%|            # Make NaN == NaN
  2287|         0|            0|            0|  0.00%|            both_nan = isnan(x) & isnan(y)
  2288|         0|            0|            0|  0.00%|
  2289|         0|            0|            0|  0.00%|            # Needed to treat masked arrays correctly. = True would not work.
  2290|         0|            0|            0|  0.00%|            cond[both_nan] = both_nan[both_nan]
  2291|         0|            0|            0|  0.00%|
  2292|         0|            0|            0|  0.00%|        return cond[()]  # Flatten 0d arrays to scalars
  2293|         0|            0|            0|  0.00%|
  2294|         0|            0|            0|  0.00%|
  2295|         0|            0|            0|  0.00%|def _array_equal_dispatcher(a1, a2):
  2296|         0|            0|            0|  0.00%|    return (a1, a2)
  2297|         0|            0|            0|  0.00%|
  2298|         0|            0|            0|  0.00%|
  2299|         0|            0|            0|  0.00%|@array_function_dispatch(_array_equal_dispatcher)
  2300|         0|            0|            0|  0.00%|def array_equal(a1, a2):
  2301|         0|            0|            0|  0.00%|    """
  2302|         0|            0|            0|  0.00%|    True if two arrays have the same shape and elements, False otherwise.
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|    Parameters
  2305|         0|            0|            0|  0.00%|    ----------
  2306|         0|            0|            0|  0.00%|    a1, a2 : array_like
  2307|         0|            0|            0|  0.00%|        Input arrays.
  2308|         0|            0|            0|  0.00%|
  2309|         0|            0|            0|  0.00%|    Returns
  2310|         0|            0|            0|  0.00%|    -------
  2311|         0|            0|            0|  0.00%|    b : bool
  2312|         0|            0|            0|  0.00%|        Returns True if the arrays are equal.
  2313|         0|            0|            0|  0.00%|
  2314|         0|            0|            0|  0.00%|    See Also
  2315|         0|            0|            0|  0.00%|    --------
  2316|         0|            0|            0|  0.00%|    allclose: Returns True if two arrays are element-wise equal within a
  2317|         0|            0|            0|  0.00%|              tolerance.
  2318|         0|            0|            0|  0.00%|    array_equiv: Returns True if input arrays are shape consistent and all
  2319|         0|            0|            0|  0.00%|                 elements equal.
  2320|         0|            0|            0|  0.00%|
  2321|         0|            0|            0|  0.00%|    Examples
  2322|         0|            0|            0|  0.00%|    --------
  2323|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 2])
  2324|         0|            0|            0|  0.00%|    True
  2325|         0|            0|            0|  0.00%|    >>> np.array_equal(np.array([1, 2]), np.array([1, 2]))
  2326|         0|            0|            0|  0.00%|    True
  2327|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 2, 3])
  2328|         0|            0|            0|  0.00%|    False
  2329|         0|            0|            0|  0.00%|    >>> np.array_equal([1, 2], [1, 4])
  2330|         0|            0|            0|  0.00%|    False
  2331|         0|            0|            0|  0.00%|
  2332|         0|            0|            0|  0.00%|    """
  2333|         0|            0|            0|  0.00%|    try:
  2334|         0|            0|            0|  0.00%|        a1, a2 = asarray(a1), asarray(a2)
  2335|         0|            0|            0|  0.00%|    except Exception:
  2336|         0|            0|            0|  0.00%|        return False
  2337|         0|            0|            0|  0.00%|    if a1.shape != a2.shape:
  2338|         0|            0|            0|  0.00%|        return False
  2339|         0|            0|            0|  0.00%|    return bool(asarray(a1 == a2).all())
  2340|         0|            0|            0|  0.00%|
  2341|         0|            0|            0|  0.00%|
  2342|         0|            0|            0|  0.00%|def _array_equiv_dispatcher(a1, a2):
  2343|         0|            0|            0|  0.00%|    return (a1, a2)
  2344|         0|            0|            0|  0.00%|
  2345|         0|            0|            0|  0.00%|
  2346|         0|            0|            0|  0.00%|@array_function_dispatch(_array_equiv_dispatcher)
  2347|         0|            0|            0|  0.00%|def array_equiv(a1, a2):
  2348|         0|            0|            0|  0.00%|    """
  2349|         0|            0|            0|  0.00%|    Returns True if input arrays are shape consistent and all elements equal.
  2350|         0|            0|            0|  0.00%|
  2351|         0|            0|            0|  0.00%|    Shape consistent means they are either the same shape, or one input array
  2352|         0|            0|            0|  0.00%|    can be broadcasted to create the same shape as the other one.
  2353|         0|            0|            0|  0.00%|
  2354|         0|            0|            0|  0.00%|    Parameters
  2355|         0|            0|            0|  0.00%|    ----------
  2356|         0|            0|            0|  0.00%|    a1, a2 : array_like
  2357|         0|            0|            0|  0.00%|        Input arrays.
  2358|         0|            0|            0|  0.00%|
  2359|         0|            0|            0|  0.00%|    Returns
  2360|         0|            0|            0|  0.00%|    -------
  2361|         0|            0|            0|  0.00%|    out : bool
  2362|         0|            0|            0|  0.00%|        True if equivalent, False otherwise.
  2363|         0|            0|            0|  0.00%|
  2364|         0|            0|            0|  0.00%|    Examples
  2365|         0|            0|            0|  0.00%|    --------
  2366|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [1, 2])
  2367|         0|            0|            0|  0.00%|    True
  2368|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [1, 3])
  2369|         0|            0|            0|  0.00%|    False
  2370|         0|            0|            0|  0.00%|
  2371|         0|            0|            0|  0.00%|    Showing the shape equivalence:
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2], [1, 2]])
  2374|         0|            0|            0|  0.00%|    True
  2375|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2, 1, 2], [1, 2, 1, 2]])
  2376|         0|            0|            0|  0.00%|    False
  2377|         0|            0|            0|  0.00%|
  2378|         0|            0|            0|  0.00%|    >>> np.array_equiv([1, 2], [[1, 2], [1, 3]])
  2379|         0|            0|            0|  0.00%|    False
  2380|         0|            0|            0|  0.00%|
  2381|         0|            0|            0|  0.00%|    """
  2382|         0|            0|            0|  0.00%|    try:
  2383|         0|            0|            0|  0.00%|        a1, a2 = asarray(a1), asarray(a2)
  2384|         0|            0|            0|  0.00%|    except Exception:
  2385|         0|            0|            0|  0.00%|        return False
  2386|         0|            0|            0|  0.00%|    try:
  2387|         0|            0|            0|  0.00%|        multiarray.broadcast(a1, a2)
  2388|         0|            0|            0|  0.00%|    except Exception:
  2389|         0|            0|            0|  0.00%|        return False
  2390|         0|            0|            0|  0.00%|
  2391|         0|            0|            0|  0.00%|    return bool(asarray(a1 == a2).all())
  2392|         0|            0|            0|  0.00%|
  2393|         0|            0|            0|  0.00%|
  2394|         0|            0|            0|  0.00%|Inf = inf = infty = Infinity = PINF
  2395|         0|            0|            0|  0.00%|nan = NaN = NAN
  2396|         0|            0|            0|  0.00%|False_ = bool_(False)
  2397|         0|            0|            0|  0.00%|True_ = bool_(True)
  2398|         0|            0|            0|  0.00%|
  2399|         0|            0|            0|  0.00%|
  2400|         0|            0|            0|  0.00%|def extend_all(module):
  2401|         0|            0|            0|  0.00%|    existing = set(__all__)
  2402|         0|            0|            0|  0.00%|    mall = getattr(module, '__all__')
  2403|         0|            0|            0|  0.00%|    for a in mall:
  2404|         0|            0|            0|  0.00%|        if a not in existing:
  2405|         0|            0|            0|  0.00%|            __all__.append(a)
  2406|         0|            0|            0|  0.00%|
  2407|         0|            0|            0|  0.00%|
  2408|         0|            0|            0|  0.00%|from .umath import *
  2409|         0|            0|            0|  0.00%|from .numerictypes import *
  2410|         0|            0|            0|  0.00%|from . import fromnumeric
  2411|         0|            0|            0|  0.00%|from .fromnumeric import *
  2412|         0|            0|            0|  0.00%|from . import arrayprint
  2413|         0|            0|            0|  0.00%|from .arrayprint import *
  2414|         0|            0|            0|  0.00%|from . import _asarray
  2415|         0|            0|            0|  0.00%|from ._asarray import *
  2416|         0|            0|            0|  0.00%|from . import _ufunc_config
  2417|         0|            0|            0|  0.00%|from ._ufunc_config import *
  2418|         0|            0|            0|  0.00%|extend_all(fromnumeric)
  2419|         0|            0|            0|  0.00%|extend_all(umath)
  2420|         0|            0|            0|  0.00%|extend_all(numerictypes)
  2421|         0|            0|            0|  0.00%|extend_all(arrayprint)
  2422|         0|            0|            0|  0.00%|extend_all(_asarray)
  2423|         0|            0|            0|  0.00%|extend_all(_ufunc_config)
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_methods.py
File duration: 0.000164986s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|Array methods which are called by both the C-code for the method
     3|         0|            0|            0|  0.00%|and the Python code for the NumPy-namespace function
     4|         0|            0|            0|  0.00%|
     5|         0|            0|            0|  0.00%|"""
     6|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     7|         0|            0|            0|  0.00%|
     8|         0|            0|            0|  0.00%|import warnings
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|from numpy.core import multiarray as mu
    11|         0|            0|            0|  0.00%|from numpy.core import umath as um
    12|         0|            0|            0|  0.00%|from numpy.core._asarray import asanyarray
    13|         0|            0|            0|  0.00%|from numpy.core import numerictypes as nt
    14|         0|            0|            0|  0.00%|from numpy.core import _exceptions
    15|         0|            0|            0|  0.00%|from numpy._globals import _NoValue
    16|         0|            0|            0|  0.00%|from numpy.compat import pickle, os_fspath, contextlib_nullcontext
    17|         0|            0|            0|  0.00%|
    18|         0|            0|            0|  0.00%|# save those O(100) nanoseconds!
    19|         0|            0|            0|  0.00%|umr_maximum = um.maximum.reduce
    20|         0|            0|            0|  0.00%|umr_minimum = um.minimum.reduce
    21|         0|            0|            0|  0.00%|umr_sum = um.add.reduce
    22|         0|            0|            0|  0.00%|umr_prod = um.multiply.reduce
    23|         0|            0|            0|  0.00%|umr_any = um.logical_or.reduce
    24|         0|            0|            0|  0.00%|umr_all = um.logical_and.reduce
    25|         0|            0|            0|  0.00%|
    26|         0|            0|            0|  0.00%|# avoid keyword arguments to speed up parsing, saves about 15%-20% for very
    27|         0|            0|            0|  0.00%|# small reductions
    28|         0|            0|            0|  0.00%|def _amax(a, axis=None, out=None, keepdims=False,
    29|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    30|         0|            0|            0|  0.00%|    return umr_maximum(a, axis, None, out, keepdims, initial, where)
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|def _amin(a, axis=None, out=None, keepdims=False,
    33|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    34|         0|            0|            0|  0.00%|    return umr_minimum(a, axis, None, out, keepdims, initial, where)
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|def _sum(a, axis=None, dtype=None, out=None, keepdims=False,
    37|         0|            0|            0|  0.00%|         initial=_NoValue, where=True):
    38|         0|            0|            0|  0.00%|    return umr_sum(a, axis, dtype, out, keepdims, initial, where)
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|def _prod(a, axis=None, dtype=None, out=None, keepdims=False,
    41|         0|            0|            0|  0.00%|          initial=_NoValue, where=True):
    42|         0|            0|            0|  0.00%|    return umr_prod(a, axis, dtype, out, keepdims, initial, where)
    43|         0|            0|            0|  0.00%|
    44|         1|  3.33786e-06|  3.33786e-06|  0.00%|def _any(a, axis=None, dtype=None, out=None, keepdims=False):
    45|         1|   2.6226e-05|   2.6226e-05|  0.00%|    return umr_any(a, axis, dtype, out, keepdims)
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|def _all(a, axis=None, dtype=None, out=None, keepdims=False):
    48|         0|            0|            0|  0.00%|    return umr_all(a, axis, dtype, out, keepdims)
    49|         0|            0|            0|  0.00%|
    50|         1|  4.52995e-06|  4.52995e-06|  0.00%|def _count_reduce_items(arr, axis):
    51|         1|  6.91414e-06|  6.91414e-06|  0.00%|    if axis is None:
    52|         0|            0|            0|  0.00%|        axis = tuple(range(arr.ndim))
    53|         1|  5.96046e-06|  5.96046e-06|  0.00%|    if not isinstance(axis, tuple):
    54|         1|   3.8147e-06|   3.8147e-06|  0.00%|        axis = (axis,)
    55|         1|  3.57628e-06|  3.57628e-06|  0.00%|    items = 1
    56|         2|  7.15256e-06|  3.57628e-06|  0.00%|    for ax in axis:
    57|         1|  4.29153e-06|  4.29153e-06|  0.00%|        items *= arr.shape[ax]
    58|         1|  2.38419e-06|  2.38419e-06|  0.00%|    return items
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|# Numpy 1.17.0, 2019-02-24
    61|         0|            0|            0|  0.00%|# Various clip behavior deprecations, marked with _clip_dep as a prefix.
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|def _clip_dep_is_scalar_nan(a):
    64|         0|            0|            0|  0.00%|    # guarded to protect circular imports
    65|         0|            0|            0|  0.00%|    from numpy.core.fromnumeric import ndim
    66|         0|            0|            0|  0.00%|    if ndim(a) != 0:
    67|         0|            0|            0|  0.00%|        return False
    68|         0|            0|            0|  0.00%|    try:
    69|         0|            0|            0|  0.00%|        return um.isnan(a)
    70|         0|            0|            0|  0.00%|    except TypeError:
    71|         0|            0|            0|  0.00%|        return False
    72|         0|            0|            0|  0.00%|
    73|         0|            0|            0|  0.00%|def _clip_dep_is_byte_swapped(a):
    74|         0|            0|            0|  0.00%|    if isinstance(a, mu.ndarray):
    75|         0|            0|            0|  0.00%|        return not a.dtype.isnative
    76|         0|            0|            0|  0.00%|    return False
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|def _clip_dep_invoke_with_casting(ufunc, *args, out=None, casting=None, **kwargs):
    79|         0|            0|            0|  0.00%|    # normal path
    80|         0|            0|            0|  0.00%|    if casting is not None:
    81|         0|            0|            0|  0.00%|        return ufunc(*args, out=out, casting=casting, **kwargs)
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|    # try to deal with broken casting rules
    84|         0|            0|            0|  0.00%|    try:
    85|         0|            0|            0|  0.00%|        return ufunc(*args, out=out, **kwargs)
    86|         0|            0|            0|  0.00%|    except _exceptions._UFuncOutputCastingError as e:
    87|         0|            0|            0|  0.00%|        # Numpy 1.17.0, 2019-02-24
    88|         0|            0|            0|  0.00%|        warnings.warn(
    89|         0|            0|            0|  0.00%|            "Converting the output of clip from {!r} to {!r} is deprecated. "
    90|         0|            0|            0|  0.00%|            "Pass `casting=\"unsafe\"` explicitly to silence this warning, or "
    91|         0|            0|            0|  0.00%|            "correct the type of the variables.".format(e.from_, e.to),
    92|         0|            0|            0|  0.00%|            DeprecationWarning,
    93|         0|            0|            0|  0.00%|            stacklevel=2
    94|         0|            0|            0|  0.00%|        )
    95|         0|            0|            0|  0.00%|        return ufunc(*args, out=out, casting="unsafe", **kwargs)
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|def _clip(a, min=None, max=None, out=None, *, casting=None, **kwargs):
    98|         0|            0|            0|  0.00%|    if min is None and max is None:
    99|         0|            0|            0|  0.00%|        raise ValueError("One of max or min must be given")
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    # Numpy 1.17.0, 2019-02-24
   102|         0|            0|            0|  0.00%|    # This deprecation probably incurs a substantial slowdown for small arrays,
   103|         0|            0|            0|  0.00%|    # it will be good to get rid of it.
   104|         0|            0|            0|  0.00%|    if not _clip_dep_is_byte_swapped(a) and not _clip_dep_is_byte_swapped(out):
   105|         0|            0|            0|  0.00%|        using_deprecated_nan = False
   106|         0|            0|            0|  0.00%|        if _clip_dep_is_scalar_nan(min):
   107|         0|            0|            0|  0.00%|            min = -float('inf')
   108|         0|            0|            0|  0.00%|            using_deprecated_nan = True
   109|         0|            0|            0|  0.00%|        if _clip_dep_is_scalar_nan(max):
   110|         0|            0|            0|  0.00%|            max = float('inf')
   111|         0|            0|            0|  0.00%|            using_deprecated_nan = True
   112|         0|            0|            0|  0.00%|        if using_deprecated_nan:
   113|         0|            0|            0|  0.00%|            warnings.warn(
   114|         0|            0|            0|  0.00%|                "Passing `np.nan` to mean no clipping in np.clip has always "
   115|         0|            0|            0|  0.00%|                "been unreliable, and is now deprecated. "
   116|         0|            0|            0|  0.00%|                "In future, this will always return nan, like it already does "
   117|         0|            0|            0|  0.00%|                "when min or max are arrays that contain nan. "
   118|         0|            0|            0|  0.00%|                "To skip a bound, pass either None or an np.inf of an "
   119|         0|            0|            0|  0.00%|                "appropriate sign.",
   120|         0|            0|            0|  0.00%|                DeprecationWarning,
   121|         0|            0|            0|  0.00%|                stacklevel=2
   122|         0|            0|            0|  0.00%|            )
   123|         0|            0|            0|  0.00%|
   124|         0|            0|            0|  0.00%|    if min is None:
   125|         0|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
   126|         0|            0|            0|  0.00%|            um.minimum, a, max, out=out, casting=casting, **kwargs)
   127|         0|            0|            0|  0.00%|    elif max is None:
   128|         0|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
   129|         0|            0|            0|  0.00%|            um.maximum, a, min, out=out, casting=casting, **kwargs)
   130|         0|            0|            0|  0.00%|    else:
   131|         0|            0|            0|  0.00%|        return _clip_dep_invoke_with_casting(
   132|         0|            0|            0|  0.00%|            um.clip, a, min, max, out=out, casting=casting, **kwargs)
   133|         0|            0|            0|  0.00%|
   134|         1|  5.96046e-06|  5.96046e-06|  0.00%|def _mean(a, axis=None, dtype=None, out=None, keepdims=False):
   135|         1|  1.26362e-05|  1.26362e-05|  0.00%|    arr = asanyarray(a)
(call)|         1|  5.96046e-06|  5.96046e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_asarray.py:88 asanyarray
   136|         0|            0|            0|  0.00%|
   137|         1|  4.52995e-06|  4.52995e-06|  0.00%|    is_float16_result = False
   138|         1|  1.21593e-05|  1.21593e-05|  0.00%|    rcount = _count_reduce_items(arr, axis)
(call)|         1|  3.86238e-05|  3.86238e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/_methods.py:50 _count_reduce_items
   139|         0|            0|            0|  0.00%|    # Make this warning show up first
   140|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if rcount == 0:
   141|         0|            0|            0|  0.00%|        warnings.warn("Mean of empty slice.", RuntimeWarning, stacklevel=2)
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|    # Cast bool, unsigned int, and int to float64 by default
   144|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if dtype is None:
   145|         1|  5.48363e-06|  5.48363e-06|  0.00%|        if issubclass(arr.dtype.type, (nt.integer, nt.bool_)):
   146|         0|            0|            0|  0.00%|            dtype = mu.dtype('f8')
   147|         1|  6.67572e-06|  6.67572e-06|  0.00%|        elif issubclass(arr.dtype.type, nt.float16):
   148|         0|            0|            0|  0.00%|            dtype = mu.dtype('f4')
   149|         0|            0|            0|  0.00%|            is_float16_result = True
   150|         0|            0|            0|  0.00%|
   151|         1|  1.43051e-05|  1.43051e-05|  0.00%|    ret = umr_sum(arr, axis, dtype, out, keepdims)
   152|         1|  6.19888e-06|  6.19888e-06|  0.00%|    if isinstance(ret, mu.ndarray):
   153|         0|            0|            0|  0.00%|        ret = um.true_divide(
   154|         0|            0|            0|  0.00%|                ret, rcount, out=ret, casting='unsafe', subok=False)
   155|         0|            0|            0|  0.00%|        if is_float16_result and out is None:
   156|         0|            0|            0|  0.00%|            ret = arr.dtype.type(ret)
   157|         1|  4.76837e-06|  4.76837e-06|  0.00%|    elif hasattr(ret, 'dtype'):
   158|         1|  4.05312e-06|  4.05312e-06|  0.00%|        if is_float16_result:
   159|         0|            0|            0|  0.00%|            ret = arr.dtype.type(ret / rcount)
   160|         0|            0|            0|  0.00%|        else:
   161|         1|  7.39098e-06|  7.39098e-06|  0.00%|            ret = ret.dtype.type(ret / rcount)
   162|         0|            0|            0|  0.00%|    else:
   163|         0|            0|            0|  0.00%|        ret = ret / rcount
   164|         0|            0|            0|  0.00%|
   165|         1|  4.52995e-06|  4.52995e-06|  0.00%|    return ret
   166|         0|            0|            0|  0.00%|
   167|         0|            0|            0|  0.00%|def _var(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
   168|         0|            0|            0|  0.00%|    arr = asanyarray(a)
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|    rcount = _count_reduce_items(arr, axis)
   171|         0|            0|            0|  0.00%|    # Make this warning show up on top.
   172|         0|            0|            0|  0.00%|    if ddof >= rcount:
   173|         0|            0|            0|  0.00%|        warnings.warn("Degrees of freedom <= 0 for slice", RuntimeWarning,
   174|         0|            0|            0|  0.00%|                      stacklevel=2)
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    # Cast bool, unsigned int, and int to float64 by default
   177|         0|            0|            0|  0.00%|    if dtype is None and issubclass(arr.dtype.type, (nt.integer, nt.bool_)):
   178|         0|            0|            0|  0.00%|        dtype = mu.dtype('f8')
   179|         0|            0|            0|  0.00%|
   180|         0|            0|            0|  0.00%|    # Compute the mean.
   181|         0|            0|            0|  0.00%|    # Note that if dtype is not of inexact type then arraymean will
   182|         0|            0|            0|  0.00%|    # not be either.
   183|         0|            0|            0|  0.00%|    arrmean = umr_sum(arr, axis, dtype, keepdims=True)
   184|         0|            0|            0|  0.00%|    if isinstance(arrmean, mu.ndarray):
   185|         0|            0|            0|  0.00%|        arrmean = um.true_divide(
   186|         0|            0|            0|  0.00%|                arrmean, rcount, out=arrmean, casting='unsafe', subok=False)
   187|         0|            0|            0|  0.00%|    else:
   188|         0|            0|            0|  0.00%|        arrmean = arrmean.dtype.type(arrmean / rcount)
   189|         0|            0|            0|  0.00%|
   190|         0|            0|            0|  0.00%|    # Compute sum of squared deviations from mean
   191|         0|            0|            0|  0.00%|    # Note that x may not be inexact and that we need it to be an array,
   192|         0|            0|            0|  0.00%|    # not a scalar.
   193|         0|            0|            0|  0.00%|    x = asanyarray(arr - arrmean)
   194|         0|            0|            0|  0.00%|    if issubclass(arr.dtype.type, (nt.floating, nt.integer)):
   195|         0|            0|            0|  0.00%|        x = um.multiply(x, x, out=x)
   196|         0|            0|            0|  0.00%|    else:
   197|         0|            0|            0|  0.00%|        x = um.multiply(x, um.conjugate(x), out=x).real
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|    ret = umr_sum(x, axis, dtype, out, keepdims)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|    # Compute degrees of freedom and make sure it is not negative.
   202|         0|            0|            0|  0.00%|    rcount = max([rcount - ddof, 0])
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    # divide by degrees of freedom
   205|         0|            0|            0|  0.00%|    if isinstance(ret, mu.ndarray):
   206|         0|            0|            0|  0.00%|        ret = um.true_divide(
   207|         0|            0|            0|  0.00%|                ret, rcount, out=ret, casting='unsafe', subok=False)
   208|         0|            0|            0|  0.00%|    elif hasattr(ret, 'dtype'):
   209|         0|            0|            0|  0.00%|        ret = ret.dtype.type(ret / rcount)
   210|         0|            0|            0|  0.00%|    else:
   211|         0|            0|            0|  0.00%|        ret = ret / rcount
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    return ret
   214|         0|            0|            0|  0.00%|
   215|         0|            0|            0|  0.00%|def _std(a, axis=None, dtype=None, out=None, ddof=0, keepdims=False):
   216|         0|            0|            0|  0.00%|    ret = _var(a, axis=axis, dtype=dtype, out=out, ddof=ddof,
   217|         0|            0|            0|  0.00%|               keepdims=keepdims)
   218|         0|            0|            0|  0.00%|
   219|         0|            0|            0|  0.00%|    if isinstance(ret, mu.ndarray):
   220|         0|            0|            0|  0.00%|        ret = um.sqrt(ret, out=ret)
   221|         0|            0|            0|  0.00%|    elif hasattr(ret, 'dtype'):
   222|         0|            0|            0|  0.00%|        ret = ret.dtype.type(um.sqrt(ret))
   223|         0|            0|            0|  0.00%|    else:
   224|         0|            0|            0|  0.00%|        ret = um.sqrt(ret)
   225|         0|            0|            0|  0.00%|
   226|         0|            0|            0|  0.00%|    return ret
   227|         0|            0|            0|  0.00%|
   228|         0|            0|            0|  0.00%|def _ptp(a, axis=None, out=None, keepdims=False):
   229|         0|            0|            0|  0.00%|    return um.subtract(
   230|         0|            0|            0|  0.00%|        umr_maximum(a, axis, None, out, keepdims),
   231|         0|            0|            0|  0.00%|        umr_minimum(a, axis, None, None, keepdims),
   232|         0|            0|            0|  0.00%|        out
   233|         0|            0|            0|  0.00%|    )
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|def _dump(self, file, protocol=2):
   236|         0|            0|            0|  0.00%|    if hasattr(file, 'write'):
   237|         0|            0|            0|  0.00%|        ctx = contextlib_nullcontext(file)
   238|         0|            0|            0|  0.00%|    else:
   239|         0|            0|            0|  0.00%|        ctx = open(os_fspath(file), "wb")
   240|         0|            0|            0|  0.00%|    with ctx as f:
   241|         0|            0|            0|  0.00%|        pickle.dump(self, f, protocol=protocol)
   242|         0|            0|            0|  0.00%|
   243|         0|            0|            0|  0.00%|def _dumps(self, protocol=2):
   244|         0|            0|            0|  0.00%|    return pickle.dumps(self, protocol=protocol)
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numerictypes.py
File duration: 0.00013113s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|numerictypes: Define the numeric type objects
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|This module is designed so "from numerictypes import \\*" is safe.
     5|         0|            0|            0|  0.00%|Exported symbols include:
     6|         0|            0|            0|  0.00%|
     7|         0|            0|            0|  0.00%|  Dictionary with all registered number types (including aliases):
     8|         0|            0|            0|  0.00%|    typeDict
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|  Type objects (not all will be available, depends on platform):
    11|         0|            0|            0|  0.00%|      see variable sctypes for which ones you have
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|    Bit-width names
    14|         0|            0|            0|  0.00%|
    15|         0|            0|            0|  0.00%|    int8 int16 int32 int64 int128
    16|         0|            0|            0|  0.00%|    uint8 uint16 uint32 uint64 uint128
    17|         0|            0|            0|  0.00%|    float16 float32 float64 float96 float128 float256
    18|         0|            0|            0|  0.00%|    complex32 complex64 complex128 complex192 complex256 complex512
    19|         0|            0|            0|  0.00%|    datetime64 timedelta64
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|    c-based names
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|    bool_
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|    object_
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    void, str_, unicode_
    28|         0|            0|            0|  0.00%|
    29|         0|            0|            0|  0.00%|    byte, ubyte,
    30|         0|            0|            0|  0.00%|    short, ushort
    31|         0|            0|            0|  0.00%|    intc, uintc,
    32|         0|            0|            0|  0.00%|    intp, uintp,
    33|         0|            0|            0|  0.00%|    int_, uint,
    34|         0|            0|            0|  0.00%|    longlong, ulonglong,
    35|         0|            0|            0|  0.00%|
    36|         0|            0|            0|  0.00%|    single, csingle,
    37|         0|            0|            0|  0.00%|    float_, complex_,
    38|         0|            0|            0|  0.00%|    longfloat, clongfloat,
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|   As part of the type-hierarchy:    xx -- is bit-width
    41|         0|            0|            0|  0.00%|
    42|         0|            0|            0|  0.00%|   generic
    43|         0|            0|            0|  0.00%|     +-> bool_                                  (kind=b)
    44|         0|            0|            0|  0.00%|     +-> number
    45|         0|            0|            0|  0.00%|     |   +-> integer
    46|         0|            0|            0|  0.00%|     |   |   +-> signedinteger     (intxx)      (kind=i)
    47|         0|            0|            0|  0.00%|     |   |   |     byte
    48|         0|            0|            0|  0.00%|     |   |   |     short
    49|         0|            0|            0|  0.00%|     |   |   |     intc
    50|         0|            0|            0|  0.00%|     |   |   |     intp            int0
    51|         0|            0|            0|  0.00%|     |   |   |     int_
    52|         0|            0|            0|  0.00%|     |   |   |     longlong
    53|         0|            0|            0|  0.00%|     |   |   \\-> unsignedinteger  (uintxx)     (kind=u)
    54|         0|            0|            0|  0.00%|     |   |         ubyte
    55|         0|            0|            0|  0.00%|     |   |         ushort
    56|         0|            0|            0|  0.00%|     |   |         uintc
    57|         0|            0|            0|  0.00%|     |   |         uintp           uint0
    58|         0|            0|            0|  0.00%|     |   |         uint_
    59|         0|            0|            0|  0.00%|     |   |         ulonglong
    60|         0|            0|            0|  0.00%|     |   +-> inexact
    61|         0|            0|            0|  0.00%|     |       +-> floating          (floatxx)    (kind=f)
    62|         0|            0|            0|  0.00%|     |       |     half
    63|         0|            0|            0|  0.00%|     |       |     single
    64|         0|            0|            0|  0.00%|     |       |     float_          (double)
    65|         0|            0|            0|  0.00%|     |       |     longfloat
    66|         0|            0|            0|  0.00%|     |       \\-> complexfloating  (complexxx)  (kind=c)
    67|         0|            0|            0|  0.00%|     |             csingle         (singlecomplex)
    68|         0|            0|            0|  0.00%|     |             complex_        (cfloat, cdouble)
    69|         0|            0|            0|  0.00%|     |             clongfloat      (longcomplex)
    70|         0|            0|            0|  0.00%|     +-> flexible
    71|         0|            0|            0|  0.00%|     |   +-> character
    72|         0|            0|            0|  0.00%|     |   |     str_     (string_, bytes_)       (kind=S)    [Python 2]
    73|         0|            0|            0|  0.00%|     |   |     unicode_                         (kind=U)    [Python 2]
    74|         0|            0|            0|  0.00%|     |   |
    75|         0|            0|            0|  0.00%|     |   |     bytes_   (string_)               (kind=S)    [Python 3]
    76|         0|            0|            0|  0.00%|     |   |     str_     (unicode_)              (kind=U)    [Python 3]
    77|         0|            0|            0|  0.00%|     |   |
    78|         0|            0|            0|  0.00%|     |   \\-> void                              (kind=V)
    79|         0|            0|            0|  0.00%|     \\-> object_ (not used much)               (kind=O)
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|"""
    82|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|import types as _types
    85|         0|            0|            0|  0.00%|import sys
    86|         0|            0|            0|  0.00%|import numbers
    87|         0|            0|            0|  0.00%|import warnings
    88|         0|            0|            0|  0.00%|
    89|         0|            0|            0|  0.00%|from numpy.compat import bytes, long
    90|         0|            0|            0|  0.00%|from numpy.core.multiarray import (
    91|         0|            0|            0|  0.00%|        typeinfo, ndarray, array, empty, dtype, datetime_data,
    92|         0|            0|            0|  0.00%|        datetime_as_string, busday_offset, busday_count, is_busday,
    93|         0|            0|            0|  0.00%|        busdaycalendar
    94|         0|            0|            0|  0.00%|        )
    95|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    96|         0|            0|            0|  0.00%|
    97|         0|            0|            0|  0.00%|# we add more at the bottom
    98|         0|            0|            0|  0.00%|__all__ = ['sctypeDict', 'sctypeNA', 'typeDict', 'typeNA', 'sctypes',
    99|         0|            0|            0|  0.00%|           'ScalarType', 'obj2sctype', 'cast', 'nbytes', 'sctype2char',
   100|         0|            0|            0|  0.00%|           'maximum_sctype', 'issctype', 'typecodes', 'find_common_type',
   101|         0|            0|            0|  0.00%|           'issubdtype', 'datetime_data', 'datetime_as_string',
   102|         0|            0|            0|  0.00%|           'busday_offset', 'busday_count', 'is_busday', 'busdaycalendar',
   103|         0|            0|            0|  0.00%|           ]
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|# we don't need all these imports, but we need to keep them for compatibility
   106|         0|            0|            0|  0.00%|# for users using np.core.numerictypes.UPPER_TABLE
   107|         0|            0|            0|  0.00%|from ._string_helpers import (
   108|         0|            0|            0|  0.00%|    english_lower, english_upper, english_capitalize, LOWER_TABLE, UPPER_TABLE
   109|         0|            0|            0|  0.00%|)
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|from ._type_aliases import (
   112|         0|            0|            0|  0.00%|    sctypeDict,
   113|         0|            0|            0|  0.00%|    sctypeNA,
   114|         0|            0|            0|  0.00%|    allTypes,
   115|         0|            0|            0|  0.00%|    bitname,
   116|         0|            0|            0|  0.00%|    sctypes,
   117|         0|            0|            0|  0.00%|    _concrete_types,
   118|         0|            0|            0|  0.00%|    _concrete_typeinfo,
   119|         0|            0|            0|  0.00%|    _bits_of,
   120|         0|            0|            0|  0.00%|)
   121|         0|            0|            0|  0.00%|from ._dtype import _kind_name
   122|         0|            0|            0|  0.00%|
   123|         0|            0|            0|  0.00%|# we don't export these for import *, but we do want them accessible
   124|         0|            0|            0|  0.00%|# as numerictypes.bool, etc.
   125|         0|            0|            0|  0.00%|if sys.version_info[0] >= 3:
   126|         0|            0|            0|  0.00%|    from builtins import bool, int, float, complex, object, str
   127|         0|            0|            0|  0.00%|    unicode = str
   128|         0|            0|            0|  0.00%|else:
   129|         0|            0|            0|  0.00%|    from __builtin__ import bool, int, float, complex, object, unicode, str
   130|         0|            0|            0|  0.00%|
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|# We use this later
   133|         0|            0|            0|  0.00%|generic = allTypes['generic']
   134|         0|            0|            0|  0.00%|
   135|         0|            0|            0|  0.00%|genericTypeRank = ['bool', 'int8', 'uint8', 'int16', 'uint16',
   136|         0|            0|            0|  0.00%|                   'int32', 'uint32', 'int64', 'uint64', 'int128',
   137|         0|            0|            0|  0.00%|                   'uint128', 'float16',
   138|         0|            0|            0|  0.00%|                   'float32', 'float64', 'float80', 'float96', 'float128',
   139|         0|            0|            0|  0.00%|                   'float256',
   140|         0|            0|            0|  0.00%|                   'complex32', 'complex64', 'complex128', 'complex160',
   141|         0|            0|            0|  0.00%|                   'complex192', 'complex256', 'complex512', 'object']
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|@set_module('numpy')
   144|         0|            0|            0|  0.00%|def maximum_sctype(t):
   145|         0|            0|            0|  0.00%|    """
   146|         0|            0|            0|  0.00%|    Return the scalar type of highest precision of the same kind as the input.
   147|         0|            0|            0|  0.00%|
   148|         0|            0|            0|  0.00%|    Parameters
   149|         0|            0|            0|  0.00%|    ----------
   150|         0|            0|            0|  0.00%|    t : dtype or dtype specifier
   151|         0|            0|            0|  0.00%|        The input data type. This can be a `dtype` object or an object that
   152|         0|            0|            0|  0.00%|        is convertible to a `dtype`.
   153|         0|            0|            0|  0.00%|
   154|         0|            0|            0|  0.00%|    Returns
   155|         0|            0|            0|  0.00%|    -------
   156|         0|            0|            0|  0.00%|    out : dtype
   157|         0|            0|            0|  0.00%|        The highest precision data type of the same kind (`dtype.kind`) as `t`.
   158|         0|            0|            0|  0.00%|
   159|         0|            0|            0|  0.00%|    See Also
   160|         0|            0|            0|  0.00%|    --------
   161|         0|            0|            0|  0.00%|    obj2sctype, mintypecode, sctype2char
   162|         0|            0|            0|  0.00%|    dtype
   163|         0|            0|            0|  0.00%|
   164|         0|            0|            0|  0.00%|    Examples
   165|         0|            0|            0|  0.00%|    --------
   166|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(int)
   167|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
   168|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(np.uint8)
   169|         0|            0|            0|  0.00%|    <class 'numpy.uint64'>
   170|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(complex)
   171|         0|            0|            0|  0.00%|    <class 'numpy.complex256'> # may vary
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|    >>> np.maximum_sctype(str)
   174|         0|            0|            0|  0.00%|    <class 'numpy.str_'>
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    >>> np.maximum_sctype('i2')
   177|         0|            0|            0|  0.00%|    <class 'numpy.int64'>
   178|         0|            0|            0|  0.00%|    >>> np.maximum_sctype('f4')
   179|         0|            0|            0|  0.00%|    <class 'numpy.float128'> # may vary
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    """
   182|         0|            0|            0|  0.00%|    g = obj2sctype(t)
   183|         0|            0|            0|  0.00%|    if g is None:
   184|         0|            0|            0|  0.00%|        return t
   185|         0|            0|            0|  0.00%|    t = g
   186|         0|            0|            0|  0.00%|    base = _kind_name(dtype(t))
   187|         0|            0|            0|  0.00%|    if base in sctypes:
   188|         0|            0|            0|  0.00%|        return sctypes[base][-1]
   189|         0|            0|            0|  0.00%|    else:
   190|         0|            0|            0|  0.00%|        return t
   191|         0|            0|            0|  0.00%|
   192|         0|            0|            0|  0.00%|
   193|         0|            0|            0|  0.00%|@set_module('numpy')
   194|         0|            0|            0|  0.00%|def issctype(rep):
   195|         0|            0|            0|  0.00%|    """
   196|         0|            0|            0|  0.00%|    Determines whether the given object represents a scalar data-type.
   197|         0|            0|            0|  0.00%|
   198|         0|            0|            0|  0.00%|    Parameters
   199|         0|            0|            0|  0.00%|    ----------
   200|         0|            0|            0|  0.00%|    rep : any
   201|         0|            0|            0|  0.00%|        If `rep` is an instance of a scalar dtype, True is returned. If not,
   202|         0|            0|            0|  0.00%|        False is returned.
   203|         0|            0|            0|  0.00%|
   204|         0|            0|            0|  0.00%|    Returns
   205|         0|            0|            0|  0.00%|    -------
   206|         0|            0|            0|  0.00%|    out : bool
   207|         0|            0|            0|  0.00%|        Boolean result of check whether `rep` is a scalar dtype.
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|    See Also
   210|         0|            0|            0|  0.00%|    --------
   211|         0|            0|            0|  0.00%|    issubsctype, issubdtype, obj2sctype, sctype2char
   212|         0|            0|            0|  0.00%|
   213|         0|            0|            0|  0.00%|    Examples
   214|         0|            0|            0|  0.00%|    --------
   215|         0|            0|            0|  0.00%|    >>> np.issctype(np.int32)
   216|         0|            0|            0|  0.00%|    True
   217|         0|            0|            0|  0.00%|    >>> np.issctype(list)
   218|         0|            0|            0|  0.00%|    False
   219|         0|            0|            0|  0.00%|    >>> np.issctype(1.1)
   220|         0|            0|            0|  0.00%|    False
   221|         0|            0|            0|  0.00%|
   222|         0|            0|            0|  0.00%|    Strings are also a scalar type:
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    >>> np.issctype(np.dtype('str'))
   225|         0|            0|            0|  0.00%|    True
   226|         0|            0|            0|  0.00%|
   227|         0|            0|            0|  0.00%|    """
   228|         0|            0|            0|  0.00%|    if not isinstance(rep, (type, dtype)):
   229|         0|            0|            0|  0.00%|        return False
   230|         0|            0|            0|  0.00%|    try:
   231|         0|            0|            0|  0.00%|        res = obj2sctype(rep)
   232|         0|            0|            0|  0.00%|        if res and res != object_:
   233|         0|            0|            0|  0.00%|            return True
   234|         0|            0|            0|  0.00%|        return False
   235|         0|            0|            0|  0.00%|    except Exception:
   236|         0|            0|            0|  0.00%|        return False
   237|         0|            0|            0|  0.00%|
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|@set_module('numpy')
   240|         0|            0|            0|  0.00%|def obj2sctype(rep, default=None):
   241|         0|            0|            0|  0.00%|    """
   242|         0|            0|            0|  0.00%|    Return the scalar dtype or NumPy equivalent of Python type of an object.
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    Parameters
   245|         0|            0|            0|  0.00%|    ----------
   246|         0|            0|            0|  0.00%|    rep : any
   247|         0|            0|            0|  0.00%|        The object of which the type is returned.
   248|         0|            0|            0|  0.00%|    default : any, optional
   249|         0|            0|            0|  0.00%|        If given, this is returned for objects whose types can not be
   250|         0|            0|            0|  0.00%|        determined. If not given, None is returned for those objects.
   251|         0|            0|            0|  0.00%|
   252|         0|            0|            0|  0.00%|    Returns
   253|         0|            0|            0|  0.00%|    -------
   254|         0|            0|            0|  0.00%|    dtype : dtype or Python type
   255|         0|            0|            0|  0.00%|        The data type of `rep`.
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|    See Also
   258|         0|            0|            0|  0.00%|    --------
   259|         0|            0|            0|  0.00%|    sctype2char, issctype, issubsctype, issubdtype, maximum_sctype
   260|         0|            0|            0|  0.00%|
   261|         0|            0|            0|  0.00%|    Examples
   262|         0|            0|            0|  0.00%|    --------
   263|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.int32)
   264|         0|            0|            0|  0.00%|    <class 'numpy.int32'>
   265|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.array([1., 2.]))
   266|         0|            0|            0|  0.00%|    <class 'numpy.float64'>
   267|         0|            0|            0|  0.00%|    >>> np.obj2sctype(np.array([1.j]))
   268|         0|            0|            0|  0.00%|    <class 'numpy.complex128'>
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    >>> np.obj2sctype(dict)
   271|         0|            0|            0|  0.00%|    <class 'numpy.object_'>
   272|         0|            0|            0|  0.00%|    >>> np.obj2sctype('string')
   273|         0|            0|            0|  0.00%|
   274|         0|            0|            0|  0.00%|    >>> np.obj2sctype(1, default=list)
   275|         0|            0|            0|  0.00%|    <class 'list'>
   276|         0|            0|            0|  0.00%|
   277|         0|            0|            0|  0.00%|    """
   278|         0|            0|            0|  0.00%|    # prevent abstract classes being upcast
   279|         0|            0|            0|  0.00%|    if isinstance(rep, type) and issubclass(rep, generic):
   280|         0|            0|            0|  0.00%|        return rep
   281|         0|            0|            0|  0.00%|    # extract dtype from arrays
   282|         0|            0|            0|  0.00%|    if isinstance(rep, ndarray):
   283|         0|            0|            0|  0.00%|        return rep.dtype.type
   284|         0|            0|            0|  0.00%|    # fall back on dtype to convert
   285|         0|            0|            0|  0.00%|    try:
   286|         0|            0|            0|  0.00%|        res = dtype(rep)
   287|         0|            0|            0|  0.00%|    except Exception:
   288|         0|            0|            0|  0.00%|        return default
   289|         0|            0|            0|  0.00%|    else:
   290|         0|            0|            0|  0.00%|        return res.type
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|
   293|         4|  1.16825e-05|  2.92063e-06|  0.00%|@set_module('numpy')
   294|         0|            0|            0|  0.00%|def issubclass_(arg1, arg2):
   295|         0|            0|            0|  0.00%|    """
   296|         0|            0|            0|  0.00%|    Determine if a class is a subclass of a second class.
   297|         0|            0|            0|  0.00%|
   298|         0|            0|            0|  0.00%|    `issubclass_` is equivalent to the Python built-in ``issubclass``,
   299|         0|            0|            0|  0.00%|    except that it returns False instead of raising a TypeError if one
   300|         0|            0|            0|  0.00%|    of the arguments is not a class.
   301|         0|            0|            0|  0.00%|
   302|         0|            0|            0|  0.00%|    Parameters
   303|         0|            0|            0|  0.00%|    ----------
   304|         0|            0|            0|  0.00%|    arg1 : class
   305|         0|            0|            0|  0.00%|        Input class. True is returned if `arg1` is a subclass of `arg2`.
   306|         0|            0|            0|  0.00%|    arg2 : class or tuple of classes.
   307|         0|            0|            0|  0.00%|        Input class. If a tuple of classes, True is returned if `arg1` is a
   308|         0|            0|            0|  0.00%|        subclass of any of the tuple elements.
   309|         0|            0|            0|  0.00%|
   310|         0|            0|            0|  0.00%|    Returns
   311|         0|            0|            0|  0.00%|    -------
   312|         0|            0|            0|  0.00%|    out : bool
   313|         0|            0|            0|  0.00%|        Whether `arg1` is a subclass of `arg2` or not.
   314|         0|            0|            0|  0.00%|
   315|         0|            0|            0|  0.00%|    See Also
   316|         0|            0|            0|  0.00%|    --------
   317|         0|            0|            0|  0.00%|    issubsctype, issubdtype, issctype
   318|         0|            0|            0|  0.00%|
   319|         0|            0|            0|  0.00%|    Examples
   320|         0|            0|            0|  0.00%|    --------
   321|         0|            0|            0|  0.00%|    >>> np.issubclass_(np.int32, int)
   322|         0|            0|            0|  0.00%|    False # True on Python 2.7
   323|         0|            0|            0|  0.00%|    >>> np.issubclass_(np.int32, float)
   324|         0|            0|            0|  0.00%|    False
   325|         0|            0|            0|  0.00%|
   326|         0|            0|            0|  0.00%|    """
   327|         4|  1.07288e-05|  2.68221e-06|  0.00%|    try:
   328|         4|  1.85966e-05|  4.64916e-06|  0.00%|        return issubclass(arg1, arg2)
   329|         2|  6.67572e-06|  3.33786e-06|  0.00%|    except TypeError:
   330|         2|  5.72205e-06|  2.86102e-06|  0.00%|        return False
   331|         0|            0|            0|  0.00%|
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|@set_module('numpy')
   334|         0|            0|            0|  0.00%|def issubsctype(arg1, arg2):
   335|         0|            0|            0|  0.00%|    """
   336|         0|            0|            0|  0.00%|    Determine if the first argument is a subclass of the second argument.
   337|         0|            0|            0|  0.00%|
   338|         0|            0|            0|  0.00%|    Parameters
   339|         0|            0|            0|  0.00%|    ----------
   340|         0|            0|            0|  0.00%|    arg1, arg2 : dtype or dtype specifier
   341|         0|            0|            0|  0.00%|        Data-types.
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    Returns
   344|         0|            0|            0|  0.00%|    -------
   345|         0|            0|            0|  0.00%|    out : bool
   346|         0|            0|            0|  0.00%|        The result.
   347|         0|            0|            0|  0.00%|
   348|         0|            0|            0|  0.00%|    See Also
   349|         0|            0|            0|  0.00%|    --------
   350|         0|            0|            0|  0.00%|    issctype, issubdtype, obj2sctype
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    Examples
   353|         0|            0|            0|  0.00%|    --------
   354|         0|            0|            0|  0.00%|    >>> np.issubsctype('S8', str)
   355|         0|            0|            0|  0.00%|    False
   356|         0|            0|            0|  0.00%|    >>> np.issubsctype(np.array([1]), int)
   357|         0|            0|            0|  0.00%|    True
   358|         0|            0|            0|  0.00%|    >>> np.issubsctype(np.array([1]), float)
   359|         0|            0|            0|  0.00%|    False
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|    """
   362|         0|            0|            0|  0.00%|    return issubclass(obj2sctype(arg1), obj2sctype(arg2))
   363|         0|            0|            0|  0.00%|
   364|         0|            0|            0|  0.00%|
   365|         2|  1.09673e-05|  5.48363e-06|  0.00%|@set_module('numpy')
   366|         0|            0|            0|  0.00%|def issubdtype(arg1, arg2):
   367|         0|            0|            0|  0.00%|    """
   368|         0|            0|            0|  0.00%|    Returns True if first argument is a typecode lower/equal in type hierarchy.
   369|         0|            0|            0|  0.00%|
   370|         0|            0|            0|  0.00%|    Parameters
   371|         0|            0|            0|  0.00%|    ----------
   372|         0|            0|            0|  0.00%|    arg1, arg2 : dtype_like
   373|         0|            0|            0|  0.00%|        dtype or string representing a typecode.
   374|         0|            0|            0|  0.00%|
   375|         0|            0|            0|  0.00%|    Returns
   376|         0|            0|            0|  0.00%|    -------
   377|         0|            0|            0|  0.00%|    out : bool
   378|         0|            0|            0|  0.00%|
   379|         0|            0|            0|  0.00%|    See Also
   380|         0|            0|            0|  0.00%|    --------
   381|         0|            0|            0|  0.00%|    issubsctype, issubclass_
   382|         0|            0|            0|  0.00%|    numpy.core.numerictypes : Overview of numpy type hierarchy.
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    Examples
   385|         0|            0|            0|  0.00%|    --------
   386|         0|            0|            0|  0.00%|    >>> np.issubdtype('S1', np.string_)
   387|         0|            0|            0|  0.00%|    True
   388|         0|            0|            0|  0.00%|    >>> np.issubdtype(np.float64, np.float32)
   389|         0|            0|            0|  0.00%|    False
   390|         0|            0|            0|  0.00%|
   391|         0|            0|            0|  0.00%|    """
   392|         2|  2.86102e-05|  1.43051e-05|  0.00%|    if not issubclass_(arg1, generic):
(call)|         2|  4.00543e-05|  2.00272e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numerictypes.py:293 issubclass_
   393|         2|  1.21593e-05|  6.07967e-06|  0.00%|        arg1 = dtype(arg1).type
   394|         2|  1.83582e-05|  9.17912e-06|  0.00%|    if not issubclass_(arg2, generic):
(call)|         2|  1.33514e-05|  6.67572e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numerictypes.py:293 issubclass_
   395|         0|            0|            0|  0.00%|        arg2_orig = arg2
   396|         0|            0|            0|  0.00%|        arg2 = dtype(arg2).type
   397|         0|            0|            0|  0.00%|        if not isinstance(arg2_orig, dtype):
   398|         0|            0|            0|  0.00%|            # weird deprecated behaviour, that tried to infer np.floating from
   399|         0|            0|            0|  0.00%|            # float, and similar less obvious things, such as np.generic from
   400|         0|            0|            0|  0.00%|            # basestring
   401|         0|            0|            0|  0.00%|            mro = arg2.mro()
   402|         0|            0|            0|  0.00%|            arg2 = mro[1] if len(mro) > 1 else mro[0]
   403|         0|            0|            0|  0.00%|
   404|         0|            0|            0|  0.00%|            def type_repr(x):
   405|         0|            0|            0|  0.00%|                """ Helper to produce clear error messages """
   406|         0|            0|            0|  0.00%|                if not isinstance(x, type):
   407|         0|            0|            0|  0.00%|                    return repr(x)
   408|         0|            0|            0|  0.00%|                elif issubclass(x, generic):
   409|         0|            0|            0|  0.00%|                    return "np.{}".format(x.__name__)
   410|         0|            0|            0|  0.00%|                else:
   411|         0|            0|            0|  0.00%|                    return x.__name__
   412|         0|            0|            0|  0.00%|
   413|         0|            0|            0|  0.00%|            # 1.14, 2017-08-01
   414|         0|            0|            0|  0.00%|            warnings.warn(
   415|         0|            0|            0|  0.00%|                "Conversion of the second argument of issubdtype from `{raw}` "
   416|         0|            0|            0|  0.00%|                "to `{abstract}` is deprecated. In future, it will be treated "
   417|         0|            0|            0|  0.00%|                "as `{concrete} == np.dtype({raw}).type`.".format(
   418|         0|            0|            0|  0.00%|                    raw=type_repr(arg2_orig),
   419|         0|            0|            0|  0.00%|                    abstract=type_repr(arg2),
   420|         0|            0|            0|  0.00%|                    concrete=type_repr(dtype(arg2_orig).type)
   421|         0|            0|            0|  0.00%|                ),
   422|         0|            0|            0|  0.00%|                FutureWarning, stacklevel=2
   423|         0|            0|            0|  0.00%|            )
   424|         0|            0|            0|  0.00%|
   425|         2|  7.62939e-06|   3.8147e-06|  0.00%|    return issubclass(arg1, arg2)
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|
   428|         0|            0|            0|  0.00%|# This dictionary allows look up based on any alias for an array data-type
   429|         0|            0|            0|  0.00%|class _typedict(dict):
   430|         0|            0|            0|  0.00%|    """
   431|         0|            0|            0|  0.00%|    Base object for a dictionary for look-up with any alias for an array dtype.
   432|         0|            0|            0|  0.00%|
   433|         0|            0|            0|  0.00%|    Instances of `_typedict` can not be used as dictionaries directly,
   434|         0|            0|            0|  0.00%|    first they have to be populated.
   435|         0|            0|            0|  0.00%|
   436|         0|            0|            0|  0.00%|    """
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    def __getitem__(self, obj):
   439|         0|            0|            0|  0.00%|        return dict.__getitem__(self, obj2sctype(obj))
   440|         0|            0|            0|  0.00%|
   441|         0|            0|            0|  0.00%|nbytes = _typedict()
   442|         0|            0|            0|  0.00%|_alignment = _typedict()
   443|         0|            0|            0|  0.00%|_maxvals = _typedict()
   444|         0|            0|            0|  0.00%|_minvals = _typedict()
   445|         0|            0|            0|  0.00%|def _construct_lookups():
   446|         0|            0|            0|  0.00%|    for name, info in _concrete_typeinfo.items():
   447|         0|            0|            0|  0.00%|        obj = info.type
   448|         0|            0|            0|  0.00%|        nbytes[obj] = info.bits // 8
   449|         0|            0|            0|  0.00%|        _alignment[obj] = info.alignment
   450|         0|            0|            0|  0.00%|        if len(info) > 5:
   451|         0|            0|            0|  0.00%|            _maxvals[obj] = info.max
   452|         0|            0|            0|  0.00%|            _minvals[obj] = info.min
   453|         0|            0|            0|  0.00%|        else:
   454|         0|            0|            0|  0.00%|            _maxvals[obj] = None
   455|         0|            0|            0|  0.00%|            _minvals[obj] = None
   456|         0|            0|            0|  0.00%|
   457|         0|            0|            0|  0.00%|_construct_lookups()
   458|         0|            0|            0|  0.00%|
   459|         0|            0|            0|  0.00%|
   460|         0|            0|            0|  0.00%|@set_module('numpy')
   461|         0|            0|            0|  0.00%|def sctype2char(sctype):
   462|         0|            0|            0|  0.00%|    """
   463|         0|            0|            0|  0.00%|    Return the string representation of a scalar dtype.
   464|         0|            0|            0|  0.00%|
   465|         0|            0|            0|  0.00%|    Parameters
   466|         0|            0|            0|  0.00%|    ----------
   467|         0|            0|            0|  0.00%|    sctype : scalar dtype or object
   468|         0|            0|            0|  0.00%|        If a scalar dtype, the corresponding string character is
   469|         0|            0|            0|  0.00%|        returned. If an object, `sctype2char` tries to infer its scalar type
   470|         0|            0|            0|  0.00%|        and then return the corresponding string character.
   471|         0|            0|            0|  0.00%|
   472|         0|            0|            0|  0.00%|    Returns
   473|         0|            0|            0|  0.00%|    -------
   474|         0|            0|            0|  0.00%|    typechar : str
   475|         0|            0|            0|  0.00%|        The string character corresponding to the scalar type.
   476|         0|            0|            0|  0.00%|
   477|         0|            0|            0|  0.00%|    Raises
   478|         0|            0|            0|  0.00%|    ------
   479|         0|            0|            0|  0.00%|    ValueError
   480|         0|            0|            0|  0.00%|        If `sctype` is an object for which the type can not be inferred.
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|    See Also
   483|         0|            0|            0|  0.00%|    --------
   484|         0|            0|            0|  0.00%|    obj2sctype, issctype, issubsctype, mintypecode
   485|         0|            0|            0|  0.00%|
   486|         0|            0|            0|  0.00%|    Examples
   487|         0|            0|            0|  0.00%|    --------
   488|         0|            0|            0|  0.00%|    >>> for sctype in [np.int32, np.double, np.complex, np.string_, np.ndarray]:
   489|         0|            0|            0|  0.00%|    ...     print(np.sctype2char(sctype))
   490|         0|            0|            0|  0.00%|    l # may vary
   491|         0|            0|            0|  0.00%|    d
   492|         0|            0|            0|  0.00%|    D
   493|         0|            0|            0|  0.00%|    S
   494|         0|            0|            0|  0.00%|    O
   495|         0|            0|            0|  0.00%|
   496|         0|            0|            0|  0.00%|    >>> x = np.array([1., 2-1.j])
   497|         0|            0|            0|  0.00%|    >>> np.sctype2char(x)
   498|         0|            0|            0|  0.00%|    'D'
   499|         0|            0|            0|  0.00%|    >>> np.sctype2char(list)
   500|         0|            0|            0|  0.00%|    'O'
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    """
   503|         0|            0|            0|  0.00%|    sctype = obj2sctype(sctype)
   504|         0|            0|            0|  0.00%|    if sctype is None:
   505|         0|            0|            0|  0.00%|        raise ValueError("unrecognized type")
   506|         0|            0|            0|  0.00%|    if sctype not in _concrete_types:
   507|         0|            0|            0|  0.00%|        # for compatibility
   508|         0|            0|            0|  0.00%|        raise KeyError(sctype)
   509|         0|            0|            0|  0.00%|    return dtype(sctype).char
   510|         0|            0|            0|  0.00%|
   511|         0|            0|            0|  0.00%|# Create dictionary of casting functions that wrap sequences
   512|         0|            0|            0|  0.00%|# indexed by type or type character
   513|         0|            0|            0|  0.00%|cast = _typedict()
   514|         0|            0|            0|  0.00%|for key in _concrete_types:
   515|         0|            0|            0|  0.00%|    cast[key] = lambda x, k=key: array(x, copy=False).astype(k)
   516|         0|            0|            0|  0.00%|
   517|         0|            0|            0|  0.00%|try:
   518|         0|            0|            0|  0.00%|    ScalarType = [_types.IntType, _types.FloatType, _types.ComplexType,
   519|         0|            0|            0|  0.00%|                  _types.LongType, _types.BooleanType,
   520|         0|            0|            0|  0.00%|                   _types.StringType, _types.UnicodeType, _types.BufferType]
   521|         0|            0|            0|  0.00%|except AttributeError:
   522|         0|            0|            0|  0.00%|    # Py3K
   523|         0|            0|            0|  0.00%|    ScalarType = [int, float, complex, int, bool, bytes, str, memoryview]
   524|         0|            0|            0|  0.00%|
   525|         0|            0|            0|  0.00%|ScalarType.extend(_concrete_types)
   526|         0|            0|            0|  0.00%|ScalarType = tuple(ScalarType)
   527|         0|            0|            0|  0.00%|
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|# Now add the types we've determined to this module
   530|         0|            0|            0|  0.00%|for key in allTypes:
   531|         0|            0|            0|  0.00%|    globals()[key] = allTypes[key]
   532|         0|            0|            0|  0.00%|    __all__.append(key)
   533|         0|            0|            0|  0.00%|
   534|         0|            0|            0|  0.00%|del key
   535|         0|            0|            0|  0.00%|
   536|         0|            0|            0|  0.00%|typecodes = {'Character':'c',
   537|         0|            0|            0|  0.00%|             'Integer':'bhilqp',
   538|         0|            0|            0|  0.00%|             'UnsignedInteger':'BHILQP',
   539|         0|            0|            0|  0.00%|             'Float':'efdg',
   540|         0|            0|            0|  0.00%|             'Complex':'FDG',
   541|         0|            0|            0|  0.00%|             'AllInteger':'bBhHiIlLqQpP',
   542|         0|            0|            0|  0.00%|             'AllFloat':'efdgFDG',
   543|         0|            0|            0|  0.00%|             'Datetime': 'Mm',
   544|         0|            0|            0|  0.00%|             'All':'?bhilqpBHILQPefdgFDGSUVOMm'}
   545|         0|            0|            0|  0.00%|
   546|         0|            0|            0|  0.00%|# backwards compatibility --- deprecated name
   547|         0|            0|            0|  0.00%|typeDict = sctypeDict
   548|         0|            0|            0|  0.00%|typeNA = sctypeNA
   549|         0|            0|            0|  0.00%|
   550|         0|            0|            0|  0.00%|# b -> boolean
   551|         0|            0|            0|  0.00%|# u -> unsigned integer
   552|         0|            0|            0|  0.00%|# i -> signed integer
   553|         0|            0|            0|  0.00%|# f -> floating point
   554|         0|            0|            0|  0.00%|# c -> complex
   555|         0|            0|            0|  0.00%|# M -> datetime
   556|         0|            0|            0|  0.00%|# m -> timedelta
   557|         0|            0|            0|  0.00%|# S -> string
   558|         0|            0|            0|  0.00%|# U -> Unicode string
   559|         0|            0|            0|  0.00%|# V -> record
   560|         0|            0|            0|  0.00%|# O -> Python object
   561|         0|            0|            0|  0.00%|_kind_list = ['b', 'u', 'i', 'f', 'c', 'S', 'U', 'V', 'O', 'M', 'm']
   562|         0|            0|            0|  0.00%|
   563|         0|            0|            0|  0.00%|__test_types = '?'+typecodes['AllInteger'][:-2]+typecodes['AllFloat']+'O'
   564|         0|            0|            0|  0.00%|__len_test_types = len(__test_types)
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|# Keep incrementing until a common type both can be coerced to
   567|         0|            0|            0|  0.00%|#  is found.  Otherwise, return None
   568|         0|            0|            0|  0.00%|def _find_common_coerce(a, b):
   569|         0|            0|            0|  0.00%|    if a > b:
   570|         0|            0|            0|  0.00%|        return a
   571|         0|            0|            0|  0.00%|    try:
   572|         0|            0|            0|  0.00%|        thisind = __test_types.index(a.char)
   573|         0|            0|            0|  0.00%|    except ValueError:
   574|         0|            0|            0|  0.00%|        return None
   575|         0|            0|            0|  0.00%|    return _can_coerce_all([a, b], start=thisind)
   576|         0|            0|            0|  0.00%|
   577|         0|            0|            0|  0.00%|# Find a data-type that all data-types in a list can be coerced to
   578|         0|            0|            0|  0.00%|def _can_coerce_all(dtypelist, start=0):
   579|         0|            0|            0|  0.00%|    N = len(dtypelist)
   580|         0|            0|            0|  0.00%|    if N == 0:
   581|         0|            0|            0|  0.00%|        return None
   582|         0|            0|            0|  0.00%|    if N == 1:
   583|         0|            0|            0|  0.00%|        return dtypelist[0]
   584|         0|            0|            0|  0.00%|    thisind = start
   585|         0|            0|            0|  0.00%|    while thisind < __len_test_types:
   586|         0|            0|            0|  0.00%|        newdtype = dtype(__test_types[thisind])
   587|         0|            0|            0|  0.00%|        numcoerce = len([x for x in dtypelist if newdtype >= x])
   588|         0|            0|            0|  0.00%|        if numcoerce == N:
   589|         0|            0|            0|  0.00%|            return newdtype
   590|         0|            0|            0|  0.00%|        thisind += 1
   591|         0|            0|            0|  0.00%|    return None
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|def _register_types():
   594|         0|            0|            0|  0.00%|    numbers.Integral.register(integer)
   595|         0|            0|            0|  0.00%|    numbers.Complex.register(inexact)
   596|         0|            0|            0|  0.00%|    numbers.Real.register(floating)
   597|         0|            0|            0|  0.00%|    numbers.Number.register(number)
   598|         0|            0|            0|  0.00%|
   599|         0|            0|            0|  0.00%|_register_types()
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|
   602|         0|            0|            0|  0.00%|@set_module('numpy')
   603|         0|            0|            0|  0.00%|def find_common_type(array_types, scalar_types):
   604|         0|            0|            0|  0.00%|    """
   605|         0|            0|            0|  0.00%|    Determine common type following standard coercion rules.
   606|         0|            0|            0|  0.00%|
   607|         0|            0|            0|  0.00%|    Parameters
   608|         0|            0|            0|  0.00%|    ----------
   609|         0|            0|            0|  0.00%|    array_types : sequence
   610|         0|            0|            0|  0.00%|        A list of dtypes or dtype convertible objects representing arrays.
   611|         0|            0|            0|  0.00%|    scalar_types : sequence
   612|         0|            0|            0|  0.00%|        A list of dtypes or dtype convertible objects representing scalars.
   613|         0|            0|            0|  0.00%|
   614|         0|            0|            0|  0.00%|    Returns
   615|         0|            0|            0|  0.00%|    -------
   616|         0|            0|            0|  0.00%|    datatype : dtype
   617|         0|            0|            0|  0.00%|        The common data type, which is the maximum of `array_types` ignoring
   618|         0|            0|            0|  0.00%|        `scalar_types`, unless the maximum of `scalar_types` is of a
   619|         0|            0|            0|  0.00%|        different kind (`dtype.kind`). If the kind is not understood, then
   620|         0|            0|            0|  0.00%|        None is returned.
   621|         0|            0|            0|  0.00%|
   622|         0|            0|            0|  0.00%|    See Also
   623|         0|            0|            0|  0.00%|    --------
   624|         0|            0|            0|  0.00%|    dtype, common_type, can_cast, mintypecode
   625|         0|            0|            0|  0.00%|
   626|         0|            0|            0|  0.00%|    Examples
   627|         0|            0|            0|  0.00%|    --------
   628|         0|            0|            0|  0.00%|    >>> np.find_common_type([], [np.int64, np.float32, complex])
   629|         0|            0|            0|  0.00%|    dtype('complex128')
   630|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.int64, np.float32], [])
   631|         0|            0|            0|  0.00%|    dtype('float64')
   632|         0|            0|            0|  0.00%|
   633|         0|            0|            0|  0.00%|    The standard casting rules ensure that a scalar cannot up-cast an
   634|         0|            0|            0|  0.00%|    array unless the scalar is of a fundamentally different kind of data
   635|         0|            0|            0|  0.00%|    (i.e. under a different hierarchy in the data type hierarchy) then
   636|         0|            0|            0|  0.00%|    the array:
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.float32], [np.int64, np.float64])
   639|         0|            0|            0|  0.00%|    dtype('float32')
   640|         0|            0|            0|  0.00%|
   641|         0|            0|            0|  0.00%|    Complex is of a different type, so it up-casts the float in the
   642|         0|            0|            0|  0.00%|    `array_types` argument:
   643|         0|            0|            0|  0.00%|
   644|         0|            0|            0|  0.00%|    >>> np.find_common_type([np.float32], [complex])
   645|         0|            0|            0|  0.00%|    dtype('complex128')
   646|         0|            0|            0|  0.00%|
   647|         0|            0|            0|  0.00%|    Type specifier strings are convertible to dtypes and can therefore
   648|         0|            0|            0|  0.00%|    be used instead of dtypes:
   649|         0|            0|            0|  0.00%|
   650|         0|            0|            0|  0.00%|    >>> np.find_common_type(['f4', 'f4', 'i4'], ['c8'])
   651|         0|            0|            0|  0.00%|    dtype('complex128')
   652|         0|            0|            0|  0.00%|
   653|         0|            0|            0|  0.00%|    """
   654|         0|            0|            0|  0.00%|    array_types = [dtype(x) for x in array_types]
   655|         0|            0|            0|  0.00%|    scalar_types = [dtype(x) for x in scalar_types]
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|    maxa = _can_coerce_all(array_types)
   658|         0|            0|            0|  0.00%|    maxsc = _can_coerce_all(scalar_types)
   659|         0|            0|            0|  0.00%|
   660|         0|            0|            0|  0.00%|    if maxa is None:
   661|         0|            0|            0|  0.00%|        return maxsc
   662|         0|            0|            0|  0.00%|
   663|         0|            0|            0|  0.00%|    if maxsc is None:
   664|         0|            0|            0|  0.00%|        return maxa
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|    try:
   667|         0|            0|            0|  0.00%|        index_a = _kind_list.index(maxa.kind)
   668|         0|            0|            0|  0.00%|        index_sc = _kind_list.index(maxsc.kind)
   669|         0|            0|            0|  0.00%|    except ValueError:
   670|         0|            0|            0|  0.00%|        return None
   671|         0|            0|            0|  0.00%|
   672|         0|            0|            0|  0.00%|    if index_sc > index_a:
   673|         0|            0|            0|  0.00%|        return _find_common_coerce(maxsc, maxa)
   674|         0|            0|            0|  0.00%|    else:
   675|         0|            0|            0|  0.00%|        return maxa
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/utils.py
File duration: 8.89301e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
     2|         0|            0|            0|  0.00%|
     3|         0|            0|            0|  0.00%|import os
     4|         0|            0|            0|  0.00%|import sys
     5|         0|            0|            0|  0.00%|import types
     6|         0|            0|            0|  0.00%|import re
     7|         0|            0|            0|  0.00%|import warnings
     8|         0|            0|            0|  0.00%|
     9|         0|            0|            0|  0.00%|from numpy.core.numerictypes import issubclass_, issubsctype, issubdtype
    10|         0|            0|            0|  0.00%|from numpy.core.overrides import set_module
    11|         0|            0|            0|  0.00%|from numpy.core import ndarray, ufunc, asarray
    12|         0|            0|            0|  0.00%|import numpy as np
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|# getargspec and formatargspec were removed in Python 3.6
    15|         0|            0|            0|  0.00%|from numpy.compat import getargspec, formatargspec
    16|         0|            0|            0|  0.00%|
    17|         0|            0|            0|  0.00%|__all__ = [
    18|         0|            0|            0|  0.00%|    'issubclass_', 'issubsctype', 'issubdtype', 'deprecate',
    19|         0|            0|            0|  0.00%|    'deprecate_with_doc', 'get_include', 'info', 'source', 'who',
    20|         0|            0|            0|  0.00%|    'lookfor', 'byte_bounds', 'safe_eval'
    21|         0|            0|            0|  0.00%|    ]
    22|         0|            0|            0|  0.00%|
    23|         0|            0|            0|  0.00%|def get_include():
    24|         0|            0|            0|  0.00%|    """
    25|         0|            0|            0|  0.00%|    Return the directory that contains the NumPy \\*.h header files.
    26|         0|            0|            0|  0.00%|
    27|         0|            0|            0|  0.00%|    Extension modules that need to compile against NumPy should use this
    28|         0|            0|            0|  0.00%|    function to locate the appropriate include directory.
    29|         0|            0|            0|  0.00%|
    30|         0|            0|            0|  0.00%|    Notes
    31|         0|            0|            0|  0.00%|    -----
    32|         0|            0|            0|  0.00%|    When using ``distutils``, for example in ``setup.py``.
    33|         0|            0|            0|  0.00%|    ::
    34|         0|            0|            0|  0.00%|
    35|         0|            0|            0|  0.00%|        import numpy as np
    36|         0|            0|            0|  0.00%|        ...
    37|         0|            0|            0|  0.00%|        Extension('extension_name', ...
    38|         0|            0|            0|  0.00%|                include_dirs=[np.get_include()])
    39|         0|            0|            0|  0.00%|        ...
    40|         0|            0|            0|  0.00%|
    41|         0|            0|            0|  0.00%|    """
    42|         0|            0|            0|  0.00%|    import numpy
    43|         0|            0|            0|  0.00%|    if numpy.show_config is None:
    44|         0|            0|            0|  0.00%|        # running from numpy source directory
    45|         0|            0|            0|  0.00%|        d = os.path.join(os.path.dirname(numpy.__file__), 'core', 'include')
    46|         0|            0|            0|  0.00%|    else:
    47|         0|            0|            0|  0.00%|        # using installed numpy core headers
    48|         0|            0|            0|  0.00%|        import numpy.core as core
    49|         0|            0|            0|  0.00%|        d = os.path.join(os.path.dirname(core.__file__), 'include')
    50|         0|            0|            0|  0.00%|    return d
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|
    53|         0|            0|            0|  0.00%|def _set_function_name(func, name):
    54|         0|            0|            0|  0.00%|    func.__name__ = name
    55|         0|            0|            0|  0.00%|    return func
    56|         0|            0|            0|  0.00%|
    57|         0|            0|            0|  0.00%|
    58|         0|            0|            0|  0.00%|class _Deprecate(object):
    59|         0|            0|            0|  0.00%|    """
    60|         0|            0|            0|  0.00%|    Decorator class to deprecate old functions.
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|    Refer to `deprecate` for details.
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|    See Also
    65|         0|            0|            0|  0.00%|    --------
    66|         0|            0|            0|  0.00%|    deprecate
    67|         0|            0|            0|  0.00%|
    68|         0|            0|            0|  0.00%|    """
    69|         0|            0|            0|  0.00%|
    70|         0|            0|            0|  0.00%|    def __init__(self, old_name=None, new_name=None, message=None):
    71|         0|            0|            0|  0.00%|        self.old_name = old_name
    72|         0|            0|            0|  0.00%|        self.new_name = new_name
    73|         0|            0|            0|  0.00%|        self.message = message
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    def __call__(self, func, *args, **kwargs):
    76|         0|            0|            0|  0.00%|        """
    77|         0|            0|            0|  0.00%|        Decorator call.  Refer to ``decorate``.
    78|         0|            0|            0|  0.00%|
    79|         0|            0|            0|  0.00%|        """
    80|         0|            0|            0|  0.00%|        old_name = self.old_name
    81|         0|            0|            0|  0.00%|        new_name = self.new_name
    82|         0|            0|            0|  0.00%|        message = self.message
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|        if old_name is None:
    85|         0|            0|            0|  0.00%|            try:
    86|         0|            0|            0|  0.00%|                old_name = func.__name__
    87|         0|            0|            0|  0.00%|            except AttributeError:
    88|         0|            0|            0|  0.00%|                old_name = func.__name__
    89|         0|            0|            0|  0.00%|        if new_name is None:
    90|         0|            0|            0|  0.00%|            depdoc = "`%s` is deprecated!" % old_name
    91|         0|            0|            0|  0.00%|        else:
    92|         0|            0|            0|  0.00%|            depdoc = "`%s` is deprecated, use `%s` instead!" % \
    93|         0|            0|            0|  0.00%|                     (old_name, new_name)
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|        if message is not None:
    96|         0|            0|            0|  0.00%|            depdoc += "\n" + message
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|        def newfunc(*args,**kwds):
    99|         0|            0|            0|  0.00%|            """`arrayrange` is deprecated, use `arange` instead!"""
   100|         0|            0|            0|  0.00%|            warnings.warn(depdoc, DeprecationWarning, stacklevel=2)
   101|         0|            0|            0|  0.00%|            return func(*args, **kwds)
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|        newfunc = _set_function_name(newfunc, old_name)
   104|         0|            0|            0|  0.00%|        doc = func.__doc__
   105|         0|            0|            0|  0.00%|        if doc is None:
   106|         0|            0|            0|  0.00%|            doc = depdoc
   107|         0|            0|            0|  0.00%|        else:
   108|         0|            0|            0|  0.00%|            lines = doc.expandtabs().split('\n')
   109|         0|            0|            0|  0.00%|            indent = _get_indent(lines[1:])
   110|         0|            0|            0|  0.00%|            if lines[0].lstrip():
   111|         0|            0|            0|  0.00%|                # Indent the original first line to let inspect.cleandoc()
   112|         0|            0|            0|  0.00%|                # dedent the docstring despite the deprecation notice.
   113|         0|            0|            0|  0.00%|                doc = indent * ' ' + doc
   114|         0|            0|            0|  0.00%|            else:
   115|         0|            0|            0|  0.00%|                # Remove the same leading blank lines as cleandoc() would.
   116|         0|            0|            0|  0.00%|                skip = len(lines[0]) + 1
   117|         0|            0|            0|  0.00%|                for line in lines[1:]:
   118|         0|            0|            0|  0.00%|                    if len(line) > indent:
   119|         0|            0|            0|  0.00%|                        break
   120|         0|            0|            0|  0.00%|                    skip += len(line) + 1
   121|         0|            0|            0|  0.00%|                doc = doc[skip:]
   122|         0|            0|            0|  0.00%|            doc = '\n\n'.join([depdoc, doc])
   123|         0|            0|            0|  0.00%|        newfunc.__doc__ = doc
   124|         0|            0|            0|  0.00%|        try:
   125|         0|            0|            0|  0.00%|            d = func.__dict__
   126|         0|            0|            0|  0.00%|        except AttributeError:
   127|         0|            0|            0|  0.00%|            pass
   128|         0|            0|            0|  0.00%|        else:
   129|         0|            0|            0|  0.00%|            newfunc.__dict__.update(d)
   130|         0|            0|            0|  0.00%|        return newfunc
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|
   133|         0|            0|            0|  0.00%|def _get_indent(lines):
   134|         0|            0|            0|  0.00%|    """
   135|         0|            0|            0|  0.00%|    Determines the leading whitespace that could be removed from all the lines.
   136|         0|            0|            0|  0.00%|    """
   137|         0|            0|            0|  0.00%|    indent = sys.maxsize
   138|         0|            0|            0|  0.00%|    for line in lines:
   139|         0|            0|            0|  0.00%|        content = len(line.lstrip())
   140|         0|            0|            0|  0.00%|        if content:
   141|         0|            0|            0|  0.00%|            indent = min(indent, len(line) - content)
   142|         0|            0|            0|  0.00%|    if indent == sys.maxsize:
   143|         0|            0|            0|  0.00%|        indent = 0
   144|         0|            0|            0|  0.00%|    return indent
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|
   147|         0|            0|            0|  0.00%|def deprecate(*args, **kwargs):
   148|         0|            0|            0|  0.00%|    """
   149|         0|            0|            0|  0.00%|    Issues a DeprecationWarning, adds warning to `old_name`'s
   150|         0|            0|            0|  0.00%|    docstring, rebinds ``old_name.__name__`` and returns the new
   151|         0|            0|            0|  0.00%|    function object.
   152|         0|            0|            0|  0.00%|
   153|         0|            0|            0|  0.00%|    This function may also be used as a decorator.
   154|         0|            0|            0|  0.00%|
   155|         0|            0|            0|  0.00%|    Parameters
   156|         0|            0|            0|  0.00%|    ----------
   157|         0|            0|            0|  0.00%|    func : function
   158|         0|            0|            0|  0.00%|        The function to be deprecated.
   159|         0|            0|            0|  0.00%|    old_name : str, optional
   160|         0|            0|            0|  0.00%|        The name of the function to be deprecated. Default is None, in
   161|         0|            0|            0|  0.00%|        which case the name of `func` is used.
   162|         0|            0|            0|  0.00%|    new_name : str, optional
   163|         0|            0|            0|  0.00%|        The new name for the function. Default is None, in which case the
   164|         0|            0|            0|  0.00%|        deprecation message is that `old_name` is deprecated. If given, the
   165|         0|            0|            0|  0.00%|        deprecation message is that `old_name` is deprecated and `new_name`
   166|         0|            0|            0|  0.00%|        should be used instead.
   167|         0|            0|            0|  0.00%|    message : str, optional
   168|         0|            0|            0|  0.00%|        Additional explanation of the deprecation.  Displayed in the
   169|         0|            0|            0|  0.00%|        docstring after the warning.
   170|         0|            0|            0|  0.00%|
   171|         0|            0|            0|  0.00%|    Returns
   172|         0|            0|            0|  0.00%|    -------
   173|         0|            0|            0|  0.00%|    old_func : function
   174|         0|            0|            0|  0.00%|        The deprecated function.
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|    Examples
   177|         0|            0|            0|  0.00%|    --------
   178|         0|            0|            0|  0.00%|    Note that ``olduint`` returns a value after printing Deprecation
   179|         0|            0|            0|  0.00%|    Warning:
   180|         0|            0|            0|  0.00%|
   181|         0|            0|            0|  0.00%|    >>> olduint = np.deprecate(np.uint)
   182|         0|            0|            0|  0.00%|    DeprecationWarning: `uint64` is deprecated! # may vary
   183|         0|            0|            0|  0.00%|    >>> olduint(6)
   184|         0|            0|            0|  0.00%|    6
   185|         0|            0|            0|  0.00%|
   186|         0|            0|            0|  0.00%|    """
   187|         0|            0|            0|  0.00%|    # Deprecate may be run as a function or as a decorator
   188|         0|            0|            0|  0.00%|    # If run as a function, we initialise the decorator class
   189|         0|            0|            0|  0.00%|    # and execute its __call__ method.
   190|         0|            0|            0|  0.00%|
   191|         0|            0|            0|  0.00%|    if args:
   192|         0|            0|            0|  0.00%|        fn = args[0]
   193|         0|            0|            0|  0.00%|        args = args[1:]
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|        return _Deprecate(*args, **kwargs)(fn)
   196|         0|            0|            0|  0.00%|    else:
   197|         0|            0|            0|  0.00%|        return _Deprecate(*args, **kwargs)
   198|         0|            0|            0|  0.00%|
   199|         0|            0|            0|  0.00%|deprecate_with_doc = lambda msg: _Deprecate(message=msg)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|
   202|         0|            0|            0|  0.00%|#--------------------------------------------
   203|         0|            0|            0|  0.00%|# Determine if two arrays can share memory
   204|         0|            0|            0|  0.00%|#--------------------------------------------
   205|         0|            0|            0|  0.00%|
   206|         0|            0|            0|  0.00%|def byte_bounds(a):
   207|         0|            0|            0|  0.00%|    """
   208|         0|            0|            0|  0.00%|    Returns pointers to the end-points of an array.
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|    Parameters
   211|         0|            0|            0|  0.00%|    ----------
   212|         0|            0|            0|  0.00%|    a : ndarray
   213|         0|            0|            0|  0.00%|        Input array. It must conform to the Python-side of the array
   214|         0|            0|            0|  0.00%|        interface.
   215|         0|            0|            0|  0.00%|
   216|         0|            0|            0|  0.00%|    Returns
   217|         0|            0|            0|  0.00%|    -------
   218|         0|            0|            0|  0.00%|    (low, high) : tuple of 2 integers
   219|         0|            0|            0|  0.00%|        The first integer is the first byte of the array, the second
   220|         0|            0|            0|  0.00%|        integer is just past the last byte of the array.  If `a` is not
   221|         0|            0|            0|  0.00%|        contiguous it will not use every byte between the (`low`, `high`)
   222|         0|            0|            0|  0.00%|        values.
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|    Examples
   225|         0|            0|            0|  0.00%|    --------
   226|         0|            0|            0|  0.00%|    >>> I = np.eye(2, dtype='f'); I.dtype
   227|         0|            0|            0|  0.00%|    dtype('float32')
   228|         0|            0|            0|  0.00%|    >>> low, high = np.byte_bounds(I)
   229|         0|            0|            0|  0.00%|    >>> high - low == I.size*I.itemsize
   230|         0|            0|            0|  0.00%|    True
   231|         0|            0|            0|  0.00%|    >>> I = np.eye(2); I.dtype
   232|         0|            0|            0|  0.00%|    dtype('float64')
   233|         0|            0|            0|  0.00%|    >>> low, high = np.byte_bounds(I)
   234|         0|            0|            0|  0.00%|    >>> high - low == I.size*I.itemsize
   235|         0|            0|            0|  0.00%|    True
   236|         0|            0|            0|  0.00%|
   237|         0|            0|            0|  0.00%|    """
   238|         0|            0|            0|  0.00%|    ai = a.__array_interface__
   239|         0|            0|            0|  0.00%|    a_data = ai['data'][0]
   240|         0|            0|            0|  0.00%|    astrides = ai['strides']
   241|         0|            0|            0|  0.00%|    ashape = ai['shape']
   242|         0|            0|            0|  0.00%|    bytes_a = asarray(a).dtype.itemsize
   243|         0|            0|            0|  0.00%|
   244|         0|            0|            0|  0.00%|    a_low = a_high = a_data
   245|         0|            0|            0|  0.00%|    if astrides is None:
   246|         0|            0|            0|  0.00%|        # contiguous case
   247|         0|            0|            0|  0.00%|        a_high += a.size * bytes_a
   248|         0|            0|            0|  0.00%|    else:
   249|         0|            0|            0|  0.00%|        for shape, stride in zip(ashape, astrides):
   250|         0|            0|            0|  0.00%|            if stride < 0:
   251|         0|            0|            0|  0.00%|                a_low += (shape-1)*stride
   252|         0|            0|            0|  0.00%|            else:
   253|         0|            0|            0|  0.00%|                a_high += (shape-1)*stride
   254|         0|            0|            0|  0.00%|        a_high += bytes_a
   255|         0|            0|            0|  0.00%|    return a_low, a_high
   256|         0|            0|            0|  0.00%|
   257|         0|            0|            0|  0.00%|
   258|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   259|         0|            0|            0|  0.00%|# Function for output and information on the variables used.
   260|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   261|         0|            0|            0|  0.00%|
   262|         0|            0|            0|  0.00%|
   263|         0|            0|            0|  0.00%|def who(vardict=None):
   264|         0|            0|            0|  0.00%|    """
   265|         0|            0|            0|  0.00%|    Print the NumPy arrays in the given dictionary.
   266|         0|            0|            0|  0.00%|
   267|         0|            0|            0|  0.00%|    If there is no dictionary passed in or `vardict` is None then returns
   268|         0|            0|            0|  0.00%|    NumPy arrays in the globals() dictionary (all NumPy arrays in the
   269|         0|            0|            0|  0.00%|    namespace).
   270|         0|            0|            0|  0.00%|
   271|         0|            0|            0|  0.00%|    Parameters
   272|         0|            0|            0|  0.00%|    ----------
   273|         0|            0|            0|  0.00%|    vardict : dict, optional
   274|         0|            0|            0|  0.00%|        A dictionary possibly containing ndarrays.  Default is globals().
   275|         0|            0|            0|  0.00%|
   276|         0|            0|            0|  0.00%|    Returns
   277|         0|            0|            0|  0.00%|    -------
   278|         0|            0|            0|  0.00%|    out : None
   279|         0|            0|            0|  0.00%|        Returns 'None'.
   280|         0|            0|            0|  0.00%|
   281|         0|            0|            0|  0.00%|    Notes
   282|         0|            0|            0|  0.00%|    -----
   283|         0|            0|            0|  0.00%|    Prints out the name, shape, bytes and type of all of the ndarrays
   284|         0|            0|            0|  0.00%|    present in `vardict`.
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    Examples
   287|         0|            0|            0|  0.00%|    --------
   288|         0|            0|            0|  0.00%|    >>> a = np.arange(10)
   289|         0|            0|            0|  0.00%|    >>> b = np.ones(20)
   290|         0|            0|            0|  0.00%|    >>> np.who()
   291|         0|            0|            0|  0.00%|    Name            Shape            Bytes            Type
   292|         0|            0|            0|  0.00%|    ===========================================================
   293|         0|            0|            0|  0.00%|    a               10               80               int64
   294|         0|            0|            0|  0.00%|    b               20               160              float64
   295|         0|            0|            0|  0.00%|    Upper bound on total bytes  =       240
   296|         0|            0|            0|  0.00%|
   297|         0|            0|            0|  0.00%|    >>> d = {'x': np.arange(2.0), 'y': np.arange(3.0), 'txt': 'Some str',
   298|         0|            0|            0|  0.00%|    ... 'idx':5}
   299|         0|            0|            0|  0.00%|    >>> np.who(d)
   300|         0|            0|            0|  0.00%|    Name            Shape            Bytes            Type
   301|         0|            0|            0|  0.00%|    ===========================================================
   302|         0|            0|            0|  0.00%|    x               2                16               float64
   303|         0|            0|            0|  0.00%|    y               3                24               float64
   304|         0|            0|            0|  0.00%|    Upper bound on total bytes  =       40
   305|         0|            0|            0|  0.00%|
   306|         0|            0|            0|  0.00%|    """
   307|         0|            0|            0|  0.00%|    if vardict is None:
   308|         0|            0|            0|  0.00%|        frame = sys._getframe().f_back
   309|         0|            0|            0|  0.00%|        vardict = frame.f_globals
   310|         0|            0|            0|  0.00%|    sta = []
   311|         0|            0|            0|  0.00%|    cache = {}
   312|         0|            0|            0|  0.00%|    for name in vardict.keys():
   313|         0|            0|            0|  0.00%|        if isinstance(vardict[name], ndarray):
   314|         0|            0|            0|  0.00%|            var = vardict[name]
   315|         0|            0|            0|  0.00%|            idv = id(var)
   316|         0|            0|            0|  0.00%|            if idv in cache.keys():
   317|         0|            0|            0|  0.00%|                namestr = name + " (%s)" % cache[idv]
   318|         0|            0|            0|  0.00%|                original = 0
   319|         0|            0|            0|  0.00%|            else:
   320|         0|            0|            0|  0.00%|                cache[idv] = name
   321|         0|            0|            0|  0.00%|                namestr = name
   322|         0|            0|            0|  0.00%|                original = 1
   323|         0|            0|            0|  0.00%|            shapestr = " x ".join(map(str, var.shape))
   324|         0|            0|            0|  0.00%|            bytestr = str(var.nbytes)
   325|         0|            0|            0|  0.00%|            sta.append([namestr, shapestr, bytestr, var.dtype.name,
   326|         0|            0|            0|  0.00%|                        original])
   327|         0|            0|            0|  0.00%|
   328|         0|            0|            0|  0.00%|    maxname = 0
   329|         0|            0|            0|  0.00%|    maxshape = 0
   330|         0|            0|            0|  0.00%|    maxbyte = 0
   331|         0|            0|            0|  0.00%|    totalbytes = 0
   332|         0|            0|            0|  0.00%|    for k in range(len(sta)):
   333|         0|            0|            0|  0.00%|        val = sta[k]
   334|         0|            0|            0|  0.00%|        if maxname < len(val[0]):
   335|         0|            0|            0|  0.00%|            maxname = len(val[0])
   336|         0|            0|            0|  0.00%|        if maxshape < len(val[1]):
   337|         0|            0|            0|  0.00%|            maxshape = len(val[1])
   338|         0|            0|            0|  0.00%|        if maxbyte < len(val[2]):
   339|         0|            0|            0|  0.00%|            maxbyte = len(val[2])
   340|         0|            0|            0|  0.00%|        if val[4]:
   341|         0|            0|            0|  0.00%|            totalbytes += int(val[2])
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    if len(sta) > 0:
   344|         0|            0|            0|  0.00%|        sp1 = max(10, maxname)
   345|         0|            0|            0|  0.00%|        sp2 = max(10, maxshape)
   346|         0|            0|            0|  0.00%|        sp3 = max(10, maxbyte)
   347|         0|            0|            0|  0.00%|        prval = "Name %s Shape %s Bytes %s Type" % (sp1*' ', sp2*' ', sp3*' ')
   348|         0|            0|            0|  0.00%|        print(prval + "\n" + "="*(len(prval)+5) + "\n")
   349|         0|            0|            0|  0.00%|
   350|         0|            0|            0|  0.00%|    for k in range(len(sta)):
   351|         0|            0|            0|  0.00%|        val = sta[k]
   352|         0|            0|            0|  0.00%|        print("%s %s %s %s %s %s %s" % (val[0], ' '*(sp1-len(val[0])+4),
   353|         0|            0|            0|  0.00%|                                        val[1], ' '*(sp2-len(val[1])+5),
   354|         0|            0|            0|  0.00%|                                        val[2], ' '*(sp3-len(val[2])+5),
   355|         0|            0|            0|  0.00%|                                        val[3]))
   356|         0|            0|            0|  0.00%|    print("\nUpper bound on total bytes  =       %d" % totalbytes)
   357|         0|            0|            0|  0.00%|    return
   358|         0|            0|            0|  0.00%|
   359|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
   360|         0|            0|            0|  0.00%|
   361|         0|            0|            0|  0.00%|
   362|         0|            0|            0|  0.00%|# NOTE:  pydoc defines a help function which works similarly to this
   363|         0|            0|            0|  0.00%|#  except it uses a pager to take over the screen.
   364|         0|            0|            0|  0.00%|
   365|         0|            0|            0|  0.00%|# combine name and arguments and split to multiple lines of width
   366|         0|            0|            0|  0.00%|# characters.  End lines on a comma and begin argument list indented with
   367|         0|            0|            0|  0.00%|# the rest of the arguments.
   368|         0|            0|            0|  0.00%|def _split_line(name, arguments, width):
   369|         0|            0|            0|  0.00%|    firstwidth = len(name)
   370|         0|            0|            0|  0.00%|    k = firstwidth
   371|         0|            0|            0|  0.00%|    newstr = name
   372|         0|            0|            0|  0.00%|    sepstr = ", "
   373|         0|            0|            0|  0.00%|    arglist = arguments.split(sepstr)
   374|         0|            0|            0|  0.00%|    for argument in arglist:
   375|         0|            0|            0|  0.00%|        if k == firstwidth:
   376|         0|            0|            0|  0.00%|            addstr = ""
   377|         0|            0|            0|  0.00%|        else:
   378|         0|            0|            0|  0.00%|            addstr = sepstr
   379|         0|            0|            0|  0.00%|        k = k + len(argument) + len(addstr)
   380|         0|            0|            0|  0.00%|        if k > width:
   381|         0|            0|            0|  0.00%|            k = firstwidth + 1 + len(argument)
   382|         0|            0|            0|  0.00%|            newstr = newstr + ",\n" + " "*(firstwidth+2) + argument
   383|         0|            0|            0|  0.00%|        else:
   384|         0|            0|            0|  0.00%|            newstr = newstr + addstr + argument
   385|         0|            0|            0|  0.00%|    return newstr
   386|         0|            0|            0|  0.00%|
   387|         0|            0|            0|  0.00%|_namedict = None
   388|         0|            0|            0|  0.00%|_dictlist = None
   389|         0|            0|            0|  0.00%|
   390|         0|            0|            0|  0.00%|# Traverse all module directories underneath globals
   391|         0|            0|            0|  0.00%|# to see if something is defined
   392|         0|            0|            0|  0.00%|def _makenamedict(module='numpy'):
   393|         0|            0|            0|  0.00%|    module = __import__(module, globals(), locals(), [])
   394|         0|            0|            0|  0.00%|    thedict = {module.__name__:module.__dict__}
   395|         0|            0|            0|  0.00%|    dictlist = [module.__name__]
   396|         0|            0|            0|  0.00%|    totraverse = [module.__dict__]
   397|         0|            0|            0|  0.00%|    while True:
   398|         0|            0|            0|  0.00%|        if len(totraverse) == 0:
   399|         0|            0|            0|  0.00%|            break
   400|         0|            0|            0|  0.00%|        thisdict = totraverse.pop(0)
   401|         0|            0|            0|  0.00%|        for x in thisdict.keys():
   402|         0|            0|            0|  0.00%|            if isinstance(thisdict[x], types.ModuleType):
   403|         0|            0|            0|  0.00%|                modname = thisdict[x].__name__
   404|         0|            0|            0|  0.00%|                if modname not in dictlist:
   405|         0|            0|            0|  0.00%|                    moddict = thisdict[x].__dict__
   406|         0|            0|            0|  0.00%|                    dictlist.append(modname)
   407|         0|            0|            0|  0.00%|                    totraverse.append(moddict)
   408|         0|            0|            0|  0.00%|                    thedict[modname] = moddict
   409|         0|            0|            0|  0.00%|    return thedict, dictlist
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|
   412|         0|            0|            0|  0.00%|def _info(obj, output=sys.stdout):
   413|         0|            0|            0|  0.00%|    """Provide information about ndarray obj.
   414|         0|            0|            0|  0.00%|
   415|         0|            0|            0|  0.00%|    Parameters
   416|         0|            0|            0|  0.00%|    ----------
   417|         0|            0|            0|  0.00%|    obj : ndarray
   418|         0|            0|            0|  0.00%|        Must be ndarray, not checked.
   419|         0|            0|            0|  0.00%|    output
   420|         0|            0|            0|  0.00%|        Where printed output goes.
   421|         0|            0|            0|  0.00%|
   422|         0|            0|            0|  0.00%|    Notes
   423|         0|            0|            0|  0.00%|    -----
   424|         0|            0|            0|  0.00%|    Copied over from the numarray module prior to its removal.
   425|         0|            0|            0|  0.00%|    Adapted somewhat as only numpy is an option now.
   426|         0|            0|            0|  0.00%|
   427|         0|            0|            0|  0.00%|    Called by info.
   428|         0|            0|            0|  0.00%|
   429|         0|            0|            0|  0.00%|    """
   430|         0|            0|            0|  0.00%|    extra = ""
   431|         0|            0|            0|  0.00%|    tic = ""
   432|         0|            0|            0|  0.00%|    bp = lambda x: x
   433|         0|            0|            0|  0.00%|    cls = getattr(obj, '__class__', type(obj))
   434|         0|            0|            0|  0.00%|    nm = getattr(cls, '__name__', cls)
   435|         0|            0|            0|  0.00%|    strides = obj.strides
   436|         0|            0|            0|  0.00%|    endian = obj.dtype.byteorder
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|    print("class: ", nm, file=output)
   439|         0|            0|            0|  0.00%|    print("shape: ", obj.shape, file=output)
   440|         0|            0|            0|  0.00%|    print("strides: ", strides, file=output)
   441|         0|            0|            0|  0.00%|    print("itemsize: ", obj.itemsize, file=output)
   442|         0|            0|            0|  0.00%|    print("aligned: ", bp(obj.flags.aligned), file=output)
   443|         0|            0|            0|  0.00%|    print("contiguous: ", bp(obj.flags.contiguous), file=output)
   444|         0|            0|            0|  0.00%|    print("fortran: ", obj.flags.fortran, file=output)
   445|         0|            0|            0|  0.00%|    print(
   446|         0|            0|            0|  0.00%|        "data pointer: %s%s" % (hex(obj.ctypes._as_parameter_.value), extra),
   447|         0|            0|            0|  0.00%|        file=output
   448|         0|            0|            0|  0.00%|        )
   449|         0|            0|            0|  0.00%|    print("byteorder: ", end=' ', file=output)
   450|         0|            0|            0|  0.00%|    if endian in ['|', '=']:
   451|         0|            0|            0|  0.00%|        print("%s%s%s" % (tic, sys.byteorder, tic), file=output)
   452|         0|            0|            0|  0.00%|        byteswap = False
   453|         0|            0|            0|  0.00%|    elif endian == '>':
   454|         0|            0|            0|  0.00%|        print("%sbig%s" % (tic, tic), file=output)
   455|         0|            0|            0|  0.00%|        byteswap = sys.byteorder != "big"
   456|         0|            0|            0|  0.00%|    else:
   457|         0|            0|            0|  0.00%|        print("%slittle%s" % (tic, tic), file=output)
   458|         0|            0|            0|  0.00%|        byteswap = sys.byteorder != "little"
   459|         0|            0|            0|  0.00%|    print("byteswap: ", bp(byteswap), file=output)
   460|         0|            0|            0|  0.00%|    print("type: %s" % obj.dtype, file=output)
   461|         0|            0|            0|  0.00%|
   462|         0|            0|            0|  0.00%|
   463|         0|            0|            0|  0.00%|@set_module('numpy')
   464|         0|            0|            0|  0.00%|def info(object=None, maxwidth=76, output=sys.stdout, toplevel='numpy'):
   465|         0|            0|            0|  0.00%|    """
   466|         0|            0|            0|  0.00%|    Get help information for a function, class, or module.
   467|         0|            0|            0|  0.00%|
   468|         0|            0|            0|  0.00%|    Parameters
   469|         0|            0|            0|  0.00%|    ----------
   470|         0|            0|            0|  0.00%|    object : object or str, optional
   471|         0|            0|            0|  0.00%|        Input object or name to get information about. If `object` is a
   472|         0|            0|            0|  0.00%|        numpy object, its docstring is given. If it is a string, available
   473|         0|            0|            0|  0.00%|        modules are searched for matching objects.  If None, information
   474|         0|            0|            0|  0.00%|        about `info` itself is returned.
   475|         0|            0|            0|  0.00%|    maxwidth : int, optional
   476|         0|            0|            0|  0.00%|        Printing width.
   477|         0|            0|            0|  0.00%|    output : file like object, optional
   478|         0|            0|            0|  0.00%|        File like object that the output is written to, default is
   479|         0|            0|            0|  0.00%|        ``stdout``.  The object has to be opened in 'w' or 'a' mode.
   480|         0|            0|            0|  0.00%|    toplevel : str, optional
   481|         0|            0|            0|  0.00%|        Start search at this level.
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|    See Also
   484|         0|            0|            0|  0.00%|    --------
   485|         0|            0|            0|  0.00%|    source, lookfor
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|    Notes
   488|         0|            0|            0|  0.00%|    -----
   489|         0|            0|            0|  0.00%|    When used interactively with an object, ``np.info(obj)`` is equivalent
   490|         0|            0|            0|  0.00%|    to ``help(obj)`` on the Python prompt or ``obj?`` on the IPython
   491|         0|            0|            0|  0.00%|    prompt.
   492|         0|            0|            0|  0.00%|
   493|         0|            0|            0|  0.00%|    Examples
   494|         0|            0|            0|  0.00%|    --------
   495|         0|            0|            0|  0.00%|    >>> np.info(np.polyval) # doctest: +SKIP
   496|         0|            0|            0|  0.00%|       polyval(p, x)
   497|         0|            0|            0|  0.00%|         Evaluate the polynomial p at x.
   498|         0|            0|            0|  0.00%|         ...
   499|         0|            0|            0|  0.00%|
   500|         0|            0|            0|  0.00%|    When using a string for `object` it is possible to get multiple results.
   501|         0|            0|            0|  0.00%|
   502|         0|            0|            0|  0.00%|    >>> np.info('fft') # doctest: +SKIP
   503|         0|            0|            0|  0.00%|         *** Found in numpy ***
   504|         0|            0|            0|  0.00%|    Core FFT routines
   505|         0|            0|            0|  0.00%|    ...
   506|         0|            0|            0|  0.00%|         *** Found in numpy.fft ***
   507|         0|            0|            0|  0.00%|     fft(a, n=None, axis=-1)
   508|         0|            0|            0|  0.00%|    ...
   509|         0|            0|            0|  0.00%|         *** Repeat reference found in numpy.fft.fftpack ***
   510|         0|            0|            0|  0.00%|         *** Total of 3 references found. ***
   511|         0|            0|            0|  0.00%|
   512|         0|            0|            0|  0.00%|    """
   513|         0|            0|            0|  0.00%|    global _namedict, _dictlist
   514|         0|            0|            0|  0.00%|    # Local import to speed up numpy's import time.
   515|         0|            0|            0|  0.00%|    import pydoc
   516|         0|            0|            0|  0.00%|    import inspect
   517|         0|            0|            0|  0.00%|
   518|         0|            0|            0|  0.00%|    if (hasattr(object, '_ppimport_importer') or
   519|         0|            0|            0|  0.00%|           hasattr(object, '_ppimport_module')):
   520|         0|            0|            0|  0.00%|        object = object._ppimport_module
   521|         0|            0|            0|  0.00%|    elif hasattr(object, '_ppimport_attr'):
   522|         0|            0|            0|  0.00%|        object = object._ppimport_attr
   523|         0|            0|            0|  0.00%|
   524|         0|            0|            0|  0.00%|    if object is None:
   525|         0|            0|            0|  0.00%|        info(info)
   526|         0|            0|            0|  0.00%|    elif isinstance(object, ndarray):
   527|         0|            0|            0|  0.00%|        _info(object, output=output)
   528|         0|            0|            0|  0.00%|    elif isinstance(object, str):
   529|         0|            0|            0|  0.00%|        if _namedict is None:
   530|         0|            0|            0|  0.00%|            _namedict, _dictlist = _makenamedict(toplevel)
   531|         0|            0|            0|  0.00%|        numfound = 0
   532|         0|            0|            0|  0.00%|        objlist = []
   533|         0|            0|            0|  0.00%|        for namestr in _dictlist:
   534|         0|            0|            0|  0.00%|            try:
   535|         0|            0|            0|  0.00%|                obj = _namedict[namestr][object]
   536|         0|            0|            0|  0.00%|                if id(obj) in objlist:
   537|         0|            0|            0|  0.00%|                    print("\n     "
   538|         0|            0|            0|  0.00%|                          "*** Repeat reference found in %s *** " % namestr,
   539|         0|            0|            0|  0.00%|                          file=output
   540|         0|            0|            0|  0.00%|                          )
   541|         0|            0|            0|  0.00%|                else:
   542|         0|            0|            0|  0.00%|                    objlist.append(id(obj))
   543|         0|            0|            0|  0.00%|                    print("     *** Found in %s ***" % namestr, file=output)
   544|         0|            0|            0|  0.00%|                    info(obj)
   545|         0|            0|            0|  0.00%|                    print("-"*maxwidth, file=output)
   546|         0|            0|            0|  0.00%|                numfound += 1
   547|         0|            0|            0|  0.00%|            except KeyError:
   548|         0|            0|            0|  0.00%|                pass
   549|         0|            0|            0|  0.00%|        if numfound == 0:
   550|         0|            0|            0|  0.00%|            print("Help for %s not found." % object, file=output)
   551|         0|            0|            0|  0.00%|        else:
   552|         0|            0|            0|  0.00%|            print("\n     "
   553|         0|            0|            0|  0.00%|                  "*** Total of %d references found. ***" % numfound,
   554|         0|            0|            0|  0.00%|                  file=output
   555|         0|            0|            0|  0.00%|                  )
   556|         0|            0|            0|  0.00%|
   557|         0|            0|            0|  0.00%|    elif inspect.isfunction(object):
   558|         0|            0|            0|  0.00%|        name = object.__name__
   559|         0|            0|            0|  0.00%|        arguments = formatargspec(*getargspec(object))
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|        if len(name+arguments) > maxwidth:
   562|         0|            0|            0|  0.00%|            argstr = _split_line(name, arguments, maxwidth)
   563|         0|            0|            0|  0.00%|        else:
   564|         0|            0|            0|  0.00%|            argstr = name + arguments
   565|         0|            0|            0|  0.00%|
   566|         0|            0|            0|  0.00%|        print(" " + argstr + "\n", file=output)
   567|         0|            0|            0|  0.00%|        print(inspect.getdoc(object), file=output)
   568|         0|            0|            0|  0.00%|
   569|         0|            0|            0|  0.00%|    elif inspect.isclass(object):
   570|         0|            0|            0|  0.00%|        name = object.__name__
   571|         0|            0|            0|  0.00%|        arguments = "()"
   572|         0|            0|            0|  0.00%|        try:
   573|         0|            0|            0|  0.00%|            if hasattr(object, '__init__'):
   574|         0|            0|            0|  0.00%|                arguments = formatargspec(
   575|         0|            0|            0|  0.00%|                        *getargspec(object.__init__.__func__)
   576|         0|            0|            0|  0.00%|                        )
   577|         0|            0|            0|  0.00%|                arglist = arguments.split(', ')
   578|         0|            0|            0|  0.00%|                if len(arglist) > 1:
   579|         0|            0|            0|  0.00%|                    arglist[1] = "("+arglist[1]
   580|         0|            0|            0|  0.00%|                    arguments = ", ".join(arglist[1:])
   581|         0|            0|            0|  0.00%|        except Exception:
   582|         0|            0|            0|  0.00%|            pass
   583|         0|            0|            0|  0.00%|
   584|         0|            0|            0|  0.00%|        if len(name+arguments) > maxwidth:
   585|         0|            0|            0|  0.00%|            argstr = _split_line(name, arguments, maxwidth)
   586|         0|            0|            0|  0.00%|        else:
   587|         0|            0|            0|  0.00%|            argstr = name + arguments
   588|         0|            0|            0|  0.00%|
   589|         0|            0|            0|  0.00%|        print(" " + argstr + "\n", file=output)
   590|         0|            0|            0|  0.00%|        doc1 = inspect.getdoc(object)
   591|         0|            0|            0|  0.00%|        if doc1 is None:
   592|         0|            0|            0|  0.00%|            if hasattr(object, '__init__'):
   593|         0|            0|            0|  0.00%|                print(inspect.getdoc(object.__init__), file=output)
   594|         0|            0|            0|  0.00%|        else:
   595|         0|            0|            0|  0.00%|            print(inspect.getdoc(object), file=output)
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|        methods = pydoc.allmethods(object)
   598|         0|            0|            0|  0.00%|        if methods != []:
   599|         0|            0|            0|  0.00%|            print("\n\nMethods:\n", file=output)
   600|         0|            0|            0|  0.00%|            for meth in methods:
   601|         0|            0|            0|  0.00%|                if meth[0] == '_':
   602|         0|            0|            0|  0.00%|                    continue
   603|         0|            0|            0|  0.00%|                thisobj = getattr(object, meth, None)
   604|         0|            0|            0|  0.00%|                if thisobj is not None:
   605|         0|            0|            0|  0.00%|                    methstr, other = pydoc.splitdoc(
   606|         0|            0|            0|  0.00%|                            inspect.getdoc(thisobj) or "None"
   607|         0|            0|            0|  0.00%|                            )
   608|         0|            0|            0|  0.00%|                print("  %s  --  %s" % (meth, methstr), file=output)
   609|         0|            0|            0|  0.00%|
   610|         0|            0|            0|  0.00%|    elif (sys.version_info[0] < 3
   611|         0|            0|            0|  0.00%|            and isinstance(object, types.InstanceType)):
   612|         0|            0|            0|  0.00%|        # check for __call__ method
   613|         0|            0|            0|  0.00%|        # types.InstanceType is the type of the instances of oldstyle classes
   614|         0|            0|            0|  0.00%|        print("Instance of class: ", object.__class__.__name__, file=output)
   615|         0|            0|            0|  0.00%|        print(file=output)
   616|         0|            0|            0|  0.00%|        if hasattr(object, '__call__'):
   617|         0|            0|            0|  0.00%|            arguments = formatargspec(
   618|         0|            0|            0|  0.00%|                    *getargspec(object.__call__.__func__)
   619|         0|            0|            0|  0.00%|                    )
   620|         0|            0|            0|  0.00%|            arglist = arguments.split(', ')
   621|         0|            0|            0|  0.00%|            if len(arglist) > 1:
   622|         0|            0|            0|  0.00%|                arglist[1] = "("+arglist[1]
   623|         0|            0|            0|  0.00%|                arguments = ", ".join(arglist[1:])
   624|         0|            0|            0|  0.00%|            else:
   625|         0|            0|            0|  0.00%|                arguments = "()"
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|            if hasattr(object, 'name'):
   628|         0|            0|            0|  0.00%|                name = "%s" % object.name
   629|         0|            0|            0|  0.00%|            else:
   630|         0|            0|            0|  0.00%|                name = "<name>"
   631|         0|            0|            0|  0.00%|            if len(name+arguments) > maxwidth:
   632|         0|            0|            0|  0.00%|                argstr = _split_line(name, arguments, maxwidth)
   633|         0|            0|            0|  0.00%|            else:
   634|         0|            0|            0|  0.00%|                argstr = name + arguments
   635|         0|            0|            0|  0.00%|
   636|         0|            0|            0|  0.00%|            print(" " + argstr + "\n", file=output)
   637|         0|            0|            0|  0.00%|            doc = inspect.getdoc(object.__call__)
   638|         0|            0|            0|  0.00%|            if doc is not None:
   639|         0|            0|            0|  0.00%|                print(inspect.getdoc(object.__call__), file=output)
   640|         0|            0|            0|  0.00%|            print(inspect.getdoc(object), file=output)
   641|         0|            0|            0|  0.00%|
   642|         0|            0|            0|  0.00%|        else:
   643|         0|            0|            0|  0.00%|            print(inspect.getdoc(object), file=output)
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    elif inspect.ismethod(object):
   646|         0|            0|            0|  0.00%|        name = object.__name__
   647|         0|            0|            0|  0.00%|        arguments = formatargspec(
   648|         0|            0|            0|  0.00%|                *getargspec(object.__func__)
   649|         0|            0|            0|  0.00%|                )
   650|         0|            0|            0|  0.00%|        arglist = arguments.split(', ')
   651|         0|            0|            0|  0.00%|        if len(arglist) > 1:
   652|         0|            0|            0|  0.00%|            arglist[1] = "("+arglist[1]
   653|         0|            0|            0|  0.00%|            arguments = ", ".join(arglist[1:])
   654|         0|            0|            0|  0.00%|        else:
   655|         0|            0|            0|  0.00%|            arguments = "()"
   656|         0|            0|            0|  0.00%|
   657|         0|            0|            0|  0.00%|        if len(name+arguments) > maxwidth:
   658|         0|            0|            0|  0.00%|            argstr = _split_line(name, arguments, maxwidth)
   659|         0|            0|            0|  0.00%|        else:
   660|         0|            0|            0|  0.00%|            argstr = name + arguments
   661|         0|            0|            0|  0.00%|
   662|         0|            0|            0|  0.00%|        print(" " + argstr + "\n", file=output)
   663|         0|            0|            0|  0.00%|        print(inspect.getdoc(object), file=output)
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|    elif hasattr(object, '__doc__'):
   666|         0|            0|            0|  0.00%|        print(inspect.getdoc(object), file=output)
   667|         0|            0|            0|  0.00%|
   668|         0|            0|            0|  0.00%|
   669|         0|            0|            0|  0.00%|@set_module('numpy')
   670|         0|            0|            0|  0.00%|def source(object, output=sys.stdout):
   671|         0|            0|            0|  0.00%|    """
   672|         0|            0|            0|  0.00%|    Print or write to a file the source code for a NumPy object.
   673|         0|            0|            0|  0.00%|
   674|         0|            0|            0|  0.00%|    The source code is only returned for objects written in Python. Many
   675|         0|            0|            0|  0.00%|    functions and classes are defined in C and will therefore not return
   676|         0|            0|            0|  0.00%|    useful information.
   677|         0|            0|            0|  0.00%|
   678|         0|            0|            0|  0.00%|    Parameters
   679|         0|            0|            0|  0.00%|    ----------
   680|         0|            0|            0|  0.00%|    object : numpy object
   681|         0|            0|            0|  0.00%|        Input object. This can be any object (function, class, module,
   682|         0|            0|            0|  0.00%|        ...).
   683|         0|            0|            0|  0.00%|    output : file object, optional
   684|         0|            0|            0|  0.00%|        If `output` not supplied then source code is printed to screen
   685|         0|            0|            0|  0.00%|        (sys.stdout).  File object must be created with either write 'w' or
   686|         0|            0|            0|  0.00%|        append 'a' modes.
   687|         0|            0|            0|  0.00%|
   688|         0|            0|            0|  0.00%|    See Also
   689|         0|            0|            0|  0.00%|    --------
   690|         0|            0|            0|  0.00%|    lookfor, info
   691|         0|            0|            0|  0.00%|
   692|         0|            0|            0|  0.00%|    Examples
   693|         0|            0|            0|  0.00%|    --------
   694|         0|            0|            0|  0.00%|    >>> np.source(np.interp)                        #doctest: +SKIP
   695|         0|            0|            0|  0.00%|    In file: /usr/lib/python2.6/dist-packages/numpy/lib/function_base.py
   696|         0|            0|            0|  0.00%|    def interp(x, xp, fp, left=None, right=None):
   697|         0|            0|            0|  0.00%|        \"\"\".... (full docstring printed)\"\"\"
   698|         0|            0|            0|  0.00%|        if isinstance(x, (float, int, number)):
   699|         0|            0|            0|  0.00%|            return compiled_interp([x], xp, fp, left, right).item()
   700|         0|            0|            0|  0.00%|        else:
   701|         0|            0|            0|  0.00%|            return compiled_interp(x, xp, fp, left, right)
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    The source code is only returned for objects written in Python.
   704|         0|            0|            0|  0.00%|
   705|         0|            0|            0|  0.00%|    >>> np.source(np.array)                         #doctest: +SKIP
   706|         0|            0|            0|  0.00%|    Not available for this object.
   707|         0|            0|            0|  0.00%|
   708|         0|            0|            0|  0.00%|    """
   709|         0|            0|            0|  0.00%|    # Local import to speed up numpy's import time.
   710|         0|            0|            0|  0.00%|    import inspect
   711|         0|            0|            0|  0.00%|    try:
   712|         0|            0|            0|  0.00%|        print("In file: %s\n" % inspect.getsourcefile(object), file=output)
   713|         0|            0|            0|  0.00%|        print(inspect.getsource(object), file=output)
   714|         0|            0|            0|  0.00%|    except Exception:
   715|         0|            0|            0|  0.00%|        print("Not available for this object.", file=output)
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|
   718|         0|            0|            0|  0.00%|# Cache for lookfor: {id(module): {name: (docstring, kind, index), ...}...}
   719|         0|            0|            0|  0.00%|# where kind: "func", "class", "module", "object"
   720|         0|            0|            0|  0.00%|# and index: index in breadth-first namespace traversal
   721|         0|            0|            0|  0.00%|_lookfor_caches = {}
   722|         0|            0|            0|  0.00%|
   723|         0|            0|            0|  0.00%|# regexp whose match indicates that the string may contain a function
   724|         0|            0|            0|  0.00%|# signature
   725|         0|            0|            0|  0.00%|_function_signature_re = re.compile(r"[a-z0-9_]+\(.*[,=].*\)", re.I)
   726|         0|            0|            0|  0.00%|
   727|         0|            0|            0|  0.00%|
   728|         0|            0|            0|  0.00%|@set_module('numpy')
   729|         0|            0|            0|  0.00%|def lookfor(what, module=None, import_modules=True, regenerate=False,
   730|         0|            0|            0|  0.00%|            output=None):
   731|         0|            0|            0|  0.00%|    """
   732|         0|            0|            0|  0.00%|    Do a keyword search on docstrings.
   733|         0|            0|            0|  0.00%|
   734|         0|            0|            0|  0.00%|    A list of objects that matched the search is displayed,
   735|         0|            0|            0|  0.00%|    sorted by relevance. All given keywords need to be found in the
   736|         0|            0|            0|  0.00%|    docstring for it to be returned as a result, but the order does
   737|         0|            0|            0|  0.00%|    not matter.
   738|         0|            0|            0|  0.00%|
   739|         0|            0|            0|  0.00%|    Parameters
   740|         0|            0|            0|  0.00%|    ----------
   741|         0|            0|            0|  0.00%|    what : str
   742|         0|            0|            0|  0.00%|        String containing words to look for.
   743|         0|            0|            0|  0.00%|    module : str or list, optional
   744|         0|            0|            0|  0.00%|        Name of module(s) whose docstrings to go through.
   745|         0|            0|            0|  0.00%|    import_modules : bool, optional
   746|         0|            0|            0|  0.00%|        Whether to import sub-modules in packages. Default is True.
   747|         0|            0|            0|  0.00%|    regenerate : bool, optional
   748|         0|            0|            0|  0.00%|        Whether to re-generate the docstring cache. Default is False.
   749|         0|            0|            0|  0.00%|    output : file-like, optional
   750|         0|            0|            0|  0.00%|        File-like object to write the output to. If omitted, use a pager.
   751|         0|            0|            0|  0.00%|
   752|         0|            0|            0|  0.00%|    See Also
   753|         0|            0|            0|  0.00%|    --------
   754|         0|            0|            0|  0.00%|    source, info
   755|         0|            0|            0|  0.00%|
   756|         0|            0|            0|  0.00%|    Notes
   757|         0|            0|            0|  0.00%|    -----
   758|         0|            0|            0|  0.00%|    Relevance is determined only roughly, by checking if the keywords occur
   759|         0|            0|            0|  0.00%|    in the function name, at the start of a docstring, etc.
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|    Examples
   762|         0|            0|            0|  0.00%|    --------
   763|         0|            0|            0|  0.00%|    >>> np.lookfor('binary representation') # doctest: +SKIP
   764|         0|            0|            0|  0.00%|    Search results for 'binary representation'
   765|         0|            0|            0|  0.00%|    ------------------------------------------
   766|         0|            0|            0|  0.00%|    numpy.binary_repr
   767|         0|            0|            0|  0.00%|        Return the binary representation of the input number as a string.
   768|         0|            0|            0|  0.00%|    numpy.core.setup_common.long_double_representation
   769|         0|            0|            0|  0.00%|        Given a binary dump as given by GNU od -b, look for long double
   770|         0|            0|            0|  0.00%|    numpy.base_repr
   771|         0|            0|            0|  0.00%|        Return a string representation of a number in the given base system.
   772|         0|            0|            0|  0.00%|    ...
   773|         0|            0|            0|  0.00%|
   774|         0|            0|            0|  0.00%|    """
   775|         0|            0|            0|  0.00%|    import pydoc
   776|         0|            0|            0|  0.00%|
   777|         0|            0|            0|  0.00%|    # Cache
   778|         0|            0|            0|  0.00%|    cache = _lookfor_generate_cache(module, import_modules, regenerate)
   779|         0|            0|            0|  0.00%|
   780|         0|            0|            0|  0.00%|    # Search
   781|         0|            0|            0|  0.00%|    # XXX: maybe using a real stemming search engine would be better?
   782|         0|            0|            0|  0.00%|    found = []
   783|         0|            0|            0|  0.00%|    whats = str(what).lower().split()
   784|         0|            0|            0|  0.00%|    if not whats:
   785|         0|            0|            0|  0.00%|        return
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|    for name, (docstring, kind, index) in cache.items():
   788|         0|            0|            0|  0.00%|        if kind in ('module', 'object'):
   789|         0|            0|            0|  0.00%|            # don't show modules or objects
   790|         0|            0|            0|  0.00%|            continue
   791|         0|            0|            0|  0.00%|        ok = True
   792|         0|            0|            0|  0.00%|        doc = docstring.lower()
   793|         0|            0|            0|  0.00%|        for w in whats:
   794|         0|            0|            0|  0.00%|            if w not in doc:
   795|         0|            0|            0|  0.00%|                ok = False
   796|         0|            0|            0|  0.00%|                break
   797|         0|            0|            0|  0.00%|        if ok:
   798|         0|            0|            0|  0.00%|            found.append(name)
   799|         0|            0|            0|  0.00%|
   800|         0|            0|            0|  0.00%|    # Relevance sort
   801|         0|            0|            0|  0.00%|    # XXX: this is full Harrison-Stetson heuristics now,
   802|         0|            0|            0|  0.00%|    # XXX: it probably could be improved
   803|         0|            0|            0|  0.00%|
   804|         0|            0|            0|  0.00%|    kind_relevance = {'func': 1000, 'class': 1000,
   805|         0|            0|            0|  0.00%|                      'module': -1000, 'object': -1000}
   806|         0|            0|            0|  0.00%|
   807|         0|            0|            0|  0.00%|    def relevance(name, docstr, kind, index):
   808|         0|            0|            0|  0.00%|        r = 0
   809|         0|            0|            0|  0.00%|        # do the keywords occur within the start of the docstring?
   810|         0|            0|            0|  0.00%|        first_doc = "\n".join(docstr.lower().strip().split("\n")[:3])
   811|         0|            0|            0|  0.00%|        r += sum([200 for w in whats if w in first_doc])
   812|         0|            0|            0|  0.00%|        # do the keywords occur in the function name?
   813|         0|            0|            0|  0.00%|        r += sum([30 for w in whats if w in name])
   814|         0|            0|            0|  0.00%|        # is the full name long?
   815|         0|            0|            0|  0.00%|        r += -len(name) * 5
   816|         0|            0|            0|  0.00%|        # is the object of bad type?
   817|         0|            0|            0|  0.00%|        r += kind_relevance.get(kind, -1000)
   818|         0|            0|            0|  0.00%|        # is the object deep in namespace hierarchy?
   819|         0|            0|            0|  0.00%|        r += -name.count('.') * 10
   820|         0|            0|            0|  0.00%|        r += max(-index / 100, -100)
   821|         0|            0|            0|  0.00%|        return r
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    def relevance_value(a):
   824|         0|            0|            0|  0.00%|        return relevance(a, *cache[a])
   825|         0|            0|            0|  0.00%|    found.sort(key=relevance_value)
   826|         0|            0|            0|  0.00%|
   827|         0|            0|            0|  0.00%|    # Pretty-print
   828|         0|            0|            0|  0.00%|    s = "Search results for '%s'" % (' '.join(whats))
   829|         0|            0|            0|  0.00%|    help_text = [s, "-"*len(s)]
   830|         0|            0|            0|  0.00%|    for name in found[::-1]:
   831|         0|            0|            0|  0.00%|        doc, kind, ix = cache[name]
   832|         0|            0|            0|  0.00%|
   833|         0|            0|            0|  0.00%|        doclines = [line.strip() for line in doc.strip().split("\n")
   834|         0|            0|            0|  0.00%|                    if line.strip()]
   835|         0|            0|            0|  0.00%|
   836|         0|            0|            0|  0.00%|        # find a suitable short description
   837|         0|            0|            0|  0.00%|        try:
   838|         0|            0|            0|  0.00%|            first_doc = doclines[0].strip()
   839|         0|            0|            0|  0.00%|            if _function_signature_re.search(first_doc):
   840|         0|            0|            0|  0.00%|                first_doc = doclines[1].strip()
   841|         0|            0|            0|  0.00%|        except IndexError:
   842|         0|            0|            0|  0.00%|            first_doc = ""
   843|         0|            0|            0|  0.00%|        help_text.append("%s\n    %s" % (name, first_doc))
   844|         0|            0|            0|  0.00%|
   845|         0|            0|            0|  0.00%|    if not found:
   846|         0|            0|            0|  0.00%|        help_text.append("Nothing found.")
   847|         0|            0|            0|  0.00%|
   848|         0|            0|            0|  0.00%|    # Output
   849|         0|            0|            0|  0.00%|    if output is not None:
   850|         0|            0|            0|  0.00%|        output.write("\n".join(help_text))
   851|         0|            0|            0|  0.00%|    elif len(help_text) > 10:
   852|         0|            0|            0|  0.00%|        pager = pydoc.getpager()
   853|         0|            0|            0|  0.00%|        pager("\n".join(help_text))
   854|         0|            0|            0|  0.00%|    else:
   855|         0|            0|            0|  0.00%|        print("\n".join(help_text))
   856|         0|            0|            0|  0.00%|
   857|         0|            0|            0|  0.00%|def _lookfor_generate_cache(module, import_modules, regenerate):
   858|         0|            0|            0|  0.00%|    """
   859|         0|            0|            0|  0.00%|    Generate docstring cache for given module.
   860|         0|            0|            0|  0.00%|
   861|         0|            0|            0|  0.00%|    Parameters
   862|         0|            0|            0|  0.00%|    ----------
   863|         0|            0|            0|  0.00%|    module : str, None, module
   864|         0|            0|            0|  0.00%|        Module for which to generate docstring cache
   865|         0|            0|            0|  0.00%|    import_modules : bool
   866|         0|            0|            0|  0.00%|        Whether to import sub-modules in packages.
   867|         0|            0|            0|  0.00%|    regenerate : bool
   868|         0|            0|            0|  0.00%|        Re-generate the docstring cache
   869|         0|            0|            0|  0.00%|
   870|         0|            0|            0|  0.00%|    Returns
   871|         0|            0|            0|  0.00%|    -------
   872|         0|            0|            0|  0.00%|    cache : dict {obj_full_name: (docstring, kind, index), ...}
   873|         0|            0|            0|  0.00%|        Docstring cache for the module, either cached one (regenerate=False)
   874|         0|            0|            0|  0.00%|        or newly generated.
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|    """
   877|         0|            0|            0|  0.00%|    global _lookfor_caches
   878|         0|            0|            0|  0.00%|    # Local import to speed up numpy's import time.
   879|         0|            0|            0|  0.00%|    import inspect
   880|         0|            0|            0|  0.00%|
   881|         0|            0|            0|  0.00%|    if sys.version_info[0] >= 3:
   882|         0|            0|            0|  0.00%|        # In Python3 stderr, stdout are text files.
   883|         0|            0|            0|  0.00%|        from io import StringIO
   884|         0|            0|            0|  0.00%|    else:
   885|         0|            0|            0|  0.00%|        from StringIO import StringIO
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|    if module is None:
   888|         0|            0|            0|  0.00%|        module = "numpy"
   889|         0|            0|            0|  0.00%|
   890|         0|            0|            0|  0.00%|    if isinstance(module, str):
   891|         0|            0|            0|  0.00%|        try:
   892|         0|            0|            0|  0.00%|            __import__(module)
   893|         0|            0|            0|  0.00%|        except ImportError:
   894|         0|            0|            0|  0.00%|            return {}
   895|         0|            0|            0|  0.00%|        module = sys.modules[module]
   896|         0|            0|            0|  0.00%|    elif isinstance(module, list) or isinstance(module, tuple):
   897|         0|            0|            0|  0.00%|        cache = {}
   898|         0|            0|            0|  0.00%|        for mod in module:
   899|         0|            0|            0|  0.00%|            cache.update(_lookfor_generate_cache(mod, import_modules,
   900|         0|            0|            0|  0.00%|                                                 regenerate))
   901|         0|            0|            0|  0.00%|        return cache
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|    if id(module) in _lookfor_caches and not regenerate:
   904|         0|            0|            0|  0.00%|        return _lookfor_caches[id(module)]
   905|         0|            0|            0|  0.00%|
   906|         0|            0|            0|  0.00%|    # walk items and collect docstrings
   907|         0|            0|            0|  0.00%|    cache = {}
   908|         0|            0|            0|  0.00%|    _lookfor_caches[id(module)] = cache
   909|         0|            0|            0|  0.00%|    seen = {}
   910|         0|            0|            0|  0.00%|    index = 0
   911|         0|            0|            0|  0.00%|    stack = [(module.__name__, module)]
   912|         0|            0|            0|  0.00%|    while stack:
   913|         0|            0|            0|  0.00%|        name, item = stack.pop(0)
   914|         0|            0|            0|  0.00%|        if id(item) in seen:
   915|         0|            0|            0|  0.00%|            continue
   916|         0|            0|            0|  0.00%|        seen[id(item)] = True
   917|         0|            0|            0|  0.00%|
   918|         0|            0|            0|  0.00%|        index += 1
   919|         0|            0|            0|  0.00%|        kind = "object"
   920|         0|            0|            0|  0.00%|
   921|         0|            0|            0|  0.00%|        if inspect.ismodule(item):
   922|         0|            0|            0|  0.00%|            kind = "module"
   923|         0|            0|            0|  0.00%|            try:
   924|         0|            0|            0|  0.00%|                _all = item.__all__
   925|         0|            0|            0|  0.00%|            except AttributeError:
   926|         0|            0|            0|  0.00%|                _all = None
   927|         0|            0|            0|  0.00%|
   928|         0|            0|            0|  0.00%|            # import sub-packages
   929|         0|            0|            0|  0.00%|            if import_modules and hasattr(item, '__path__'):
   930|         0|            0|            0|  0.00%|                for pth in item.__path__:
   931|         0|            0|            0|  0.00%|                    for mod_path in os.listdir(pth):
   932|         0|            0|            0|  0.00%|                        this_py = os.path.join(pth, mod_path)
   933|         0|            0|            0|  0.00%|                        init_py = os.path.join(pth, mod_path, '__init__.py')
   934|         0|            0|            0|  0.00%|                        if (os.path.isfile(this_py) and
   935|         0|            0|            0|  0.00%|                                mod_path.endswith('.py')):
   936|         0|            0|            0|  0.00%|                            to_import = mod_path[:-3]
   937|         0|            0|            0|  0.00%|                        elif os.path.isfile(init_py):
   938|         0|            0|            0|  0.00%|                            to_import = mod_path
   939|         0|            0|            0|  0.00%|                        else:
   940|         0|            0|            0|  0.00%|                            continue
   941|         0|            0|            0|  0.00%|                        if to_import == '__init__':
   942|         0|            0|            0|  0.00%|                            continue
   943|         0|            0|            0|  0.00%|
   944|         0|            0|            0|  0.00%|                        try:
   945|         0|            0|            0|  0.00%|                            old_stdout = sys.stdout
   946|         0|            0|            0|  0.00%|                            old_stderr = sys.stderr
   947|         0|            0|            0|  0.00%|                            try:
   948|         0|            0|            0|  0.00%|                                sys.stdout = StringIO()
   949|         0|            0|            0|  0.00%|                                sys.stderr = StringIO()
   950|         0|            0|            0|  0.00%|                                __import__("%s.%s" % (name, to_import))
   951|         0|            0|            0|  0.00%|                            finally:
   952|         0|            0|            0|  0.00%|                                sys.stdout = old_stdout
   953|         0|            0|            0|  0.00%|                                sys.stderr = old_stderr
   954|         0|            0|            0|  0.00%|                        # Catch SystemExit, too
   955|         0|            0|            0|  0.00%|                        except BaseException:
   956|         0|            0|            0|  0.00%|                            continue
   957|         0|            0|            0|  0.00%|
   958|         0|            0|            0|  0.00%|            for n, v in _getmembers(item):
   959|         0|            0|            0|  0.00%|                try:
   960|         0|            0|            0|  0.00%|                    item_name = getattr(v, '__name__', "%s.%s" % (name, n))
   961|         0|            0|            0|  0.00%|                    mod_name = getattr(v, '__module__', None)
   962|         0|            0|            0|  0.00%|                except NameError:
   963|         0|            0|            0|  0.00%|                    # ref. SWIG's global cvars
   964|         0|            0|            0|  0.00%|                    #    NameError: Unknown C global variable
   965|         0|            0|            0|  0.00%|                    item_name = "%s.%s" % (name, n)
   966|         0|            0|            0|  0.00%|                    mod_name = None
   967|         0|            0|            0|  0.00%|                if '.' not in item_name and mod_name:
   968|         0|            0|            0|  0.00%|                    item_name = "%s.%s" % (mod_name, item_name)
   969|         0|            0|            0|  0.00%|
   970|         0|            0|            0|  0.00%|                if not item_name.startswith(name + '.'):
   971|         0|            0|            0|  0.00%|                    # don't crawl "foreign" objects
   972|         0|            0|            0|  0.00%|                    if isinstance(v, ufunc):
   973|         0|            0|            0|  0.00%|                        # ... unless they are ufuncs
   974|         0|            0|            0|  0.00%|                        pass
   975|         0|            0|            0|  0.00%|                    else:
   976|         0|            0|            0|  0.00%|                        continue
   977|         0|            0|            0|  0.00%|                elif not (inspect.ismodule(v) or _all is None or n in _all):
   978|         0|            0|            0|  0.00%|                    continue
   979|         0|            0|            0|  0.00%|                stack.append(("%s.%s" % (name, n), v))
   980|         0|            0|            0|  0.00%|        elif inspect.isclass(item):
   981|         0|            0|            0|  0.00%|            kind = "class"
   982|         0|            0|            0|  0.00%|            for n, v in _getmembers(item):
   983|         0|            0|            0|  0.00%|                stack.append(("%s.%s" % (name, n), v))
   984|         0|            0|            0|  0.00%|        elif hasattr(item, "__call__"):
   985|         0|            0|            0|  0.00%|            kind = "func"
   986|         0|            0|            0|  0.00%|
   987|         0|            0|            0|  0.00%|        try:
   988|         0|            0|            0|  0.00%|            doc = inspect.getdoc(item)
   989|         0|            0|            0|  0.00%|        except NameError:
   990|         0|            0|            0|  0.00%|            # ref SWIG's NameError: Unknown C global variable
   991|         0|            0|            0|  0.00%|            doc = None
   992|         0|            0|            0|  0.00%|        if doc is not None:
   993|         0|            0|            0|  0.00%|            cache[name] = (doc, kind, index)
   994|         0|            0|            0|  0.00%|
   995|         0|            0|            0|  0.00%|    return cache
   996|         0|            0|            0|  0.00%|
   997|         0|            0|            0|  0.00%|def _getmembers(item):
   998|         0|            0|            0|  0.00%|    import inspect
   999|         0|            0|            0|  0.00%|    try:
  1000|         0|            0|            0|  0.00%|        members = inspect.getmembers(item)
  1001|         0|            0|            0|  0.00%|    except Exception:
  1002|         0|            0|            0|  0.00%|        members = [(x, getattr(item, x)) for x in dir(item)
  1003|         0|            0|            0|  0.00%|                   if hasattr(item, x)]
  1004|         0|            0|            0|  0.00%|    return members
  1005|         0|            0|            0|  0.00%|
  1006|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
  1007|         0|            0|            0|  0.00%|
  1008|         0|            0|            0|  0.00%|# The following SafeEval class and company are adapted from Michael Spencer's
  1009|         0|            0|            0|  0.00%|# ASPN Python Cookbook recipe: https://code.activestate.com/recipes/364469/
  1010|         0|            0|            0|  0.00%|#
  1011|         0|            0|            0|  0.00%|# Accordingly it is mostly Copyright 2006 by Michael Spencer.
  1012|         0|            0|            0|  0.00%|# The recipe, like most of the other ASPN Python Cookbook recipes was made
  1013|         0|            0|            0|  0.00%|# available under the Python license.
  1014|         0|            0|            0|  0.00%|#   https://en.wikipedia.org/wiki/Python_License
  1015|         0|            0|            0|  0.00%|
  1016|         0|            0|            0|  0.00%|# It has been modified to:
  1017|         0|            0|            0|  0.00%|#   * handle unary -/+
  1018|         0|            0|            0|  0.00%|#   * support True/False/None
  1019|         0|            0|            0|  0.00%|#   * raise SyntaxError instead of a custom exception.
  1020|         0|            0|            0|  0.00%|
  1021|         0|            0|            0|  0.00%|class SafeEval(object):
  1022|         0|            0|            0|  0.00%|    """
  1023|         0|            0|            0|  0.00%|    Object to evaluate constant string expressions.
  1024|         0|            0|            0|  0.00%|
  1025|         0|            0|            0|  0.00%|    This includes strings with lists, dicts and tuples using the abstract
  1026|         0|            0|            0|  0.00%|    syntax tree created by ``compiler.parse``.
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|    .. deprecated:: 1.10.0
  1029|         0|            0|            0|  0.00%|
  1030|         0|            0|            0|  0.00%|    See Also
  1031|         0|            0|            0|  0.00%|    --------
  1032|         0|            0|            0|  0.00%|    safe_eval
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|    """
  1035|         0|            0|            0|  0.00%|    def __init__(self):
  1036|         0|            0|            0|  0.00%|        # 2014-10-15, 1.10
  1037|         0|            0|            0|  0.00%|        warnings.warn("SafeEval is deprecated in 1.10 and will be removed.",
  1038|         0|            0|            0|  0.00%|                      DeprecationWarning, stacklevel=2)
  1039|         0|            0|            0|  0.00%|
  1040|         0|            0|            0|  0.00%|    def visit(self, node):
  1041|         0|            0|            0|  0.00%|        cls = node.__class__
  1042|         0|            0|            0|  0.00%|        meth = getattr(self, 'visit' + cls.__name__, self.default)
  1043|         0|            0|            0|  0.00%|        return meth(node)
  1044|         0|            0|            0|  0.00%|
  1045|         0|            0|            0|  0.00%|    def default(self, node):
  1046|         0|            0|            0|  0.00%|        raise SyntaxError("Unsupported source construct: %s"
  1047|         0|            0|            0|  0.00%|                          % node.__class__)
  1048|         0|            0|            0|  0.00%|
  1049|         0|            0|            0|  0.00%|    def visitExpression(self, node):
  1050|         0|            0|            0|  0.00%|        return self.visit(node.body)
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|    def visitNum(self, node):
  1053|         0|            0|            0|  0.00%|        return node.n
  1054|         0|            0|            0|  0.00%|
  1055|         0|            0|            0|  0.00%|    def visitStr(self, node):
  1056|         0|            0|            0|  0.00%|        return node.s
  1057|         0|            0|            0|  0.00%|
  1058|         0|            0|            0|  0.00%|    def visitBytes(self, node):
  1059|         0|            0|            0|  0.00%|        return node.s
  1060|         0|            0|            0|  0.00%|
  1061|         0|            0|            0|  0.00%|    def visitDict(self, node,**kw):
  1062|         0|            0|            0|  0.00%|        return dict([(self.visit(k), self.visit(v))
  1063|         0|            0|            0|  0.00%|                     for k, v in zip(node.keys, node.values)])
  1064|         0|            0|            0|  0.00%|
  1065|         0|            0|            0|  0.00%|    def visitTuple(self, node):
  1066|         0|            0|            0|  0.00%|        return tuple([self.visit(i) for i in node.elts])
  1067|         0|            0|            0|  0.00%|
  1068|         0|            0|            0|  0.00%|    def visitList(self, node):
  1069|         0|            0|            0|  0.00%|        return [self.visit(i) for i in node.elts]
  1070|         0|            0|            0|  0.00%|
  1071|         0|            0|            0|  0.00%|    def visitUnaryOp(self, node):
  1072|         0|            0|            0|  0.00%|        import ast
  1073|         0|            0|            0|  0.00%|        if isinstance(node.op, ast.UAdd):
  1074|         0|            0|            0|  0.00%|            return +self.visit(node.operand)
  1075|         0|            0|            0|  0.00%|        elif isinstance(node.op, ast.USub):
  1076|         0|            0|            0|  0.00%|            return -self.visit(node.operand)
  1077|         0|            0|            0|  0.00%|        else:
  1078|         0|            0|            0|  0.00%|            raise SyntaxError("Unknown unary op: %r" % node.op)
  1079|         0|            0|            0|  0.00%|
  1080|         0|            0|            0|  0.00%|    def visitName(self, node):
  1081|         0|            0|            0|  0.00%|        if node.id == 'False':
  1082|         0|            0|            0|  0.00%|            return False
  1083|         0|            0|            0|  0.00%|        elif node.id == 'True':
  1084|         0|            0|            0|  0.00%|            return True
  1085|         0|            0|            0|  0.00%|        elif node.id == 'None':
  1086|         0|            0|            0|  0.00%|            return None
  1087|         0|            0|            0|  0.00%|        else:
  1088|         0|            0|            0|  0.00%|            raise SyntaxError("Unknown name: %s" % node.id)
  1089|         0|            0|            0|  0.00%|
  1090|         0|            0|            0|  0.00%|    def visitNameConstant(self, node):
  1091|         0|            0|            0|  0.00%|        return node.value
  1092|         0|            0|            0|  0.00%|
  1093|         0|            0|            0|  0.00%|
  1094|         0|            0|            0|  0.00%|def safe_eval(source):
  1095|         0|            0|            0|  0.00%|    """
  1096|         0|            0|            0|  0.00%|    Protected string evaluation.
  1097|         0|            0|            0|  0.00%|
  1098|         0|            0|            0|  0.00%|    Evaluate a string containing a Python literal expression without
  1099|         0|            0|            0|  0.00%|    allowing the execution of arbitrary non-literal code.
  1100|         0|            0|            0|  0.00%|
  1101|         0|            0|            0|  0.00%|    Parameters
  1102|         0|            0|            0|  0.00%|    ----------
  1103|         0|            0|            0|  0.00%|    source : str
  1104|         0|            0|            0|  0.00%|        The string to evaluate.
  1105|         0|            0|            0|  0.00%|
  1106|         0|            0|            0|  0.00%|    Returns
  1107|         0|            0|            0|  0.00%|    -------
  1108|         0|            0|            0|  0.00%|    obj : object
  1109|         0|            0|            0|  0.00%|       The result of evaluating `source`.
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|    Raises
  1112|         0|            0|            0|  0.00%|    ------
  1113|         0|            0|            0|  0.00%|    SyntaxError
  1114|         0|            0|            0|  0.00%|        If the code has invalid Python syntax, or if it contains
  1115|         0|            0|            0|  0.00%|        non-literal code.
  1116|         0|            0|            0|  0.00%|
  1117|         0|            0|            0|  0.00%|    Examples
  1118|         0|            0|            0|  0.00%|    --------
  1119|         0|            0|            0|  0.00%|    >>> np.safe_eval('1')
  1120|         0|            0|            0|  0.00%|    1
  1121|         0|            0|            0|  0.00%|    >>> np.safe_eval('[1, 2, 3]')
  1122|         0|            0|            0|  0.00%|    [1, 2, 3]
  1123|         0|            0|            0|  0.00%|    >>> np.safe_eval('{"foo": ("bar", 10.0)}')
  1124|         0|            0|            0|  0.00%|    {'foo': ('bar', 10.0)}
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|    >>> np.safe_eval('import os')
  1127|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1128|         0|            0|            0|  0.00%|      ...
  1129|         0|            0|            0|  0.00%|    SyntaxError: invalid syntax
  1130|         0|            0|            0|  0.00%|
  1131|         0|            0|            0|  0.00%|    >>> np.safe_eval('open("/home/user/.ssh/id_dsa").read()')
  1132|         0|            0|            0|  0.00%|    Traceback (most recent call last):
  1133|         0|            0|            0|  0.00%|      ...
  1134|         0|            0|            0|  0.00%|    ValueError: malformed node or string: <_ast.Call object at 0x...>
  1135|         0|            0|            0|  0.00%|
  1136|         0|            0|            0|  0.00%|    """
  1137|         0|            0|            0|  0.00%|    # Local import to speed up numpy's import time.
  1138|         0|            0|            0|  0.00%|    import ast
  1139|         0|            0|            0|  0.00%|    return ast.literal_eval(source)
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|
  1142|         1|  6.67572e-06|  6.67572e-06|  0.00%|def _median_nancheck(data, result, axis, out):
  1143|         0|            0|            0|  0.00%|    """
  1144|         0|            0|            0|  0.00%|    Utility function to check median result from data for NaN values at the end
  1145|         0|            0|            0|  0.00%|    and return NaN in that case. Input result can also be a MaskedArray.
  1146|         0|            0|            0|  0.00%|
  1147|         0|            0|            0|  0.00%|    Parameters
  1148|         0|            0|            0|  0.00%|    ----------
  1149|         0|            0|            0|  0.00%|    data : array
  1150|         0|            0|            0|  0.00%|        Input data to median function
  1151|         0|            0|            0|  0.00%|    result : Array or MaskedArray
  1152|         0|            0|            0|  0.00%|        Result of median function
  1153|         0|            0|            0|  0.00%|    axis : {int, sequence of int, None}, optional
  1154|         0|            0|            0|  0.00%|        Axis or axes along which the median was computed.
  1155|         0|            0|            0|  0.00%|    out : ndarray, optional
  1156|         0|            0|            0|  0.00%|        Output array in which to place the result.
  1157|         0|            0|            0|  0.00%|    Returns
  1158|         0|            0|            0|  0.00%|    -------
  1159|         0|            0|            0|  0.00%|    median : scalar or ndarray
  1160|         0|            0|            0|  0.00%|        Median or NaN in axes which contained NaN in the input.
  1161|         0|            0|            0|  0.00%|    """
  1162|         1|  1.14441e-05|  1.14441e-05|  0.00%|    if data.size == 0:
  1163|         0|            0|            0|  0.00%|        return result
  1164|         1|  1.35899e-05|  1.35899e-05|  0.00%|    data = np.moveaxis(data, axis, -1)
(call)|         1|  0.000258207|  0.000258207|  0.00%|# <__array_function__ internals>_7:2 moveaxis
  1165|         1|   1.3113e-05|   1.3113e-05|  0.00%|    n = np.isnan(data[..., -1])
  1166|         0|            0|            0|  0.00%|    # masked NaN values are ok
  1167|         1|  2.19345e-05|  2.19345e-05|  0.00%|    if np.ma.isMaskedArray(n):
(call)|         1|  1.69277e-05|  1.69277e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/ma/core.py:6251 isMaskedArray
  1168|         0|            0|            0|  0.00%|        n = n.filled(False)
  1169|         1|  4.05312e-06|  4.05312e-06|  0.00%|    if result.ndim == 0:
  1170|         1|  1.35899e-05|  1.35899e-05|  0.00%|        if n == True:
  1171|         0|            0|            0|  0.00%|            if out is not None:
  1172|         0|            0|            0|  0.00%|                out[...] = data.dtype.type(np.nan)
  1173|         0|            0|            0|  0.00%|                result = out
  1174|         0|            0|            0|  0.00%|            else:
  1175|         0|            0|            0|  0.00%|                result = data.dtype.type(np.nan)
  1176|         0|            0|            0|  0.00%|    elif np.count_nonzero(n.ravel()) > 0:
  1177|         0|            0|            0|  0.00%|        result[n] = np.nan
  1178|         1|  4.52995e-06|  4.52995e-06|  0.00%|    return result
  1179|         0|            0|            0|  0.00%|
  1180|         0|            0|            0|  0.00%|#-----------------------------------------------------------------------------
File: <__array_function__ internals>
File duration: 7.31945e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  1.95503e-05|  1.95503e-05|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|   2.7895e-05|   2.7895e-05|  0.00%|
(call)|         1|  1.54972e-05|  1.54972e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/function_base.py:32 _linspace_dispatcher
     5|         1|  4.05312e-06|  4.05312e-06|  0.00%|
     6|         1|  2.16961e-05|  2.16961e-05|  0.00%|
(call)|         1|  0.000780821|  0.000780821|  0.01%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/function_base.py:37 linspace
File: <__array_function__ internals>_8
File duration: 6.91414e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         2|  1.23978e-05|  6.19888e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         2|   2.3365e-05|  1.16825e-05|  0.00%|
(call)|         2|  1.88351e-05|  9.41753e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3075 _around_dispatcher
     5|         2|  5.48363e-06|  2.74181e-06|  0.00%|
     6|         2|   2.7895e-05|  1.39475e-05|  0.00%|
(call)|         2|  0.000274897|  0.000137448|  0.01%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3512 round_
File: <__array_function__ internals>_4
File duration: 5.126e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  1.52588e-05|  1.52588e-05|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.95503e-05|  1.95503e-05|  0.00%|
(call)|         1|  7.62939e-06|  7.62939e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:3414 _median_dispatcher
     5|         1|  3.57628e-06|  3.57628e-06|  0.00%|
     6|         1|  1.28746e-05|  1.28746e-05|  0.00%|
(call)|         1|   0.00111389|   0.00111389|  0.02%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:3419 median
File: <__array_function__ internals>_9
File duration: 4.86374e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         2|  4.52995e-06|  2.26498e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         2|  2.02656e-05|  1.01328e-05|  0.00%|
(call)|         2|  9.05991e-06|  4.52995e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3075 _around_dispatcher
     5|         2|  5.72205e-06|  2.86102e-06|  0.00%|
     6|         2|  1.81198e-05|  9.05991e-06|  0.00%|
(call)|         2|  0.000193834|  9.69172e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3079 around
File: <__array_function__ internals>_3
File duration: 4.3869e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  6.91414e-06|  6.91414e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.90735e-05|  1.90735e-05|  0.00%|
(call)|         1|  1.16825e-05|  1.16825e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:1143 _diff_dispatcher
     5|         1|  3.57628e-06|  3.57628e-06|  0.00%|
     6|         1|  1.43051e-05|  1.43051e-05|  0.00%|
(call)|         1|   0.00014925|   0.00014925|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/lib/function_base.py:1147 diff
File: <__array_function__ internals>_1
File duration: 3.88622e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  4.29153e-06|  4.29153e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|   1.7643e-05|   1.7643e-05|  0.00%|
(call)|         1|  1.23978e-05|  1.23978e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:2982 _ndim_dispatcher
     5|         1|  3.33786e-06|  3.33786e-06|  0.00%|
     6|         1|  1.35899e-05|  1.35899e-05|  0.00%|
(call)|         1|  1.57356e-05|  1.57356e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:2986 ndim
File: <__array_function__ internals>_2
File duration: 3.74317e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  3.33786e-06|  3.33786e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.50204e-05|  1.50204e-05|  0.00%|
(call)|         1|  6.67572e-06|  6.67572e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:2185 _any_dispatcher
     5|         1|  3.57628e-06|  3.57628e-06|  0.00%|
     6|         1|  1.54972e-05|  1.54972e-05|  0.00%|
(call)|         1|  0.000128269|  0.000128269|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:2189 any
File: <__array_function__ internals>_7
File duration: 3.60012e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  3.09944e-06|  3.09944e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.57356e-05|  1.57356e-05|  0.00%|
(call)|         1|  7.86781e-06|  7.86781e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1332 _moveaxis_dispatcher
     5|         1|  3.57628e-06|  3.57628e-06|  0.00%|
     6|         1|  1.35899e-05|  1.35899e-05|  0.00%|
(call)|         1|  0.000214338|  0.000214338|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/numeric.py:1336 moveaxis
File: <__array_function__ internals>_0
File duration: 3.60012e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  4.05312e-06|  4.05312e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|   1.7643e-05|   1.7643e-05|  0.00%|
(call)|         1|  1.50204e-05|  1.50204e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/multiarray.py:635 result_type
     5|         1|   3.8147e-06|   3.8147e-06|  0.00%|
     6|         1|  1.04904e-05|  1.04904e-05|  0.00%|
File: <__array_function__ internals>_5
File duration: 3.52859e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  3.33786e-06|  3.33786e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.45435e-05|  1.45435e-05|  0.00%|
(call)|         1|  7.62939e-06|  7.62939e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:653 _partition_dispatcher
     5|         1|  3.57628e-06|  3.57628e-06|  0.00%|
     6|         1|  1.38283e-05|  1.38283e-05|  0.00%|
(call)|         1|  7.51019e-05|  7.51019e-05|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:657 partition
File: <__array_function__ internals>_6
File duration: 3.26633e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|
     2|         1|  3.33786e-06|  3.33786e-06|  0.00%|
     3|         0|            0|            0|  0.00%|
     4|         1|  1.43051e-05|  1.43051e-05|  0.00%|
(call)|         1|  6.67572e-06|  6.67572e-06|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3149 _mean_dispatcher
     5|         1|  3.33786e-06|  3.33786e-06|  0.00%|
     6|         1|  1.16825e-05|  1.16825e-05|  0.00%|
(call)|         1|  0.000183105|  0.000183105|  0.00%|# /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/core/fromnumeric.py:3153 mean
File: /home/jkok1g14/anaconda3/lib/python3.7/site-packages/numpy/ma/core.py
File duration: 1.69277e-05s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|"""
     2|         0|            0|            0|  0.00%|numpy.ma : a package to handle missing or invalid values.
     3|         0|            0|            0|  0.00%|
     4|         0|            0|            0|  0.00%|This package was initially written for numarray by Paul F. Dubois
     5|         0|            0|            0|  0.00%|at Lawrence Livermore National Laboratory.
     6|         0|            0|            0|  0.00%|In 2006, the package was completely rewritten by Pierre Gerard-Marchant
     7|         0|            0|            0|  0.00%|(University of Georgia) to make the MaskedArray class a subclass of ndarray,
     8|         0|            0|            0|  0.00%|and to improve support of structured arrays.
     9|         0|            0|            0|  0.00%|
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|Copyright 1999, 2000, 2001 Regents of the University of California.
    12|         0|            0|            0|  0.00%|Released for unlimited redistribution.
    13|         0|            0|            0|  0.00%|
    14|         0|            0|            0|  0.00%|* Adapted for numpy_core 2005 by Travis Oliphant and (mainly) Paul Dubois.
    15|         0|            0|            0|  0.00%|* Subclassing of the base `ndarray` 2006 by Pierre Gerard-Marchant
    16|         0|            0|            0|  0.00%|  (pgmdevlist_AT_gmail_DOT_com)
    17|         0|            0|            0|  0.00%|* Improvements suggested by Reggie Dugard (reggie_AT_merfinllc_DOT_com)
    18|         0|            0|            0|  0.00%|
    19|         0|            0|            0|  0.00%|.. moduleauthor:: Pierre Gerard-Marchant
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|"""
    22|         0|            0|            0|  0.00%|# pylint: disable-msg=E1002
    23|         0|            0|            0|  0.00%|from __future__ import division, absolute_import, print_function
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|import sys
    26|         0|            0|            0|  0.00%|import operator
    27|         0|            0|            0|  0.00%|import warnings
    28|         0|            0|            0|  0.00%|import textwrap
    29|         0|            0|            0|  0.00%|import re
    30|         0|            0|            0|  0.00%|from functools import reduce
    31|         0|            0|            0|  0.00%|
    32|         0|            0|            0|  0.00%|if sys.version_info[0] >= 3:
    33|         0|            0|            0|  0.00%|    import builtins
    34|         0|            0|            0|  0.00%|else:
    35|         0|            0|            0|  0.00%|    import __builtin__ as builtins
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|import numpy as np
    38|         0|            0|            0|  0.00%|import numpy.core.umath as umath
    39|         0|            0|            0|  0.00%|import numpy.core.numerictypes as ntypes
    40|         0|            0|            0|  0.00%|from numpy import ndarray, amax, amin, iscomplexobj, bool_, _NoValue
    41|         0|            0|            0|  0.00%|from numpy import array as narray
    42|         0|            0|            0|  0.00%|from numpy.lib.function_base import angle
    43|         0|            0|            0|  0.00%|from numpy.compat import (
    44|         0|            0|            0|  0.00%|    getargspec, formatargspec, long, basestring, unicode, bytes
    45|         0|            0|            0|  0.00%|    )
    46|         0|            0|            0|  0.00%|from numpy import expand_dims
    47|         0|            0|            0|  0.00%|from numpy.core.numeric import normalize_axis_tuple
    48|         0|            0|            0|  0.00%|from numpy.core._internal import recursive
    49|         0|            0|            0|  0.00%|from numpy.compat import pickle
    50|         0|            0|            0|  0.00%|
    51|         0|            0|            0|  0.00%|
    52|         0|            0|            0|  0.00%|__all__ = [
    53|         0|            0|            0|  0.00%|    'MAError', 'MaskError', 'MaskType', 'MaskedArray', 'abs', 'absolute',
    54|         0|            0|            0|  0.00%|    'add', 'all', 'allclose', 'allequal', 'alltrue', 'amax', 'amin',
    55|         0|            0|            0|  0.00%|    'angle', 'anom', 'anomalies', 'any', 'append', 'arange', 'arccos',
    56|         0|            0|            0|  0.00%|    'arccosh', 'arcsin', 'arcsinh', 'arctan', 'arctan2', 'arctanh',
    57|         0|            0|            0|  0.00%|    'argmax', 'argmin', 'argsort', 'around', 'array', 'asanyarray',
    58|         0|            0|            0|  0.00%|    'asarray', 'bitwise_and', 'bitwise_or', 'bitwise_xor', 'bool_', 'ceil',
    59|         0|            0|            0|  0.00%|    'choose', 'clip', 'common_fill_value', 'compress', 'compressed',
    60|         0|            0|            0|  0.00%|    'concatenate', 'conjugate', 'convolve', 'copy', 'correlate', 'cos', 'cosh',
    61|         0|            0|            0|  0.00%|    'count', 'cumprod', 'cumsum', 'default_fill_value', 'diag', 'diagonal',
    62|         0|            0|            0|  0.00%|    'diff', 'divide', 'dump', 'dumps', 'empty', 'empty_like', 'equal', 'exp',
    63|         0|            0|            0|  0.00%|    'expand_dims', 'fabs', 'filled', 'fix_invalid', 'flatten_mask',
    64|         0|            0|            0|  0.00%|    'flatten_structured_array', 'floor', 'floor_divide', 'fmod',
    65|         0|            0|            0|  0.00%|    'frombuffer', 'fromflex', 'fromfunction', 'getdata', 'getmask',
    66|         0|            0|            0|  0.00%|    'getmaskarray', 'greater', 'greater_equal', 'harden_mask', 'hypot',
    67|         0|            0|            0|  0.00%|    'identity', 'ids', 'indices', 'inner', 'innerproduct', 'isMA',
    68|         0|            0|            0|  0.00%|    'isMaskedArray', 'is_mask', 'is_masked', 'isarray', 'left_shift',
    69|         0|            0|            0|  0.00%|    'less', 'less_equal', 'load', 'loads', 'log', 'log10', 'log2',
    70|         0|            0|            0|  0.00%|    'logical_and', 'logical_not', 'logical_or', 'logical_xor', 'make_mask',
    71|         0|            0|            0|  0.00%|    'make_mask_descr', 'make_mask_none', 'mask_or', 'masked',
    72|         0|            0|            0|  0.00%|    'masked_array', 'masked_equal', 'masked_greater',
    73|         0|            0|            0|  0.00%|    'masked_greater_equal', 'masked_inside', 'masked_invalid',
    74|         0|            0|            0|  0.00%|    'masked_less', 'masked_less_equal', 'masked_not_equal',
    75|         0|            0|            0|  0.00%|    'masked_object', 'masked_outside', 'masked_print_option',
    76|         0|            0|            0|  0.00%|    'masked_singleton', 'masked_values', 'masked_where', 'max', 'maximum',
    77|         0|            0|            0|  0.00%|    'maximum_fill_value', 'mean', 'min', 'minimum', 'minimum_fill_value',
    78|         0|            0|            0|  0.00%|    'mod', 'multiply', 'mvoid', 'ndim', 'negative', 'nomask', 'nonzero',
    79|         0|            0|            0|  0.00%|    'not_equal', 'ones', 'outer', 'outerproduct', 'power', 'prod',
    80|         0|            0|            0|  0.00%|    'product', 'ptp', 'put', 'putmask', 'rank', 'ravel', 'remainder',
    81|         0|            0|            0|  0.00%|    'repeat', 'reshape', 'resize', 'right_shift', 'round', 'round_',
    82|         0|            0|            0|  0.00%|    'set_fill_value', 'shape', 'sin', 'sinh', 'size', 'soften_mask',
    83|         0|            0|            0|  0.00%|    'sometrue', 'sort', 'sqrt', 'squeeze', 'std', 'subtract', 'sum',
    84|         0|            0|            0|  0.00%|    'swapaxes', 'take', 'tan', 'tanh', 'trace', 'transpose', 'true_divide',
    85|         0|            0|            0|  0.00%|    'var', 'where', 'zeros',
    86|         0|            0|            0|  0.00%|    ]
    87|         0|            0|            0|  0.00%|
    88|         0|            0|            0|  0.00%|MaskType = np.bool_
    89|         0|            0|            0|  0.00%|nomask = MaskType(0)
    90|         0|            0|            0|  0.00%|
    91|         0|            0|            0|  0.00%|class MaskedArrayFutureWarning(FutureWarning):
    92|         0|            0|            0|  0.00%|    pass
    93|         0|            0|            0|  0.00%|
    94|         0|            0|            0|  0.00%|def _deprecate_argsort_axis(arr):
    95|         0|            0|            0|  0.00%|    """
    96|         0|            0|            0|  0.00%|    Adjust the axis passed to argsort, warning if necessary
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    Parameters
    99|         0|            0|            0|  0.00%|    ----------
   100|         0|            0|            0|  0.00%|    arr
   101|         0|            0|            0|  0.00%|        The array which argsort was called on
   102|         0|            0|            0|  0.00%|
   103|         0|            0|            0|  0.00%|    np.ma.argsort has a long-term bug where the default of the axis argument
   104|         0|            0|            0|  0.00%|    is wrong (gh-8701), which now must be kept for backwards compatibiity.
   105|         0|            0|            0|  0.00%|    Thankfully, this only makes a difference when arrays are 2- or more-
   106|         0|            0|            0|  0.00%|    dimensional, so we only need a warning then.
   107|         0|            0|            0|  0.00%|    """
   108|         0|            0|            0|  0.00%|    if arr.ndim <= 1:
   109|         0|            0|            0|  0.00%|        # no warning needed - but switch to -1 anyway, to avoid surprising
   110|         0|            0|            0|  0.00%|        # subclasses, which are more likely to implement scalar axes.
   111|         0|            0|            0|  0.00%|        return -1
   112|         0|            0|            0|  0.00%|    else:
   113|         0|            0|            0|  0.00%|        # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
   114|         0|            0|            0|  0.00%|        warnings.warn(
   115|         0|            0|            0|  0.00%|            "In the future the default for argsort will be axis=-1, not the "
   116|         0|            0|            0|  0.00%|            "current None, to match its documentation and np.argsort. "
   117|         0|            0|            0|  0.00%|            "Explicitly pass -1 or None to silence this warning.",
   118|         0|            0|            0|  0.00%|            MaskedArrayFutureWarning, stacklevel=3)
   119|         0|            0|            0|  0.00%|        return None
   120|         0|            0|            0|  0.00%|
   121|         0|            0|            0|  0.00%|
   122|         0|            0|            0|  0.00%|def doc_note(initialdoc, note):
   123|         0|            0|            0|  0.00%|    """
   124|         0|            0|            0|  0.00%|    Adds a Notes section to an existing docstring.
   125|         0|            0|            0|  0.00%|
   126|         0|            0|            0|  0.00%|    """
   127|         0|            0|            0|  0.00%|    if initialdoc is None:
   128|         0|            0|            0|  0.00%|        return
   129|         0|            0|            0|  0.00%|    if note is None:
   130|         0|            0|            0|  0.00%|        return initialdoc
   131|         0|            0|            0|  0.00%|
   132|         0|            0|            0|  0.00%|    notesplit = re.split(r'\n\s*?Notes\n\s*?-----', initialdoc)
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    notedoc = """\
   135|         0|            0|            0|  0.00%|Notes
   136|         0|            0|            0|  0.00%|    -----
   137|         0|            0|            0|  0.00%|    %s""" % note
   138|         0|            0|            0|  0.00%|
   139|         0|            0|            0|  0.00%|    if len(notesplit) > 1:
   140|         0|            0|            0|  0.00%|        notedoc = '\n\n    ' + notedoc + '\n'
   141|         0|            0|            0|  0.00%|
   142|         0|            0|            0|  0.00%|    return ''.join(notesplit[:1] + [notedoc] + notesplit[1:])
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|def get_object_signature(obj):
   146|         0|            0|            0|  0.00%|    """
   147|         0|            0|            0|  0.00%|    Get the signature from obj
   148|         0|            0|            0|  0.00%|
   149|         0|            0|            0|  0.00%|    """
   150|         0|            0|            0|  0.00%|    try:
   151|         0|            0|            0|  0.00%|        sig = formatargspec(*getargspec(obj))
   152|         0|            0|            0|  0.00%|    except TypeError:
   153|         0|            0|            0|  0.00%|        sig = ''
   154|         0|            0|            0|  0.00%|    return sig
   155|         0|            0|            0|  0.00%|
   156|         0|            0|            0|  0.00%|
   157|         0|            0|            0|  0.00%|###############################################################################
   158|         0|            0|            0|  0.00%|#                              Exceptions                                     #
   159|         0|            0|            0|  0.00%|###############################################################################
   160|         0|            0|            0|  0.00%|
   161|         0|            0|            0|  0.00%|
   162|         0|            0|            0|  0.00%|class MAError(Exception):
   163|         0|            0|            0|  0.00%|    """
   164|         0|            0|            0|  0.00%|    Class for masked array related errors.
   165|         0|            0|            0|  0.00%|
   166|         0|            0|            0|  0.00%|    """
   167|         0|            0|            0|  0.00%|    pass
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|
   170|         0|            0|            0|  0.00%|class MaskError(MAError):
   171|         0|            0|            0|  0.00%|    """
   172|         0|            0|            0|  0.00%|    Class for mask related errors.
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|    """
   175|         0|            0|            0|  0.00%|    pass
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|
   178|         0|            0|            0|  0.00%|###############################################################################
   179|         0|            0|            0|  0.00%|#                           Filling options                                   #
   180|         0|            0|            0|  0.00%|###############################################################################
   181|         0|            0|            0|  0.00%|
   182|         0|            0|            0|  0.00%|
   183|         0|            0|            0|  0.00%|# b: boolean - c: complex - f: floats - i: integer - O: object - S: string
   184|         0|            0|            0|  0.00%|default_filler = {'b': True,
   185|         0|            0|            0|  0.00%|                  'c': 1.e20 + 0.0j,
   186|         0|            0|            0|  0.00%|                  'f': 1.e20,
   187|         0|            0|            0|  0.00%|                  'i': 999999,
   188|         0|            0|            0|  0.00%|                  'O': '?',
   189|         0|            0|            0|  0.00%|                  'S': b'N/A',
   190|         0|            0|            0|  0.00%|                  'u': 999999,
   191|         0|            0|            0|  0.00%|                  'V': b'???',
   192|         0|            0|            0|  0.00%|                  'U': u'N/A'
   193|         0|            0|            0|  0.00%|                  }
   194|         0|            0|            0|  0.00%|
   195|         0|            0|            0|  0.00%|# Add datetime64 and timedelta64 types
   196|         0|            0|            0|  0.00%|for v in ["Y", "M", "W", "D", "h", "m", "s", "ms", "us", "ns", "ps",
   197|         0|            0|            0|  0.00%|          "fs", "as"]:
   198|         0|            0|            0|  0.00%|    default_filler["M8[" + v + "]"] = np.datetime64("NaT", v)
   199|         0|            0|            0|  0.00%|    default_filler["m8[" + v + "]"] = np.timedelta64("NaT", v)
   200|         0|            0|            0|  0.00%|
   201|         0|            0|            0|  0.00%|max_filler = ntypes._minvals
   202|         0|            0|            0|  0.00%|max_filler.update([(k, -np.inf) for k in [np.float32, np.float64]])
   203|         0|            0|            0|  0.00%|min_filler = ntypes._maxvals
   204|         0|            0|            0|  0.00%|min_filler.update([(k, +np.inf) for k in [np.float32, np.float64]])
   205|         0|            0|            0|  0.00%|if 'float128' in ntypes.typeDict:
   206|         0|            0|            0|  0.00%|    max_filler.update([(np.float128, -np.inf)])
   207|         0|            0|            0|  0.00%|    min_filler.update([(np.float128, +np.inf)])
   208|         0|            0|            0|  0.00%|
   209|         0|            0|            0|  0.00%|
   210|         0|            0|            0|  0.00%|def _recursive_fill_value(dtype, f):
   211|         0|            0|            0|  0.00%|    """
   212|         0|            0|            0|  0.00%|    Recursively produce a fill value for `dtype`, calling f on scalar dtypes
   213|         0|            0|            0|  0.00%|    """
   214|         0|            0|            0|  0.00%|    if dtype.names is not None:
   215|         0|            0|            0|  0.00%|        vals = tuple(_recursive_fill_value(dtype[name], f) for name in dtype.names)
   216|         0|            0|            0|  0.00%|        return np.array(vals, dtype=dtype)[()]  # decay to void scalar from 0d
   217|         0|            0|            0|  0.00%|    elif dtype.subdtype:
   218|         0|            0|            0|  0.00%|        subtype, shape = dtype.subdtype
   219|         0|            0|            0|  0.00%|        subval = _recursive_fill_value(subtype, f)
   220|         0|            0|            0|  0.00%|        return np.full(shape, subval)
   221|         0|            0|            0|  0.00%|    else:
   222|         0|            0|            0|  0.00%|        return f(dtype)
   223|         0|            0|            0|  0.00%|
   224|         0|            0|            0|  0.00%|
   225|         0|            0|            0|  0.00%|def _get_dtype_of(obj):
   226|         0|            0|            0|  0.00%|    """ Convert the argument for *_fill_value into a dtype """
   227|         0|            0|            0|  0.00%|    if isinstance(obj, np.dtype):
   228|         0|            0|            0|  0.00%|        return obj
   229|         0|            0|            0|  0.00%|    elif hasattr(obj, 'dtype'):
   230|         0|            0|            0|  0.00%|        return obj.dtype
   231|         0|            0|            0|  0.00%|    else:
   232|         0|            0|            0|  0.00%|        return np.asanyarray(obj).dtype
   233|         0|            0|            0|  0.00%|
   234|         0|            0|            0|  0.00%|
   235|         0|            0|            0|  0.00%|def default_fill_value(obj):
   236|         0|            0|            0|  0.00%|    """
   237|         0|            0|            0|  0.00%|    Return the default fill value for the argument object.
   238|         0|            0|            0|  0.00%|
   239|         0|            0|            0|  0.00%|    The default filling value depends on the datatype of the input
   240|         0|            0|            0|  0.00%|    array or the type of the input scalar:
   241|         0|            0|            0|  0.00%|
   242|         0|            0|            0|  0.00%|       ========  ========
   243|         0|            0|            0|  0.00%|       datatype  default
   244|         0|            0|            0|  0.00%|       ========  ========
   245|         0|            0|            0|  0.00%|       bool      True
   246|         0|            0|            0|  0.00%|       int       999999
   247|         0|            0|            0|  0.00%|       float     1.e20
   248|         0|            0|            0|  0.00%|       complex   1.e20+0j
   249|         0|            0|            0|  0.00%|       object    '?'
   250|         0|            0|            0|  0.00%|       string    'N/A'
   251|         0|            0|            0|  0.00%|       ========  ========
   252|         0|            0|            0|  0.00%|
   253|         0|            0|            0|  0.00%|    For structured types, a structured scalar is returned, with each field the
   254|         0|            0|            0|  0.00%|    default fill value for its type.
   255|         0|            0|            0|  0.00%|
   256|         0|            0|            0|  0.00%|    For subarray types, the fill value is an array of the same size containing
   257|         0|            0|            0|  0.00%|    the default scalar fill value.
   258|         0|            0|            0|  0.00%|
   259|         0|            0|            0|  0.00%|    Parameters
   260|         0|            0|            0|  0.00%|    ----------
   261|         0|            0|            0|  0.00%|    obj : ndarray, dtype or scalar
   262|         0|            0|            0|  0.00%|        The array data-type or scalar for which the default fill value
   263|         0|            0|            0|  0.00%|        is returned.
   264|         0|            0|            0|  0.00%|
   265|         0|            0|            0|  0.00%|    Returns
   266|         0|            0|            0|  0.00%|    -------
   267|         0|            0|            0|  0.00%|    fill_value : scalar
   268|         0|            0|            0|  0.00%|        The default fill value.
   269|         0|            0|            0|  0.00%|
   270|         0|            0|            0|  0.00%|    Examples
   271|         0|            0|            0|  0.00%|    --------
   272|         0|            0|            0|  0.00%|    >>> np.ma.default_fill_value(1)
   273|         0|            0|            0|  0.00%|    999999
   274|         0|            0|            0|  0.00%|    >>> np.ma.default_fill_value(np.array([1.1, 2., np.pi]))
   275|         0|            0|            0|  0.00%|    1e+20
   276|         0|            0|            0|  0.00%|    >>> np.ma.default_fill_value(np.dtype(complex))
   277|         0|            0|            0|  0.00%|    (1e+20+0j)
   278|         0|            0|            0|  0.00%|
   279|         0|            0|            0|  0.00%|    """
   280|         0|            0|            0|  0.00%|    def _scalar_fill_value(dtype):
   281|         0|            0|            0|  0.00%|        if dtype.kind in 'Mm':
   282|         0|            0|            0|  0.00%|            return default_filler.get(dtype.str[1:], '?')
   283|         0|            0|            0|  0.00%|        else:
   284|         0|            0|            0|  0.00%|            return default_filler.get(dtype.kind, '?')
   285|         0|            0|            0|  0.00%|
   286|         0|            0|            0|  0.00%|    dtype = _get_dtype_of(obj)
   287|         0|            0|            0|  0.00%|    return _recursive_fill_value(dtype, _scalar_fill_value)
   288|         0|            0|            0|  0.00%|
   289|         0|            0|            0|  0.00%|
   290|         0|            0|            0|  0.00%|def _extremum_fill_value(obj, extremum, extremum_name):
   291|         0|            0|            0|  0.00%|
   292|         0|            0|            0|  0.00%|    def _scalar_fill_value(dtype):
   293|         0|            0|            0|  0.00%|        try:
   294|         0|            0|            0|  0.00%|            return extremum[dtype]
   295|         0|            0|            0|  0.00%|        except KeyError:
   296|         0|            0|            0|  0.00%|            raise TypeError(
   297|         0|            0|            0|  0.00%|                "Unsuitable type {} for calculating {}."
   298|         0|            0|            0|  0.00%|                .format(dtype, extremum_name)
   299|         0|            0|            0|  0.00%|            )
   300|         0|            0|            0|  0.00%|
   301|         0|            0|            0|  0.00%|    dtype = _get_dtype_of(obj)
   302|         0|            0|            0|  0.00%|    return _recursive_fill_value(dtype, _scalar_fill_value)
   303|         0|            0|            0|  0.00%|
   304|         0|            0|            0|  0.00%|
   305|         0|            0|            0|  0.00%|def minimum_fill_value(obj):
   306|         0|            0|            0|  0.00%|    """
   307|         0|            0|            0|  0.00%|    Return the maximum value that can be represented by the dtype of an object.
   308|         0|            0|            0|  0.00%|
   309|         0|            0|            0|  0.00%|    This function is useful for calculating a fill value suitable for
   310|         0|            0|            0|  0.00%|    taking the minimum of an array with a given dtype.
   311|         0|            0|            0|  0.00%|
   312|         0|            0|            0|  0.00%|    Parameters
   313|         0|            0|            0|  0.00%|    ----------
   314|         0|            0|            0|  0.00%|    obj : ndarray, dtype or scalar
   315|         0|            0|            0|  0.00%|        An object that can be queried for it's numeric type.
   316|         0|            0|            0|  0.00%|
   317|         0|            0|            0|  0.00%|    Returns
   318|         0|            0|            0|  0.00%|    -------
   319|         0|            0|            0|  0.00%|    val : scalar
   320|         0|            0|            0|  0.00%|        The maximum representable value.
   321|         0|            0|            0|  0.00%|
   322|         0|            0|            0|  0.00%|    Raises
   323|         0|            0|            0|  0.00%|    ------
   324|         0|            0|            0|  0.00%|    TypeError
   325|         0|            0|            0|  0.00%|        If `obj` isn't a suitable numeric type.
   326|         0|            0|            0|  0.00%|
   327|         0|            0|            0|  0.00%|    See Also
   328|         0|            0|            0|  0.00%|    --------
   329|         0|            0|            0|  0.00%|    maximum_fill_value : The inverse function.
   330|         0|            0|            0|  0.00%|    set_fill_value : Set the filling value of a masked array.
   331|         0|            0|            0|  0.00%|    MaskedArray.fill_value : Return current fill value.
   332|         0|            0|            0|  0.00%|
   333|         0|            0|            0|  0.00%|    Examples
   334|         0|            0|            0|  0.00%|    --------
   335|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
   336|         0|            0|            0|  0.00%|    >>> a = np.int8()
   337|         0|            0|            0|  0.00%|    >>> ma.minimum_fill_value(a)
   338|         0|            0|            0|  0.00%|    127
   339|         0|            0|            0|  0.00%|    >>> a = np.int32()
   340|         0|            0|            0|  0.00%|    >>> ma.minimum_fill_value(a)
   341|         0|            0|            0|  0.00%|    2147483647
   342|         0|            0|            0|  0.00%|
   343|         0|            0|            0|  0.00%|    An array of numeric data can also be passed.
   344|         0|            0|            0|  0.00%|
   345|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3], dtype=np.int8)
   346|         0|            0|            0|  0.00%|    >>> ma.minimum_fill_value(a)
   347|         0|            0|            0|  0.00%|    127
   348|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3], dtype=np.float32)
   349|         0|            0|            0|  0.00%|    >>> ma.minimum_fill_value(a)
   350|         0|            0|            0|  0.00%|    inf
   351|         0|            0|            0|  0.00%|
   352|         0|            0|            0|  0.00%|    """
   353|         0|            0|            0|  0.00%|    return _extremum_fill_value(obj, min_filler, "minimum")
   354|         0|            0|            0|  0.00%|
   355|         0|            0|            0|  0.00%|
   356|         0|            0|            0|  0.00%|def maximum_fill_value(obj):
   357|         0|            0|            0|  0.00%|    """
   358|         0|            0|            0|  0.00%|    Return the minimum value that can be represented by the dtype of an object.
   359|         0|            0|            0|  0.00%|
   360|         0|            0|            0|  0.00%|    This function is useful for calculating a fill value suitable for
   361|         0|            0|            0|  0.00%|    taking the maximum of an array with a given dtype.
   362|         0|            0|            0|  0.00%|
   363|         0|            0|            0|  0.00%|    Parameters
   364|         0|            0|            0|  0.00%|    ----------
   365|         0|            0|            0|  0.00%|    obj : ndarray, dtype or scalar
   366|         0|            0|            0|  0.00%|        An object that can be queried for it's numeric type.
   367|         0|            0|            0|  0.00%|
   368|         0|            0|            0|  0.00%|    Returns
   369|         0|            0|            0|  0.00%|    -------
   370|         0|            0|            0|  0.00%|    val : scalar
   371|         0|            0|            0|  0.00%|        The minimum representable value.
   372|         0|            0|            0|  0.00%|
   373|         0|            0|            0|  0.00%|    Raises
   374|         0|            0|            0|  0.00%|    ------
   375|         0|            0|            0|  0.00%|    TypeError
   376|         0|            0|            0|  0.00%|        If `obj` isn't a suitable numeric type.
   377|         0|            0|            0|  0.00%|
   378|         0|            0|            0|  0.00%|    See Also
   379|         0|            0|            0|  0.00%|    --------
   380|         0|            0|            0|  0.00%|    minimum_fill_value : The inverse function.
   381|         0|            0|            0|  0.00%|    set_fill_value : Set the filling value of a masked array.
   382|         0|            0|            0|  0.00%|    MaskedArray.fill_value : Return current fill value.
   383|         0|            0|            0|  0.00%|
   384|         0|            0|            0|  0.00%|    Examples
   385|         0|            0|            0|  0.00%|    --------
   386|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
   387|         0|            0|            0|  0.00%|    >>> a = np.int8()
   388|         0|            0|            0|  0.00%|    >>> ma.maximum_fill_value(a)
   389|         0|            0|            0|  0.00%|    -128
   390|         0|            0|            0|  0.00%|    >>> a = np.int32()
   391|         0|            0|            0|  0.00%|    >>> ma.maximum_fill_value(a)
   392|         0|            0|            0|  0.00%|    -2147483648
   393|         0|            0|            0|  0.00%|
   394|         0|            0|            0|  0.00%|    An array of numeric data can also be passed.
   395|         0|            0|            0|  0.00%|
   396|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3], dtype=np.int8)
   397|         0|            0|            0|  0.00%|    >>> ma.maximum_fill_value(a)
   398|         0|            0|            0|  0.00%|    -128
   399|         0|            0|            0|  0.00%|    >>> a = np.array([1, 2, 3], dtype=np.float32)
   400|         0|            0|            0|  0.00%|    >>> ma.maximum_fill_value(a)
   401|         0|            0|            0|  0.00%|    -inf
   402|         0|            0|            0|  0.00%|
   403|         0|            0|            0|  0.00%|    """
   404|         0|            0|            0|  0.00%|    return _extremum_fill_value(obj, max_filler, "maximum")
   405|         0|            0|            0|  0.00%|
   406|         0|            0|            0|  0.00%|
   407|         0|            0|            0|  0.00%|def _recursive_set_fill_value(fillvalue, dt):
   408|         0|            0|            0|  0.00%|    """
   409|         0|            0|            0|  0.00%|    Create a fill value for a structured dtype.
   410|         0|            0|            0|  0.00%|
   411|         0|            0|            0|  0.00%|    Parameters
   412|         0|            0|            0|  0.00%|    ----------
   413|         0|            0|            0|  0.00%|    fillvalue: scalar or array_like
   414|         0|            0|            0|  0.00%|        Scalar or array representing the fill value. If it is of shorter
   415|         0|            0|            0|  0.00%|        length than the number of fields in dt, it will be resized.
   416|         0|            0|            0|  0.00%|    dt: dtype
   417|         0|            0|            0|  0.00%|        The structured dtype for which to create the fill value.
   418|         0|            0|            0|  0.00%|
   419|         0|            0|            0|  0.00%|    Returns
   420|         0|            0|            0|  0.00%|    -------
   421|         0|            0|            0|  0.00%|    val: tuple
   422|         0|            0|            0|  0.00%|        A tuple of values corresponding to the structured fill value.
   423|         0|            0|            0|  0.00%|
   424|         0|            0|            0|  0.00%|    """
   425|         0|            0|            0|  0.00%|    fillvalue = np.resize(fillvalue, len(dt.names))
   426|         0|            0|            0|  0.00%|    output_value = []
   427|         0|            0|            0|  0.00%|    for (fval, name) in zip(fillvalue, dt.names):
   428|         0|            0|            0|  0.00%|        cdtype = dt[name]
   429|         0|            0|            0|  0.00%|        if cdtype.subdtype:
   430|         0|            0|            0|  0.00%|            cdtype = cdtype.subdtype[0]
   431|         0|            0|            0|  0.00%|
   432|         0|            0|            0|  0.00%|        if cdtype.names is not None:
   433|         0|            0|            0|  0.00%|            output_value.append(tuple(_recursive_set_fill_value(fval, cdtype)))
   434|         0|            0|            0|  0.00%|        else:
   435|         0|            0|            0|  0.00%|            output_value.append(np.array(fval, dtype=cdtype).item())
   436|         0|            0|            0|  0.00%|    return tuple(output_value)
   437|         0|            0|            0|  0.00%|
   438|         0|            0|            0|  0.00%|
   439|         0|            0|            0|  0.00%|def _check_fill_value(fill_value, ndtype):
   440|         0|            0|            0|  0.00%|    """
   441|         0|            0|            0|  0.00%|    Private function validating the given `fill_value` for the given dtype.
   442|         0|            0|            0|  0.00%|
   443|         0|            0|            0|  0.00%|    If fill_value is None, it is set to the default corresponding to the dtype.
   444|         0|            0|            0|  0.00%|
   445|         0|            0|            0|  0.00%|    If fill_value is not None, its value is forced to the given dtype.
   446|         0|            0|            0|  0.00%|
   447|         0|            0|            0|  0.00%|    The result is always a 0d array.
   448|         0|            0|            0|  0.00%|
   449|         0|            0|            0|  0.00%|    """
   450|         0|            0|            0|  0.00%|    ndtype = np.dtype(ndtype)
   451|         0|            0|            0|  0.00%|    if fill_value is None:
   452|         0|            0|            0|  0.00%|        fill_value = default_fill_value(ndtype)
   453|         0|            0|            0|  0.00%|    elif ndtype.names is not None:
   454|         0|            0|            0|  0.00%|        if isinstance(fill_value, (ndarray, np.void)):
   455|         0|            0|            0|  0.00%|            try:
   456|         0|            0|            0|  0.00%|                fill_value = np.array(fill_value, copy=False, dtype=ndtype)
   457|         0|            0|            0|  0.00%|            except ValueError:
   458|         0|            0|            0|  0.00%|                err_msg = "Unable to transform %s to dtype %s"
   459|         0|            0|            0|  0.00%|                raise ValueError(err_msg % (fill_value, ndtype))
   460|         0|            0|            0|  0.00%|        else:
   461|         0|            0|            0|  0.00%|            fill_value = np.asarray(fill_value, dtype=object)
   462|         0|            0|            0|  0.00%|            fill_value = np.array(_recursive_set_fill_value(fill_value, ndtype),
   463|         0|            0|            0|  0.00%|                                  dtype=ndtype)
   464|         0|            0|            0|  0.00%|    else:
   465|         0|            0|            0|  0.00%|        if isinstance(fill_value, basestring) and (ndtype.char not in 'OSVU'):
   466|         0|            0|            0|  0.00%|            # Note this check doesn't work if fill_value is not a scalar
   467|         0|            0|            0|  0.00%|            err_msg = "Cannot set fill value of string with array of dtype %s"
   468|         0|            0|            0|  0.00%|            raise TypeError(err_msg % ndtype)
   469|         0|            0|            0|  0.00%|        else:
   470|         0|            0|            0|  0.00%|            # In case we want to convert 1e20 to int.
   471|         0|            0|            0|  0.00%|            # Also in case of converting string arrays.
   472|         0|            0|            0|  0.00%|            try:
   473|         0|            0|            0|  0.00%|                fill_value = np.array(fill_value, copy=False, dtype=ndtype)
   474|         0|            0|            0|  0.00%|            except (OverflowError, ValueError):
   475|         0|            0|            0|  0.00%|                # Raise TypeError instead of OverflowError or ValueError.
   476|         0|            0|            0|  0.00%|                # OverflowError is seldom used, and the real problem here is
   477|         0|            0|            0|  0.00%|                # that the passed fill_value is not compatible with the ndtype.
   478|         0|            0|            0|  0.00%|                err_msg = "Cannot convert fill_value %s to dtype %s"
   479|         0|            0|            0|  0.00%|                raise TypeError(err_msg % (fill_value, ndtype))
   480|         0|            0|            0|  0.00%|    return np.array(fill_value)
   481|         0|            0|            0|  0.00%|
   482|         0|            0|            0|  0.00%|
   483|         0|            0|            0|  0.00%|def set_fill_value(a, fill_value):
   484|         0|            0|            0|  0.00%|    """
   485|         0|            0|            0|  0.00%|    Set the filling value of a, if a is a masked array.
   486|         0|            0|            0|  0.00%|
   487|         0|            0|            0|  0.00%|    This function changes the fill value of the masked array `a` in place.
   488|         0|            0|            0|  0.00%|    If `a` is not a masked array, the function returns silently, without
   489|         0|            0|            0|  0.00%|    doing anything.
   490|         0|            0|            0|  0.00%|
   491|         0|            0|            0|  0.00%|    Parameters
   492|         0|            0|            0|  0.00%|    ----------
   493|         0|            0|            0|  0.00%|    a : array_like
   494|         0|            0|            0|  0.00%|        Input array.
   495|         0|            0|            0|  0.00%|    fill_value : dtype
   496|         0|            0|            0|  0.00%|        Filling value. A consistency test is performed to make sure
   497|         0|            0|            0|  0.00%|        the value is compatible with the dtype of `a`.
   498|         0|            0|            0|  0.00%|
   499|         0|            0|            0|  0.00%|    Returns
   500|         0|            0|            0|  0.00%|    -------
   501|         0|            0|            0|  0.00%|    None
   502|         0|            0|            0|  0.00%|        Nothing returned by this function.
   503|         0|            0|            0|  0.00%|
   504|         0|            0|            0|  0.00%|    See Also
   505|         0|            0|            0|  0.00%|    --------
   506|         0|            0|            0|  0.00%|    maximum_fill_value : Return the default fill value for a dtype.
   507|         0|            0|            0|  0.00%|    MaskedArray.fill_value : Return current fill value.
   508|         0|            0|            0|  0.00%|    MaskedArray.set_fill_value : Equivalent method.
   509|         0|            0|            0|  0.00%|
   510|         0|            0|            0|  0.00%|    Examples
   511|         0|            0|            0|  0.00%|    --------
   512|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
   513|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   514|         0|            0|            0|  0.00%|    >>> a
   515|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4])
   516|         0|            0|            0|  0.00%|    >>> a = ma.masked_where(a < 3, a)
   517|         0|            0|            0|  0.00%|    >>> a
   518|         0|            0|            0|  0.00%|    masked_array(data=[--, --, --, 3, 4],
   519|         0|            0|            0|  0.00%|                 mask=[ True,  True,  True, False, False],
   520|         0|            0|            0|  0.00%|           fill_value=999999)
   521|         0|            0|            0|  0.00%|    >>> ma.set_fill_value(a, -999)
   522|         0|            0|            0|  0.00%|    >>> a
   523|         0|            0|            0|  0.00%|    masked_array(data=[--, --, --, 3, 4],
   524|         0|            0|            0|  0.00%|                 mask=[ True,  True,  True, False, False],
   525|         0|            0|            0|  0.00%|           fill_value=-999)
   526|         0|            0|            0|  0.00%|
   527|         0|            0|            0|  0.00%|    Nothing happens if `a` is not a masked array.
   528|         0|            0|            0|  0.00%|
   529|         0|            0|            0|  0.00%|    >>> a = list(range(5))
   530|         0|            0|            0|  0.00%|    >>> a
   531|         0|            0|            0|  0.00%|    [0, 1, 2, 3, 4]
   532|         0|            0|            0|  0.00%|    >>> ma.set_fill_value(a, 100)
   533|         0|            0|            0|  0.00%|    >>> a
   534|         0|            0|            0|  0.00%|    [0, 1, 2, 3, 4]
   535|         0|            0|            0|  0.00%|    >>> a = np.arange(5)
   536|         0|            0|            0|  0.00%|    >>> a
   537|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4])
   538|         0|            0|            0|  0.00%|    >>> ma.set_fill_value(a, 100)
   539|         0|            0|            0|  0.00%|    >>> a
   540|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4])
   541|         0|            0|            0|  0.00%|
   542|         0|            0|            0|  0.00%|    """
   543|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
   544|         0|            0|            0|  0.00%|        a.set_fill_value(fill_value)
   545|         0|            0|            0|  0.00%|    return
   546|         0|            0|            0|  0.00%|
   547|         0|            0|            0|  0.00%|
   548|         0|            0|            0|  0.00%|def get_fill_value(a):
   549|         0|            0|            0|  0.00%|    """
   550|         0|            0|            0|  0.00%|    Return the filling value of a, if any.  Otherwise, returns the
   551|         0|            0|            0|  0.00%|    default filling value for that type.
   552|         0|            0|            0|  0.00%|
   553|         0|            0|            0|  0.00%|    """
   554|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
   555|         0|            0|            0|  0.00%|        result = a.fill_value
   556|         0|            0|            0|  0.00%|    else:
   557|         0|            0|            0|  0.00%|        result = default_fill_value(a)
   558|         0|            0|            0|  0.00%|    return result
   559|         0|            0|            0|  0.00%|
   560|         0|            0|            0|  0.00%|
   561|         0|            0|            0|  0.00%|def common_fill_value(a, b):
   562|         0|            0|            0|  0.00%|    """
   563|         0|            0|            0|  0.00%|    Return the common filling value of two masked arrays, if any.
   564|         0|            0|            0|  0.00%|
   565|         0|            0|            0|  0.00%|    If ``a.fill_value == b.fill_value``, return the fill value,
   566|         0|            0|            0|  0.00%|    otherwise return None.
   567|         0|            0|            0|  0.00%|
   568|         0|            0|            0|  0.00%|    Parameters
   569|         0|            0|            0|  0.00%|    ----------
   570|         0|            0|            0|  0.00%|    a, b : MaskedArray
   571|         0|            0|            0|  0.00%|        The masked arrays for which to compare fill values.
   572|         0|            0|            0|  0.00%|
   573|         0|            0|            0|  0.00%|    Returns
   574|         0|            0|            0|  0.00%|    -------
   575|         0|            0|            0|  0.00%|    fill_value : scalar or None
   576|         0|            0|            0|  0.00%|        The common fill value, or None.
   577|         0|            0|            0|  0.00%|
   578|         0|            0|            0|  0.00%|    Examples
   579|         0|            0|            0|  0.00%|    --------
   580|         0|            0|            0|  0.00%|    >>> x = np.ma.array([0, 1.], fill_value=3)
   581|         0|            0|            0|  0.00%|    >>> y = np.ma.array([0, 1.], fill_value=3)
   582|         0|            0|            0|  0.00%|    >>> np.ma.common_fill_value(x, y)
   583|         0|            0|            0|  0.00%|    3.0
   584|         0|            0|            0|  0.00%|
   585|         0|            0|            0|  0.00%|    """
   586|         0|            0|            0|  0.00%|    t1 = get_fill_value(a)
   587|         0|            0|            0|  0.00%|    t2 = get_fill_value(b)
   588|         0|            0|            0|  0.00%|    if t1 == t2:
   589|         0|            0|            0|  0.00%|        return t1
   590|         0|            0|            0|  0.00%|    return None
   591|         0|            0|            0|  0.00%|
   592|         0|            0|            0|  0.00%|
   593|         0|            0|            0|  0.00%|def filled(a, fill_value=None):
   594|         0|            0|            0|  0.00%|    """
   595|         0|            0|            0|  0.00%|    Return input as an array with masked data replaced by a fill value.
   596|         0|            0|            0|  0.00%|
   597|         0|            0|            0|  0.00%|    If `a` is not a `MaskedArray`, `a` itself is returned.
   598|         0|            0|            0|  0.00%|    If `a` is a `MaskedArray` and `fill_value` is None, `fill_value` is set to
   599|         0|            0|            0|  0.00%|    ``a.fill_value``.
   600|         0|            0|            0|  0.00%|
   601|         0|            0|            0|  0.00%|    Parameters
   602|         0|            0|            0|  0.00%|    ----------
   603|         0|            0|            0|  0.00%|    a : MaskedArray or array_like
   604|         0|            0|            0|  0.00%|        An input object.
   605|         0|            0|            0|  0.00%|    fill_value : scalar, optional
   606|         0|            0|            0|  0.00%|        Filling value. Default is None.
   607|         0|            0|            0|  0.00%|
   608|         0|            0|            0|  0.00%|    Returns
   609|         0|            0|            0|  0.00%|    -------
   610|         0|            0|            0|  0.00%|    a : ndarray
   611|         0|            0|            0|  0.00%|        The filled array.
   612|         0|            0|            0|  0.00%|
   613|         0|            0|            0|  0.00%|    See Also
   614|         0|            0|            0|  0.00%|    --------
   615|         0|            0|            0|  0.00%|    compressed
   616|         0|            0|            0|  0.00%|
   617|         0|            0|            0|  0.00%|    Examples
   618|         0|            0|            0|  0.00%|    --------
   619|         0|            0|            0|  0.00%|    >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[[1, 0, 0],
   620|         0|            0|            0|  0.00%|    ...                                                   [1, 0, 0],
   621|         0|            0|            0|  0.00%|    ...                                                   [0, 0, 0]])
   622|         0|            0|            0|  0.00%|    >>> x.filled()
   623|         0|            0|            0|  0.00%|    array([[999999,      1,      2],
   624|         0|            0|            0|  0.00%|           [999999,      4,      5],
   625|         0|            0|            0|  0.00%|           [     6,      7,      8]])
   626|         0|            0|            0|  0.00%|
   627|         0|            0|            0|  0.00%|    """
   628|         0|            0|            0|  0.00%|    if hasattr(a, 'filled'):
   629|         0|            0|            0|  0.00%|        return a.filled(fill_value)
   630|         0|            0|            0|  0.00%|    elif isinstance(a, ndarray):
   631|         0|            0|            0|  0.00%|        # Should we check for contiguity ? and a.flags['CONTIGUOUS']:
   632|         0|            0|            0|  0.00%|        return a
   633|         0|            0|            0|  0.00%|    elif isinstance(a, dict):
   634|         0|            0|            0|  0.00%|        return np.array(a, 'O')
   635|         0|            0|            0|  0.00%|    else:
   636|         0|            0|            0|  0.00%|        return np.array(a)
   637|         0|            0|            0|  0.00%|
   638|         0|            0|            0|  0.00%|
   639|         0|            0|            0|  0.00%|def get_masked_subclass(*arrays):
   640|         0|            0|            0|  0.00%|    """
   641|         0|            0|            0|  0.00%|    Return the youngest subclass of MaskedArray from a list of (masked) arrays.
   642|         0|            0|            0|  0.00%|
   643|         0|            0|            0|  0.00%|    In case of siblings, the first listed takes over.
   644|         0|            0|            0|  0.00%|
   645|         0|            0|            0|  0.00%|    """
   646|         0|            0|            0|  0.00%|    if len(arrays) == 1:
   647|         0|            0|            0|  0.00%|        arr = arrays[0]
   648|         0|            0|            0|  0.00%|        if isinstance(arr, MaskedArray):
   649|         0|            0|            0|  0.00%|            rcls = type(arr)
   650|         0|            0|            0|  0.00%|        else:
   651|         0|            0|            0|  0.00%|            rcls = MaskedArray
   652|         0|            0|            0|  0.00%|    else:
   653|         0|            0|            0|  0.00%|        arrcls = [type(a) for a in arrays]
   654|         0|            0|            0|  0.00%|        rcls = arrcls[0]
   655|         0|            0|            0|  0.00%|        if not issubclass(rcls, MaskedArray):
   656|         0|            0|            0|  0.00%|            rcls = MaskedArray
   657|         0|            0|            0|  0.00%|        for cls in arrcls[1:]:
   658|         0|            0|            0|  0.00%|            if issubclass(cls, rcls):
   659|         0|            0|            0|  0.00%|                rcls = cls
   660|         0|            0|            0|  0.00%|    # Don't return MaskedConstant as result: revert to MaskedArray
   661|         0|            0|            0|  0.00%|    if rcls.__name__ == 'MaskedConstant':
   662|         0|            0|            0|  0.00%|        return MaskedArray
   663|         0|            0|            0|  0.00%|    return rcls
   664|         0|            0|            0|  0.00%|
   665|         0|            0|            0|  0.00%|
   666|         0|            0|            0|  0.00%|def getdata(a, subok=True):
   667|         0|            0|            0|  0.00%|    """
   668|         0|            0|            0|  0.00%|    Return the data of a masked array as an ndarray.
   669|         0|            0|            0|  0.00%|
   670|         0|            0|            0|  0.00%|    Return the data of `a` (if any) as an ndarray if `a` is a ``MaskedArray``,
   671|         0|            0|            0|  0.00%|    else return `a` as a ndarray or subclass (depending on `subok`) if not.
   672|         0|            0|            0|  0.00%|
   673|         0|            0|            0|  0.00%|    Parameters
   674|         0|            0|            0|  0.00%|    ----------
   675|         0|            0|            0|  0.00%|    a : array_like
   676|         0|            0|            0|  0.00%|        Input ``MaskedArray``, alternatively a ndarray or a subclass thereof.
   677|         0|            0|            0|  0.00%|    subok : bool
   678|         0|            0|            0|  0.00%|        Whether to force the output to be a `pure` ndarray (False) or to
   679|         0|            0|            0|  0.00%|        return a subclass of ndarray if appropriate (True, default).
   680|         0|            0|            0|  0.00%|
   681|         0|            0|            0|  0.00%|    See Also
   682|         0|            0|            0|  0.00%|    --------
   683|         0|            0|            0|  0.00%|    getmask : Return the mask of a masked array, or nomask.
   684|         0|            0|            0|  0.00%|    getmaskarray : Return the mask of a masked array, or full array of False.
   685|         0|            0|            0|  0.00%|
   686|         0|            0|            0|  0.00%|    Examples
   687|         0|            0|            0|  0.00%|    --------
   688|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
   689|         0|            0|            0|  0.00%|    >>> a = ma.masked_equal([[1,2],[3,4]], 2)
   690|         0|            0|            0|  0.00%|    >>> a
   691|         0|            0|            0|  0.00%|    masked_array(
   692|         0|            0|            0|  0.00%|      data=[[1, --],
   693|         0|            0|            0|  0.00%|            [3, 4]],
   694|         0|            0|            0|  0.00%|      mask=[[False,  True],
   695|         0|            0|            0|  0.00%|            [False, False]],
   696|         0|            0|            0|  0.00%|      fill_value=2)
   697|         0|            0|            0|  0.00%|    >>> ma.getdata(a)
   698|         0|            0|            0|  0.00%|    array([[1, 2],
   699|         0|            0|            0|  0.00%|           [3, 4]])
   700|         0|            0|            0|  0.00%|
   701|         0|            0|            0|  0.00%|    Equivalently use the ``MaskedArray`` `data` attribute.
   702|         0|            0|            0|  0.00%|
   703|         0|            0|            0|  0.00%|    >>> a.data
   704|         0|            0|            0|  0.00%|    array([[1, 2],
   705|         0|            0|            0|  0.00%|           [3, 4]])
   706|         0|            0|            0|  0.00%|
   707|         0|            0|            0|  0.00%|    """
   708|         0|            0|            0|  0.00%|    try:
   709|         0|            0|            0|  0.00%|        data = a._data
   710|         0|            0|            0|  0.00%|    except AttributeError:
   711|         0|            0|            0|  0.00%|        data = np.array(a, copy=False, subok=subok)
   712|         0|            0|            0|  0.00%|    if not subok:
   713|         0|            0|            0|  0.00%|        return data.view(ndarray)
   714|         0|            0|            0|  0.00%|    return data
   715|         0|            0|            0|  0.00%|
   716|         0|            0|            0|  0.00%|
   717|         0|            0|            0|  0.00%|get_data = getdata
   718|         0|            0|            0|  0.00%|
   719|         0|            0|            0|  0.00%|
   720|         0|            0|            0|  0.00%|def fix_invalid(a, mask=nomask, copy=True, fill_value=None):
   721|         0|            0|            0|  0.00%|    """
   722|         0|            0|            0|  0.00%|    Return input with invalid data masked and replaced by a fill value.
   723|         0|            0|            0|  0.00%|
   724|         0|            0|            0|  0.00%|    Invalid data means values of `nan`, `inf`, etc.
   725|         0|            0|            0|  0.00%|
   726|         0|            0|            0|  0.00%|    Parameters
   727|         0|            0|            0|  0.00%|    ----------
   728|         0|            0|            0|  0.00%|    a : array_like
   729|         0|            0|            0|  0.00%|        Input array, a (subclass of) ndarray.
   730|         0|            0|            0|  0.00%|    mask : sequence, optional
   731|         0|            0|            0|  0.00%|        Mask. Must be convertible to an array of booleans with the same
   732|         0|            0|            0|  0.00%|        shape as `data`. True indicates a masked (i.e. invalid) data.
   733|         0|            0|            0|  0.00%|    copy : bool, optional
   734|         0|            0|            0|  0.00%|        Whether to use a copy of `a` (True) or to fix `a` in place (False).
   735|         0|            0|            0|  0.00%|        Default is True.
   736|         0|            0|            0|  0.00%|    fill_value : scalar, optional
   737|         0|            0|            0|  0.00%|        Value used for fixing invalid data. Default is None, in which case
   738|         0|            0|            0|  0.00%|        the ``a.fill_value`` is used.
   739|         0|            0|            0|  0.00%|
   740|         0|            0|            0|  0.00%|    Returns
   741|         0|            0|            0|  0.00%|    -------
   742|         0|            0|            0|  0.00%|    b : MaskedArray
   743|         0|            0|            0|  0.00%|        The input array with invalid entries fixed.
   744|         0|            0|            0|  0.00%|
   745|         0|            0|            0|  0.00%|    Notes
   746|         0|            0|            0|  0.00%|    -----
   747|         0|            0|            0|  0.00%|    A copy is performed by default.
   748|         0|            0|            0|  0.00%|
   749|         0|            0|            0|  0.00%|    Examples
   750|         0|            0|            0|  0.00%|    --------
   751|         0|            0|            0|  0.00%|    >>> x = np.ma.array([1., -1, np.nan, np.inf], mask=[1] + [0]*3)
   752|         0|            0|            0|  0.00%|    >>> x
   753|         0|            0|            0|  0.00%|    masked_array(data=[--, -1.0, nan, inf],
   754|         0|            0|            0|  0.00%|                 mask=[ True, False, False, False],
   755|         0|            0|            0|  0.00%|           fill_value=1e+20)
   756|         0|            0|            0|  0.00%|    >>> np.ma.fix_invalid(x)
   757|         0|            0|            0|  0.00%|    masked_array(data=[--, -1.0, --, --],
   758|         0|            0|            0|  0.00%|                 mask=[ True, False,  True,  True],
   759|         0|            0|            0|  0.00%|           fill_value=1e+20)
   760|         0|            0|            0|  0.00%|
   761|         0|            0|            0|  0.00%|    >>> fixed = np.ma.fix_invalid(x)
   762|         0|            0|            0|  0.00%|    >>> fixed.data
   763|         0|            0|            0|  0.00%|    array([ 1.e+00, -1.e+00,  1.e+20,  1.e+20])
   764|         0|            0|            0|  0.00%|    >>> x.data
   765|         0|            0|            0|  0.00%|    array([ 1., -1., nan, inf])
   766|         0|            0|            0|  0.00%|
   767|         0|            0|            0|  0.00%|    """
   768|         0|            0|            0|  0.00%|    a = masked_array(a, copy=copy, mask=mask, subok=True)
   769|         0|            0|            0|  0.00%|    invalid = np.logical_not(np.isfinite(a._data))
   770|         0|            0|            0|  0.00%|    if not invalid.any():
   771|         0|            0|            0|  0.00%|        return a
   772|         0|            0|            0|  0.00%|    a._mask |= invalid
   773|         0|            0|            0|  0.00%|    if fill_value is None:
   774|         0|            0|            0|  0.00%|        fill_value = a.fill_value
   775|         0|            0|            0|  0.00%|    a._data[invalid] = fill_value
   776|         0|            0|            0|  0.00%|    return a
   777|         0|            0|            0|  0.00%|
   778|         0|            0|            0|  0.00%|def is_string_or_list_of_strings(val):
   779|         0|            0|            0|  0.00%|    return (isinstance(val, basestring) or
   780|         0|            0|            0|  0.00%|            (isinstance(val, list) and val and
   781|         0|            0|            0|  0.00%|             builtins.all(isinstance(s, basestring) for s in val)))
   782|         0|            0|            0|  0.00%|
   783|         0|            0|            0|  0.00%|###############################################################################
   784|         0|            0|            0|  0.00%|#                                  Ufuncs                                     #
   785|         0|            0|            0|  0.00%|###############################################################################
   786|         0|            0|            0|  0.00%|
   787|         0|            0|            0|  0.00%|
   788|         0|            0|            0|  0.00%|ufunc_domain = {}
   789|         0|            0|            0|  0.00%|ufunc_fills = {}
   790|         0|            0|            0|  0.00%|
   791|         0|            0|            0|  0.00%|
   792|         0|            0|            0|  0.00%|class _DomainCheckInterval(object):
   793|         0|            0|            0|  0.00%|    """
   794|         0|            0|            0|  0.00%|    Define a valid interval, so that :
   795|         0|            0|            0|  0.00%|
   796|         0|            0|            0|  0.00%|    ``domain_check_interval(a,b)(x) == True`` where
   797|         0|            0|            0|  0.00%|    ``x < a`` or ``x > b``.
   798|         0|            0|            0|  0.00%|
   799|         0|            0|            0|  0.00%|    """
   800|         0|            0|            0|  0.00%|
   801|         0|            0|            0|  0.00%|    def __init__(self, a, b):
   802|         0|            0|            0|  0.00%|        "domain_check_interval(a,b)(x) = true where x < a or y > b"
   803|         0|            0|            0|  0.00%|        if (a > b):
   804|         0|            0|            0|  0.00%|            (a, b) = (b, a)
   805|         0|            0|            0|  0.00%|        self.a = a
   806|         0|            0|            0|  0.00%|        self.b = b
   807|         0|            0|            0|  0.00%|
   808|         0|            0|            0|  0.00%|    def __call__(self, x):
   809|         0|            0|            0|  0.00%|        "Execute the call behavior."
   810|         0|            0|            0|  0.00%|        # nans at masked positions cause RuntimeWarnings, even though
   811|         0|            0|            0|  0.00%|        # they are masked. To avoid this we suppress warnings.
   812|         0|            0|            0|  0.00%|        with np.errstate(invalid='ignore'):
   813|         0|            0|            0|  0.00%|            return umath.logical_or(umath.greater(x, self.b),
   814|         0|            0|            0|  0.00%|                                    umath.less(x, self.a))
   815|         0|            0|            0|  0.00%|
   816|         0|            0|            0|  0.00%|
   817|         0|            0|            0|  0.00%|class _DomainTan(object):
   818|         0|            0|            0|  0.00%|    """
   819|         0|            0|            0|  0.00%|    Define a valid interval for the `tan` function, so that:
   820|         0|            0|            0|  0.00%|
   821|         0|            0|            0|  0.00%|    ``domain_tan(eps) = True`` where ``abs(cos(x)) < eps``
   822|         0|            0|            0|  0.00%|
   823|         0|            0|            0|  0.00%|    """
   824|         0|            0|            0|  0.00%|
   825|         0|            0|            0|  0.00%|    def __init__(self, eps):
   826|         0|            0|            0|  0.00%|        "domain_tan(eps) = true where abs(cos(x)) < eps)"
   827|         0|            0|            0|  0.00%|        self.eps = eps
   828|         0|            0|            0|  0.00%|
   829|         0|            0|            0|  0.00%|    def __call__(self, x):
   830|         0|            0|            0|  0.00%|        "Executes the call behavior."
   831|         0|            0|            0|  0.00%|        with np.errstate(invalid='ignore'):
   832|         0|            0|            0|  0.00%|            return umath.less(umath.absolute(umath.cos(x)), self.eps)
   833|         0|            0|            0|  0.00%|
   834|         0|            0|            0|  0.00%|
   835|         0|            0|            0|  0.00%|class _DomainSafeDivide(object):
   836|         0|            0|            0|  0.00%|    """
   837|         0|            0|            0|  0.00%|    Define a domain for safe division.
   838|         0|            0|            0|  0.00%|
   839|         0|            0|            0|  0.00%|    """
   840|         0|            0|            0|  0.00%|
   841|         0|            0|            0|  0.00%|    def __init__(self, tolerance=None):
   842|         0|            0|            0|  0.00%|        self.tolerance = tolerance
   843|         0|            0|            0|  0.00%|
   844|         0|            0|            0|  0.00%|    def __call__(self, a, b):
   845|         0|            0|            0|  0.00%|        # Delay the selection of the tolerance to here in order to reduce numpy
   846|         0|            0|            0|  0.00%|        # import times. The calculation of these parameters is a substantial
   847|         0|            0|            0|  0.00%|        # component of numpy's import time.
   848|         0|            0|            0|  0.00%|        if self.tolerance is None:
   849|         0|            0|            0|  0.00%|            self.tolerance = np.finfo(float).tiny
   850|         0|            0|            0|  0.00%|        # don't call ma ufuncs from __array_wrap__ which would fail for scalars
   851|         0|            0|            0|  0.00%|        a, b = np.asarray(a), np.asarray(b)
   852|         0|            0|            0|  0.00%|        with np.errstate(invalid='ignore'):
   853|         0|            0|            0|  0.00%|            return umath.absolute(a) * self.tolerance >= umath.absolute(b)
   854|         0|            0|            0|  0.00%|
   855|         0|            0|            0|  0.00%|
   856|         0|            0|            0|  0.00%|class _DomainGreater(object):
   857|         0|            0|            0|  0.00%|    """
   858|         0|            0|            0|  0.00%|    DomainGreater(v)(x) is True where x <= v.
   859|         0|            0|            0|  0.00%|
   860|         0|            0|            0|  0.00%|    """
   861|         0|            0|            0|  0.00%|
   862|         0|            0|            0|  0.00%|    def __init__(self, critical_value):
   863|         0|            0|            0|  0.00%|        "DomainGreater(v)(x) = true where x <= v"
   864|         0|            0|            0|  0.00%|        self.critical_value = critical_value
   865|         0|            0|            0|  0.00%|
   866|         0|            0|            0|  0.00%|    def __call__(self, x):
   867|         0|            0|            0|  0.00%|        "Executes the call behavior."
   868|         0|            0|            0|  0.00%|        with np.errstate(invalid='ignore'):
   869|         0|            0|            0|  0.00%|            return umath.less_equal(x, self.critical_value)
   870|         0|            0|            0|  0.00%|
   871|         0|            0|            0|  0.00%|
   872|         0|            0|            0|  0.00%|class _DomainGreaterEqual(object):
   873|         0|            0|            0|  0.00%|    """
   874|         0|            0|            0|  0.00%|    DomainGreaterEqual(v)(x) is True where x < v.
   875|         0|            0|            0|  0.00%|
   876|         0|            0|            0|  0.00%|    """
   877|         0|            0|            0|  0.00%|
   878|         0|            0|            0|  0.00%|    def __init__(self, critical_value):
   879|         0|            0|            0|  0.00%|        "DomainGreaterEqual(v)(x) = true where x < v"
   880|         0|            0|            0|  0.00%|        self.critical_value = critical_value
   881|         0|            0|            0|  0.00%|
   882|         0|            0|            0|  0.00%|    def __call__(self, x):
   883|         0|            0|            0|  0.00%|        "Executes the call behavior."
   884|         0|            0|            0|  0.00%|        with np.errstate(invalid='ignore'):
   885|         0|            0|            0|  0.00%|            return umath.less(x, self.critical_value)
   886|         0|            0|            0|  0.00%|
   887|         0|            0|            0|  0.00%|
   888|         0|            0|            0|  0.00%|class _MaskedUFunc(object):
   889|         0|            0|            0|  0.00%|    def __init__(self, ufunc):
   890|         0|            0|            0|  0.00%|        self.f = ufunc
   891|         0|            0|            0|  0.00%|        self.__doc__ = ufunc.__doc__
   892|         0|            0|            0|  0.00%|        self.__name__ = ufunc.__name__
   893|         0|            0|            0|  0.00%|
   894|         0|            0|            0|  0.00%|    def __str__(self):
   895|         0|            0|            0|  0.00%|        return "Masked version of {}".format(self.f)
   896|         0|            0|            0|  0.00%|
   897|         0|            0|            0|  0.00%|
   898|         0|            0|            0|  0.00%|class _MaskedUnaryOperation(_MaskedUFunc):
   899|         0|            0|            0|  0.00%|    """
   900|         0|            0|            0|  0.00%|    Defines masked version of unary operations, where invalid values are
   901|         0|            0|            0|  0.00%|    pre-masked.
   902|         0|            0|            0|  0.00%|
   903|         0|            0|            0|  0.00%|    Parameters
   904|         0|            0|            0|  0.00%|    ----------
   905|         0|            0|            0|  0.00%|    mufunc : callable
   906|         0|            0|            0|  0.00%|        The function for which to define a masked version. Made available
   907|         0|            0|            0|  0.00%|        as ``_MaskedUnaryOperation.f``.
   908|         0|            0|            0|  0.00%|    fill : scalar, optional
   909|         0|            0|            0|  0.00%|        Filling value, default is 0.
   910|         0|            0|            0|  0.00%|    domain : class instance
   911|         0|            0|            0|  0.00%|        Domain for the function. Should be one of the ``_Domain*``
   912|         0|            0|            0|  0.00%|        classes. Default is None.
   913|         0|            0|            0|  0.00%|
   914|         0|            0|            0|  0.00%|    """
   915|         0|            0|            0|  0.00%|
   916|         0|            0|            0|  0.00%|    def __init__(self, mufunc, fill=0, domain=None):
   917|         0|            0|            0|  0.00%|        super(_MaskedUnaryOperation, self).__init__(mufunc)
   918|         0|            0|            0|  0.00%|        self.fill = fill
   919|         0|            0|            0|  0.00%|        self.domain = domain
   920|         0|            0|            0|  0.00%|        ufunc_domain[mufunc] = domain
   921|         0|            0|            0|  0.00%|        ufunc_fills[mufunc] = fill
   922|         0|            0|            0|  0.00%|
   923|         0|            0|            0|  0.00%|    def __call__(self, a, *args, **kwargs):
   924|         0|            0|            0|  0.00%|        """
   925|         0|            0|            0|  0.00%|        Execute the call behavior.
   926|         0|            0|            0|  0.00%|
   927|         0|            0|            0|  0.00%|        """
   928|         0|            0|            0|  0.00%|        d = getdata(a)
   929|         0|            0|            0|  0.00%|        # Deal with domain
   930|         0|            0|            0|  0.00%|        if self.domain is not None:
   931|         0|            0|            0|  0.00%|            # Case 1.1. : Domained function
   932|         0|            0|            0|  0.00%|            # nans at masked positions cause RuntimeWarnings, even though
   933|         0|            0|            0|  0.00%|            # they are masked. To avoid this we suppress warnings.
   934|         0|            0|            0|  0.00%|            with np.errstate(divide='ignore', invalid='ignore'):
   935|         0|            0|            0|  0.00%|                result = self.f(d, *args, **kwargs)
   936|         0|            0|            0|  0.00%|            # Make a mask
   937|         0|            0|            0|  0.00%|            m = ~umath.isfinite(result)
   938|         0|            0|            0|  0.00%|            m |= self.domain(d)
   939|         0|            0|            0|  0.00%|            m |= getmask(a)
   940|         0|            0|            0|  0.00%|        else:
   941|         0|            0|            0|  0.00%|            # Case 1.2. : Function without a domain
   942|         0|            0|            0|  0.00%|            # Get the result and the mask
   943|         0|            0|            0|  0.00%|            with np.errstate(divide='ignore', invalid='ignore'):
   944|         0|            0|            0|  0.00%|                result = self.f(d, *args, **kwargs)
   945|         0|            0|            0|  0.00%|            m = getmask(a)
   946|         0|            0|            0|  0.00%|
   947|         0|            0|            0|  0.00%|        if not result.ndim:
   948|         0|            0|            0|  0.00%|            # Case 2.1. : The result is scalarscalar
   949|         0|            0|            0|  0.00%|            if m:
   950|         0|            0|            0|  0.00%|                return masked
   951|         0|            0|            0|  0.00%|            return result
   952|         0|            0|            0|  0.00%|
   953|         0|            0|            0|  0.00%|        if m is not nomask:
   954|         0|            0|            0|  0.00%|            # Case 2.2. The result is an array
   955|         0|            0|            0|  0.00%|            # We need to fill the invalid data back w/ the input Now,
   956|         0|            0|            0|  0.00%|            # that's plain silly: in C, we would just skip the element and
   957|         0|            0|            0|  0.00%|            # keep the original, but we do have to do it that way in Python
   958|         0|            0|            0|  0.00%|
   959|         0|            0|            0|  0.00%|            # In case result has a lower dtype than the inputs (as in
   960|         0|            0|            0|  0.00%|            # equal)
   961|         0|            0|            0|  0.00%|            try:
   962|         0|            0|            0|  0.00%|                np.copyto(result, d, where=m)
   963|         0|            0|            0|  0.00%|            except TypeError:
   964|         0|            0|            0|  0.00%|                pass
   965|         0|            0|            0|  0.00%|        # Transform to
   966|         0|            0|            0|  0.00%|        masked_result = result.view(get_masked_subclass(a))
   967|         0|            0|            0|  0.00%|        masked_result._mask = m
   968|         0|            0|            0|  0.00%|        masked_result._update_from(a)
   969|         0|            0|            0|  0.00%|        return masked_result
   970|         0|            0|            0|  0.00%|
   971|         0|            0|            0|  0.00%|
   972|         0|            0|            0|  0.00%|class _MaskedBinaryOperation(_MaskedUFunc):
   973|         0|            0|            0|  0.00%|    """
   974|         0|            0|            0|  0.00%|    Define masked version of binary operations, where invalid
   975|         0|            0|            0|  0.00%|    values are pre-masked.
   976|         0|            0|            0|  0.00%|
   977|         0|            0|            0|  0.00%|    Parameters
   978|         0|            0|            0|  0.00%|    ----------
   979|         0|            0|            0|  0.00%|    mbfunc : function
   980|         0|            0|            0|  0.00%|        The function for which to define a masked version. Made available
   981|         0|            0|            0|  0.00%|        as ``_MaskedBinaryOperation.f``.
   982|         0|            0|            0|  0.00%|    domain : class instance
   983|         0|            0|            0|  0.00%|        Default domain for the function. Should be one of the ``_Domain*``
   984|         0|            0|            0|  0.00%|        classes. Default is None.
   985|         0|            0|            0|  0.00%|    fillx : scalar, optional
   986|         0|            0|            0|  0.00%|        Filling value for the first argument, default is 0.
   987|         0|            0|            0|  0.00%|    filly : scalar, optional
   988|         0|            0|            0|  0.00%|        Filling value for the second argument, default is 0.
   989|         0|            0|            0|  0.00%|
   990|         0|            0|            0|  0.00%|    """
   991|         0|            0|            0|  0.00%|
   992|         0|            0|            0|  0.00%|    def __init__(self, mbfunc, fillx=0, filly=0):
   993|         0|            0|            0|  0.00%|        """
   994|         0|            0|            0|  0.00%|        abfunc(fillx, filly) must be defined.
   995|         0|            0|            0|  0.00%|
   996|         0|            0|            0|  0.00%|        abfunc(x, filly) = x for all x to enable reduce.
   997|         0|            0|            0|  0.00%|
   998|         0|            0|            0|  0.00%|        """
   999|         0|            0|            0|  0.00%|        super(_MaskedBinaryOperation, self).__init__(mbfunc)
  1000|         0|            0|            0|  0.00%|        self.fillx = fillx
  1001|         0|            0|            0|  0.00%|        self.filly = filly
  1002|         0|            0|            0|  0.00%|        ufunc_domain[mbfunc] = None
  1003|         0|            0|            0|  0.00%|        ufunc_fills[mbfunc] = (fillx, filly)
  1004|         0|            0|            0|  0.00%|
  1005|         0|            0|            0|  0.00%|    def __call__(self, a, b, *args, **kwargs):
  1006|         0|            0|            0|  0.00%|        """
  1007|         0|            0|            0|  0.00%|        Execute the call behavior.
  1008|         0|            0|            0|  0.00%|
  1009|         0|            0|            0|  0.00%|        """
  1010|         0|            0|            0|  0.00%|        # Get the data, as ndarray
  1011|         0|            0|            0|  0.00%|        (da, db) = (getdata(a), getdata(b))
  1012|         0|            0|            0|  0.00%|        # Get the result
  1013|         0|            0|            0|  0.00%|        with np.errstate():
  1014|         0|            0|            0|  0.00%|            np.seterr(divide='ignore', invalid='ignore')
  1015|         0|            0|            0|  0.00%|            result = self.f(da, db, *args, **kwargs)
  1016|         0|            0|            0|  0.00%|        # Get the mask for the result
  1017|         0|            0|            0|  0.00%|        (ma, mb) = (getmask(a), getmask(b))
  1018|         0|            0|            0|  0.00%|        if ma is nomask:
  1019|         0|            0|            0|  0.00%|            if mb is nomask:
  1020|         0|            0|            0|  0.00%|                m = nomask
  1021|         0|            0|            0|  0.00%|            else:
  1022|         0|            0|            0|  0.00%|                m = umath.logical_or(getmaskarray(a), mb)
  1023|         0|            0|            0|  0.00%|        elif mb is nomask:
  1024|         0|            0|            0|  0.00%|            m = umath.logical_or(ma, getmaskarray(b))
  1025|         0|            0|            0|  0.00%|        else:
  1026|         0|            0|            0|  0.00%|            m = umath.logical_or(ma, mb)
  1027|         0|            0|            0|  0.00%|
  1028|         0|            0|            0|  0.00%|        # Case 1. : scalar
  1029|         0|            0|            0|  0.00%|        if not result.ndim:
  1030|         0|            0|            0|  0.00%|            if m:
  1031|         0|            0|            0|  0.00%|                return masked
  1032|         0|            0|            0|  0.00%|            return result
  1033|         0|            0|            0|  0.00%|
  1034|         0|            0|            0|  0.00%|        # Case 2. : array
  1035|         0|            0|            0|  0.00%|        # Revert result to da where masked
  1036|         0|            0|            0|  0.00%|        if m is not nomask and m.any():
  1037|         0|            0|            0|  0.00%|            # any errors, just abort; impossible to guarantee masked values
  1038|         0|            0|            0|  0.00%|            try:
  1039|         0|            0|            0|  0.00%|                np.copyto(result, da, casting='unsafe', where=m)
  1040|         0|            0|            0|  0.00%|            except Exception:
  1041|         0|            0|            0|  0.00%|                pass
  1042|         0|            0|            0|  0.00%|
  1043|         0|            0|            0|  0.00%|        # Transforms to a (subclass of) MaskedArray
  1044|         0|            0|            0|  0.00%|        masked_result = result.view(get_masked_subclass(a, b))
  1045|         0|            0|            0|  0.00%|        masked_result._mask = m
  1046|         0|            0|            0|  0.00%|        if isinstance(a, MaskedArray):
  1047|         0|            0|            0|  0.00%|            masked_result._update_from(a)
  1048|         0|            0|            0|  0.00%|        elif isinstance(b, MaskedArray):
  1049|         0|            0|            0|  0.00%|            masked_result._update_from(b)
  1050|         0|            0|            0|  0.00%|        return masked_result
  1051|         0|            0|            0|  0.00%|
  1052|         0|            0|            0|  0.00%|    def reduce(self, target, axis=0, dtype=None):
  1053|         0|            0|            0|  0.00%|        """
  1054|         0|            0|            0|  0.00%|        Reduce `target` along the given `axis`.
  1055|         0|            0|            0|  0.00%|
  1056|         0|            0|            0|  0.00%|        """
  1057|         0|            0|            0|  0.00%|        tclass = get_masked_subclass(target)
  1058|         0|            0|            0|  0.00%|        m = getmask(target)
  1059|         0|            0|            0|  0.00%|        t = filled(target, self.filly)
  1060|         0|            0|            0|  0.00%|        if t.shape == ():
  1061|         0|            0|            0|  0.00%|            t = t.reshape(1)
  1062|         0|            0|            0|  0.00%|            if m is not nomask:
  1063|         0|            0|            0|  0.00%|                m = make_mask(m, copy=1)
  1064|         0|            0|            0|  0.00%|                m.shape = (1,)
  1065|         0|            0|            0|  0.00%|
  1066|         0|            0|            0|  0.00%|        if m is nomask:
  1067|         0|            0|            0|  0.00%|            tr = self.f.reduce(t, axis)
  1068|         0|            0|            0|  0.00%|            mr = nomask
  1069|         0|            0|            0|  0.00%|        else:
  1070|         0|            0|            0|  0.00%|            tr = self.f.reduce(t, axis, dtype=dtype or t.dtype)
  1071|         0|            0|            0|  0.00%|            mr = umath.logical_and.reduce(m, axis)
  1072|         0|            0|            0|  0.00%|
  1073|         0|            0|            0|  0.00%|        if not tr.shape:
  1074|         0|            0|            0|  0.00%|            if mr:
  1075|         0|            0|            0|  0.00%|                return masked
  1076|         0|            0|            0|  0.00%|            else:
  1077|         0|            0|            0|  0.00%|                return tr
  1078|         0|            0|            0|  0.00%|        masked_tr = tr.view(tclass)
  1079|         0|            0|            0|  0.00%|        masked_tr._mask = mr
  1080|         0|            0|            0|  0.00%|        return masked_tr
  1081|         0|            0|            0|  0.00%|
  1082|         0|            0|            0|  0.00%|    def outer(self, a, b):
  1083|         0|            0|            0|  0.00%|        """
  1084|         0|            0|            0|  0.00%|        Return the function applied to the outer product of a and b.
  1085|         0|            0|            0|  0.00%|
  1086|         0|            0|            0|  0.00%|        """
  1087|         0|            0|            0|  0.00%|        (da, db) = (getdata(a), getdata(b))
  1088|         0|            0|            0|  0.00%|        d = self.f.outer(da, db)
  1089|         0|            0|            0|  0.00%|        ma = getmask(a)
  1090|         0|            0|            0|  0.00%|        mb = getmask(b)
  1091|         0|            0|            0|  0.00%|        if ma is nomask and mb is nomask:
  1092|         0|            0|            0|  0.00%|            m = nomask
  1093|         0|            0|            0|  0.00%|        else:
  1094|         0|            0|            0|  0.00%|            ma = getmaskarray(a)
  1095|         0|            0|            0|  0.00%|            mb = getmaskarray(b)
  1096|         0|            0|            0|  0.00%|            m = umath.logical_or.outer(ma, mb)
  1097|         0|            0|            0|  0.00%|        if (not m.ndim) and m:
  1098|         0|            0|            0|  0.00%|            return masked
  1099|         0|            0|            0|  0.00%|        if m is not nomask:
  1100|         0|            0|            0|  0.00%|            np.copyto(d, da, where=m)
  1101|         0|            0|            0|  0.00%|        if not d.shape:
  1102|         0|            0|            0|  0.00%|            return d
  1103|         0|            0|            0|  0.00%|        masked_d = d.view(get_masked_subclass(a, b))
  1104|         0|            0|            0|  0.00%|        masked_d._mask = m
  1105|         0|            0|            0|  0.00%|        return masked_d
  1106|         0|            0|            0|  0.00%|
  1107|         0|            0|            0|  0.00%|    def accumulate(self, target, axis=0):
  1108|         0|            0|            0|  0.00%|        """Accumulate `target` along `axis` after filling with y fill
  1109|         0|            0|            0|  0.00%|        value.
  1110|         0|            0|            0|  0.00%|
  1111|         0|            0|            0|  0.00%|        """
  1112|         0|            0|            0|  0.00%|        tclass = get_masked_subclass(target)
  1113|         0|            0|            0|  0.00%|        t = filled(target, self.filly)
  1114|         0|            0|            0|  0.00%|        result = self.f.accumulate(t, axis)
  1115|         0|            0|            0|  0.00%|        masked_result = result.view(tclass)
  1116|         0|            0|            0|  0.00%|        return masked_result
  1117|         0|            0|            0|  0.00%|
  1118|         0|            0|            0|  0.00%|
  1119|         0|            0|            0|  0.00%|
  1120|         0|            0|            0|  0.00%|class _DomainedBinaryOperation(_MaskedUFunc):
  1121|         0|            0|            0|  0.00%|    """
  1122|         0|            0|            0|  0.00%|    Define binary operations that have a domain, like divide.
  1123|         0|            0|            0|  0.00%|
  1124|         0|            0|            0|  0.00%|    They have no reduce, outer or accumulate.
  1125|         0|            0|            0|  0.00%|
  1126|         0|            0|            0|  0.00%|    Parameters
  1127|         0|            0|            0|  0.00%|    ----------
  1128|         0|            0|            0|  0.00%|    mbfunc : function
  1129|         0|            0|            0|  0.00%|        The function for which to define a masked version. Made available
  1130|         0|            0|            0|  0.00%|        as ``_DomainedBinaryOperation.f``.
  1131|         0|            0|            0|  0.00%|    domain : class instance
  1132|         0|            0|            0|  0.00%|        Default domain for the function. Should be one of the ``_Domain*``
  1133|         0|            0|            0|  0.00%|        classes.
  1134|         0|            0|            0|  0.00%|    fillx : scalar, optional
  1135|         0|            0|            0|  0.00%|        Filling value for the first argument, default is 0.
  1136|         0|            0|            0|  0.00%|    filly : scalar, optional
  1137|         0|            0|            0|  0.00%|        Filling value for the second argument, default is 0.
  1138|         0|            0|            0|  0.00%|
  1139|         0|            0|            0|  0.00%|    """
  1140|         0|            0|            0|  0.00%|
  1141|         0|            0|            0|  0.00%|    def __init__(self, dbfunc, domain, fillx=0, filly=0):
  1142|         0|            0|            0|  0.00%|        """abfunc(fillx, filly) must be defined.
  1143|         0|            0|            0|  0.00%|           abfunc(x, filly) = x for all x to enable reduce.
  1144|         0|            0|            0|  0.00%|        """
  1145|         0|            0|            0|  0.00%|        super(_DomainedBinaryOperation, self).__init__(dbfunc)
  1146|         0|            0|            0|  0.00%|        self.domain = domain
  1147|         0|            0|            0|  0.00%|        self.fillx = fillx
  1148|         0|            0|            0|  0.00%|        self.filly = filly
  1149|         0|            0|            0|  0.00%|        ufunc_domain[dbfunc] = domain
  1150|         0|            0|            0|  0.00%|        ufunc_fills[dbfunc] = (fillx, filly)
  1151|         0|            0|            0|  0.00%|
  1152|         0|            0|            0|  0.00%|    def __call__(self, a, b, *args, **kwargs):
  1153|         0|            0|            0|  0.00%|        "Execute the call behavior."
  1154|         0|            0|            0|  0.00%|        # Get the data
  1155|         0|            0|            0|  0.00%|        (da, db) = (getdata(a), getdata(b))
  1156|         0|            0|            0|  0.00%|        # Get the result
  1157|         0|            0|            0|  0.00%|        with np.errstate(divide='ignore', invalid='ignore'):
  1158|         0|            0|            0|  0.00%|            result = self.f(da, db, *args, **kwargs)
  1159|         0|            0|            0|  0.00%|        # Get the mask as a combination of the source masks and invalid
  1160|         0|            0|            0|  0.00%|        m = ~umath.isfinite(result)
  1161|         0|            0|            0|  0.00%|        m |= getmask(a)
  1162|         0|            0|            0|  0.00%|        m |= getmask(b)
  1163|         0|            0|            0|  0.00%|        # Apply the domain
  1164|         0|            0|            0|  0.00%|        domain = ufunc_domain.get(self.f, None)
  1165|         0|            0|            0|  0.00%|        if domain is not None:
  1166|         0|            0|            0|  0.00%|            m |= domain(da, db)
  1167|         0|            0|            0|  0.00%|        # Take care of the scalar case first
  1168|         0|            0|            0|  0.00%|        if (not m.ndim):
  1169|         0|            0|            0|  0.00%|            if m:
  1170|         0|            0|            0|  0.00%|                return masked
  1171|         0|            0|            0|  0.00%|            else:
  1172|         0|            0|            0|  0.00%|                return result
  1173|         0|            0|            0|  0.00%|        # When the mask is True, put back da if possible
  1174|         0|            0|            0|  0.00%|        # any errors, just abort; impossible to guarantee masked values
  1175|         0|            0|            0|  0.00%|        try:
  1176|         0|            0|            0|  0.00%|            np.copyto(result, 0, casting='unsafe', where=m)
  1177|         0|            0|            0|  0.00%|            # avoid using "*" since this may be overlaid
  1178|         0|            0|            0|  0.00%|            masked_da = umath.multiply(m, da)
  1179|         0|            0|            0|  0.00%|            # only add back if it can be cast safely
  1180|         0|            0|            0|  0.00%|            if np.can_cast(masked_da.dtype, result.dtype, casting='safe'):
  1181|         0|            0|            0|  0.00%|                result += masked_da
  1182|         0|            0|            0|  0.00%|        except Exception:
  1183|         0|            0|            0|  0.00%|            pass
  1184|         0|            0|            0|  0.00%|
  1185|         0|            0|            0|  0.00%|        # Transforms to a (subclass of) MaskedArray
  1186|         0|            0|            0|  0.00%|        masked_result = result.view(get_masked_subclass(a, b))
  1187|         0|            0|            0|  0.00%|        masked_result._mask = m
  1188|         0|            0|            0|  0.00%|        if isinstance(a, MaskedArray):
  1189|         0|            0|            0|  0.00%|            masked_result._update_from(a)
  1190|         0|            0|            0|  0.00%|        elif isinstance(b, MaskedArray):
  1191|         0|            0|            0|  0.00%|            masked_result._update_from(b)
  1192|         0|            0|            0|  0.00%|        return masked_result
  1193|         0|            0|            0|  0.00%|
  1194|         0|            0|            0|  0.00%|
  1195|         0|            0|            0|  0.00%|# Unary ufuncs
  1196|         0|            0|            0|  0.00%|exp = _MaskedUnaryOperation(umath.exp)
  1197|         0|            0|            0|  0.00%|conjugate = _MaskedUnaryOperation(umath.conjugate)
  1198|         0|            0|            0|  0.00%|sin = _MaskedUnaryOperation(umath.sin)
  1199|         0|            0|            0|  0.00%|cos = _MaskedUnaryOperation(umath.cos)
  1200|         0|            0|            0|  0.00%|arctan = _MaskedUnaryOperation(umath.arctan)
  1201|         0|            0|            0|  0.00%|arcsinh = _MaskedUnaryOperation(umath.arcsinh)
  1202|         0|            0|            0|  0.00%|sinh = _MaskedUnaryOperation(umath.sinh)
  1203|         0|            0|            0|  0.00%|cosh = _MaskedUnaryOperation(umath.cosh)
  1204|         0|            0|            0|  0.00%|tanh = _MaskedUnaryOperation(umath.tanh)
  1205|         0|            0|            0|  0.00%|abs = absolute = _MaskedUnaryOperation(umath.absolute)
  1206|         0|            0|            0|  0.00%|angle = _MaskedUnaryOperation(angle)  # from numpy.lib.function_base
  1207|         0|            0|            0|  0.00%|fabs = _MaskedUnaryOperation(umath.fabs)
  1208|         0|            0|            0|  0.00%|negative = _MaskedUnaryOperation(umath.negative)
  1209|         0|            0|            0|  0.00%|floor = _MaskedUnaryOperation(umath.floor)
  1210|         0|            0|            0|  0.00%|ceil = _MaskedUnaryOperation(umath.ceil)
  1211|         0|            0|            0|  0.00%|around = _MaskedUnaryOperation(np.round_)
  1212|         0|            0|            0|  0.00%|logical_not = _MaskedUnaryOperation(umath.logical_not)
  1213|         0|            0|            0|  0.00%|
  1214|         0|            0|            0|  0.00%|# Domained unary ufuncs
  1215|         0|            0|            0|  0.00%|sqrt = _MaskedUnaryOperation(umath.sqrt, 0.0,
  1216|         0|            0|            0|  0.00%|                             _DomainGreaterEqual(0.0))
  1217|         0|            0|            0|  0.00%|log = _MaskedUnaryOperation(umath.log, 1.0,
  1218|         0|            0|            0|  0.00%|                            _DomainGreater(0.0))
  1219|         0|            0|            0|  0.00%|log2 = _MaskedUnaryOperation(umath.log2, 1.0,
  1220|         0|            0|            0|  0.00%|                             _DomainGreater(0.0))
  1221|         0|            0|            0|  0.00%|log10 = _MaskedUnaryOperation(umath.log10, 1.0,
  1222|         0|            0|            0|  0.00%|                              _DomainGreater(0.0))
  1223|         0|            0|            0|  0.00%|tan = _MaskedUnaryOperation(umath.tan, 0.0,
  1224|         0|            0|            0|  0.00%|                            _DomainTan(1e-35))
  1225|         0|            0|            0|  0.00%|arcsin = _MaskedUnaryOperation(umath.arcsin, 0.0,
  1226|         0|            0|            0|  0.00%|                               _DomainCheckInterval(-1.0, 1.0))
  1227|         0|            0|            0|  0.00%|arccos = _MaskedUnaryOperation(umath.arccos, 0.0,
  1228|         0|            0|            0|  0.00%|                               _DomainCheckInterval(-1.0, 1.0))
  1229|         0|            0|            0|  0.00%|arccosh = _MaskedUnaryOperation(umath.arccosh, 1.0,
  1230|         0|            0|            0|  0.00%|                                _DomainGreaterEqual(1.0))
  1231|         0|            0|            0|  0.00%|arctanh = _MaskedUnaryOperation(umath.arctanh, 0.0,
  1232|         0|            0|            0|  0.00%|                                _DomainCheckInterval(-1.0 + 1e-15, 1.0 - 1e-15))
  1233|         0|            0|            0|  0.00%|
  1234|         0|            0|            0|  0.00%|# Binary ufuncs
  1235|         0|            0|            0|  0.00%|add = _MaskedBinaryOperation(umath.add)
  1236|         0|            0|            0|  0.00%|subtract = _MaskedBinaryOperation(umath.subtract)
  1237|         0|            0|            0|  0.00%|multiply = _MaskedBinaryOperation(umath.multiply, 1, 1)
  1238|         0|            0|            0|  0.00%|arctan2 = _MaskedBinaryOperation(umath.arctan2, 0.0, 1.0)
  1239|         0|            0|            0|  0.00%|equal = _MaskedBinaryOperation(umath.equal)
  1240|         0|            0|            0|  0.00%|equal.reduce = None
  1241|         0|            0|            0|  0.00%|not_equal = _MaskedBinaryOperation(umath.not_equal)
  1242|         0|            0|            0|  0.00%|not_equal.reduce = None
  1243|         0|            0|            0|  0.00%|less_equal = _MaskedBinaryOperation(umath.less_equal)
  1244|         0|            0|            0|  0.00%|less_equal.reduce = None
  1245|         0|            0|            0|  0.00%|greater_equal = _MaskedBinaryOperation(umath.greater_equal)
  1246|         0|            0|            0|  0.00%|greater_equal.reduce = None
  1247|         0|            0|            0|  0.00%|less = _MaskedBinaryOperation(umath.less)
  1248|         0|            0|            0|  0.00%|less.reduce = None
  1249|         0|            0|            0|  0.00%|greater = _MaskedBinaryOperation(umath.greater)
  1250|         0|            0|            0|  0.00%|greater.reduce = None
  1251|         0|            0|            0|  0.00%|logical_and = _MaskedBinaryOperation(umath.logical_and)
  1252|         0|            0|            0|  0.00%|alltrue = _MaskedBinaryOperation(umath.logical_and, 1, 1).reduce
  1253|         0|            0|            0|  0.00%|logical_or = _MaskedBinaryOperation(umath.logical_or)
  1254|         0|            0|            0|  0.00%|sometrue = logical_or.reduce
  1255|         0|            0|            0|  0.00%|logical_xor = _MaskedBinaryOperation(umath.logical_xor)
  1256|         0|            0|            0|  0.00%|bitwise_and = _MaskedBinaryOperation(umath.bitwise_and)
  1257|         0|            0|            0|  0.00%|bitwise_or = _MaskedBinaryOperation(umath.bitwise_or)
  1258|         0|            0|            0|  0.00%|bitwise_xor = _MaskedBinaryOperation(umath.bitwise_xor)
  1259|         0|            0|            0|  0.00%|hypot = _MaskedBinaryOperation(umath.hypot)
  1260|         0|            0|            0|  0.00%|
  1261|         0|            0|            0|  0.00%|# Domained binary ufuncs
  1262|         0|            0|            0|  0.00%|divide = _DomainedBinaryOperation(umath.divide, _DomainSafeDivide(), 0, 1)
  1263|         0|            0|            0|  0.00%|true_divide = _DomainedBinaryOperation(umath.true_divide,
  1264|         0|            0|            0|  0.00%|                                       _DomainSafeDivide(), 0, 1)
  1265|         0|            0|            0|  0.00%|floor_divide = _DomainedBinaryOperation(umath.floor_divide,
  1266|         0|            0|            0|  0.00%|                                        _DomainSafeDivide(), 0, 1)
  1267|         0|            0|            0|  0.00%|remainder = _DomainedBinaryOperation(umath.remainder,
  1268|         0|            0|            0|  0.00%|                                     _DomainSafeDivide(), 0, 1)
  1269|         0|            0|            0|  0.00%|fmod = _DomainedBinaryOperation(umath.fmod, _DomainSafeDivide(), 0, 1)
  1270|         0|            0|            0|  0.00%|mod = _DomainedBinaryOperation(umath.mod, _DomainSafeDivide(), 0, 1)
  1271|         0|            0|            0|  0.00%|
  1272|         0|            0|            0|  0.00%|
  1273|         0|            0|            0|  0.00%|###############################################################################
  1274|         0|            0|            0|  0.00%|#                        Mask creation functions                              #
  1275|         0|            0|            0|  0.00%|###############################################################################
  1276|         0|            0|            0|  0.00%|
  1277|         0|            0|            0|  0.00%|
  1278|         0|            0|            0|  0.00%|def _replace_dtype_fields_recursive(dtype, primitive_dtype):
  1279|         0|            0|            0|  0.00%|    "Private function allowing recursion in _replace_dtype_fields."
  1280|         0|            0|            0|  0.00%|    _recurse = _replace_dtype_fields_recursive
  1281|         0|            0|            0|  0.00%|
  1282|         0|            0|            0|  0.00%|    # Do we have some name fields ?
  1283|         0|            0|            0|  0.00%|    if dtype.names is not None:
  1284|         0|            0|            0|  0.00%|        descr = []
  1285|         0|            0|            0|  0.00%|        for name in dtype.names:
  1286|         0|            0|            0|  0.00%|            field = dtype.fields[name]
  1287|         0|            0|            0|  0.00%|            if len(field) == 3:
  1288|         0|            0|            0|  0.00%|                # Prepend the title to the name
  1289|         0|            0|            0|  0.00%|                name = (field[-1], name)
  1290|         0|            0|            0|  0.00%|            descr.append((name, _recurse(field[0], primitive_dtype)))
  1291|         0|            0|            0|  0.00%|        new_dtype = np.dtype(descr)
  1292|         0|            0|            0|  0.00%|
  1293|         0|            0|            0|  0.00%|    # Is this some kind of composite a la (float,2)
  1294|         0|            0|            0|  0.00%|    elif dtype.subdtype:
  1295|         0|            0|            0|  0.00%|        descr = list(dtype.subdtype)
  1296|         0|            0|            0|  0.00%|        descr[0] = _recurse(dtype.subdtype[0], primitive_dtype)
  1297|         0|            0|            0|  0.00%|        new_dtype = np.dtype(tuple(descr))
  1298|         0|            0|            0|  0.00%|
  1299|         0|            0|            0|  0.00%|    # this is a primitive type, so do a direct replacement
  1300|         0|            0|            0|  0.00%|    else:
  1301|         0|            0|            0|  0.00%|        new_dtype = primitive_dtype
  1302|         0|            0|            0|  0.00%|
  1303|         0|            0|            0|  0.00%|    # preserve identity of dtypes
  1304|         0|            0|            0|  0.00%|    if new_dtype == dtype:
  1305|         0|            0|            0|  0.00%|        new_dtype = dtype
  1306|         0|            0|            0|  0.00%|
  1307|         0|            0|            0|  0.00%|    return new_dtype
  1308|         0|            0|            0|  0.00%|
  1309|         0|            0|            0|  0.00%|
  1310|         0|            0|            0|  0.00%|def _replace_dtype_fields(dtype, primitive_dtype):
  1311|         0|            0|            0|  0.00%|    """
  1312|         0|            0|            0|  0.00%|    Construct a dtype description list from a given dtype.
  1313|         0|            0|            0|  0.00%|
  1314|         0|            0|            0|  0.00%|    Returns a new dtype object, with all fields and subtypes in the given type
  1315|         0|            0|            0|  0.00%|    recursively replaced with `primitive_dtype`.
  1316|         0|            0|            0|  0.00%|
  1317|         0|            0|            0|  0.00%|    Arguments are coerced to dtypes first.
  1318|         0|            0|            0|  0.00%|    """
  1319|         0|            0|            0|  0.00%|    dtype = np.dtype(dtype)
  1320|         0|            0|            0|  0.00%|    primitive_dtype = np.dtype(primitive_dtype)
  1321|         0|            0|            0|  0.00%|    return _replace_dtype_fields_recursive(dtype, primitive_dtype)
  1322|         0|            0|            0|  0.00%|
  1323|         0|            0|            0|  0.00%|
  1324|         0|            0|            0|  0.00%|def make_mask_descr(ndtype):
  1325|         0|            0|            0|  0.00%|    """
  1326|         0|            0|            0|  0.00%|    Construct a dtype description list from a given dtype.
  1327|         0|            0|            0|  0.00%|
  1328|         0|            0|            0|  0.00%|    Returns a new dtype object, with the type of all fields in `ndtype` to a
  1329|         0|            0|            0|  0.00%|    boolean type. Field names are not altered.
  1330|         0|            0|            0|  0.00%|
  1331|         0|            0|            0|  0.00%|    Parameters
  1332|         0|            0|            0|  0.00%|    ----------
  1333|         0|            0|            0|  0.00%|    ndtype : dtype
  1334|         0|            0|            0|  0.00%|        The dtype to convert.
  1335|         0|            0|            0|  0.00%|
  1336|         0|            0|            0|  0.00%|    Returns
  1337|         0|            0|            0|  0.00%|    -------
  1338|         0|            0|            0|  0.00%|    result : dtype
  1339|         0|            0|            0|  0.00%|        A dtype that looks like `ndtype`, the type of all fields is boolean.
  1340|         0|            0|            0|  0.00%|
  1341|         0|            0|            0|  0.00%|    Examples
  1342|         0|            0|            0|  0.00%|    --------
  1343|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1344|         0|            0|            0|  0.00%|    >>> dtype = np.dtype({'names':['foo', 'bar'],
  1345|         0|            0|            0|  0.00%|    ...                   'formats':[np.float32, np.int64]})
  1346|         0|            0|            0|  0.00%|    >>> dtype
  1347|         0|            0|            0|  0.00%|    dtype([('foo', '<f4'), ('bar', '<i8')])
  1348|         0|            0|            0|  0.00%|    >>> ma.make_mask_descr(dtype)
  1349|         0|            0|            0|  0.00%|    dtype([('foo', '|b1'), ('bar', '|b1')])
  1350|         0|            0|            0|  0.00%|    >>> ma.make_mask_descr(np.float32)
  1351|         0|            0|            0|  0.00%|    dtype('bool')
  1352|         0|            0|            0|  0.00%|
  1353|         0|            0|            0|  0.00%|    """
  1354|         0|            0|            0|  0.00%|    return _replace_dtype_fields(ndtype, MaskType)
  1355|         0|            0|            0|  0.00%|
  1356|         0|            0|            0|  0.00%|
  1357|         0|            0|            0|  0.00%|def getmask(a):
  1358|         0|            0|            0|  0.00%|    """
  1359|         0|            0|            0|  0.00%|    Return the mask of a masked array, or nomask.
  1360|         0|            0|            0|  0.00%|
  1361|         0|            0|            0|  0.00%|    Return the mask of `a` as an ndarray if `a` is a `MaskedArray` and the
  1362|         0|            0|            0|  0.00%|    mask is not `nomask`, else return `nomask`. To guarantee a full array
  1363|         0|            0|            0|  0.00%|    of booleans of the same shape as a, use `getmaskarray`.
  1364|         0|            0|            0|  0.00%|
  1365|         0|            0|            0|  0.00%|    Parameters
  1366|         0|            0|            0|  0.00%|    ----------
  1367|         0|            0|            0|  0.00%|    a : array_like
  1368|         0|            0|            0|  0.00%|        Input `MaskedArray` for which the mask is required.
  1369|         0|            0|            0|  0.00%|
  1370|         0|            0|            0|  0.00%|    See Also
  1371|         0|            0|            0|  0.00%|    --------
  1372|         0|            0|            0|  0.00%|    getdata : Return the data of a masked array as an ndarray.
  1373|         0|            0|            0|  0.00%|    getmaskarray : Return the mask of a masked array, or full array of False.
  1374|         0|            0|            0|  0.00%|
  1375|         0|            0|            0|  0.00%|    Examples
  1376|         0|            0|            0|  0.00%|    --------
  1377|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1378|         0|            0|            0|  0.00%|    >>> a = ma.masked_equal([[1,2],[3,4]], 2)
  1379|         0|            0|            0|  0.00%|    >>> a
  1380|         0|            0|            0|  0.00%|    masked_array(
  1381|         0|            0|            0|  0.00%|      data=[[1, --],
  1382|         0|            0|            0|  0.00%|            [3, 4]],
  1383|         0|            0|            0|  0.00%|      mask=[[False,  True],
  1384|         0|            0|            0|  0.00%|            [False, False]],
  1385|         0|            0|            0|  0.00%|      fill_value=2)
  1386|         0|            0|            0|  0.00%|    >>> ma.getmask(a)
  1387|         0|            0|            0|  0.00%|    array([[False,  True],
  1388|         0|            0|            0|  0.00%|           [False, False]])
  1389|         0|            0|            0|  0.00%|
  1390|         0|            0|            0|  0.00%|    Equivalently use the `MaskedArray` `mask` attribute.
  1391|         0|            0|            0|  0.00%|
  1392|         0|            0|            0|  0.00%|    >>> a.mask
  1393|         0|            0|            0|  0.00%|    array([[False,  True],
  1394|         0|            0|            0|  0.00%|           [False, False]])
  1395|         0|            0|            0|  0.00%|
  1396|         0|            0|            0|  0.00%|    Result when mask == `nomask`
  1397|         0|            0|            0|  0.00%|
  1398|         0|            0|            0|  0.00%|    >>> b = ma.masked_array([[1,2],[3,4]])
  1399|         0|            0|            0|  0.00%|    >>> b
  1400|         0|            0|            0|  0.00%|    masked_array(
  1401|         0|            0|            0|  0.00%|      data=[[1, 2],
  1402|         0|            0|            0|  0.00%|            [3, 4]],
  1403|         0|            0|            0|  0.00%|      mask=False,
  1404|         0|            0|            0|  0.00%|      fill_value=999999)
  1405|         0|            0|            0|  0.00%|    >>> ma.nomask
  1406|         0|            0|            0|  0.00%|    False
  1407|         0|            0|            0|  0.00%|    >>> ma.getmask(b) == ma.nomask
  1408|         0|            0|            0|  0.00%|    True
  1409|         0|            0|            0|  0.00%|    >>> b.mask == ma.nomask
  1410|         0|            0|            0|  0.00%|    True
  1411|         0|            0|            0|  0.00%|
  1412|         0|            0|            0|  0.00%|    """
  1413|         0|            0|            0|  0.00%|    return getattr(a, '_mask', nomask)
  1414|         0|            0|            0|  0.00%|
  1415|         0|            0|            0|  0.00%|
  1416|         0|            0|            0|  0.00%|get_mask = getmask
  1417|         0|            0|            0|  0.00%|
  1418|         0|            0|            0|  0.00%|
  1419|         0|            0|            0|  0.00%|def getmaskarray(arr):
  1420|         0|            0|            0|  0.00%|    """
  1421|         0|            0|            0|  0.00%|    Return the mask of a masked array, or full boolean array of False.
  1422|         0|            0|            0|  0.00%|
  1423|         0|            0|            0|  0.00%|    Return the mask of `arr` as an ndarray if `arr` is a `MaskedArray` and
  1424|         0|            0|            0|  0.00%|    the mask is not `nomask`, else return a full boolean array of False of
  1425|         0|            0|            0|  0.00%|    the same shape as `arr`.
  1426|         0|            0|            0|  0.00%|
  1427|         0|            0|            0|  0.00%|    Parameters
  1428|         0|            0|            0|  0.00%|    ----------
  1429|         0|            0|            0|  0.00%|    arr : array_like
  1430|         0|            0|            0|  0.00%|        Input `MaskedArray` for which the mask is required.
  1431|         0|            0|            0|  0.00%|
  1432|         0|            0|            0|  0.00%|    See Also
  1433|         0|            0|            0|  0.00%|    --------
  1434|         0|            0|            0|  0.00%|    getmask : Return the mask of a masked array, or nomask.
  1435|         0|            0|            0|  0.00%|    getdata : Return the data of a masked array as an ndarray.
  1436|         0|            0|            0|  0.00%|
  1437|         0|            0|            0|  0.00%|    Examples
  1438|         0|            0|            0|  0.00%|    --------
  1439|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1440|         0|            0|            0|  0.00%|    >>> a = ma.masked_equal([[1,2],[3,4]], 2)
  1441|         0|            0|            0|  0.00%|    >>> a
  1442|         0|            0|            0|  0.00%|    masked_array(
  1443|         0|            0|            0|  0.00%|      data=[[1, --],
  1444|         0|            0|            0|  0.00%|            [3, 4]],
  1445|         0|            0|            0|  0.00%|      mask=[[False,  True],
  1446|         0|            0|            0|  0.00%|            [False, False]],
  1447|         0|            0|            0|  0.00%|      fill_value=2)
  1448|         0|            0|            0|  0.00%|    >>> ma.getmaskarray(a)
  1449|         0|            0|            0|  0.00%|    array([[False,  True],
  1450|         0|            0|            0|  0.00%|           [False, False]])
  1451|         0|            0|            0|  0.00%|
  1452|         0|            0|            0|  0.00%|    Result when mask == ``nomask``
  1453|         0|            0|            0|  0.00%|
  1454|         0|            0|            0|  0.00%|    >>> b = ma.masked_array([[1,2],[3,4]])
  1455|         0|            0|            0|  0.00%|    >>> b
  1456|         0|            0|            0|  0.00%|    masked_array(
  1457|         0|            0|            0|  0.00%|      data=[[1, 2],
  1458|         0|            0|            0|  0.00%|            [3, 4]],
  1459|         0|            0|            0|  0.00%|      mask=False,
  1460|         0|            0|            0|  0.00%|      fill_value=999999)
  1461|         0|            0|            0|  0.00%|    >>> ma.getmaskarray(b)
  1462|         0|            0|            0|  0.00%|    array([[False, False],
  1463|         0|            0|            0|  0.00%|           [False, False]])
  1464|         0|            0|            0|  0.00%|
  1465|         0|            0|            0|  0.00%|    """
  1466|         0|            0|            0|  0.00%|    mask = getmask(arr)
  1467|         0|            0|            0|  0.00%|    if mask is nomask:
  1468|         0|            0|            0|  0.00%|        mask = make_mask_none(np.shape(arr), getattr(arr, 'dtype', None))
  1469|         0|            0|            0|  0.00%|    return mask
  1470|         0|            0|            0|  0.00%|
  1471|         0|            0|            0|  0.00%|
  1472|         0|            0|            0|  0.00%|def is_mask(m):
  1473|         0|            0|            0|  0.00%|    """
  1474|         0|            0|            0|  0.00%|    Return True if m is a valid, standard mask.
  1475|         0|            0|            0|  0.00%|
  1476|         0|            0|            0|  0.00%|    This function does not check the contents of the input, only that the
  1477|         0|            0|            0|  0.00%|    type is MaskType. In particular, this function returns False if the
  1478|         0|            0|            0|  0.00%|    mask has a flexible dtype.
  1479|         0|            0|            0|  0.00%|
  1480|         0|            0|            0|  0.00%|    Parameters
  1481|         0|            0|            0|  0.00%|    ----------
  1482|         0|            0|            0|  0.00%|    m : array_like
  1483|         0|            0|            0|  0.00%|        Array to test.
  1484|         0|            0|            0|  0.00%|
  1485|         0|            0|            0|  0.00%|    Returns
  1486|         0|            0|            0|  0.00%|    -------
  1487|         0|            0|            0|  0.00%|    result : bool
  1488|         0|            0|            0|  0.00%|        True if `m.dtype.type` is MaskType, False otherwise.
  1489|         0|            0|            0|  0.00%|
  1490|         0|            0|            0|  0.00%|    See Also
  1491|         0|            0|            0|  0.00%|    --------
  1492|         0|            0|            0|  0.00%|    isMaskedArray : Test whether input is an instance of MaskedArray.
  1493|         0|            0|            0|  0.00%|
  1494|         0|            0|            0|  0.00%|    Examples
  1495|         0|            0|            0|  0.00%|    --------
  1496|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1497|         0|            0|            0|  0.00%|    >>> m = ma.masked_equal([0, 1, 0, 2, 3], 0)
  1498|         0|            0|            0|  0.00%|    >>> m
  1499|         0|            0|            0|  0.00%|    masked_array(data=[--, 1, --, 2, 3],
  1500|         0|            0|            0|  0.00%|                 mask=[ True, False,  True, False, False],
  1501|         0|            0|            0|  0.00%|           fill_value=0)
  1502|         0|            0|            0|  0.00%|    >>> ma.is_mask(m)
  1503|         0|            0|            0|  0.00%|    False
  1504|         0|            0|            0|  0.00%|    >>> ma.is_mask(m.mask)
  1505|         0|            0|            0|  0.00%|    True
  1506|         0|            0|            0|  0.00%|
  1507|         0|            0|            0|  0.00%|    Input must be an ndarray (or have similar attributes)
  1508|         0|            0|            0|  0.00%|    for it to be considered a valid mask.
  1509|         0|            0|            0|  0.00%|
  1510|         0|            0|            0|  0.00%|    >>> m = [False, True, False]
  1511|         0|            0|            0|  0.00%|    >>> ma.is_mask(m)
  1512|         0|            0|            0|  0.00%|    False
  1513|         0|            0|            0|  0.00%|    >>> m = np.array([False, True, False])
  1514|         0|            0|            0|  0.00%|    >>> m
  1515|         0|            0|            0|  0.00%|    array([False,  True, False])
  1516|         0|            0|            0|  0.00%|    >>> ma.is_mask(m)
  1517|         0|            0|            0|  0.00%|    True
  1518|         0|            0|            0|  0.00%|
  1519|         0|            0|            0|  0.00%|    Arrays with complex dtypes don't return True.
  1520|         0|            0|            0|  0.00%|
  1521|         0|            0|            0|  0.00%|    >>> dtype = np.dtype({'names':['monty', 'pithon'],
  1522|         0|            0|            0|  0.00%|    ...                   'formats':[bool, bool]})
  1523|         0|            0|            0|  0.00%|    >>> dtype
  1524|         0|            0|            0|  0.00%|    dtype([('monty', '|b1'), ('pithon', '|b1')])
  1525|         0|            0|            0|  0.00%|    >>> m = np.array([(True, False), (False, True), (True, False)],
  1526|         0|            0|            0|  0.00%|    ...              dtype=dtype)
  1527|         0|            0|            0|  0.00%|    >>> m
  1528|         0|            0|            0|  0.00%|    array([( True, False), (False,  True), ( True, False)],
  1529|         0|            0|            0|  0.00%|          dtype=[('monty', '?'), ('pithon', '?')])
  1530|         0|            0|            0|  0.00%|    >>> ma.is_mask(m)
  1531|         0|            0|            0|  0.00%|    False
  1532|         0|            0|            0|  0.00%|
  1533|         0|            0|            0|  0.00%|    """
  1534|         0|            0|            0|  0.00%|    try:
  1535|         0|            0|            0|  0.00%|        return m.dtype.type is MaskType
  1536|         0|            0|            0|  0.00%|    except AttributeError:
  1537|         0|            0|            0|  0.00%|        return False
  1538|         0|            0|            0|  0.00%|
  1539|         0|            0|            0|  0.00%|
  1540|         0|            0|            0|  0.00%|def _shrink_mask(m):
  1541|         0|            0|            0|  0.00%|    """
  1542|         0|            0|            0|  0.00%|    Shrink a mask to nomask if possible
  1543|         0|            0|            0|  0.00%|    """
  1544|         0|            0|            0|  0.00%|    if m.dtype.names is None and not m.any():
  1545|         0|            0|            0|  0.00%|        return nomask
  1546|         0|            0|            0|  0.00%|    else:
  1547|         0|            0|            0|  0.00%|        return m
  1548|         0|            0|            0|  0.00%|
  1549|         0|            0|            0|  0.00%|
  1550|         0|            0|            0|  0.00%|def make_mask(m, copy=False, shrink=True, dtype=MaskType):
  1551|         0|            0|            0|  0.00%|    """
  1552|         0|            0|            0|  0.00%|    Create a boolean mask from an array.
  1553|         0|            0|            0|  0.00%|
  1554|         0|            0|            0|  0.00%|    Return `m` as a boolean mask, creating a copy if necessary or requested.
  1555|         0|            0|            0|  0.00%|    The function can accept any sequence that is convertible to integers,
  1556|         0|            0|            0|  0.00%|    or ``nomask``.  Does not require that contents must be 0s and 1s, values
  1557|         0|            0|            0|  0.00%|    of 0 are interepreted as False, everything else as True.
  1558|         0|            0|            0|  0.00%|
  1559|         0|            0|            0|  0.00%|    Parameters
  1560|         0|            0|            0|  0.00%|    ----------
  1561|         0|            0|            0|  0.00%|    m : array_like
  1562|         0|            0|            0|  0.00%|        Potential mask.
  1563|         0|            0|            0|  0.00%|    copy : bool, optional
  1564|         0|            0|            0|  0.00%|        Whether to return a copy of `m` (True) or `m` itself (False).
  1565|         0|            0|            0|  0.00%|    shrink : bool, optional
  1566|         0|            0|            0|  0.00%|        Whether to shrink `m` to ``nomask`` if all its values are False.
  1567|         0|            0|            0|  0.00%|    dtype : dtype, optional
  1568|         0|            0|            0|  0.00%|        Data-type of the output mask. By default, the output mask has a
  1569|         0|            0|            0|  0.00%|        dtype of MaskType (bool). If the dtype is flexible, each field has
  1570|         0|            0|            0|  0.00%|        a boolean dtype. This is ignored when `m` is ``nomask``, in which
  1571|         0|            0|            0|  0.00%|        case ``nomask`` is always returned.
  1572|         0|            0|            0|  0.00%|
  1573|         0|            0|            0|  0.00%|    Returns
  1574|         0|            0|            0|  0.00%|    -------
  1575|         0|            0|            0|  0.00%|    result : ndarray
  1576|         0|            0|            0|  0.00%|        A boolean mask derived from `m`.
  1577|         0|            0|            0|  0.00%|
  1578|         0|            0|            0|  0.00%|    Examples
  1579|         0|            0|            0|  0.00%|    --------
  1580|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1581|         0|            0|            0|  0.00%|    >>> m = [True, False, True, True]
  1582|         0|            0|            0|  0.00%|    >>> ma.make_mask(m)
  1583|         0|            0|            0|  0.00%|    array([ True, False,  True,  True])
  1584|         0|            0|            0|  0.00%|    >>> m = [1, 0, 1, 1]
  1585|         0|            0|            0|  0.00%|    >>> ma.make_mask(m)
  1586|         0|            0|            0|  0.00%|    array([ True, False,  True,  True])
  1587|         0|            0|            0|  0.00%|    >>> m = [1, 0, 2, -3]
  1588|         0|            0|            0|  0.00%|    >>> ma.make_mask(m)
  1589|         0|            0|            0|  0.00%|    array([ True, False,  True,  True])
  1590|         0|            0|            0|  0.00%|
  1591|         0|            0|            0|  0.00%|    Effect of the `shrink` parameter.
  1592|         0|            0|            0|  0.00%|
  1593|         0|            0|            0|  0.00%|    >>> m = np.zeros(4)
  1594|         0|            0|            0|  0.00%|    >>> m
  1595|         0|            0|            0|  0.00%|    array([0., 0., 0., 0.])
  1596|         0|            0|            0|  0.00%|    >>> ma.make_mask(m)
  1597|         0|            0|            0|  0.00%|    False
  1598|         0|            0|            0|  0.00%|    >>> ma.make_mask(m, shrink=False)
  1599|         0|            0|            0|  0.00%|    array([False, False, False, False])
  1600|         0|            0|            0|  0.00%|
  1601|         0|            0|            0|  0.00%|    Using a flexible `dtype`.
  1602|         0|            0|            0|  0.00%|
  1603|         0|            0|            0|  0.00%|    >>> m = [1, 0, 1, 1]
  1604|         0|            0|            0|  0.00%|    >>> n = [0, 1, 0, 0]
  1605|         0|            0|            0|  0.00%|    >>> arr = []
  1606|         0|            0|            0|  0.00%|    >>> for man, mouse in zip(m, n):
  1607|         0|            0|            0|  0.00%|    ...     arr.append((man, mouse))
  1608|         0|            0|            0|  0.00%|    >>> arr
  1609|         0|            0|            0|  0.00%|    [(1, 0), (0, 1), (1, 0), (1, 0)]
  1610|         0|            0|            0|  0.00%|    >>> dtype = np.dtype({'names':['man', 'mouse'],
  1611|         0|            0|            0|  0.00%|    ...                   'formats':[np.int64, np.int64]})
  1612|         0|            0|            0|  0.00%|    >>> arr = np.array(arr, dtype=dtype)
  1613|         0|            0|            0|  0.00%|    >>> arr
  1614|         0|            0|            0|  0.00%|    array([(1, 0), (0, 1), (1, 0), (1, 0)],
  1615|         0|            0|            0|  0.00%|          dtype=[('man', '<i8'), ('mouse', '<i8')])
  1616|         0|            0|            0|  0.00%|    >>> ma.make_mask(arr, dtype=dtype)
  1617|         0|            0|            0|  0.00%|    array([(True, False), (False, True), (True, False), (True, False)],
  1618|         0|            0|            0|  0.00%|          dtype=[('man', '|b1'), ('mouse', '|b1')])
  1619|         0|            0|            0|  0.00%|
  1620|         0|            0|            0|  0.00%|    """
  1621|         0|            0|            0|  0.00%|    if m is nomask:
  1622|         0|            0|            0|  0.00%|        return nomask
  1623|         0|            0|            0|  0.00%|
  1624|         0|            0|            0|  0.00%|    # Make sure the input dtype is valid.
  1625|         0|            0|            0|  0.00%|    dtype = make_mask_descr(dtype)
  1626|         0|            0|            0|  0.00%|
  1627|         0|            0|            0|  0.00%|    # legacy boolean special case: "existence of fields implies true"
  1628|         0|            0|            0|  0.00%|    if isinstance(m, ndarray) and m.dtype.fields and dtype == np.bool_:
  1629|         0|            0|            0|  0.00%|        return np.ones(m.shape, dtype=dtype)
  1630|         0|            0|            0|  0.00%|
  1631|         0|            0|            0|  0.00%|    # Fill the mask in case there are missing data; turn it into an ndarray.
  1632|         0|            0|            0|  0.00%|    result = np.array(filled(m, True), copy=copy, dtype=dtype, subok=True)
  1633|         0|            0|            0|  0.00%|    # Bas les masques !
  1634|         0|            0|            0|  0.00%|    if shrink:
  1635|         0|            0|            0|  0.00%|        result = _shrink_mask(result)
  1636|         0|            0|            0|  0.00%|    return result
  1637|         0|            0|            0|  0.00%|
  1638|         0|            0|            0|  0.00%|
  1639|         0|            0|            0|  0.00%|def make_mask_none(newshape, dtype=None):
  1640|         0|            0|            0|  0.00%|    """
  1641|         0|            0|            0|  0.00%|    Return a boolean mask of the given shape, filled with False.
  1642|         0|            0|            0|  0.00%|
  1643|         0|            0|            0|  0.00%|    This function returns a boolean ndarray with all entries False, that can
  1644|         0|            0|            0|  0.00%|    be used in common mask manipulations. If a complex dtype is specified, the
  1645|         0|            0|            0|  0.00%|    type of each field is converted to a boolean type.
  1646|         0|            0|            0|  0.00%|
  1647|         0|            0|            0|  0.00%|    Parameters
  1648|         0|            0|            0|  0.00%|    ----------
  1649|         0|            0|            0|  0.00%|    newshape : tuple
  1650|         0|            0|            0|  0.00%|        A tuple indicating the shape of the mask.
  1651|         0|            0|            0|  0.00%|    dtype : {None, dtype}, optional
  1652|         0|            0|            0|  0.00%|        If None, use a MaskType instance. Otherwise, use a new datatype with
  1653|         0|            0|            0|  0.00%|        the same fields as `dtype`, converted to boolean types.
  1654|         0|            0|            0|  0.00%|
  1655|         0|            0|            0|  0.00%|    Returns
  1656|         0|            0|            0|  0.00%|    -------
  1657|         0|            0|            0|  0.00%|    result : ndarray
  1658|         0|            0|            0|  0.00%|        An ndarray of appropriate shape and dtype, filled with False.
  1659|         0|            0|            0|  0.00%|
  1660|         0|            0|            0|  0.00%|    See Also
  1661|         0|            0|            0|  0.00%|    --------
  1662|         0|            0|            0|  0.00%|    make_mask : Create a boolean mask from an array.
  1663|         0|            0|            0|  0.00%|    make_mask_descr : Construct a dtype description list from a given dtype.
  1664|         0|            0|            0|  0.00%|
  1665|         0|            0|            0|  0.00%|    Examples
  1666|         0|            0|            0|  0.00%|    --------
  1667|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1668|         0|            0|            0|  0.00%|    >>> ma.make_mask_none((3,))
  1669|         0|            0|            0|  0.00%|    array([False, False, False])
  1670|         0|            0|            0|  0.00%|
  1671|         0|            0|            0|  0.00%|    Defining a more complex dtype.
  1672|         0|            0|            0|  0.00%|
  1673|         0|            0|            0|  0.00%|    >>> dtype = np.dtype({'names':['foo', 'bar'],
  1674|         0|            0|            0|  0.00%|    ...                   'formats':[np.float32, np.int64]})
  1675|         0|            0|            0|  0.00%|    >>> dtype
  1676|         0|            0|            0|  0.00%|    dtype([('foo', '<f4'), ('bar', '<i8')])
  1677|         0|            0|            0|  0.00%|    >>> ma.make_mask_none((3,), dtype=dtype)
  1678|         0|            0|            0|  0.00%|    array([(False, False), (False, False), (False, False)],
  1679|         0|            0|            0|  0.00%|          dtype=[('foo', '|b1'), ('bar', '|b1')])
  1680|         0|            0|            0|  0.00%|
  1681|         0|            0|            0|  0.00%|    """
  1682|         0|            0|            0|  0.00%|    if dtype is None:
  1683|         0|            0|            0|  0.00%|        result = np.zeros(newshape, dtype=MaskType)
  1684|         0|            0|            0|  0.00%|    else:
  1685|         0|            0|            0|  0.00%|        result = np.zeros(newshape, dtype=make_mask_descr(dtype))
  1686|         0|            0|            0|  0.00%|    return result
  1687|         0|            0|            0|  0.00%|
  1688|         0|            0|            0|  0.00%|
  1689|         0|            0|            0|  0.00%|def mask_or(m1, m2, copy=False, shrink=True):
  1690|         0|            0|            0|  0.00%|    """
  1691|         0|            0|            0|  0.00%|    Combine two masks with the ``logical_or`` operator.
  1692|         0|            0|            0|  0.00%|
  1693|         0|            0|            0|  0.00%|    The result may be a view on `m1` or `m2` if the other is `nomask`
  1694|         0|            0|            0|  0.00%|    (i.e. False).
  1695|         0|            0|            0|  0.00%|
  1696|         0|            0|            0|  0.00%|    Parameters
  1697|         0|            0|            0|  0.00%|    ----------
  1698|         0|            0|            0|  0.00%|    m1, m2 : array_like
  1699|         0|            0|            0|  0.00%|        Input masks.
  1700|         0|            0|            0|  0.00%|    copy : bool, optional
  1701|         0|            0|            0|  0.00%|        If copy is False and one of the inputs is `nomask`, return a view
  1702|         0|            0|            0|  0.00%|        of the other input mask. Defaults to False.
  1703|         0|            0|            0|  0.00%|    shrink : bool, optional
  1704|         0|            0|            0|  0.00%|        Whether to shrink the output to `nomask` if all its values are
  1705|         0|            0|            0|  0.00%|        False. Defaults to True.
  1706|         0|            0|            0|  0.00%|
  1707|         0|            0|            0|  0.00%|    Returns
  1708|         0|            0|            0|  0.00%|    -------
  1709|         0|            0|            0|  0.00%|    mask : output mask
  1710|         0|            0|            0|  0.00%|        The result masks values that are masked in either `m1` or `m2`.
  1711|         0|            0|            0|  0.00%|
  1712|         0|            0|            0|  0.00%|    Raises
  1713|         0|            0|            0|  0.00%|    ------
  1714|         0|            0|            0|  0.00%|    ValueError
  1715|         0|            0|            0|  0.00%|        If `m1` and `m2` have different flexible dtypes.
  1716|         0|            0|            0|  0.00%|
  1717|         0|            0|            0|  0.00%|    Examples
  1718|         0|            0|            0|  0.00%|    --------
  1719|         0|            0|            0|  0.00%|    >>> m1 = np.ma.make_mask([0, 1, 1, 0])
  1720|         0|            0|            0|  0.00%|    >>> m2 = np.ma.make_mask([1, 0, 0, 0])
  1721|         0|            0|            0|  0.00%|    >>> np.ma.mask_or(m1, m2)
  1722|         0|            0|            0|  0.00%|    array([ True,  True,  True, False])
  1723|         0|            0|            0|  0.00%|
  1724|         0|            0|            0|  0.00%|    """
  1725|         0|            0|            0|  0.00%|
  1726|         0|            0|            0|  0.00%|    @recursive
  1727|         0|            0|            0|  0.00%|    def _recursive_mask_or(self, m1, m2, newmask):
  1728|         0|            0|            0|  0.00%|        names = m1.dtype.names
  1729|         0|            0|            0|  0.00%|        for name in names:
  1730|         0|            0|            0|  0.00%|            current1 = m1[name]
  1731|         0|            0|            0|  0.00%|            if current1.dtype.names is not None:
  1732|         0|            0|            0|  0.00%|                self(current1, m2[name], newmask[name])
  1733|         0|            0|            0|  0.00%|            else:
  1734|         0|            0|            0|  0.00%|                umath.logical_or(current1, m2[name], newmask[name])
  1735|         0|            0|            0|  0.00%|        return
  1736|         0|            0|            0|  0.00%|
  1737|         0|            0|            0|  0.00%|    if (m1 is nomask) or (m1 is False):
  1738|         0|            0|            0|  0.00%|        dtype = getattr(m2, 'dtype', MaskType)
  1739|         0|            0|            0|  0.00%|        return make_mask(m2, copy=copy, shrink=shrink, dtype=dtype)
  1740|         0|            0|            0|  0.00%|    if (m2 is nomask) or (m2 is False):
  1741|         0|            0|            0|  0.00%|        dtype = getattr(m1, 'dtype', MaskType)
  1742|         0|            0|            0|  0.00%|        return make_mask(m1, copy=copy, shrink=shrink, dtype=dtype)
  1743|         0|            0|            0|  0.00%|    if m1 is m2 and is_mask(m1):
  1744|         0|            0|            0|  0.00%|        return m1
  1745|         0|            0|            0|  0.00%|    (dtype1, dtype2) = (getattr(m1, 'dtype', None), getattr(m2, 'dtype', None))
  1746|         0|            0|            0|  0.00%|    if (dtype1 != dtype2):
  1747|         0|            0|            0|  0.00%|        raise ValueError("Incompatible dtypes '%s'<>'%s'" % (dtype1, dtype2))
  1748|         0|            0|            0|  0.00%|    if dtype1.names is not None:
  1749|         0|            0|            0|  0.00%|        # Allocate an output mask array with the properly broadcast shape.
  1750|         0|            0|            0|  0.00%|        newmask = np.empty(np.broadcast(m1, m2).shape, dtype1)
  1751|         0|            0|            0|  0.00%|        _recursive_mask_or(m1, m2, newmask)
  1752|         0|            0|            0|  0.00%|        return newmask
  1753|         0|            0|            0|  0.00%|    return make_mask(umath.logical_or(m1, m2), copy=copy, shrink=shrink)
  1754|         0|            0|            0|  0.00%|
  1755|         0|            0|            0|  0.00%|
  1756|         0|            0|            0|  0.00%|def flatten_mask(mask):
  1757|         0|            0|            0|  0.00%|    """
  1758|         0|            0|            0|  0.00%|    Returns a completely flattened version of the mask, where nested fields
  1759|         0|            0|            0|  0.00%|    are collapsed.
  1760|         0|            0|            0|  0.00%|
  1761|         0|            0|            0|  0.00%|    Parameters
  1762|         0|            0|            0|  0.00%|    ----------
  1763|         0|            0|            0|  0.00%|    mask : array_like
  1764|         0|            0|            0|  0.00%|        Input array, which will be interpreted as booleans.
  1765|         0|            0|            0|  0.00%|
  1766|         0|            0|            0|  0.00%|    Returns
  1767|         0|            0|            0|  0.00%|    -------
  1768|         0|            0|            0|  0.00%|    flattened_mask : ndarray of bools
  1769|         0|            0|            0|  0.00%|        The flattened input.
  1770|         0|            0|            0|  0.00%|
  1771|         0|            0|            0|  0.00%|    Examples
  1772|         0|            0|            0|  0.00%|    --------
  1773|         0|            0|            0|  0.00%|    >>> mask = np.array([0, 0, 1])
  1774|         0|            0|            0|  0.00%|    >>> np.ma.flatten_mask(mask)
  1775|         0|            0|            0|  0.00%|    array([False, False,  True])
  1776|         0|            0|            0|  0.00%|
  1777|         0|            0|            0|  0.00%|    >>> mask = np.array([(0, 0), (0, 1)], dtype=[('a', bool), ('b', bool)])
  1778|         0|            0|            0|  0.00%|    >>> np.ma.flatten_mask(mask)
  1779|         0|            0|            0|  0.00%|    array([False, False, False,  True])
  1780|         0|            0|            0|  0.00%|
  1781|         0|            0|            0|  0.00%|    >>> mdtype = [('a', bool), ('b', [('ba', bool), ('bb', bool)])]
  1782|         0|            0|            0|  0.00%|    >>> mask = np.array([(0, (0, 0)), (0, (0, 1))], dtype=mdtype)
  1783|         0|            0|            0|  0.00%|    >>> np.ma.flatten_mask(mask)
  1784|         0|            0|            0|  0.00%|    array([False, False, False, False, False,  True])
  1785|         0|            0|            0|  0.00%|
  1786|         0|            0|            0|  0.00%|    """
  1787|         0|            0|            0|  0.00%|
  1788|         0|            0|            0|  0.00%|    def _flatmask(mask):
  1789|         0|            0|            0|  0.00%|        "Flatten the mask and returns a (maybe nested) sequence of booleans."
  1790|         0|            0|            0|  0.00%|        mnames = mask.dtype.names
  1791|         0|            0|            0|  0.00%|        if mnames is not None:
  1792|         0|            0|            0|  0.00%|            return [flatten_mask(mask[name]) for name in mnames]
  1793|         0|            0|            0|  0.00%|        else:
  1794|         0|            0|            0|  0.00%|            return mask
  1795|         0|            0|            0|  0.00%|
  1796|         0|            0|            0|  0.00%|    def _flatsequence(sequence):
  1797|         0|            0|            0|  0.00%|        "Generates a flattened version of the sequence."
  1798|         0|            0|            0|  0.00%|        try:
  1799|         0|            0|            0|  0.00%|            for element in sequence:
  1800|         0|            0|            0|  0.00%|                if hasattr(element, '__iter__'):
  1801|         0|            0|            0|  0.00%|                    for f in _flatsequence(element):
  1802|         0|            0|            0|  0.00%|                        yield f
  1803|         0|            0|            0|  0.00%|                else:
  1804|         0|            0|            0|  0.00%|                    yield element
  1805|         0|            0|            0|  0.00%|        except TypeError:
  1806|         0|            0|            0|  0.00%|            yield sequence
  1807|         0|            0|            0|  0.00%|
  1808|         0|            0|            0|  0.00%|    mask = np.asarray(mask)
  1809|         0|            0|            0|  0.00%|    flattened = _flatsequence(_flatmask(mask))
  1810|         0|            0|            0|  0.00%|    return np.array([_ for _ in flattened], dtype=bool)
  1811|         0|            0|            0|  0.00%|
  1812|         0|            0|            0|  0.00%|
  1813|         0|            0|            0|  0.00%|def _check_mask_axis(mask, axis, keepdims=np._NoValue):
  1814|         0|            0|            0|  0.00%|    "Check whether there are masked values along the given axis"
  1815|         0|            0|            0|  0.00%|    kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  1816|         0|            0|            0|  0.00%|    if mask is not nomask:
  1817|         0|            0|            0|  0.00%|        return mask.all(axis=axis, **kwargs)
  1818|         0|            0|            0|  0.00%|    return nomask
  1819|         0|            0|            0|  0.00%|
  1820|         0|            0|            0|  0.00%|
  1821|         0|            0|            0|  0.00%|###############################################################################
  1822|         0|            0|            0|  0.00%|#                             Masking functions                               #
  1823|         0|            0|            0|  0.00%|###############################################################################
  1824|         0|            0|            0|  0.00%|
  1825|         0|            0|            0|  0.00%|def masked_where(condition, a, copy=True):
  1826|         0|            0|            0|  0.00%|    """
  1827|         0|            0|            0|  0.00%|    Mask an array where a condition is met.
  1828|         0|            0|            0|  0.00%|
  1829|         0|            0|            0|  0.00%|    Return `a` as an array masked where `condition` is True.
  1830|         0|            0|            0|  0.00%|    Any masked values of `a` or `condition` are also masked in the output.
  1831|         0|            0|            0|  0.00%|
  1832|         0|            0|            0|  0.00%|    Parameters
  1833|         0|            0|            0|  0.00%|    ----------
  1834|         0|            0|            0|  0.00%|    condition : array_like
  1835|         0|            0|            0|  0.00%|        Masking condition.  When `condition` tests floating point values for
  1836|         0|            0|            0|  0.00%|        equality, consider using ``masked_values`` instead.
  1837|         0|            0|            0|  0.00%|    a : array_like
  1838|         0|            0|            0|  0.00%|        Array to mask.
  1839|         0|            0|            0|  0.00%|    copy : bool
  1840|         0|            0|            0|  0.00%|        If True (default) make a copy of `a` in the result.  If False modify
  1841|         0|            0|            0|  0.00%|        `a` in place and return a view.
  1842|         0|            0|            0|  0.00%|
  1843|         0|            0|            0|  0.00%|    Returns
  1844|         0|            0|            0|  0.00%|    -------
  1845|         0|            0|            0|  0.00%|    result : MaskedArray
  1846|         0|            0|            0|  0.00%|        The result of masking `a` where `condition` is True.
  1847|         0|            0|            0|  0.00%|
  1848|         0|            0|            0|  0.00%|    See Also
  1849|         0|            0|            0|  0.00%|    --------
  1850|         0|            0|            0|  0.00%|    masked_values : Mask using floating point equality.
  1851|         0|            0|            0|  0.00%|    masked_equal : Mask where equal to a given value.
  1852|         0|            0|            0|  0.00%|    masked_not_equal : Mask where `not` equal to a given value.
  1853|         0|            0|            0|  0.00%|    masked_less_equal : Mask where less than or equal to a given value.
  1854|         0|            0|            0|  0.00%|    masked_greater_equal : Mask where greater than or equal to a given value.
  1855|         0|            0|            0|  0.00%|    masked_less : Mask where less than a given value.
  1856|         0|            0|            0|  0.00%|    masked_greater : Mask where greater than a given value.
  1857|         0|            0|            0|  0.00%|    masked_inside : Mask inside a given interval.
  1858|         0|            0|            0|  0.00%|    masked_outside : Mask outside a given interval.
  1859|         0|            0|            0|  0.00%|    masked_invalid : Mask invalid values (NaNs or infs).
  1860|         0|            0|            0|  0.00%|
  1861|         0|            0|            0|  0.00%|    Examples
  1862|         0|            0|            0|  0.00%|    --------
  1863|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1864|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  1865|         0|            0|            0|  0.00%|    >>> a
  1866|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  1867|         0|            0|            0|  0.00%|    >>> ma.masked_where(a <= 2, a)
  1868|         0|            0|            0|  0.00%|    masked_array(data=[--, --, --, 3],
  1869|         0|            0|            0|  0.00%|                 mask=[ True,  True,  True, False],
  1870|         0|            0|            0|  0.00%|           fill_value=999999)
  1871|         0|            0|            0|  0.00%|
  1872|         0|            0|            0|  0.00%|    Mask array `b` conditional on `a`.
  1873|         0|            0|            0|  0.00%|
  1874|         0|            0|            0|  0.00%|    >>> b = ['a', 'b', 'c', 'd']
  1875|         0|            0|            0|  0.00%|    >>> ma.masked_where(a == 2, b)
  1876|         0|            0|            0|  0.00%|    masked_array(data=['a', 'b', --, 'd'],
  1877|         0|            0|            0|  0.00%|                 mask=[False, False,  True, False],
  1878|         0|            0|            0|  0.00%|           fill_value='N/A',
  1879|         0|            0|            0|  0.00%|                dtype='<U1')
  1880|         0|            0|            0|  0.00%|
  1881|         0|            0|            0|  0.00%|    Effect of the `copy` argument.
  1882|         0|            0|            0|  0.00%|
  1883|         0|            0|            0|  0.00%|    >>> c = ma.masked_where(a <= 2, a)
  1884|         0|            0|            0|  0.00%|    >>> c
  1885|         0|            0|            0|  0.00%|    masked_array(data=[--, --, --, 3],
  1886|         0|            0|            0|  0.00%|                 mask=[ True,  True,  True, False],
  1887|         0|            0|            0|  0.00%|           fill_value=999999)
  1888|         0|            0|            0|  0.00%|    >>> c[0] = 99
  1889|         0|            0|            0|  0.00%|    >>> c
  1890|         0|            0|            0|  0.00%|    masked_array(data=[99, --, --, 3],
  1891|         0|            0|            0|  0.00%|                 mask=[False,  True,  True, False],
  1892|         0|            0|            0|  0.00%|           fill_value=999999)
  1893|         0|            0|            0|  0.00%|    >>> a
  1894|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  1895|         0|            0|            0|  0.00%|    >>> c = ma.masked_where(a <= 2, a, copy=False)
  1896|         0|            0|            0|  0.00%|    >>> c[0] = 99
  1897|         0|            0|            0|  0.00%|    >>> c
  1898|         0|            0|            0|  0.00%|    masked_array(data=[99, --, --, 3],
  1899|         0|            0|            0|  0.00%|                 mask=[False,  True,  True, False],
  1900|         0|            0|            0|  0.00%|           fill_value=999999)
  1901|         0|            0|            0|  0.00%|    >>> a
  1902|         0|            0|            0|  0.00%|    array([99,  1,  2,  3])
  1903|         0|            0|            0|  0.00%|
  1904|         0|            0|            0|  0.00%|    When `condition` or `a` contain masked values.
  1905|         0|            0|            0|  0.00%|
  1906|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  1907|         0|            0|            0|  0.00%|    >>> a = ma.masked_where(a == 2, a)
  1908|         0|            0|            0|  0.00%|    >>> a
  1909|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, --, 3],
  1910|         0|            0|            0|  0.00%|                 mask=[False, False,  True, False],
  1911|         0|            0|            0|  0.00%|           fill_value=999999)
  1912|         0|            0|            0|  0.00%|    >>> b = np.arange(4)
  1913|         0|            0|            0|  0.00%|    >>> b = ma.masked_where(b == 0, b)
  1914|         0|            0|            0|  0.00%|    >>> b
  1915|         0|            0|            0|  0.00%|    masked_array(data=[--, 1, 2, 3],
  1916|         0|            0|            0|  0.00%|                 mask=[ True, False, False, False],
  1917|         0|            0|            0|  0.00%|           fill_value=999999)
  1918|         0|            0|            0|  0.00%|    >>> ma.masked_where(a == 3, b)
  1919|         0|            0|            0|  0.00%|    masked_array(data=[--, 1, --, --],
  1920|         0|            0|            0|  0.00%|                 mask=[ True, False,  True,  True],
  1921|         0|            0|            0|  0.00%|           fill_value=999999)
  1922|         0|            0|            0|  0.00%|
  1923|         0|            0|            0|  0.00%|    """
  1924|         0|            0|            0|  0.00%|    # Make sure that condition is a valid standard-type mask.
  1925|         0|            0|            0|  0.00%|    cond = make_mask(condition, shrink=False)
  1926|         0|            0|            0|  0.00%|    a = np.array(a, copy=copy, subok=True)
  1927|         0|            0|            0|  0.00%|
  1928|         0|            0|            0|  0.00%|    (cshape, ashape) = (cond.shape, a.shape)
  1929|         0|            0|            0|  0.00%|    if cshape and cshape != ashape:
  1930|         0|            0|            0|  0.00%|        raise IndexError("Inconsistent shape between the condition and the input"
  1931|         0|            0|            0|  0.00%|                         " (got %s and %s)" % (cshape, ashape))
  1932|         0|            0|            0|  0.00%|    if hasattr(a, '_mask'):
  1933|         0|            0|            0|  0.00%|        cond = mask_or(cond, a._mask)
  1934|         0|            0|            0|  0.00%|        cls = type(a)
  1935|         0|            0|            0|  0.00%|    else:
  1936|         0|            0|            0|  0.00%|        cls = MaskedArray
  1937|         0|            0|            0|  0.00%|    result = a.view(cls)
  1938|         0|            0|            0|  0.00%|    # Assign to *.mask so that structured masks are handled correctly.
  1939|         0|            0|            0|  0.00%|    result.mask = _shrink_mask(cond)
  1940|         0|            0|            0|  0.00%|    return result
  1941|         0|            0|            0|  0.00%|
  1942|         0|            0|            0|  0.00%|
  1943|         0|            0|            0|  0.00%|def masked_greater(x, value, copy=True):
  1944|         0|            0|            0|  0.00%|    """
  1945|         0|            0|            0|  0.00%|    Mask an array where greater than a given value.
  1946|         0|            0|            0|  0.00%|
  1947|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  1948|         0|            0|            0|  0.00%|    `condition` = (x > value).
  1949|         0|            0|            0|  0.00%|
  1950|         0|            0|            0|  0.00%|    See Also
  1951|         0|            0|            0|  0.00%|    --------
  1952|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  1953|         0|            0|            0|  0.00%|
  1954|         0|            0|            0|  0.00%|    Examples
  1955|         0|            0|            0|  0.00%|    --------
  1956|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1957|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  1958|         0|            0|            0|  0.00%|    >>> a
  1959|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  1960|         0|            0|            0|  0.00%|    >>> ma.masked_greater(a, 2)
  1961|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, 2, --],
  1962|         0|            0|            0|  0.00%|                 mask=[False, False, False,  True],
  1963|         0|            0|            0|  0.00%|           fill_value=999999)
  1964|         0|            0|            0|  0.00%|
  1965|         0|            0|            0|  0.00%|    """
  1966|         0|            0|            0|  0.00%|    return masked_where(greater(x, value), x, copy=copy)
  1967|         0|            0|            0|  0.00%|
  1968|         0|            0|            0|  0.00%|
  1969|         0|            0|            0|  0.00%|def masked_greater_equal(x, value, copy=True):
  1970|         0|            0|            0|  0.00%|    """
  1971|         0|            0|            0|  0.00%|    Mask an array where greater than or equal to a given value.
  1972|         0|            0|            0|  0.00%|
  1973|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  1974|         0|            0|            0|  0.00%|    `condition` = (x >= value).
  1975|         0|            0|            0|  0.00%|
  1976|         0|            0|            0|  0.00%|    See Also
  1977|         0|            0|            0|  0.00%|    --------
  1978|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  1979|         0|            0|            0|  0.00%|
  1980|         0|            0|            0|  0.00%|    Examples
  1981|         0|            0|            0|  0.00%|    --------
  1982|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  1983|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  1984|         0|            0|            0|  0.00%|    >>> a
  1985|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  1986|         0|            0|            0|  0.00%|    >>> ma.masked_greater_equal(a, 2)
  1987|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, --, --],
  1988|         0|            0|            0|  0.00%|                 mask=[False, False,  True,  True],
  1989|         0|            0|            0|  0.00%|           fill_value=999999)
  1990|         0|            0|            0|  0.00%|
  1991|         0|            0|            0|  0.00%|    """
  1992|         0|            0|            0|  0.00%|    return masked_where(greater_equal(x, value), x, copy=copy)
  1993|         0|            0|            0|  0.00%|
  1994|         0|            0|            0|  0.00%|
  1995|         0|            0|            0|  0.00%|def masked_less(x, value, copy=True):
  1996|         0|            0|            0|  0.00%|    """
  1997|         0|            0|            0|  0.00%|    Mask an array where less than a given value.
  1998|         0|            0|            0|  0.00%|
  1999|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  2000|         0|            0|            0|  0.00%|    `condition` = (x < value).
  2001|         0|            0|            0|  0.00%|
  2002|         0|            0|            0|  0.00%|    See Also
  2003|         0|            0|            0|  0.00%|    --------
  2004|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2005|         0|            0|            0|  0.00%|
  2006|         0|            0|            0|  0.00%|    Examples
  2007|         0|            0|            0|  0.00%|    --------
  2008|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2009|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  2010|         0|            0|            0|  0.00%|    >>> a
  2011|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  2012|         0|            0|            0|  0.00%|    >>> ma.masked_less(a, 2)
  2013|         0|            0|            0|  0.00%|    masked_array(data=[--, --, 2, 3],
  2014|         0|            0|            0|  0.00%|                 mask=[ True,  True, False, False],
  2015|         0|            0|            0|  0.00%|           fill_value=999999)
  2016|         0|            0|            0|  0.00%|
  2017|         0|            0|            0|  0.00%|    """
  2018|         0|            0|            0|  0.00%|    return masked_where(less(x, value), x, copy=copy)
  2019|         0|            0|            0|  0.00%|
  2020|         0|            0|            0|  0.00%|
  2021|         0|            0|            0|  0.00%|def masked_less_equal(x, value, copy=True):
  2022|         0|            0|            0|  0.00%|    """
  2023|         0|            0|            0|  0.00%|    Mask an array where less than or equal to a given value.
  2024|         0|            0|            0|  0.00%|
  2025|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  2026|         0|            0|            0|  0.00%|    `condition` = (x <= value).
  2027|         0|            0|            0|  0.00%|
  2028|         0|            0|            0|  0.00%|    See Also
  2029|         0|            0|            0|  0.00%|    --------
  2030|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2031|         0|            0|            0|  0.00%|
  2032|         0|            0|            0|  0.00%|    Examples
  2033|         0|            0|            0|  0.00%|    --------
  2034|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2035|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  2036|         0|            0|            0|  0.00%|    >>> a
  2037|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  2038|         0|            0|            0|  0.00%|    >>> ma.masked_less_equal(a, 2)
  2039|         0|            0|            0|  0.00%|    masked_array(data=[--, --, --, 3],
  2040|         0|            0|            0|  0.00%|                 mask=[ True,  True,  True, False],
  2041|         0|            0|            0|  0.00%|           fill_value=999999)
  2042|         0|            0|            0|  0.00%|
  2043|         0|            0|            0|  0.00%|    """
  2044|         0|            0|            0|  0.00%|    return masked_where(less_equal(x, value), x, copy=copy)
  2045|         0|            0|            0|  0.00%|
  2046|         0|            0|            0|  0.00%|
  2047|         0|            0|            0|  0.00%|def masked_not_equal(x, value, copy=True):
  2048|         0|            0|            0|  0.00%|    """
  2049|         0|            0|            0|  0.00%|    Mask an array where `not` equal to a given value.
  2050|         0|            0|            0|  0.00%|
  2051|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  2052|         0|            0|            0|  0.00%|    `condition` = (x != value).
  2053|         0|            0|            0|  0.00%|
  2054|         0|            0|            0|  0.00%|    See Also
  2055|         0|            0|            0|  0.00%|    --------
  2056|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2057|         0|            0|            0|  0.00%|
  2058|         0|            0|            0|  0.00%|    Examples
  2059|         0|            0|            0|  0.00%|    --------
  2060|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2061|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  2062|         0|            0|            0|  0.00%|    >>> a
  2063|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  2064|         0|            0|            0|  0.00%|    >>> ma.masked_not_equal(a, 2)
  2065|         0|            0|            0|  0.00%|    masked_array(data=[--, --, 2, --],
  2066|         0|            0|            0|  0.00%|                 mask=[ True,  True, False,  True],
  2067|         0|            0|            0|  0.00%|           fill_value=999999)
  2068|         0|            0|            0|  0.00%|
  2069|         0|            0|            0|  0.00%|    """
  2070|         0|            0|            0|  0.00%|    return masked_where(not_equal(x, value), x, copy=copy)
  2071|         0|            0|            0|  0.00%|
  2072|         0|            0|            0|  0.00%|
  2073|         0|            0|            0|  0.00%|def masked_equal(x, value, copy=True):
  2074|         0|            0|            0|  0.00%|    """
  2075|         0|            0|            0|  0.00%|    Mask an array where equal to a given value.
  2076|         0|            0|            0|  0.00%|
  2077|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  2078|         0|            0|            0|  0.00%|    `condition` = (x == value).  For floating point arrays,
  2079|         0|            0|            0|  0.00%|    consider using ``masked_values(x, value)``.
  2080|         0|            0|            0|  0.00%|
  2081|         0|            0|            0|  0.00%|    See Also
  2082|         0|            0|            0|  0.00%|    --------
  2083|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2084|         0|            0|            0|  0.00%|    masked_values : Mask using floating point equality.
  2085|         0|            0|            0|  0.00%|
  2086|         0|            0|            0|  0.00%|    Examples
  2087|         0|            0|            0|  0.00%|    --------
  2088|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2089|         0|            0|            0|  0.00%|    >>> a = np.arange(4)
  2090|         0|            0|            0|  0.00%|    >>> a
  2091|         0|            0|            0|  0.00%|    array([0, 1, 2, 3])
  2092|         0|            0|            0|  0.00%|    >>> ma.masked_equal(a, 2)
  2093|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, --, 3],
  2094|         0|            0|            0|  0.00%|                 mask=[False, False,  True, False],
  2095|         0|            0|            0|  0.00%|           fill_value=2)
  2096|         0|            0|            0|  0.00%|
  2097|         0|            0|            0|  0.00%|    """
  2098|         0|            0|            0|  0.00%|    output = masked_where(equal(x, value), x, copy=copy)
  2099|         0|            0|            0|  0.00%|    output.fill_value = value
  2100|         0|            0|            0|  0.00%|    return output
  2101|         0|            0|            0|  0.00%|
  2102|         0|            0|            0|  0.00%|
  2103|         0|            0|            0|  0.00%|def masked_inside(x, v1, v2, copy=True):
  2104|         0|            0|            0|  0.00%|    """
  2105|         0|            0|            0|  0.00%|    Mask an array inside a given interval.
  2106|         0|            0|            0|  0.00%|
  2107|         0|            0|            0|  0.00%|    Shortcut to ``masked_where``, where `condition` is True for `x` inside
  2108|         0|            0|            0|  0.00%|    the interval [v1,v2] (v1 <= x <= v2).  The boundaries `v1` and `v2`
  2109|         0|            0|            0|  0.00%|    can be given in either order.
  2110|         0|            0|            0|  0.00%|
  2111|         0|            0|            0|  0.00%|    See Also
  2112|         0|            0|            0|  0.00%|    --------
  2113|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2114|         0|            0|            0|  0.00%|
  2115|         0|            0|            0|  0.00%|    Notes
  2116|         0|            0|            0|  0.00%|    -----
  2117|         0|            0|            0|  0.00%|    The array `x` is prefilled with its filling value.
  2118|         0|            0|            0|  0.00%|
  2119|         0|            0|            0|  0.00%|    Examples
  2120|         0|            0|            0|  0.00%|    --------
  2121|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2122|         0|            0|            0|  0.00%|    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
  2123|         0|            0|            0|  0.00%|    >>> ma.masked_inside(x, -0.3, 0.3)
  2124|         0|            0|            0|  0.00%|    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
  2125|         0|            0|            0|  0.00%|                 mask=[False, False,  True,  True, False, False],
  2126|         0|            0|            0|  0.00%|           fill_value=1e+20)
  2127|         0|            0|            0|  0.00%|
  2128|         0|            0|            0|  0.00%|    The order of `v1` and `v2` doesn't matter.
  2129|         0|            0|            0|  0.00%|
  2130|         0|            0|            0|  0.00%|    >>> ma.masked_inside(x, 0.3, -0.3)
  2131|         0|            0|            0|  0.00%|    masked_array(data=[0.31, 1.2, --, --, -0.4, -1.1],
  2132|         0|            0|            0|  0.00%|                 mask=[False, False,  True,  True, False, False],
  2133|         0|            0|            0|  0.00%|           fill_value=1e+20)
  2134|         0|            0|            0|  0.00%|
  2135|         0|            0|            0|  0.00%|    """
  2136|         0|            0|            0|  0.00%|    if v2 < v1:
  2137|         0|            0|            0|  0.00%|        (v1, v2) = (v2, v1)
  2138|         0|            0|            0|  0.00%|    xf = filled(x)
  2139|         0|            0|            0|  0.00%|    condition = (xf >= v1) & (xf <= v2)
  2140|         0|            0|            0|  0.00%|    return masked_where(condition, x, copy=copy)
  2141|         0|            0|            0|  0.00%|
  2142|         0|            0|            0|  0.00%|
  2143|         0|            0|            0|  0.00%|def masked_outside(x, v1, v2, copy=True):
  2144|         0|            0|            0|  0.00%|    """
  2145|         0|            0|            0|  0.00%|    Mask an array outside a given interval.
  2146|         0|            0|            0|  0.00%|
  2147|         0|            0|            0|  0.00%|    Shortcut to ``masked_where``, where `condition` is True for `x` outside
  2148|         0|            0|            0|  0.00%|    the interval [v1,v2] (x < v1)|(x > v2).
  2149|         0|            0|            0|  0.00%|    The boundaries `v1` and `v2` can be given in either order.
  2150|         0|            0|            0|  0.00%|
  2151|         0|            0|            0|  0.00%|    See Also
  2152|         0|            0|            0|  0.00%|    --------
  2153|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2154|         0|            0|            0|  0.00%|
  2155|         0|            0|            0|  0.00%|    Notes
  2156|         0|            0|            0|  0.00%|    -----
  2157|         0|            0|            0|  0.00%|    The array `x` is prefilled with its filling value.
  2158|         0|            0|            0|  0.00%|
  2159|         0|            0|            0|  0.00%|    Examples
  2160|         0|            0|            0|  0.00%|    --------
  2161|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2162|         0|            0|            0|  0.00%|    >>> x = [0.31, 1.2, 0.01, 0.2, -0.4, -1.1]
  2163|         0|            0|            0|  0.00%|    >>> ma.masked_outside(x, -0.3, 0.3)
  2164|         0|            0|            0|  0.00%|    masked_array(data=[--, --, 0.01, 0.2, --, --],
  2165|         0|            0|            0|  0.00%|                 mask=[ True,  True, False, False,  True,  True],
  2166|         0|            0|            0|  0.00%|           fill_value=1e+20)
  2167|         0|            0|            0|  0.00%|
  2168|         0|            0|            0|  0.00%|    The order of `v1` and `v2` doesn't matter.
  2169|         0|            0|            0|  0.00%|
  2170|         0|            0|            0|  0.00%|    >>> ma.masked_outside(x, 0.3, -0.3)
  2171|         0|            0|            0|  0.00%|    masked_array(data=[--, --, 0.01, 0.2, --, --],
  2172|         0|            0|            0|  0.00%|                 mask=[ True,  True, False, False,  True,  True],
  2173|         0|            0|            0|  0.00%|           fill_value=1e+20)
  2174|         0|            0|            0|  0.00%|
  2175|         0|            0|            0|  0.00%|    """
  2176|         0|            0|            0|  0.00%|    if v2 < v1:
  2177|         0|            0|            0|  0.00%|        (v1, v2) = (v2, v1)
  2178|         0|            0|            0|  0.00%|    xf = filled(x)
  2179|         0|            0|            0|  0.00%|    condition = (xf < v1) | (xf > v2)
  2180|         0|            0|            0|  0.00%|    return masked_where(condition, x, copy=copy)
  2181|         0|            0|            0|  0.00%|
  2182|         0|            0|            0|  0.00%|
  2183|         0|            0|            0|  0.00%|def masked_object(x, value, copy=True, shrink=True):
  2184|         0|            0|            0|  0.00%|    """
  2185|         0|            0|            0|  0.00%|    Mask the array `x` where the data are exactly equal to value.
  2186|         0|            0|            0|  0.00%|
  2187|         0|            0|            0|  0.00%|    This function is similar to `masked_values`, but only suitable
  2188|         0|            0|            0|  0.00%|    for object arrays: for floating point, use `masked_values` instead.
  2189|         0|            0|            0|  0.00%|
  2190|         0|            0|            0|  0.00%|    Parameters
  2191|         0|            0|            0|  0.00%|    ----------
  2192|         0|            0|            0|  0.00%|    x : array_like
  2193|         0|            0|            0|  0.00%|        Array to mask
  2194|         0|            0|            0|  0.00%|    value : object
  2195|         0|            0|            0|  0.00%|        Comparison value
  2196|         0|            0|            0|  0.00%|    copy : {True, False}, optional
  2197|         0|            0|            0|  0.00%|        Whether to return a copy of `x`.
  2198|         0|            0|            0|  0.00%|    shrink : {True, False}, optional
  2199|         0|            0|            0|  0.00%|        Whether to collapse a mask full of False to nomask
  2200|         0|            0|            0|  0.00%|
  2201|         0|            0|            0|  0.00%|    Returns
  2202|         0|            0|            0|  0.00%|    -------
  2203|         0|            0|            0|  0.00%|    result : MaskedArray
  2204|         0|            0|            0|  0.00%|        The result of masking `x` where equal to `value`.
  2205|         0|            0|            0|  0.00%|
  2206|         0|            0|            0|  0.00%|    See Also
  2207|         0|            0|            0|  0.00%|    --------
  2208|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2209|         0|            0|            0|  0.00%|    masked_equal : Mask where equal to a given value (integers).
  2210|         0|            0|            0|  0.00%|    masked_values : Mask using floating point equality.
  2211|         0|            0|            0|  0.00%|
  2212|         0|            0|            0|  0.00%|    Examples
  2213|         0|            0|            0|  0.00%|    --------
  2214|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2215|         0|            0|            0|  0.00%|    >>> food = np.array(['green_eggs', 'ham'], dtype=object)
  2216|         0|            0|            0|  0.00%|    >>> # don't eat spoiled food
  2217|         0|            0|            0|  0.00%|    >>> eat = ma.masked_object(food, 'green_eggs')
  2218|         0|            0|            0|  0.00%|    >>> eat
  2219|         0|            0|            0|  0.00%|    masked_array(data=[--, 'ham'],
  2220|         0|            0|            0|  0.00%|                 mask=[ True, False],
  2221|         0|            0|            0|  0.00%|           fill_value='green_eggs',
  2222|         0|            0|            0|  0.00%|                dtype=object)
  2223|         0|            0|            0|  0.00%|    >>> # plain ol` ham is boring
  2224|         0|            0|            0|  0.00%|    >>> fresh_food = np.array(['cheese', 'ham', 'pineapple'], dtype=object)
  2225|         0|            0|            0|  0.00%|    >>> eat = ma.masked_object(fresh_food, 'green_eggs')
  2226|         0|            0|            0|  0.00%|    >>> eat
  2227|         0|            0|            0|  0.00%|    masked_array(data=['cheese', 'ham', 'pineapple'],
  2228|         0|            0|            0|  0.00%|                 mask=False,
  2229|         0|            0|            0|  0.00%|           fill_value='green_eggs',
  2230|         0|            0|            0|  0.00%|                dtype=object)
  2231|         0|            0|            0|  0.00%|
  2232|         0|            0|            0|  0.00%|    Note that `mask` is set to ``nomask`` if possible.
  2233|         0|            0|            0|  0.00%|
  2234|         0|            0|            0|  0.00%|    >>> eat
  2235|         0|            0|            0|  0.00%|    masked_array(data=['cheese', 'ham', 'pineapple'],
  2236|         0|            0|            0|  0.00%|                 mask=False,
  2237|         0|            0|            0|  0.00%|           fill_value='green_eggs',
  2238|         0|            0|            0|  0.00%|                dtype=object)
  2239|         0|            0|            0|  0.00%|
  2240|         0|            0|            0|  0.00%|    """
  2241|         0|            0|            0|  0.00%|    if isMaskedArray(x):
  2242|         0|            0|            0|  0.00%|        condition = umath.equal(x._data, value)
  2243|         0|            0|            0|  0.00%|        mask = x._mask
  2244|         0|            0|            0|  0.00%|    else:
  2245|         0|            0|            0|  0.00%|        condition = umath.equal(np.asarray(x), value)
  2246|         0|            0|            0|  0.00%|        mask = nomask
  2247|         0|            0|            0|  0.00%|    mask = mask_or(mask, make_mask(condition, shrink=shrink))
  2248|         0|            0|            0|  0.00%|    return masked_array(x, mask=mask, copy=copy, fill_value=value)
  2249|         0|            0|            0|  0.00%|
  2250|         0|            0|            0|  0.00%|
  2251|         0|            0|            0|  0.00%|def masked_values(x, value, rtol=1e-5, atol=1e-8, copy=True, shrink=True):
  2252|         0|            0|            0|  0.00%|    """
  2253|         0|            0|            0|  0.00%|    Mask using floating point equality.
  2254|         0|            0|            0|  0.00%|
  2255|         0|            0|            0|  0.00%|    Return a MaskedArray, masked where the data in array `x` are approximately
  2256|         0|            0|            0|  0.00%|    equal to `value`, determined using `isclose`. The default tolerances for
  2257|         0|            0|            0|  0.00%|    `masked_values` are the same as those for `isclose`.
  2258|         0|            0|            0|  0.00%|
  2259|         0|            0|            0|  0.00%|    For integer types, exact equality is used, in the same way as
  2260|         0|            0|            0|  0.00%|    `masked_equal`.
  2261|         0|            0|            0|  0.00%|
  2262|         0|            0|            0|  0.00%|    The fill_value is set to `value` and the mask is set to ``nomask`` if
  2263|         0|            0|            0|  0.00%|    possible.
  2264|         0|            0|            0|  0.00%|
  2265|         0|            0|            0|  0.00%|    Parameters
  2266|         0|            0|            0|  0.00%|    ----------
  2267|         0|            0|            0|  0.00%|    x : array_like
  2268|         0|            0|            0|  0.00%|        Array to mask.
  2269|         0|            0|            0|  0.00%|    value : float
  2270|         0|            0|            0|  0.00%|        Masking value.
  2271|         0|            0|            0|  0.00%|    rtol, atol : float, optional
  2272|         0|            0|            0|  0.00%|        Tolerance parameters passed on to `isclose`
  2273|         0|            0|            0|  0.00%|    copy : bool, optional
  2274|         0|            0|            0|  0.00%|        Whether to return a copy of `x`.
  2275|         0|            0|            0|  0.00%|    shrink : bool, optional
  2276|         0|            0|            0|  0.00%|        Whether to collapse a mask full of False to ``nomask``.
  2277|         0|            0|            0|  0.00%|
  2278|         0|            0|            0|  0.00%|    Returns
  2279|         0|            0|            0|  0.00%|    -------
  2280|         0|            0|            0|  0.00%|    result : MaskedArray
  2281|         0|            0|            0|  0.00%|        The result of masking `x` where approximately equal to `value`.
  2282|         0|            0|            0|  0.00%|
  2283|         0|            0|            0|  0.00%|    See Also
  2284|         0|            0|            0|  0.00%|    --------
  2285|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2286|         0|            0|            0|  0.00%|    masked_equal : Mask where equal to a given value (integers).
  2287|         0|            0|            0|  0.00%|
  2288|         0|            0|            0|  0.00%|    Examples
  2289|         0|            0|            0|  0.00%|    --------
  2290|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2291|         0|            0|            0|  0.00%|    >>> x = np.array([1, 1.1, 2, 1.1, 3])
  2292|         0|            0|            0|  0.00%|    >>> ma.masked_values(x, 1.1)
  2293|         0|            0|            0|  0.00%|    masked_array(data=[1.0, --, 2.0, --, 3.0],
  2294|         0|            0|            0|  0.00%|                 mask=[False,  True, False,  True, False],
  2295|         0|            0|            0|  0.00%|           fill_value=1.1)
  2296|         0|            0|            0|  0.00%|
  2297|         0|            0|            0|  0.00%|    Note that `mask` is set to ``nomask`` if possible.
  2298|         0|            0|            0|  0.00%|
  2299|         0|            0|            0|  0.00%|    >>> ma.masked_values(x, 1.5)
  2300|         0|            0|            0|  0.00%|    masked_array(data=[1. , 1.1, 2. , 1.1, 3. ],
  2301|         0|            0|            0|  0.00%|                 mask=False,
  2302|         0|            0|            0|  0.00%|           fill_value=1.5)
  2303|         0|            0|            0|  0.00%|
  2304|         0|            0|            0|  0.00%|    For integers, the fill value will be different in general to the
  2305|         0|            0|            0|  0.00%|    result of ``masked_equal``.
  2306|         0|            0|            0|  0.00%|
  2307|         0|            0|            0|  0.00%|    >>> x = np.arange(5)
  2308|         0|            0|            0|  0.00%|    >>> x
  2309|         0|            0|            0|  0.00%|    array([0, 1, 2, 3, 4])
  2310|         0|            0|            0|  0.00%|    >>> ma.masked_values(x, 2)
  2311|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, --, 3, 4],
  2312|         0|            0|            0|  0.00%|                 mask=[False, False,  True, False, False],
  2313|         0|            0|            0|  0.00%|           fill_value=2)
  2314|         0|            0|            0|  0.00%|    >>> ma.masked_equal(x, 2)
  2315|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, --, 3, 4],
  2316|         0|            0|            0|  0.00%|                 mask=[False, False,  True, False, False],
  2317|         0|            0|            0|  0.00%|           fill_value=2)
  2318|         0|            0|            0|  0.00%|
  2319|         0|            0|            0|  0.00%|    """
  2320|         0|            0|            0|  0.00%|    xnew = filled(x, value)
  2321|         0|            0|            0|  0.00%|    if np.issubdtype(xnew.dtype, np.floating):
  2322|         0|            0|            0|  0.00%|        mask = np.isclose(xnew, value, atol=atol, rtol=rtol)
  2323|         0|            0|            0|  0.00%|    else:
  2324|         0|            0|            0|  0.00%|        mask = umath.equal(xnew, value)
  2325|         0|            0|            0|  0.00%|    ret = masked_array(xnew, mask=mask, copy=copy, fill_value=value)
  2326|         0|            0|            0|  0.00%|    if shrink:
  2327|         0|            0|            0|  0.00%|        ret.shrink_mask()
  2328|         0|            0|            0|  0.00%|    return ret
  2329|         0|            0|            0|  0.00%|
  2330|         0|            0|            0|  0.00%|
  2331|         0|            0|            0|  0.00%|def masked_invalid(a, copy=True):
  2332|         0|            0|            0|  0.00%|    """
  2333|         0|            0|            0|  0.00%|    Mask an array where invalid values occur (NaNs or infs).
  2334|         0|            0|            0|  0.00%|
  2335|         0|            0|            0|  0.00%|    This function is a shortcut to ``masked_where``, with
  2336|         0|            0|            0|  0.00%|    `condition` = ~(np.isfinite(a)). Any pre-existing mask is conserved.
  2337|         0|            0|            0|  0.00%|    Only applies to arrays with a dtype where NaNs or infs make sense
  2338|         0|            0|            0|  0.00%|    (i.e. floating point types), but accepts any array_like object.
  2339|         0|            0|            0|  0.00%|
  2340|         0|            0|            0|  0.00%|    See Also
  2341|         0|            0|            0|  0.00%|    --------
  2342|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  2343|         0|            0|            0|  0.00%|
  2344|         0|            0|            0|  0.00%|    Examples
  2345|         0|            0|            0|  0.00%|    --------
  2346|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  2347|         0|            0|            0|  0.00%|    >>> a = np.arange(5, dtype=float)
  2348|         0|            0|            0|  0.00%|    >>> a[2] = np.NaN
  2349|         0|            0|            0|  0.00%|    >>> a[3] = np.PINF
  2350|         0|            0|            0|  0.00%|    >>> a
  2351|         0|            0|            0|  0.00%|    array([ 0.,  1., nan, inf,  4.])
  2352|         0|            0|            0|  0.00%|    >>> ma.masked_invalid(a)
  2353|         0|            0|            0|  0.00%|    masked_array(data=[0.0, 1.0, --, --, 4.0],
  2354|         0|            0|            0|  0.00%|                 mask=[False, False,  True,  True, False],
  2355|         0|            0|            0|  0.00%|           fill_value=1e+20)
  2356|         0|            0|            0|  0.00%|
  2357|         0|            0|            0|  0.00%|    """
  2358|         0|            0|            0|  0.00%|    a = np.array(a, copy=copy, subok=True)
  2359|         0|            0|            0|  0.00%|    mask = getattr(a, '_mask', None)
  2360|         0|            0|            0|  0.00%|    if mask is not None:
  2361|         0|            0|            0|  0.00%|        condition = ~(np.isfinite(getdata(a)))
  2362|         0|            0|            0|  0.00%|        if mask is not nomask:
  2363|         0|            0|            0|  0.00%|            condition |= mask
  2364|         0|            0|            0|  0.00%|        cls = type(a)
  2365|         0|            0|            0|  0.00%|    else:
  2366|         0|            0|            0|  0.00%|        condition = ~(np.isfinite(a))
  2367|         0|            0|            0|  0.00%|        cls = MaskedArray
  2368|         0|            0|            0|  0.00%|    result = a.view(cls)
  2369|         0|            0|            0|  0.00%|    result._mask = condition
  2370|         0|            0|            0|  0.00%|    return result
  2371|         0|            0|            0|  0.00%|
  2372|         0|            0|            0|  0.00%|
  2373|         0|            0|            0|  0.00%|###############################################################################
  2374|         0|            0|            0|  0.00%|#                            Printing options                                 #
  2375|         0|            0|            0|  0.00%|###############################################################################
  2376|         0|            0|            0|  0.00%|
  2377|         0|            0|            0|  0.00%|
  2378|         0|            0|            0|  0.00%|class _MaskedPrintOption(object):
  2379|         0|            0|            0|  0.00%|    """
  2380|         0|            0|            0|  0.00%|    Handle the string used to represent missing data in a masked array.
  2381|         0|            0|            0|  0.00%|
  2382|         0|            0|            0|  0.00%|    """
  2383|         0|            0|            0|  0.00%|
  2384|         0|            0|            0|  0.00%|    def __init__(self, display):
  2385|         0|            0|            0|  0.00%|        """
  2386|         0|            0|            0|  0.00%|        Create the masked_print_option object.
  2387|         0|            0|            0|  0.00%|
  2388|         0|            0|            0|  0.00%|        """
  2389|         0|            0|            0|  0.00%|        self._display = display
  2390|         0|            0|            0|  0.00%|        self._enabled = True
  2391|         0|            0|            0|  0.00%|
  2392|         0|            0|            0|  0.00%|    def display(self):
  2393|         0|            0|            0|  0.00%|        """
  2394|         0|            0|            0|  0.00%|        Display the string to print for masked values.
  2395|         0|            0|            0|  0.00%|
  2396|         0|            0|            0|  0.00%|        """
  2397|         0|            0|            0|  0.00%|        return self._display
  2398|         0|            0|            0|  0.00%|
  2399|         0|            0|            0|  0.00%|    def set_display(self, s):
  2400|         0|            0|            0|  0.00%|        """
  2401|         0|            0|            0|  0.00%|        Set the string to print for masked values.
  2402|         0|            0|            0|  0.00%|
  2403|         0|            0|            0|  0.00%|        """
  2404|         0|            0|            0|  0.00%|        self._display = s
  2405|         0|            0|            0|  0.00%|
  2406|         0|            0|            0|  0.00%|    def enabled(self):
  2407|         0|            0|            0|  0.00%|        """
  2408|         0|            0|            0|  0.00%|        Is the use of the display value enabled?
  2409|         0|            0|            0|  0.00%|
  2410|         0|            0|            0|  0.00%|        """
  2411|         0|            0|            0|  0.00%|        return self._enabled
  2412|         0|            0|            0|  0.00%|
  2413|         0|            0|            0|  0.00%|    def enable(self, shrink=1):
  2414|         0|            0|            0|  0.00%|        """
  2415|         0|            0|            0|  0.00%|        Set the enabling shrink to `shrink`.
  2416|         0|            0|            0|  0.00%|
  2417|         0|            0|            0|  0.00%|        """
  2418|         0|            0|            0|  0.00%|        self._enabled = shrink
  2419|         0|            0|            0|  0.00%|
  2420|         0|            0|            0|  0.00%|    def __str__(self):
  2421|         0|            0|            0|  0.00%|        return str(self._display)
  2422|         0|            0|            0|  0.00%|
  2423|         0|            0|            0|  0.00%|    __repr__ = __str__
  2424|         0|            0|            0|  0.00%|
  2425|         0|            0|            0|  0.00%|# if you single index into a masked location you get this object.
  2426|         0|            0|            0|  0.00%|masked_print_option = _MaskedPrintOption('--')
  2427|         0|            0|            0|  0.00%|
  2428|         0|            0|            0|  0.00%|
  2429|         0|            0|            0|  0.00%|def _recursive_printoption(result, mask, printopt):
  2430|         0|            0|            0|  0.00%|    """
  2431|         0|            0|            0|  0.00%|    Puts printoptions in result where mask is True.
  2432|         0|            0|            0|  0.00%|
  2433|         0|            0|            0|  0.00%|    Private function allowing for recursion
  2434|         0|            0|            0|  0.00%|
  2435|         0|            0|            0|  0.00%|    """
  2436|         0|            0|            0|  0.00%|    names = result.dtype.names
  2437|         0|            0|            0|  0.00%|    if names is not None:
  2438|         0|            0|            0|  0.00%|        for name in names:
  2439|         0|            0|            0|  0.00%|            curdata = result[name]
  2440|         0|            0|            0|  0.00%|            curmask = mask[name]
  2441|         0|            0|            0|  0.00%|            _recursive_printoption(curdata, curmask, printopt)
  2442|         0|            0|            0|  0.00%|    else:
  2443|         0|            0|            0|  0.00%|        np.copyto(result, printopt, where=mask)
  2444|         0|            0|            0|  0.00%|    return
  2445|         0|            0|            0|  0.00%|
  2446|         0|            0|            0|  0.00%|# For better or worse, these end in a newline
  2447|         0|            0|            0|  0.00%|_legacy_print_templates = dict(
  2448|         0|            0|            0|  0.00%|    long_std=textwrap.dedent("""\
  2449|         0|            0|            0|  0.00%|        masked_%(name)s(data =
  2450|         0|            0|            0|  0.00%|         %(data)s,
  2451|         0|            0|            0|  0.00%|        %(nlen)s        mask =
  2452|         0|            0|            0|  0.00%|         %(mask)s,
  2453|         0|            0|            0|  0.00%|        %(nlen)s  fill_value = %(fill)s)
  2454|         0|            0|            0|  0.00%|        """),
  2455|         0|            0|            0|  0.00%|    long_flx=textwrap.dedent("""\
  2456|         0|            0|            0|  0.00%|        masked_%(name)s(data =
  2457|         0|            0|            0|  0.00%|         %(data)s,
  2458|         0|            0|            0|  0.00%|        %(nlen)s        mask =
  2459|         0|            0|            0|  0.00%|         %(mask)s,
  2460|         0|            0|            0|  0.00%|        %(nlen)s  fill_value = %(fill)s,
  2461|         0|            0|            0|  0.00%|        %(nlen)s       dtype = %(dtype)s)
  2462|         0|            0|            0|  0.00%|        """),
  2463|         0|            0|            0|  0.00%|    short_std=textwrap.dedent("""\
  2464|         0|            0|            0|  0.00%|        masked_%(name)s(data = %(data)s,
  2465|         0|            0|            0|  0.00%|        %(nlen)s        mask = %(mask)s,
  2466|         0|            0|            0|  0.00%|        %(nlen)s  fill_value = %(fill)s)
  2467|         0|            0|            0|  0.00%|        """),
  2468|         0|            0|            0|  0.00%|    short_flx=textwrap.dedent("""\
  2469|         0|            0|            0|  0.00%|        masked_%(name)s(data = %(data)s,
  2470|         0|            0|            0|  0.00%|        %(nlen)s        mask = %(mask)s,
  2471|         0|            0|            0|  0.00%|        %(nlen)s  fill_value = %(fill)s,
  2472|         0|            0|            0|  0.00%|        %(nlen)s       dtype = %(dtype)s)
  2473|         0|            0|            0|  0.00%|        """)
  2474|         0|            0|            0|  0.00%|)
  2475|         0|            0|            0|  0.00%|
  2476|         0|            0|            0|  0.00%|###############################################################################
  2477|         0|            0|            0|  0.00%|#                          MaskedArray class                                  #
  2478|         0|            0|            0|  0.00%|###############################################################################
  2479|         0|            0|            0|  0.00%|
  2480|         0|            0|            0|  0.00%|
  2481|         0|            0|            0|  0.00%|def _recursive_filled(a, mask, fill_value):
  2482|         0|            0|            0|  0.00%|    """
  2483|         0|            0|            0|  0.00%|    Recursively fill `a` with `fill_value`.
  2484|         0|            0|            0|  0.00%|
  2485|         0|            0|            0|  0.00%|    """
  2486|         0|            0|            0|  0.00%|    names = a.dtype.names
  2487|         0|            0|            0|  0.00%|    for name in names:
  2488|         0|            0|            0|  0.00%|        current = a[name]
  2489|         0|            0|            0|  0.00%|        if current.dtype.names is not None:
  2490|         0|            0|            0|  0.00%|            _recursive_filled(current, mask[name], fill_value[name])
  2491|         0|            0|            0|  0.00%|        else:
  2492|         0|            0|            0|  0.00%|            np.copyto(current, fill_value[name], where=mask[name])
  2493|         0|            0|            0|  0.00%|
  2494|         0|            0|            0|  0.00%|
  2495|         0|            0|            0|  0.00%|def flatten_structured_array(a):
  2496|         0|            0|            0|  0.00%|    """
  2497|         0|            0|            0|  0.00%|    Flatten a structured array.
  2498|         0|            0|            0|  0.00%|
  2499|         0|            0|            0|  0.00%|    The data type of the output is chosen such that it can represent all of the
  2500|         0|            0|            0|  0.00%|    (nested) fields.
  2501|         0|            0|            0|  0.00%|
  2502|         0|            0|            0|  0.00%|    Parameters
  2503|         0|            0|            0|  0.00%|    ----------
  2504|         0|            0|            0|  0.00%|    a : structured array
  2505|         0|            0|            0|  0.00%|
  2506|         0|            0|            0|  0.00%|    Returns
  2507|         0|            0|            0|  0.00%|    -------
  2508|         0|            0|            0|  0.00%|    output : masked array or ndarray
  2509|         0|            0|            0|  0.00%|        A flattened masked array if the input is a masked array, otherwise a
  2510|         0|            0|            0|  0.00%|        standard ndarray.
  2511|         0|            0|            0|  0.00%|
  2512|         0|            0|            0|  0.00%|    Examples
  2513|         0|            0|            0|  0.00%|    --------
  2514|         0|            0|            0|  0.00%|    >>> ndtype = [('a', int), ('b', float)]
  2515|         0|            0|            0|  0.00%|    >>> a = np.array([(1, 1), (2, 2)], dtype=ndtype)
  2516|         0|            0|            0|  0.00%|    >>> np.ma.flatten_structured_array(a)
  2517|         0|            0|            0|  0.00%|    array([[1., 1.],
  2518|         0|            0|            0|  0.00%|           [2., 2.]])
  2519|         0|            0|            0|  0.00%|
  2520|         0|            0|            0|  0.00%|    """
  2521|         0|            0|            0|  0.00%|
  2522|         0|            0|            0|  0.00%|    def flatten_sequence(iterable):
  2523|         0|            0|            0|  0.00%|        """
  2524|         0|            0|            0|  0.00%|        Flattens a compound of nested iterables.
  2525|         0|            0|            0|  0.00%|
  2526|         0|            0|            0|  0.00%|        """
  2527|         0|            0|            0|  0.00%|        for elm in iter(iterable):
  2528|         0|            0|            0|  0.00%|            if hasattr(elm, '__iter__'):
  2529|         0|            0|            0|  0.00%|                for f in flatten_sequence(elm):
  2530|         0|            0|            0|  0.00%|                    yield f
  2531|         0|            0|            0|  0.00%|            else:
  2532|         0|            0|            0|  0.00%|                yield elm
  2533|         0|            0|            0|  0.00%|
  2534|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
  2535|         0|            0|            0|  0.00%|    inishape = a.shape
  2536|         0|            0|            0|  0.00%|    a = a.ravel()
  2537|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
  2538|         0|            0|            0|  0.00%|        out = np.array([tuple(flatten_sequence(d.item())) for d in a._data])
  2539|         0|            0|            0|  0.00%|        out = out.view(MaskedArray)
  2540|         0|            0|            0|  0.00%|        out._mask = np.array([tuple(flatten_sequence(d.item()))
  2541|         0|            0|            0|  0.00%|                              for d in getmaskarray(a)])
  2542|         0|            0|            0|  0.00%|    else:
  2543|         0|            0|            0|  0.00%|        out = np.array([tuple(flatten_sequence(d.item())) for d in a])
  2544|         0|            0|            0|  0.00%|    if len(inishape) > 1:
  2545|         0|            0|            0|  0.00%|        newshape = list(out.shape)
  2546|         0|            0|            0|  0.00%|        newshape[0] = inishape
  2547|         0|            0|            0|  0.00%|        out.shape = tuple(flatten_sequence(newshape))
  2548|         0|            0|            0|  0.00%|    return out
  2549|         0|            0|            0|  0.00%|
  2550|         0|            0|            0|  0.00%|
  2551|         0|            0|            0|  0.00%|def _arraymethod(funcname, onmask=True):
  2552|         0|            0|            0|  0.00%|    """
  2553|         0|            0|            0|  0.00%|    Return a class method wrapper around a basic array method.
  2554|         0|            0|            0|  0.00%|
  2555|         0|            0|            0|  0.00%|    Creates a class method which returns a masked array, where the new
  2556|         0|            0|            0|  0.00%|    ``_data`` array is the output of the corresponding basic method called
  2557|         0|            0|            0|  0.00%|    on the original ``_data``.
  2558|         0|            0|            0|  0.00%|
  2559|         0|            0|            0|  0.00%|    If `onmask` is True, the new mask is the output of the method called
  2560|         0|            0|            0|  0.00%|    on the initial mask. Otherwise, the new mask is just a reference
  2561|         0|            0|            0|  0.00%|    to the initial mask.
  2562|         0|            0|            0|  0.00%|
  2563|         0|            0|            0|  0.00%|    Parameters
  2564|         0|            0|            0|  0.00%|    ----------
  2565|         0|            0|            0|  0.00%|    funcname : str
  2566|         0|            0|            0|  0.00%|        Name of the function to apply on data.
  2567|         0|            0|            0|  0.00%|    onmask : bool
  2568|         0|            0|            0|  0.00%|        Whether the mask must be processed also (True) or left
  2569|         0|            0|            0|  0.00%|        alone (False). Default is True. Make available as `_onmask`
  2570|         0|            0|            0|  0.00%|        attribute.
  2571|         0|            0|            0|  0.00%|
  2572|         0|            0|            0|  0.00%|    Returns
  2573|         0|            0|            0|  0.00%|    -------
  2574|         0|            0|            0|  0.00%|    method : instancemethod
  2575|         0|            0|            0|  0.00%|        Class method wrapper of the specified basic array method.
  2576|         0|            0|            0|  0.00%|
  2577|         0|            0|            0|  0.00%|    """
  2578|         0|            0|            0|  0.00%|    def wrapped_method(self, *args, **params):
  2579|         0|            0|            0|  0.00%|        result = getattr(self._data, funcname)(*args, **params)
  2580|         0|            0|            0|  0.00%|        result = result.view(type(self))
  2581|         0|            0|            0|  0.00%|        result._update_from(self)
  2582|         0|            0|            0|  0.00%|        mask = self._mask
  2583|         0|            0|            0|  0.00%|        if not onmask:
  2584|         0|            0|            0|  0.00%|            result.__setmask__(mask)
  2585|         0|            0|            0|  0.00%|        elif mask is not nomask:
  2586|         0|            0|            0|  0.00%|            # __setmask__ makes a copy, which we don't want
  2587|         0|            0|            0|  0.00%|            result._mask = getattr(mask, funcname)(*args, **params)
  2588|         0|            0|            0|  0.00%|        return result
  2589|         0|            0|            0|  0.00%|    methdoc = getattr(ndarray, funcname, None) or getattr(np, funcname, None)
  2590|         0|            0|            0|  0.00%|    if methdoc is not None:
  2591|         0|            0|            0|  0.00%|        wrapped_method.__doc__ = methdoc.__doc__
  2592|         0|            0|            0|  0.00%|    wrapped_method.__name__ = funcname
  2593|         0|            0|            0|  0.00%|    return wrapped_method
  2594|         0|            0|            0|  0.00%|
  2595|         0|            0|            0|  0.00%|
  2596|         0|            0|            0|  0.00%|class MaskedIterator(object):
  2597|         0|            0|            0|  0.00%|    """
  2598|         0|            0|            0|  0.00%|    Flat iterator object to iterate over masked arrays.
  2599|         0|            0|            0|  0.00%|
  2600|         0|            0|            0|  0.00%|    A `MaskedIterator` iterator is returned by ``x.flat`` for any masked array
  2601|         0|            0|            0|  0.00%|    `x`. It allows iterating over the array as if it were a 1-D array,
  2602|         0|            0|            0|  0.00%|    either in a for-loop or by calling its `next` method.
  2603|         0|            0|            0|  0.00%|
  2604|         0|            0|            0|  0.00%|    Iteration is done in C-contiguous style, with the last index varying the
  2605|         0|            0|            0|  0.00%|    fastest. The iterator can also be indexed using basic slicing or
  2606|         0|            0|            0|  0.00%|    advanced indexing.
  2607|         0|            0|            0|  0.00%|
  2608|         0|            0|            0|  0.00%|    See Also
  2609|         0|            0|            0|  0.00%|    --------
  2610|         0|            0|            0|  0.00%|    MaskedArray.flat : Return a flat iterator over an array.
  2611|         0|            0|            0|  0.00%|    MaskedArray.flatten : Returns a flattened copy of an array.
  2612|         0|            0|            0|  0.00%|
  2613|         0|            0|            0|  0.00%|    Notes
  2614|         0|            0|            0|  0.00%|    -----
  2615|         0|            0|            0|  0.00%|    `MaskedIterator` is not exported by the `ma` module. Instead of
  2616|         0|            0|            0|  0.00%|    instantiating a `MaskedIterator` directly, use `MaskedArray.flat`.
  2617|         0|            0|            0|  0.00%|
  2618|         0|            0|            0|  0.00%|    Examples
  2619|         0|            0|            0|  0.00%|    --------
  2620|         0|            0|            0|  0.00%|    >>> x = np.ma.array(arange(6).reshape(2, 3))
  2621|         0|            0|            0|  0.00%|    >>> fl = x.flat
  2622|         0|            0|            0|  0.00%|    >>> type(fl)
  2623|         0|            0|            0|  0.00%|    <class 'numpy.ma.core.MaskedIterator'>
  2624|         0|            0|            0|  0.00%|    >>> for item in fl:
  2625|         0|            0|            0|  0.00%|    ...     print(item)
  2626|         0|            0|            0|  0.00%|    ...
  2627|         0|            0|            0|  0.00%|    0
  2628|         0|            0|            0|  0.00%|    1
  2629|         0|            0|            0|  0.00%|    2
  2630|         0|            0|            0|  0.00%|    3
  2631|         0|            0|            0|  0.00%|    4
  2632|         0|            0|            0|  0.00%|    5
  2633|         0|            0|            0|  0.00%|
  2634|         0|            0|            0|  0.00%|    Extracting more than a single element b indexing the `MaskedIterator`
  2635|         0|            0|            0|  0.00%|    returns a masked array:
  2636|         0|            0|            0|  0.00%|
  2637|         0|            0|            0|  0.00%|    >>> fl[2:4]
  2638|         0|            0|            0|  0.00%|    masked_array(data = [2 3],
  2639|         0|            0|            0|  0.00%|                 mask = False,
  2640|         0|            0|            0|  0.00%|           fill_value = 999999)
  2641|         0|            0|            0|  0.00%|
  2642|         0|            0|            0|  0.00%|    """
  2643|         0|            0|            0|  0.00%|
  2644|         0|            0|            0|  0.00%|    def __init__(self, ma):
  2645|         0|            0|            0|  0.00%|        self.ma = ma
  2646|         0|            0|            0|  0.00%|        self.dataiter = ma._data.flat
  2647|         0|            0|            0|  0.00%|
  2648|         0|            0|            0|  0.00%|        if ma._mask is nomask:
  2649|         0|            0|            0|  0.00%|            self.maskiter = None
  2650|         0|            0|            0|  0.00%|        else:
  2651|         0|            0|            0|  0.00%|            self.maskiter = ma._mask.flat
  2652|         0|            0|            0|  0.00%|
  2653|         0|            0|            0|  0.00%|    def __iter__(self):
  2654|         0|            0|            0|  0.00%|        return self
  2655|         0|            0|            0|  0.00%|
  2656|         0|            0|            0|  0.00%|    def __getitem__(self, indx):
  2657|         0|            0|            0|  0.00%|        result = self.dataiter.__getitem__(indx).view(type(self.ma))
  2658|         0|            0|            0|  0.00%|        if self.maskiter is not None:
  2659|         0|            0|            0|  0.00%|            _mask = self.maskiter.__getitem__(indx)
  2660|         0|            0|            0|  0.00%|            if isinstance(_mask, ndarray):
  2661|         0|            0|            0|  0.00%|                # set shape to match that of data; this is needed for matrices
  2662|         0|            0|            0|  0.00%|                _mask.shape = result.shape
  2663|         0|            0|            0|  0.00%|                result._mask = _mask
  2664|         0|            0|            0|  0.00%|            elif isinstance(_mask, np.void):
  2665|         0|            0|            0|  0.00%|                return mvoid(result, mask=_mask, hardmask=self.ma._hardmask)
  2666|         0|            0|            0|  0.00%|            elif _mask:  # Just a scalar, masked
  2667|         0|            0|            0|  0.00%|                return masked
  2668|         0|            0|            0|  0.00%|        return result
  2669|         0|            0|            0|  0.00%|
  2670|         0|            0|            0|  0.00%|    # This won't work if ravel makes a copy
  2671|         0|            0|            0|  0.00%|    def __setitem__(self, index, value):
  2672|         0|            0|            0|  0.00%|        self.dataiter[index] = getdata(value)
  2673|         0|            0|            0|  0.00%|        if self.maskiter is not None:
  2674|         0|            0|            0|  0.00%|            self.maskiter[index] = getmaskarray(value)
  2675|         0|            0|            0|  0.00%|
  2676|         0|            0|            0|  0.00%|    def __next__(self):
  2677|         0|            0|            0|  0.00%|        """
  2678|         0|            0|            0|  0.00%|        Return the next value, or raise StopIteration.
  2679|         0|            0|            0|  0.00%|
  2680|         0|            0|            0|  0.00%|        Examples
  2681|         0|            0|            0|  0.00%|        --------
  2682|         0|            0|            0|  0.00%|        >>> x = np.ma.array([3, 2], mask=[0, 1])
  2683|         0|            0|            0|  0.00%|        >>> fl = x.flat
  2684|         0|            0|            0|  0.00%|        >>> fl.next()
  2685|         0|            0|            0|  0.00%|        3
  2686|         0|            0|            0|  0.00%|        >>> fl.next()
  2687|         0|            0|            0|  0.00%|        masked
  2688|         0|            0|            0|  0.00%|        >>> fl.next()
  2689|         0|            0|            0|  0.00%|        Traceback (most recent call last):
  2690|         0|            0|            0|  0.00%|          File "<stdin>", line 1, in <module>
  2691|         0|            0|            0|  0.00%|          File "/home/ralf/python/numpy/numpy/ma/core.py", line 2243, in next
  2692|         0|            0|            0|  0.00%|            d = self.dataiter.next()
  2693|         0|            0|            0|  0.00%|        StopIteration
  2694|         0|            0|            0|  0.00%|
  2695|         0|            0|            0|  0.00%|        """
  2696|         0|            0|            0|  0.00%|        d = next(self.dataiter)
  2697|         0|            0|            0|  0.00%|        if self.maskiter is not None:
  2698|         0|            0|            0|  0.00%|            m = next(self.maskiter)
  2699|         0|            0|            0|  0.00%|            if isinstance(m, np.void):
  2700|         0|            0|            0|  0.00%|                return mvoid(d, mask=m, hardmask=self.ma._hardmask)
  2701|         0|            0|            0|  0.00%|            elif m:  # Just a scalar, masked
  2702|         0|            0|            0|  0.00%|                return masked
  2703|         0|            0|            0|  0.00%|        return d
  2704|         0|            0|            0|  0.00%|
  2705|         0|            0|            0|  0.00%|    next = __next__
  2706|         0|            0|            0|  0.00%|
  2707|         0|            0|            0|  0.00%|
  2708|         0|            0|            0|  0.00%|class MaskedArray(ndarray):
  2709|         0|            0|            0|  0.00%|    """
  2710|         0|            0|            0|  0.00%|    An array class with possibly masked values.
  2711|         0|            0|            0|  0.00%|
  2712|         0|            0|            0|  0.00%|    Masked values of True exclude the corresponding element from any
  2713|         0|            0|            0|  0.00%|    computation.
  2714|         0|            0|            0|  0.00%|
  2715|         0|            0|            0|  0.00%|    Construction::
  2716|         0|            0|            0|  0.00%|
  2717|         0|            0|            0|  0.00%|      x = MaskedArray(data, mask=nomask, dtype=None, copy=False, subok=True,
  2718|         0|            0|            0|  0.00%|                      ndmin=0, fill_value=None, keep_mask=True, hard_mask=None,
  2719|         0|            0|            0|  0.00%|                      shrink=True, order=None)
  2720|         0|            0|            0|  0.00%|
  2721|         0|            0|            0|  0.00%|    Parameters
  2722|         0|            0|            0|  0.00%|    ----------
  2723|         0|            0|            0|  0.00%|    data : array_like
  2724|         0|            0|            0|  0.00%|        Input data.
  2725|         0|            0|            0|  0.00%|    mask : sequence, optional
  2726|         0|            0|            0|  0.00%|        Mask. Must be convertible to an array of booleans with the same
  2727|         0|            0|            0|  0.00%|        shape as `data`. True indicates a masked (i.e. invalid) data.
  2728|         0|            0|            0|  0.00%|    dtype : dtype, optional
  2729|         0|            0|            0|  0.00%|        Data type of the output.
  2730|         0|            0|            0|  0.00%|        If `dtype` is None, the type of the data argument (``data.dtype``)
  2731|         0|            0|            0|  0.00%|        is used. If `dtype` is not None and different from ``data.dtype``,
  2732|         0|            0|            0|  0.00%|        a copy is performed.
  2733|         0|            0|            0|  0.00%|    copy : bool, optional
  2734|         0|            0|            0|  0.00%|        Whether to copy the input data (True), or to use a reference instead.
  2735|         0|            0|            0|  0.00%|        Default is False.
  2736|         0|            0|            0|  0.00%|    subok : bool, optional
  2737|         0|            0|            0|  0.00%|        Whether to return a subclass of `MaskedArray` if possible (True) or a
  2738|         0|            0|            0|  0.00%|        plain `MaskedArray`. Default is True.
  2739|         0|            0|            0|  0.00%|    ndmin : int, optional
  2740|         0|            0|            0|  0.00%|        Minimum number of dimensions. Default is 0.
  2741|         0|            0|            0|  0.00%|    fill_value : scalar, optional
  2742|         0|            0|            0|  0.00%|        Value used to fill in the masked values when necessary.
  2743|         0|            0|            0|  0.00%|        If None, a default based on the data-type is used.
  2744|         0|            0|            0|  0.00%|    keep_mask : bool, optional
  2745|         0|            0|            0|  0.00%|        Whether to combine `mask` with the mask of the input data, if any
  2746|         0|            0|            0|  0.00%|        (True), or to use only `mask` for the output (False). Default is True.
  2747|         0|            0|            0|  0.00%|    hard_mask : bool, optional
  2748|         0|            0|            0|  0.00%|        Whether to use a hard mask or not. With a hard mask, masked values
  2749|         0|            0|            0|  0.00%|        cannot be unmasked. Default is False.
  2750|         0|            0|            0|  0.00%|    shrink : bool, optional
  2751|         0|            0|            0|  0.00%|        Whether to force compression of an empty mask. Default is True.
  2752|         0|            0|            0|  0.00%|    order : {'C', 'F', 'A'}, optional
  2753|         0|            0|            0|  0.00%|        Specify the order of the array.  If order is 'C', then the array
  2754|         0|            0|            0|  0.00%|        will be in C-contiguous order (last-index varies the fastest).
  2755|         0|            0|            0|  0.00%|        If order is 'F', then the returned array will be in
  2756|         0|            0|            0|  0.00%|        Fortran-contiguous order (first-index varies the fastest).
  2757|         0|            0|            0|  0.00%|        If order is 'A' (default), then the returned array may be
  2758|         0|            0|            0|  0.00%|        in any order (either C-, Fortran-contiguous, or even discontiguous),
  2759|         0|            0|            0|  0.00%|        unless a copy is required, in which case it will be C-contiguous.
  2760|         0|            0|            0|  0.00%|
  2761|         0|            0|            0|  0.00%|    """
  2762|         0|            0|            0|  0.00%|
  2763|         0|            0|            0|  0.00%|    __array_priority__ = 15
  2764|         0|            0|            0|  0.00%|    _defaultmask = nomask
  2765|         0|            0|            0|  0.00%|    _defaulthardmask = False
  2766|         0|            0|            0|  0.00%|    _baseclass = ndarray
  2767|         0|            0|            0|  0.00%|
  2768|         0|            0|            0|  0.00%|    # Maximum number of elements per axis used when printing an array. The
  2769|         0|            0|            0|  0.00%|    # 1d case is handled separately because we need more values in this case.
  2770|         0|            0|            0|  0.00%|    _print_width = 100
  2771|         0|            0|            0|  0.00%|    _print_width_1d = 1500
  2772|         0|            0|            0|  0.00%|
  2773|         0|            0|            0|  0.00%|    def __new__(cls, data=None, mask=nomask, dtype=None, copy=False,
  2774|         0|            0|            0|  0.00%|                subok=True, ndmin=0, fill_value=None, keep_mask=True,
  2775|         0|            0|            0|  0.00%|                hard_mask=None, shrink=True, order=None, **options):
  2776|         0|            0|            0|  0.00%|        """
  2777|         0|            0|            0|  0.00%|        Create a new masked array from scratch.
  2778|         0|            0|            0|  0.00%|
  2779|         0|            0|            0|  0.00%|        Notes
  2780|         0|            0|            0|  0.00%|        -----
  2781|         0|            0|            0|  0.00%|        A masked array can also be created by taking a .view(MaskedArray).
  2782|         0|            0|            0|  0.00%|
  2783|         0|            0|            0|  0.00%|        """
  2784|         0|            0|            0|  0.00%|        # Process data.
  2785|         0|            0|            0|  0.00%|        _data = np.array(data, dtype=dtype, copy=copy,
  2786|         0|            0|            0|  0.00%|                         order=order, subok=True, ndmin=ndmin)
  2787|         0|            0|            0|  0.00%|        _baseclass = getattr(data, '_baseclass', type(_data))
  2788|         0|            0|            0|  0.00%|        # Check that we're not erasing the mask.
  2789|         0|            0|            0|  0.00%|        if isinstance(data, MaskedArray) and (data.shape != _data.shape):
  2790|         0|            0|            0|  0.00%|            copy = True
  2791|         0|            0|            0|  0.00%|
  2792|         0|            0|            0|  0.00%|        # Here, we copy the _view_, so that we can attach new properties to it
  2793|         0|            0|            0|  0.00%|        # we must never do .view(MaskedConstant), as that would create a new
  2794|         0|            0|            0|  0.00%|        # instance of np.ma.masked, which make identity comparison fail
  2795|         0|            0|            0|  0.00%|        if isinstance(data, cls) and subok and not isinstance(data, MaskedConstant):
  2796|         0|            0|            0|  0.00%|            _data = ndarray.view(_data, type(data))
  2797|         0|            0|            0|  0.00%|        else:
  2798|         0|            0|            0|  0.00%|            _data = ndarray.view(_data, cls)
  2799|         0|            0|            0|  0.00%|        # Backwards compatibility w/ numpy.core.ma.
  2800|         0|            0|            0|  0.00%|        if hasattr(data, '_mask') and not isinstance(data, ndarray):
  2801|         0|            0|            0|  0.00%|            _data._mask = data._mask
  2802|         0|            0|            0|  0.00%|            # FIXME _sharedmask is never used.
  2803|         0|            0|            0|  0.00%|            _sharedmask = True
  2804|         0|            0|            0|  0.00%|        # Process mask.
  2805|         0|            0|            0|  0.00%|        # Type of the mask
  2806|         0|            0|            0|  0.00%|        mdtype = make_mask_descr(_data.dtype)
  2807|         0|            0|            0|  0.00%|
  2808|         0|            0|            0|  0.00%|        if mask is nomask:
  2809|         0|            0|            0|  0.00%|            # Case 1. : no mask in input.
  2810|         0|            0|            0|  0.00%|            # Erase the current mask ?
  2811|         0|            0|            0|  0.00%|            if not keep_mask:
  2812|         0|            0|            0|  0.00%|                # With a reduced version
  2813|         0|            0|            0|  0.00%|                if shrink:
  2814|         0|            0|            0|  0.00%|                    _data._mask = nomask
  2815|         0|            0|            0|  0.00%|                # With full version
  2816|         0|            0|            0|  0.00%|                else:
  2817|         0|            0|            0|  0.00%|                    _data._mask = np.zeros(_data.shape, dtype=mdtype)
  2818|         0|            0|            0|  0.00%|            # Check whether we missed something
  2819|         0|            0|            0|  0.00%|            elif isinstance(data, (tuple, list)):
  2820|         0|            0|            0|  0.00%|                try:
  2821|         0|            0|            0|  0.00%|                    # If data is a sequence of masked array
  2822|         0|            0|            0|  0.00%|                    mask = np.array([getmaskarray(m) for m in data],
  2823|         0|            0|            0|  0.00%|                                    dtype=mdtype)
  2824|         0|            0|            0|  0.00%|                except ValueError:
  2825|         0|            0|            0|  0.00%|                    # If data is nested
  2826|         0|            0|            0|  0.00%|                    mask = nomask
  2827|         0|            0|            0|  0.00%|                # Force shrinking of the mask if needed (and possible)
  2828|         0|            0|            0|  0.00%|                if (mdtype == MaskType) and mask.any():
  2829|         0|            0|            0|  0.00%|                    _data._mask = mask
  2830|         0|            0|            0|  0.00%|                    _data._sharedmask = False
  2831|         0|            0|            0|  0.00%|            else:
  2832|         0|            0|            0|  0.00%|                _data._sharedmask = not copy
  2833|         0|            0|            0|  0.00%|                if copy:
  2834|         0|            0|            0|  0.00%|                    _data._mask = _data._mask.copy()
  2835|         0|            0|            0|  0.00%|                    # Reset the shape of the original mask
  2836|         0|            0|            0|  0.00%|                    if getmask(data) is not nomask:
  2837|         0|            0|            0|  0.00%|                        data._mask.shape = data.shape
  2838|         0|            0|            0|  0.00%|        else:
  2839|         0|            0|            0|  0.00%|            # Case 2. : With a mask in input.
  2840|         0|            0|            0|  0.00%|            # If mask is boolean, create an array of True or False
  2841|         0|            0|            0|  0.00%|            if mask is True and mdtype == MaskType:
  2842|         0|            0|            0|  0.00%|                mask = np.ones(_data.shape, dtype=mdtype)
  2843|         0|            0|            0|  0.00%|            elif mask is False and mdtype == MaskType:
  2844|         0|            0|            0|  0.00%|                mask = np.zeros(_data.shape, dtype=mdtype)
  2845|         0|            0|            0|  0.00%|            else:
  2846|         0|            0|            0|  0.00%|                # Read the mask with the current mdtype
  2847|         0|            0|            0|  0.00%|                try:
  2848|         0|            0|            0|  0.00%|                    mask = np.array(mask, copy=copy, dtype=mdtype)
  2849|         0|            0|            0|  0.00%|                # Or assume it's a sequence of bool/int
  2850|         0|            0|            0|  0.00%|                except TypeError:
  2851|         0|            0|            0|  0.00%|                    mask = np.array([tuple([m] * len(mdtype)) for m in mask],
  2852|         0|            0|            0|  0.00%|                                    dtype=mdtype)
  2853|         0|            0|            0|  0.00%|            # Make sure the mask and the data have the same shape
  2854|         0|            0|            0|  0.00%|            if mask.shape != _data.shape:
  2855|         0|            0|            0|  0.00%|                (nd, nm) = (_data.size, mask.size)
  2856|         0|            0|            0|  0.00%|                if nm == 1:
  2857|         0|            0|            0|  0.00%|                    mask = np.resize(mask, _data.shape)
  2858|         0|            0|            0|  0.00%|                elif nm == nd:
  2859|         0|            0|            0|  0.00%|                    mask = np.reshape(mask, _data.shape)
  2860|         0|            0|            0|  0.00%|                else:
  2861|         0|            0|            0|  0.00%|                    msg = "Mask and data not compatible: data size is %i, " + \
  2862|         0|            0|            0|  0.00%|                          "mask size is %i."
  2863|         0|            0|            0|  0.00%|                    raise MaskError(msg % (nd, nm))
  2864|         0|            0|            0|  0.00%|                copy = True
  2865|         0|            0|            0|  0.00%|            # Set the mask to the new value
  2866|         0|            0|            0|  0.00%|            if _data._mask is nomask:
  2867|         0|            0|            0|  0.00%|                _data._mask = mask
  2868|         0|            0|            0|  0.00%|                _data._sharedmask = not copy
  2869|         0|            0|            0|  0.00%|            else:
  2870|         0|            0|            0|  0.00%|                if not keep_mask:
  2871|         0|            0|            0|  0.00%|                    _data._mask = mask
  2872|         0|            0|            0|  0.00%|                    _data._sharedmask = not copy
  2873|         0|            0|            0|  0.00%|                else:
  2874|         0|            0|            0|  0.00%|                    if _data.dtype.names is not None:
  2875|         0|            0|            0|  0.00%|                        def _recursive_or(a, b):
  2876|         0|            0|            0|  0.00%|                            "do a|=b on each field of a, recursively"
  2877|         0|            0|            0|  0.00%|                            for name in a.dtype.names:
  2878|         0|            0|            0|  0.00%|                                (af, bf) = (a[name], b[name])
  2879|         0|            0|            0|  0.00%|                                if af.dtype.names is not None:
  2880|         0|            0|            0|  0.00%|                                    _recursive_or(af, bf)
  2881|         0|            0|            0|  0.00%|                                else:
  2882|         0|            0|            0|  0.00%|                                    af |= bf
  2883|         0|            0|            0|  0.00%|
  2884|         0|            0|            0|  0.00%|                        _recursive_or(_data._mask, mask)
  2885|         0|            0|            0|  0.00%|                    else:
  2886|         0|            0|            0|  0.00%|                        _data._mask = np.logical_or(mask, _data._mask)
  2887|         0|            0|            0|  0.00%|                    _data._sharedmask = False
  2888|         0|            0|            0|  0.00%|        # Update fill_value.
  2889|         0|            0|            0|  0.00%|        if fill_value is None:
  2890|         0|            0|            0|  0.00%|            fill_value = getattr(data, '_fill_value', None)
  2891|         0|            0|            0|  0.00%|        # But don't run the check unless we have something to check.
  2892|         0|            0|            0|  0.00%|        if fill_value is not None:
  2893|         0|            0|            0|  0.00%|            _data._fill_value = _check_fill_value(fill_value, _data.dtype)
  2894|         0|            0|            0|  0.00%|        # Process extra options ..
  2895|         0|            0|            0|  0.00%|        if hard_mask is None:
  2896|         0|            0|            0|  0.00%|            _data._hardmask = getattr(data, '_hardmask', False)
  2897|         0|            0|            0|  0.00%|        else:
  2898|         0|            0|            0|  0.00%|            _data._hardmask = hard_mask
  2899|         0|            0|            0|  0.00%|        _data._baseclass = _baseclass
  2900|         0|            0|            0|  0.00%|        return _data
  2901|         0|            0|            0|  0.00%|
  2902|         0|            0|            0|  0.00%|
  2903|         0|            0|            0|  0.00%|    def _update_from(self, obj):
  2904|         0|            0|            0|  0.00%|        """
  2905|         0|            0|            0|  0.00%|        Copies some attributes of obj to self.
  2906|         0|            0|            0|  0.00%|
  2907|         0|            0|            0|  0.00%|        """
  2908|         0|            0|            0|  0.00%|        if isinstance(obj, ndarray):
  2909|         0|            0|            0|  0.00%|            _baseclass = type(obj)
  2910|         0|            0|            0|  0.00%|        else:
  2911|         0|            0|            0|  0.00%|            _baseclass = ndarray
  2912|         0|            0|            0|  0.00%|        # We need to copy the _basedict to avoid backward propagation
  2913|         0|            0|            0|  0.00%|        _optinfo = {}
  2914|         0|            0|            0|  0.00%|        _optinfo.update(getattr(obj, '_optinfo', {}))
  2915|         0|            0|            0|  0.00%|        _optinfo.update(getattr(obj, '_basedict', {}))
  2916|         0|            0|            0|  0.00%|        if not isinstance(obj, MaskedArray):
  2917|         0|            0|            0|  0.00%|            _optinfo.update(getattr(obj, '__dict__', {}))
  2918|         0|            0|            0|  0.00%|        _dict = dict(_fill_value=getattr(obj, '_fill_value', None),
  2919|         0|            0|            0|  0.00%|                     _hardmask=getattr(obj, '_hardmask', False),
  2920|         0|            0|            0|  0.00%|                     _sharedmask=getattr(obj, '_sharedmask', False),
  2921|         0|            0|            0|  0.00%|                     _isfield=getattr(obj, '_isfield', False),
  2922|         0|            0|            0|  0.00%|                     _baseclass=getattr(obj, '_baseclass', _baseclass),
  2923|         0|            0|            0|  0.00%|                     _optinfo=_optinfo,
  2924|         0|            0|            0|  0.00%|                     _basedict=_optinfo)
  2925|         0|            0|            0|  0.00%|        self.__dict__.update(_dict)
  2926|         0|            0|            0|  0.00%|        self.__dict__.update(_optinfo)
  2927|         0|            0|            0|  0.00%|        return
  2928|         0|            0|            0|  0.00%|
  2929|         0|            0|            0|  0.00%|    def __array_finalize__(self, obj):
  2930|         0|            0|            0|  0.00%|        """
  2931|         0|            0|            0|  0.00%|        Finalizes the masked array.
  2932|         0|            0|            0|  0.00%|
  2933|         0|            0|            0|  0.00%|        """
  2934|         0|            0|            0|  0.00%|        # Get main attributes.
  2935|         0|            0|            0|  0.00%|        self._update_from(obj)
  2936|         0|            0|            0|  0.00%|
  2937|         0|            0|            0|  0.00%|        # We have to decide how to initialize self.mask, based on
  2938|         0|            0|            0|  0.00%|        # obj.mask. This is very difficult.  There might be some
  2939|         0|            0|            0|  0.00%|        # correspondence between the elements in the array we are being
  2940|         0|            0|            0|  0.00%|        # created from (= obj) and us. Or there might not. This method can
  2941|         0|            0|            0|  0.00%|        # be called in all kinds of places for all kinds of reasons -- could
  2942|         0|            0|            0|  0.00%|        # be empty_like, could be slicing, could be a ufunc, could be a view.
  2943|         0|            0|            0|  0.00%|        # The numpy subclassing interface simply doesn't give us any way
  2944|         0|            0|            0|  0.00%|        # to know, which means that at best this method will be based on
  2945|         0|            0|            0|  0.00%|        # guesswork and heuristics. To make things worse, there isn't even any
  2946|         0|            0|            0|  0.00%|        # clear consensus about what the desired behavior is. For instance,
  2947|         0|            0|            0|  0.00%|        # most users think that np.empty_like(marr) -- which goes via this
  2948|         0|            0|            0|  0.00%|        # method -- should return a masked array with an empty mask (see
  2949|         0|            0|            0|  0.00%|        # gh-3404 and linked discussions), but others disagree, and they have
  2950|         0|            0|            0|  0.00%|        # existing code which depends on empty_like returning an array that
  2951|         0|            0|            0|  0.00%|        # matches the input mask.
  2952|         0|            0|            0|  0.00%|        #
  2953|         0|            0|            0|  0.00%|        # Historically our algorithm was: if the template object mask had the
  2954|         0|            0|            0|  0.00%|        # same *number of elements* as us, then we used *it's mask object
  2955|         0|            0|            0|  0.00%|        # itself* as our mask, so that writes to us would also write to the
  2956|         0|            0|            0|  0.00%|        # original array. This is horribly broken in multiple ways.
  2957|         0|            0|            0|  0.00%|        #
  2958|         0|            0|            0|  0.00%|        # Now what we do instead is, if the template object mask has the same
  2959|         0|            0|            0|  0.00%|        # number of elements as us, and we do not have the same base pointer
  2960|         0|            0|            0|  0.00%|        # as the template object (b/c views like arr[...] should keep the same
  2961|         0|            0|            0|  0.00%|        # mask), then we make a copy of the template object mask and use
  2962|         0|            0|            0|  0.00%|        # that. This is also horribly broken but somewhat less so. Maybe.
  2963|         0|            0|            0|  0.00%|        if isinstance(obj, ndarray):
  2964|         0|            0|            0|  0.00%|            # XX: This looks like a bug -- shouldn't it check self.dtype
  2965|         0|            0|            0|  0.00%|            # instead?
  2966|         0|            0|            0|  0.00%|            if obj.dtype.names is not None:
  2967|         0|            0|            0|  0.00%|                _mask = getmaskarray(obj)
  2968|         0|            0|            0|  0.00%|            else:
  2969|         0|            0|            0|  0.00%|                _mask = getmask(obj)
  2970|         0|            0|            0|  0.00%|
  2971|         0|            0|            0|  0.00%|            # If self and obj point to exactly the same data, then probably
  2972|         0|            0|            0|  0.00%|            # self is a simple view of obj (e.g., self = obj[...]), so they
  2973|         0|            0|            0|  0.00%|            # should share the same mask. (This isn't 100% reliable, e.g. self
  2974|         0|            0|            0|  0.00%|            # could be the first row of obj, or have strange strides, but as a
  2975|         0|            0|            0|  0.00%|            # heuristic it's not bad.) In all other cases, we make a copy of
  2976|         0|            0|            0|  0.00%|            # the mask, so that future modifications to 'self' do not end up
  2977|         0|            0|            0|  0.00%|            # side-effecting 'obj' as well.
  2978|         0|            0|            0|  0.00%|            if (_mask is not nomask and obj.__array_interface__["data"][0]
  2979|         0|            0|            0|  0.00%|                    != self.__array_interface__["data"][0]):
  2980|         0|            0|            0|  0.00%|                # We should make a copy. But we could get here via astype,
  2981|         0|            0|            0|  0.00%|                # in which case the mask might need a new dtype as well
  2982|         0|            0|            0|  0.00%|                # (e.g., changing to or from a structured dtype), and the
  2983|         0|            0|            0|  0.00%|                # order could have changed. So, change the mask type if
  2984|         0|            0|            0|  0.00%|                # needed and use astype instead of copy.
  2985|         0|            0|            0|  0.00%|                if self.dtype == obj.dtype:
  2986|         0|            0|            0|  0.00%|                    _mask_dtype = _mask.dtype
  2987|         0|            0|            0|  0.00%|                else:
  2988|         0|            0|            0|  0.00%|                    _mask_dtype = make_mask_descr(self.dtype)
  2989|         0|            0|            0|  0.00%|
  2990|         0|            0|            0|  0.00%|                if self.flags.c_contiguous:
  2991|         0|            0|            0|  0.00%|                    order = "C"
  2992|         0|            0|            0|  0.00%|                elif self.flags.f_contiguous:
  2993|         0|            0|            0|  0.00%|                    order = "F"
  2994|         0|            0|            0|  0.00%|                else:
  2995|         0|            0|            0|  0.00%|                    order = "K"
  2996|         0|            0|            0|  0.00%|
  2997|         0|            0|            0|  0.00%|                _mask = _mask.astype(_mask_dtype, order)
  2998|         0|            0|            0|  0.00%|            else:
  2999|         0|            0|            0|  0.00%|                # Take a view so shape changes, etc., do not propagate back.
  3000|         0|            0|            0|  0.00%|                _mask = _mask.view()
  3001|         0|            0|            0|  0.00%|        else:
  3002|         0|            0|            0|  0.00%|            _mask = nomask
  3003|         0|            0|            0|  0.00%|
  3004|         0|            0|            0|  0.00%|        self._mask = _mask
  3005|         0|            0|            0|  0.00%|        # Finalize the mask
  3006|         0|            0|            0|  0.00%|        if self._mask is not nomask:
  3007|         0|            0|            0|  0.00%|            try:
  3008|         0|            0|            0|  0.00%|                self._mask.shape = self.shape
  3009|         0|            0|            0|  0.00%|            except ValueError:
  3010|         0|            0|            0|  0.00%|                self._mask = nomask
  3011|         0|            0|            0|  0.00%|            except (TypeError, AttributeError):
  3012|         0|            0|            0|  0.00%|                # When _mask.shape is not writable (because it's a void)
  3013|         0|            0|            0|  0.00%|                pass
  3014|         0|            0|            0|  0.00%|
  3015|         0|            0|            0|  0.00%|        # Finalize the fill_value
  3016|         0|            0|            0|  0.00%|        if self._fill_value is not None:
  3017|         0|            0|            0|  0.00%|            self._fill_value = _check_fill_value(self._fill_value, self.dtype)
  3018|         0|            0|            0|  0.00%|        elif self.dtype.names is not None:
  3019|         0|            0|            0|  0.00%|            # Finalize the default fill_value for structured arrays
  3020|         0|            0|            0|  0.00%|            self._fill_value = _check_fill_value(None, self.dtype)
  3021|         0|            0|            0|  0.00%|
  3022|         0|            0|            0|  0.00%|    def __array_wrap__(self, obj, context=None):
  3023|         0|            0|            0|  0.00%|        """
  3024|         0|            0|            0|  0.00%|        Special hook for ufuncs.
  3025|         0|            0|            0|  0.00%|
  3026|         0|            0|            0|  0.00%|        Wraps the numpy array and sets the mask according to context.
  3027|         0|            0|            0|  0.00%|
  3028|         0|            0|            0|  0.00%|        """
  3029|         0|            0|            0|  0.00%|        if obj is self:  # for in-place operations
  3030|         0|            0|            0|  0.00%|            result = obj
  3031|         0|            0|            0|  0.00%|        else:
  3032|         0|            0|            0|  0.00%|            result = obj.view(type(self))
  3033|         0|            0|            0|  0.00%|            result._update_from(self)
  3034|         0|            0|            0|  0.00%|
  3035|         0|            0|            0|  0.00%|        if context is not None:
  3036|         0|            0|            0|  0.00%|            result._mask = result._mask.copy()
  3037|         0|            0|            0|  0.00%|            func, args, out_i = context
  3038|         0|            0|            0|  0.00%|            # args sometimes contains outputs (gh-10459), which we don't want
  3039|         0|            0|            0|  0.00%|            input_args = args[:func.nin]
  3040|         0|            0|            0|  0.00%|            m = reduce(mask_or, [getmaskarray(arg) for arg in input_args])
  3041|         0|            0|            0|  0.00%|            # Get the domain mask
  3042|         0|            0|            0|  0.00%|            domain = ufunc_domain.get(func, None)
  3043|         0|            0|            0|  0.00%|            if domain is not None:
  3044|         0|            0|            0|  0.00%|                # Take the domain, and make sure it's a ndarray
  3045|         0|            0|            0|  0.00%|                with np.errstate(divide='ignore', invalid='ignore'):
  3046|         0|            0|            0|  0.00%|                    d = filled(domain(*input_args), True)
  3047|         0|            0|            0|  0.00%|
  3048|         0|            0|            0|  0.00%|                if d.any():
  3049|         0|            0|            0|  0.00%|                    # Fill the result where the domain is wrong
  3050|         0|            0|            0|  0.00%|                    try:
  3051|         0|            0|            0|  0.00%|                        # Binary domain: take the last value
  3052|         0|            0|            0|  0.00%|                        fill_value = ufunc_fills[func][-1]
  3053|         0|            0|            0|  0.00%|                    except TypeError:
  3054|         0|            0|            0|  0.00%|                        # Unary domain: just use this one
  3055|         0|            0|            0|  0.00%|                        fill_value = ufunc_fills[func]
  3056|         0|            0|            0|  0.00%|                    except KeyError:
  3057|         0|            0|            0|  0.00%|                        # Domain not recognized, use fill_value instead
  3058|         0|            0|            0|  0.00%|                        fill_value = self.fill_value
  3059|         0|            0|            0|  0.00%|
  3060|         0|            0|            0|  0.00%|                    np.copyto(result, fill_value, where=d)
  3061|         0|            0|            0|  0.00%|
  3062|         0|            0|            0|  0.00%|                    # Update the mask
  3063|         0|            0|            0|  0.00%|                    if m is nomask:
  3064|         0|            0|            0|  0.00%|                        m = d
  3065|         0|            0|            0|  0.00%|                    else:
  3066|         0|            0|            0|  0.00%|                        # Don't modify inplace, we risk back-propagation
  3067|         0|            0|            0|  0.00%|                        m = (m | d)
  3068|         0|            0|            0|  0.00%|
  3069|         0|            0|            0|  0.00%|            # Make sure the mask has the proper size
  3070|         0|            0|            0|  0.00%|            if result is not self and result.shape == () and m:
  3071|         0|            0|            0|  0.00%|                return masked
  3072|         0|            0|            0|  0.00%|            else:
  3073|         0|            0|            0|  0.00%|                result._mask = m
  3074|         0|            0|            0|  0.00%|                result._sharedmask = False
  3075|         0|            0|            0|  0.00%|
  3076|         0|            0|            0|  0.00%|        return result
  3077|         0|            0|            0|  0.00%|
  3078|         0|            0|            0|  0.00%|    def view(self, dtype=None, type=None, fill_value=None):
  3079|         0|            0|            0|  0.00%|        """
  3080|         0|            0|            0|  0.00%|        Return a view of the MaskedArray data
  3081|         0|            0|            0|  0.00%|
  3082|         0|            0|            0|  0.00%|        Parameters
  3083|         0|            0|            0|  0.00%|        ----------
  3084|         0|            0|            0|  0.00%|        dtype : data-type or ndarray sub-class, optional
  3085|         0|            0|            0|  0.00%|            Data-type descriptor of the returned view, e.g., float32 or int16.
  3086|         0|            0|            0|  0.00%|            The default, None, results in the view having the same data-type
  3087|         0|            0|            0|  0.00%|            as `a`. As with ``ndarray.view``, dtype can also be specified as
  3088|         0|            0|            0|  0.00%|            an ndarray sub-class, which then specifies the type of the
  3089|         0|            0|            0|  0.00%|            returned object (this is equivalent to setting the ``type``
  3090|         0|            0|            0|  0.00%|            parameter).
  3091|         0|            0|            0|  0.00%|        type : Python type, optional
  3092|         0|            0|            0|  0.00%|            Type of the returned view, either ndarray or a subclass.  The
  3093|         0|            0|            0|  0.00%|            default None results in type preservation.
  3094|         0|            0|            0|  0.00%|
  3095|         0|            0|            0|  0.00%|        Notes
  3096|         0|            0|            0|  0.00%|        -----
  3097|         0|            0|            0|  0.00%|
  3098|         0|            0|            0|  0.00%|        ``a.view()`` is used two different ways:
  3099|         0|            0|            0|  0.00%|
  3100|         0|            0|            0|  0.00%|        ``a.view(some_dtype)`` or ``a.view(dtype=some_dtype)`` constructs a view
  3101|         0|            0|            0|  0.00%|        of the array's memory with a different data-type.  This can cause a
  3102|         0|            0|            0|  0.00%|        reinterpretation of the bytes of memory.
  3103|         0|            0|            0|  0.00%|
  3104|         0|            0|            0|  0.00%|        ``a.view(ndarray_subclass)`` or ``a.view(type=ndarray_subclass)`` just
  3105|         0|            0|            0|  0.00%|        returns an instance of `ndarray_subclass` that looks at the same array
  3106|         0|            0|            0|  0.00%|        (same shape, dtype, etc.)  This does not cause a reinterpretation of the
  3107|         0|            0|            0|  0.00%|        memory.
  3108|         0|            0|            0|  0.00%|
  3109|         0|            0|            0|  0.00%|        If `fill_value` is not specified, but `dtype` is specified (and is not
  3110|         0|            0|            0|  0.00%|        an ndarray sub-class), the `fill_value` of the MaskedArray will be
  3111|         0|            0|            0|  0.00%|        reset. If neither `fill_value` nor `dtype` are specified (or if
  3112|         0|            0|            0|  0.00%|        `dtype` is an ndarray sub-class), then the fill value is preserved.
  3113|         0|            0|            0|  0.00%|        Finally, if `fill_value` is specified, but `dtype` is not, the fill
  3114|         0|            0|            0|  0.00%|        value is set to the specified value.
  3115|         0|            0|            0|  0.00%|
  3116|         0|            0|            0|  0.00%|        For ``a.view(some_dtype)``, if ``some_dtype`` has a different number of
  3117|         0|            0|            0|  0.00%|        bytes per entry than the previous dtype (for example, converting a
  3118|         0|            0|            0|  0.00%|        regular array to a structured array), then the behavior of the view
  3119|         0|            0|            0|  0.00%|        cannot be predicted just from the superficial appearance of ``a`` (shown
  3120|         0|            0|            0|  0.00%|        by ``print(a)``). It also depends on exactly how ``a`` is stored in
  3121|         0|            0|            0|  0.00%|        memory. Therefore if ``a`` is C-ordered versus fortran-ordered, versus
  3122|         0|            0|            0|  0.00%|        defined as a slice or transpose, etc., the view may give different
  3123|         0|            0|            0|  0.00%|        results.
  3124|         0|            0|            0|  0.00%|        """
  3125|         0|            0|            0|  0.00%|
  3126|         0|            0|            0|  0.00%|        if dtype is None:
  3127|         0|            0|            0|  0.00%|            if type is None:
  3128|         0|            0|            0|  0.00%|                output = ndarray.view(self)
  3129|         0|            0|            0|  0.00%|            else:
  3130|         0|            0|            0|  0.00%|                output = ndarray.view(self, type)
  3131|         0|            0|            0|  0.00%|        elif type is None:
  3132|         0|            0|            0|  0.00%|            try:
  3133|         0|            0|            0|  0.00%|                if issubclass(dtype, ndarray):
  3134|         0|            0|            0|  0.00%|                    output = ndarray.view(self, dtype)
  3135|         0|            0|            0|  0.00%|                    dtype = None
  3136|         0|            0|            0|  0.00%|                else:
  3137|         0|            0|            0|  0.00%|                    output = ndarray.view(self, dtype)
  3138|         0|            0|            0|  0.00%|            except TypeError:
  3139|         0|            0|            0|  0.00%|                output = ndarray.view(self, dtype)
  3140|         0|            0|            0|  0.00%|        else:
  3141|         0|            0|            0|  0.00%|            output = ndarray.view(self, dtype, type)
  3142|         0|            0|            0|  0.00%|
  3143|         0|            0|            0|  0.00%|        # also make the mask be a view (so attr changes to the view's
  3144|         0|            0|            0|  0.00%|        # mask do no affect original object's mask)
  3145|         0|            0|            0|  0.00%|        # (especially important to avoid affecting np.masked singleton)
  3146|         0|            0|            0|  0.00%|        if (getmask(output) is not nomask):
  3147|         0|            0|            0|  0.00%|            output._mask = output._mask.view()
  3148|         0|            0|            0|  0.00%|
  3149|         0|            0|            0|  0.00%|        # Make sure to reset the _fill_value if needed
  3150|         0|            0|            0|  0.00%|        if getattr(output, '_fill_value', None) is not None:
  3151|         0|            0|            0|  0.00%|            if fill_value is None:
  3152|         0|            0|            0|  0.00%|                if dtype is None:
  3153|         0|            0|            0|  0.00%|                    pass  # leave _fill_value as is
  3154|         0|            0|            0|  0.00%|                else:
  3155|         0|            0|            0|  0.00%|                    output._fill_value = None
  3156|         0|            0|            0|  0.00%|            else:
  3157|         0|            0|            0|  0.00%|                output.fill_value = fill_value
  3158|         0|            0|            0|  0.00%|        return output
  3159|         0|            0|            0|  0.00%|    view.__doc__ = ndarray.view.__doc__
  3160|         0|            0|            0|  0.00%|
  3161|         0|            0|            0|  0.00%|    def __getitem__(self, indx):
  3162|         0|            0|            0|  0.00%|        """
  3163|         0|            0|            0|  0.00%|        x.__getitem__(y) <==> x[y]
  3164|         0|            0|            0|  0.00%|
  3165|         0|            0|            0|  0.00%|        Return the item described by i, as a masked array.
  3166|         0|            0|            0|  0.00%|
  3167|         0|            0|            0|  0.00%|        """
  3168|         0|            0|            0|  0.00%|        # We could directly use ndarray.__getitem__ on self.
  3169|         0|            0|            0|  0.00%|        # But then we would have to modify __array_finalize__ to prevent the
  3170|         0|            0|            0|  0.00%|        # mask of being reshaped if it hasn't been set up properly yet
  3171|         0|            0|            0|  0.00%|        # So it's easier to stick to the current version
  3172|         0|            0|            0|  0.00%|        dout = self.data[indx]
  3173|         0|            0|            0|  0.00%|        _mask = self._mask
  3174|         0|            0|            0|  0.00%|
  3175|         0|            0|            0|  0.00%|        def _is_scalar(m):
  3176|         0|            0|            0|  0.00%|            return not isinstance(m, np.ndarray)
  3177|         0|            0|            0|  0.00%|
  3178|         0|            0|            0|  0.00%|        def _scalar_heuristic(arr, elem):
  3179|         0|            0|            0|  0.00%|            """
  3180|         0|            0|            0|  0.00%|            Return whether `elem` is a scalar result of indexing `arr`, or None
  3181|         0|            0|            0|  0.00%|            if undecidable without promoting nomask to a full mask
  3182|         0|            0|            0|  0.00%|            """
  3183|         0|            0|            0|  0.00%|            # obviously a scalar
  3184|         0|            0|            0|  0.00%|            if not isinstance(elem, np.ndarray):
  3185|         0|            0|            0|  0.00%|                return True
  3186|         0|            0|            0|  0.00%|
  3187|         0|            0|            0|  0.00%|            # object array scalar indexing can return anything
  3188|         0|            0|            0|  0.00%|            elif arr.dtype.type is np.object_:
  3189|         0|            0|            0|  0.00%|                if arr.dtype is not elem.dtype:
  3190|         0|            0|            0|  0.00%|                    # elem is an array, but dtypes do not match, so must be
  3191|         0|            0|            0|  0.00%|                    # an element
  3192|         0|            0|            0|  0.00%|                    return True
  3193|         0|            0|            0|  0.00%|
  3194|         0|            0|            0|  0.00%|            # well-behaved subclass that only returns 0d arrays when
  3195|         0|            0|            0|  0.00%|            # expected - this is not a scalar
  3196|         0|            0|            0|  0.00%|            elif type(arr).__getitem__ == ndarray.__getitem__:
  3197|         0|            0|            0|  0.00%|                return False
  3198|         0|            0|            0|  0.00%|
  3199|         0|            0|            0|  0.00%|            return None
  3200|         0|            0|            0|  0.00%|
  3201|         0|            0|            0|  0.00%|        if _mask is not nomask:
  3202|         0|            0|            0|  0.00%|            # _mask cannot be a subclass, so it tells us whether we should
  3203|         0|            0|            0|  0.00%|            # expect a scalar. It also cannot be of dtype object.
  3204|         0|            0|            0|  0.00%|            mout = _mask[indx]
  3205|         0|            0|            0|  0.00%|            scalar_expected = _is_scalar(mout)
  3206|         0|            0|            0|  0.00%|
  3207|         0|            0|            0|  0.00%|        else:
  3208|         0|            0|            0|  0.00%|            # attempt to apply the heuristic to avoid constructing a full mask
  3209|         0|            0|            0|  0.00%|            mout = nomask
  3210|         0|            0|            0|  0.00%|            scalar_expected = _scalar_heuristic(self.data, dout)
  3211|         0|            0|            0|  0.00%|            if scalar_expected is None:
  3212|         0|            0|            0|  0.00%|                # heuristics have failed
  3213|         0|            0|            0|  0.00%|                # construct a full array, so we can be certain. This is costly.
  3214|         0|            0|            0|  0.00%|                # we could also fall back on ndarray.__getitem__(self.data, indx)
  3215|         0|            0|            0|  0.00%|                scalar_expected = _is_scalar(getmaskarray(self)[indx])
  3216|         0|            0|            0|  0.00%|
  3217|         0|            0|            0|  0.00%|        # Did we extract a single item?
  3218|         0|            0|            0|  0.00%|        if scalar_expected:
  3219|         0|            0|            0|  0.00%|            # A record
  3220|         0|            0|            0|  0.00%|            if isinstance(dout, np.void):
  3221|         0|            0|            0|  0.00%|                # We should always re-cast to mvoid, otherwise users can
  3222|         0|            0|            0|  0.00%|                # change masks on rows that already have masked values, but not
  3223|         0|            0|            0|  0.00%|                # on rows that have no masked values, which is inconsistent.
  3224|         0|            0|            0|  0.00%|                return mvoid(dout, mask=mout, hardmask=self._hardmask)
  3225|         0|            0|            0|  0.00%|
  3226|         0|            0|            0|  0.00%|            # special case introduced in gh-5962
  3227|         0|            0|            0|  0.00%|            elif (self.dtype.type is np.object_ and
  3228|         0|            0|            0|  0.00%|                  isinstance(dout, np.ndarray) and
  3229|         0|            0|            0|  0.00%|                  dout is not masked):
  3230|         0|            0|            0|  0.00%|                # If masked, turn into a MaskedArray, with everything masked.
  3231|         0|            0|            0|  0.00%|                if mout:
  3232|         0|            0|            0|  0.00%|                    return MaskedArray(dout, mask=True)
  3233|         0|            0|            0|  0.00%|                else:
  3234|         0|            0|            0|  0.00%|                    return dout
  3235|         0|            0|            0|  0.00%|
  3236|         0|            0|            0|  0.00%|            # Just a scalar
  3237|         0|            0|            0|  0.00%|            else:
  3238|         0|            0|            0|  0.00%|                if mout:
  3239|         0|            0|            0|  0.00%|                    return masked
  3240|         0|            0|            0|  0.00%|                else:
  3241|         0|            0|            0|  0.00%|                    return dout
  3242|         0|            0|            0|  0.00%|        else:
  3243|         0|            0|            0|  0.00%|            # Force dout to MA
  3244|         0|            0|            0|  0.00%|            dout = dout.view(type(self))
  3245|         0|            0|            0|  0.00%|            # Inherit attributes from self
  3246|         0|            0|            0|  0.00%|            dout._update_from(self)
  3247|         0|            0|            0|  0.00%|            # Check the fill_value
  3248|         0|            0|            0|  0.00%|            if is_string_or_list_of_strings(indx):
  3249|         0|            0|            0|  0.00%|                if self._fill_value is not None:
  3250|         0|            0|            0|  0.00%|                    dout._fill_value = self._fill_value[indx]
  3251|         0|            0|            0|  0.00%|
  3252|         0|            0|            0|  0.00%|                    # If we're indexing a multidimensional field in a
  3253|         0|            0|            0|  0.00%|                    # structured array (such as dtype("(2,)i2,(2,)i1")),
  3254|         0|            0|            0|  0.00%|                    # dimensionality goes up (M[field].ndim == M.ndim +
  3255|         0|            0|            0|  0.00%|                    # M.dtype[field].ndim).  That's fine for
  3256|         0|            0|            0|  0.00%|                    # M[field] but problematic for M[field].fill_value
  3257|         0|            0|            0|  0.00%|                    # which should have shape () to avoid breaking several
  3258|         0|            0|            0|  0.00%|                    # methods. There is no great way out, so set to
  3259|         0|            0|            0|  0.00%|                    # first element.  See issue #6723.
  3260|         0|            0|            0|  0.00%|                    if dout._fill_value.ndim > 0:
  3261|         0|            0|            0|  0.00%|                        if not (dout._fill_value ==
  3262|         0|            0|            0|  0.00%|                                dout._fill_value.flat[0]).all():
  3263|         0|            0|            0|  0.00%|                            warnings.warn(
  3264|         0|            0|            0|  0.00%|                                "Upon accessing multidimensional field "
  3265|         0|            0|            0|  0.00%|                                "{indx:s}, need to keep dimensionality "
  3266|         0|            0|            0|  0.00%|                                "of fill_value at 0. Discarding "
  3267|         0|            0|            0|  0.00%|                                "heterogeneous fill_value and setting "
  3268|         0|            0|            0|  0.00%|                                "all to {fv!s}.".format(indx=indx,
  3269|         0|            0|            0|  0.00%|                                    fv=dout._fill_value[0]),
  3270|         0|            0|            0|  0.00%|                                stacklevel=2)
  3271|         0|            0|            0|  0.00%|                        dout._fill_value = dout._fill_value.flat[0]
  3272|         0|            0|            0|  0.00%|                dout._isfield = True
  3273|         0|            0|            0|  0.00%|            # Update the mask if needed
  3274|         0|            0|            0|  0.00%|            if mout is not nomask:
  3275|         0|            0|            0|  0.00%|                # set shape to match that of data; this is needed for matrices
  3276|         0|            0|            0|  0.00%|                dout._mask = reshape(mout, dout.shape)
  3277|         0|            0|            0|  0.00%|                dout._sharedmask = True
  3278|         0|            0|            0|  0.00%|                # Note: Don't try to check for m.any(), that'll take too long
  3279|         0|            0|            0|  0.00%|        return dout
  3280|         0|            0|            0|  0.00%|
  3281|         0|            0|            0|  0.00%|    def __setitem__(self, indx, value):
  3282|         0|            0|            0|  0.00%|        """
  3283|         0|            0|            0|  0.00%|        x.__setitem__(i, y) <==> x[i]=y
  3284|         0|            0|            0|  0.00%|
  3285|         0|            0|            0|  0.00%|        Set item described by index. If value is masked, masks those
  3286|         0|            0|            0|  0.00%|        locations.
  3287|         0|            0|            0|  0.00%|
  3288|         0|            0|            0|  0.00%|        """
  3289|         0|            0|            0|  0.00%|        if self is masked:
  3290|         0|            0|            0|  0.00%|            raise MaskError('Cannot alter the masked element.')
  3291|         0|            0|            0|  0.00%|        _data = self._data
  3292|         0|            0|            0|  0.00%|        _mask = self._mask
  3293|         0|            0|            0|  0.00%|        if isinstance(indx, basestring):
  3294|         0|            0|            0|  0.00%|            _data[indx] = value
  3295|         0|            0|            0|  0.00%|            if _mask is nomask:
  3296|         0|            0|            0|  0.00%|                self._mask = _mask = make_mask_none(self.shape, self.dtype)
  3297|         0|            0|            0|  0.00%|            _mask[indx] = getmask(value)
  3298|         0|            0|            0|  0.00%|            return
  3299|         0|            0|            0|  0.00%|
  3300|         0|            0|            0|  0.00%|        _dtype = _data.dtype
  3301|         0|            0|            0|  0.00%|
  3302|         0|            0|            0|  0.00%|        if value is masked:
  3303|         0|            0|            0|  0.00%|            # The mask wasn't set: create a full version.
  3304|         0|            0|            0|  0.00%|            if _mask is nomask:
  3305|         0|            0|            0|  0.00%|                _mask = self._mask = make_mask_none(self.shape, _dtype)
  3306|         0|            0|            0|  0.00%|            # Now, set the mask to its value.
  3307|         0|            0|            0|  0.00%|            if _dtype.names is not None:
  3308|         0|            0|            0|  0.00%|                _mask[indx] = tuple([True] * len(_dtype.names))
  3309|         0|            0|            0|  0.00%|            else:
  3310|         0|            0|            0|  0.00%|                _mask[indx] = True
  3311|         0|            0|            0|  0.00%|            return
  3312|         0|            0|            0|  0.00%|
  3313|         0|            0|            0|  0.00%|        # Get the _data part of the new value
  3314|         0|            0|            0|  0.00%|        dval = getattr(value, '_data', value)
  3315|         0|            0|            0|  0.00%|        # Get the _mask part of the new value
  3316|         0|            0|            0|  0.00%|        mval = getmask(value)
  3317|         0|            0|            0|  0.00%|        if _dtype.names is not None and mval is nomask:
  3318|         0|            0|            0|  0.00%|            mval = tuple([False] * len(_dtype.names))
  3319|         0|            0|            0|  0.00%|        if _mask is nomask:
  3320|         0|            0|            0|  0.00%|            # Set the data, then the mask
  3321|         0|            0|            0|  0.00%|            _data[indx] = dval
  3322|         0|            0|            0|  0.00%|            if mval is not nomask:
  3323|         0|            0|            0|  0.00%|                _mask = self._mask = make_mask_none(self.shape, _dtype)
  3324|         0|            0|            0|  0.00%|                _mask[indx] = mval
  3325|         0|            0|            0|  0.00%|        elif not self._hardmask:
  3326|         0|            0|            0|  0.00%|            # Set the data, then the mask
  3327|         0|            0|            0|  0.00%|            _data[indx] = dval
  3328|         0|            0|            0|  0.00%|            _mask[indx] = mval
  3329|         0|            0|            0|  0.00%|        elif hasattr(indx, 'dtype') and (indx.dtype == MaskType):
  3330|         0|            0|            0|  0.00%|            indx = indx * umath.logical_not(_mask)
  3331|         0|            0|            0|  0.00%|            _data[indx] = dval
  3332|         0|            0|            0|  0.00%|        else:
  3333|         0|            0|            0|  0.00%|            if _dtype.names is not None:
  3334|         0|            0|            0|  0.00%|                err_msg = "Flexible 'hard' masks are not yet supported."
  3335|         0|            0|            0|  0.00%|                raise NotImplementedError(err_msg)
  3336|         0|            0|            0|  0.00%|            mindx = mask_or(_mask[indx], mval, copy=True)
  3337|         0|            0|            0|  0.00%|            dindx = self._data[indx]
  3338|         0|            0|            0|  0.00%|            if dindx.size > 1:
  3339|         0|            0|            0|  0.00%|                np.copyto(dindx, dval, where=~mindx)
  3340|         0|            0|            0|  0.00%|            elif mindx is nomask:
  3341|         0|            0|            0|  0.00%|                dindx = dval
  3342|         0|            0|            0|  0.00%|            _data[indx] = dindx
  3343|         0|            0|            0|  0.00%|            _mask[indx] = mindx
  3344|         0|            0|            0|  0.00%|        return
  3345|         0|            0|            0|  0.00%|
  3346|         0|            0|            0|  0.00%|    # Define so that we can overwrite the setter.
  3347|         0|            0|            0|  0.00%|    @property
  3348|         0|            0|            0|  0.00%|    def dtype(self):
  3349|         0|            0|            0|  0.00%|        return super(MaskedArray, self).dtype
  3350|         0|            0|            0|  0.00%|
  3351|         0|            0|            0|  0.00%|    @dtype.setter
  3352|         0|            0|            0|  0.00%|    def dtype(self, dtype):
  3353|         0|            0|            0|  0.00%|        super(MaskedArray, type(self)).dtype.__set__(self, dtype)
  3354|         0|            0|            0|  0.00%|        if self._mask is not nomask:
  3355|         0|            0|            0|  0.00%|            self._mask = self._mask.view(make_mask_descr(dtype), ndarray)
  3356|         0|            0|            0|  0.00%|            # Try to reset the shape of the mask (if we don't have a void).
  3357|         0|            0|            0|  0.00%|            # This raises a ValueError if the dtype change won't work.
  3358|         0|            0|            0|  0.00%|            try:
  3359|         0|            0|            0|  0.00%|                self._mask.shape = self.shape
  3360|         0|            0|            0|  0.00%|            except (AttributeError, TypeError):
  3361|         0|            0|            0|  0.00%|                pass
  3362|         0|            0|            0|  0.00%|
  3363|         0|            0|            0|  0.00%|    @property
  3364|         0|            0|            0|  0.00%|    def shape(self):
  3365|         0|            0|            0|  0.00%|        return super(MaskedArray, self).shape
  3366|         0|            0|            0|  0.00%|
  3367|         0|            0|            0|  0.00%|    @shape.setter
  3368|         0|            0|            0|  0.00%|    def shape(self, shape):
  3369|         0|            0|            0|  0.00%|        super(MaskedArray, type(self)).shape.__set__(self, shape)
  3370|         0|            0|            0|  0.00%|        # Cannot use self._mask, since it may not (yet) exist when a
  3371|         0|            0|            0|  0.00%|        # masked matrix sets the shape.
  3372|         0|            0|            0|  0.00%|        if getmask(self) is not nomask:
  3373|         0|            0|            0|  0.00%|            self._mask.shape = self.shape
  3374|         0|            0|            0|  0.00%|
  3375|         0|            0|            0|  0.00%|    def __setmask__(self, mask, copy=False):
  3376|         0|            0|            0|  0.00%|        """
  3377|         0|            0|            0|  0.00%|        Set the mask.
  3378|         0|            0|            0|  0.00%|
  3379|         0|            0|            0|  0.00%|        """
  3380|         0|            0|            0|  0.00%|        idtype = self.dtype
  3381|         0|            0|            0|  0.00%|        current_mask = self._mask
  3382|         0|            0|            0|  0.00%|        if mask is masked:
  3383|         0|            0|            0|  0.00%|            mask = True
  3384|         0|            0|            0|  0.00%|
  3385|         0|            0|            0|  0.00%|        if (current_mask is nomask):
  3386|         0|            0|            0|  0.00%|            # Make sure the mask is set
  3387|         0|            0|            0|  0.00%|            # Just don't do anything if there's nothing to do.
  3388|         0|            0|            0|  0.00%|            if mask is nomask:
  3389|         0|            0|            0|  0.00%|                return
  3390|         0|            0|            0|  0.00%|            current_mask = self._mask = make_mask_none(self.shape, idtype)
  3391|         0|            0|            0|  0.00%|
  3392|         0|            0|            0|  0.00%|        if idtype.names is None:
  3393|         0|            0|            0|  0.00%|            # No named fields.
  3394|         0|            0|            0|  0.00%|            # Hardmask: don't unmask the data
  3395|         0|            0|            0|  0.00%|            if self._hardmask:
  3396|         0|            0|            0|  0.00%|                current_mask |= mask
  3397|         0|            0|            0|  0.00%|            # Softmask: set everything to False
  3398|         0|            0|            0|  0.00%|            # If it's obviously a compatible scalar, use a quick update
  3399|         0|            0|            0|  0.00%|            # method.
  3400|         0|            0|            0|  0.00%|            elif isinstance(mask, (int, float, np.bool_, np.number)):
  3401|         0|            0|            0|  0.00%|                current_mask[...] = mask
  3402|         0|            0|            0|  0.00%|            # Otherwise fall back to the slower, general purpose way.
  3403|         0|            0|            0|  0.00%|            else:
  3404|         0|            0|            0|  0.00%|                current_mask.flat = mask
  3405|         0|            0|            0|  0.00%|        else:
  3406|         0|            0|            0|  0.00%|            # Named fields w/
  3407|         0|            0|            0|  0.00%|            mdtype = current_mask.dtype
  3408|         0|            0|            0|  0.00%|            mask = np.array(mask, copy=False)
  3409|         0|            0|            0|  0.00%|            # Mask is a singleton
  3410|         0|            0|            0|  0.00%|            if not mask.ndim:
  3411|         0|            0|            0|  0.00%|                # It's a boolean : make a record
  3412|         0|            0|            0|  0.00%|                if mask.dtype.kind == 'b':
  3413|         0|            0|            0|  0.00%|                    mask = np.array(tuple([mask.item()] * len(mdtype)),
  3414|         0|            0|            0|  0.00%|                                    dtype=mdtype)
  3415|         0|            0|            0|  0.00%|                # It's a record: make sure the dtype is correct
  3416|         0|            0|            0|  0.00%|                else:
  3417|         0|            0|            0|  0.00%|                    mask = mask.astype(mdtype)
  3418|         0|            0|            0|  0.00%|            # Mask is a sequence
  3419|         0|            0|            0|  0.00%|            else:
  3420|         0|            0|            0|  0.00%|                # Make sure the new mask is a ndarray with the proper dtype
  3421|         0|            0|            0|  0.00%|                try:
  3422|         0|            0|            0|  0.00%|                    mask = np.array(mask, copy=copy, dtype=mdtype)
  3423|         0|            0|            0|  0.00%|                # Or assume it's a sequence of bool/int
  3424|         0|            0|            0|  0.00%|                except TypeError:
  3425|         0|            0|            0|  0.00%|                    mask = np.array([tuple([m] * len(mdtype)) for m in mask],
  3426|         0|            0|            0|  0.00%|                                    dtype=mdtype)
  3427|         0|            0|            0|  0.00%|            # Hardmask: don't unmask the data
  3428|         0|            0|            0|  0.00%|            if self._hardmask:
  3429|         0|            0|            0|  0.00%|                for n in idtype.names:
  3430|         0|            0|            0|  0.00%|                    current_mask[n] |= mask[n]
  3431|         0|            0|            0|  0.00%|            # Softmask: set everything to False
  3432|         0|            0|            0|  0.00%|            # If it's obviously a compatible scalar, use a quick update
  3433|         0|            0|            0|  0.00%|            # method.
  3434|         0|            0|            0|  0.00%|            elif isinstance(mask, (int, float, np.bool_, np.number)):
  3435|         0|            0|            0|  0.00%|                current_mask[...] = mask
  3436|         0|            0|            0|  0.00%|            # Otherwise fall back to the slower, general purpose way.
  3437|         0|            0|            0|  0.00%|            else:
  3438|         0|            0|            0|  0.00%|                current_mask.flat = mask
  3439|         0|            0|            0|  0.00%|        # Reshape if needed
  3440|         0|            0|            0|  0.00%|        if current_mask.shape:
  3441|         0|            0|            0|  0.00%|            current_mask.shape = self.shape
  3442|         0|            0|            0|  0.00%|        return
  3443|         0|            0|            0|  0.00%|
  3444|         0|            0|            0|  0.00%|    _set_mask = __setmask__
  3445|         0|            0|            0|  0.00%|
  3446|         0|            0|            0|  0.00%|    @property
  3447|         0|            0|            0|  0.00%|    def mask(self):
  3448|         0|            0|            0|  0.00%|        """ Current mask. """
  3449|         0|            0|            0|  0.00%|
  3450|         0|            0|            0|  0.00%|        # We could try to force a reshape, but that wouldn't work in some
  3451|         0|            0|            0|  0.00%|        # cases.
  3452|         0|            0|            0|  0.00%|        # Return a view so that the dtype and shape cannot be changed in place
  3453|         0|            0|            0|  0.00%|        # This still preserves nomask by identity
  3454|         0|            0|            0|  0.00%|        return self._mask.view()
  3455|         0|            0|            0|  0.00%|
  3456|         0|            0|            0|  0.00%|    @mask.setter
  3457|         0|            0|            0|  0.00%|    def mask(self, value):
  3458|         0|            0|            0|  0.00%|        self.__setmask__(value)
  3459|         0|            0|            0|  0.00%|
  3460|         0|            0|            0|  0.00%|    @property
  3461|         0|            0|            0|  0.00%|    def recordmask(self):
  3462|         0|            0|            0|  0.00%|        """
  3463|         0|            0|            0|  0.00%|        Get or set the mask of the array if it has no named fields. For
  3464|         0|            0|            0|  0.00%|        structured arrays, returns a ndarray of booleans where entries are
  3465|         0|            0|            0|  0.00%|        ``True`` if **all** the fields are masked, ``False`` otherwise:
  3466|         0|            0|            0|  0.00%|
  3467|         0|            0|            0|  0.00%|        >>> x = np.ma.array([(1, 1), (2, 2), (3, 3), (4, 4), (5, 5)],
  3468|         0|            0|            0|  0.00%|        ...         mask=[(0, 0), (1, 0), (1, 1), (0, 1), (0, 0)],
  3469|         0|            0|            0|  0.00%|        ...        dtype=[('a', int), ('b', int)])
  3470|         0|            0|            0|  0.00%|        >>> x.recordmask
  3471|         0|            0|            0|  0.00%|        array([False, False,  True, False, False])
  3472|         0|            0|            0|  0.00%|        """
  3473|         0|            0|            0|  0.00%|
  3474|         0|            0|            0|  0.00%|        _mask = self._mask.view(ndarray)
  3475|         0|            0|            0|  0.00%|        if _mask.dtype.names is None:
  3476|         0|            0|            0|  0.00%|            return _mask
  3477|         0|            0|            0|  0.00%|        return np.all(flatten_structured_array(_mask), axis=-1)
  3478|         0|            0|            0|  0.00%|
  3479|         0|            0|            0|  0.00%|    @recordmask.setter
  3480|         0|            0|            0|  0.00%|    def recordmask(self, mask):
  3481|         0|            0|            0|  0.00%|        raise NotImplementedError("Coming soon: setting the mask per records!")
  3482|         0|            0|            0|  0.00%|
  3483|         0|            0|            0|  0.00%|    def harden_mask(self):
  3484|         0|            0|            0|  0.00%|        """
  3485|         0|            0|            0|  0.00%|        Force the mask to hard.
  3486|         0|            0|            0|  0.00%|
  3487|         0|            0|            0|  0.00%|        Whether the mask of a masked array is hard or soft is determined by
  3488|         0|            0|            0|  0.00%|        its `hardmask` property. `harden_mask` sets `hardmask` to True.
  3489|         0|            0|            0|  0.00%|
  3490|         0|            0|            0|  0.00%|        See Also
  3491|         0|            0|            0|  0.00%|        --------
  3492|         0|            0|            0|  0.00%|        hardmask
  3493|         0|            0|            0|  0.00%|
  3494|         0|            0|            0|  0.00%|        """
  3495|         0|            0|            0|  0.00%|        self._hardmask = True
  3496|         0|            0|            0|  0.00%|        return self
  3497|         0|            0|            0|  0.00%|
  3498|         0|            0|            0|  0.00%|    def soften_mask(self):
  3499|         0|            0|            0|  0.00%|        """
  3500|         0|            0|            0|  0.00%|        Force the mask to soft.
  3501|         0|            0|            0|  0.00%|
  3502|         0|            0|            0|  0.00%|        Whether the mask of a masked array is hard or soft is determined by
  3503|         0|            0|            0|  0.00%|        its `hardmask` property. `soften_mask` sets `hardmask` to False.
  3504|         0|            0|            0|  0.00%|
  3505|         0|            0|            0|  0.00%|        See Also
  3506|         0|            0|            0|  0.00%|        --------
  3507|         0|            0|            0|  0.00%|        hardmask
  3508|         0|            0|            0|  0.00%|
  3509|         0|            0|            0|  0.00%|        """
  3510|         0|            0|            0|  0.00%|        self._hardmask = False
  3511|         0|            0|            0|  0.00%|        return self
  3512|         0|            0|            0|  0.00%|
  3513|         0|            0|            0|  0.00%|    @property
  3514|         0|            0|            0|  0.00%|    def hardmask(self):
  3515|         0|            0|            0|  0.00%|        """ Hardness of the mask """
  3516|         0|            0|            0|  0.00%|        return self._hardmask
  3517|         0|            0|            0|  0.00%|
  3518|         0|            0|            0|  0.00%|    def unshare_mask(self):
  3519|         0|            0|            0|  0.00%|        """
  3520|         0|            0|            0|  0.00%|        Copy the mask and set the sharedmask flag to False.
  3521|         0|            0|            0|  0.00%|
  3522|         0|            0|            0|  0.00%|        Whether the mask is shared between masked arrays can be seen from
  3523|         0|            0|            0|  0.00%|        the `sharedmask` property. `unshare_mask` ensures the mask is not shared.
  3524|         0|            0|            0|  0.00%|        A copy of the mask is only made if it was shared.
  3525|         0|            0|            0|  0.00%|
  3526|         0|            0|            0|  0.00%|        See Also
  3527|         0|            0|            0|  0.00%|        --------
  3528|         0|            0|            0|  0.00%|        sharedmask
  3529|         0|            0|            0|  0.00%|
  3530|         0|            0|            0|  0.00%|        """
  3531|         0|            0|            0|  0.00%|        if self._sharedmask:
  3532|         0|            0|            0|  0.00%|            self._mask = self._mask.copy()
  3533|         0|            0|            0|  0.00%|            self._sharedmask = False
  3534|         0|            0|            0|  0.00%|        return self
  3535|         0|            0|            0|  0.00%|
  3536|         0|            0|            0|  0.00%|    @property
  3537|         0|            0|            0|  0.00%|    def sharedmask(self):
  3538|         0|            0|            0|  0.00%|        """ Share status of the mask (read-only). """
  3539|         0|            0|            0|  0.00%|        return self._sharedmask
  3540|         0|            0|            0|  0.00%|
  3541|         0|            0|            0|  0.00%|    def shrink_mask(self):
  3542|         0|            0|            0|  0.00%|        """
  3543|         0|            0|            0|  0.00%|        Reduce a mask to nomask when possible.
  3544|         0|            0|            0|  0.00%|
  3545|         0|            0|            0|  0.00%|        Parameters
  3546|         0|            0|            0|  0.00%|        ----------
  3547|         0|            0|            0|  0.00%|        None
  3548|         0|            0|            0|  0.00%|
  3549|         0|            0|            0|  0.00%|        Returns
  3550|         0|            0|            0|  0.00%|        -------
  3551|         0|            0|            0|  0.00%|        None
  3552|         0|            0|            0|  0.00%|
  3553|         0|            0|            0|  0.00%|        Examples
  3554|         0|            0|            0|  0.00%|        --------
  3555|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2 ], [3, 4]], mask=[0]*4)
  3556|         0|            0|            0|  0.00%|        >>> x.mask
  3557|         0|            0|            0|  0.00%|        array([[False, False],
  3558|         0|            0|            0|  0.00%|               [False, False]])
  3559|         0|            0|            0|  0.00%|        >>> x.shrink_mask()
  3560|         0|            0|            0|  0.00%|        masked_array(
  3561|         0|            0|            0|  0.00%|          data=[[1, 2],
  3562|         0|            0|            0|  0.00%|                [3, 4]],
  3563|         0|            0|            0|  0.00%|          mask=False,
  3564|         0|            0|            0|  0.00%|          fill_value=999999)
  3565|         0|            0|            0|  0.00%|        >>> x.mask
  3566|         0|            0|            0|  0.00%|        False
  3567|         0|            0|            0|  0.00%|
  3568|         0|            0|            0|  0.00%|        """
  3569|         0|            0|            0|  0.00%|        self._mask = _shrink_mask(self._mask)
  3570|         0|            0|            0|  0.00%|        return self
  3571|         0|            0|            0|  0.00%|
  3572|         0|            0|            0|  0.00%|    @property
  3573|         0|            0|            0|  0.00%|    def baseclass(self):
  3574|         0|            0|            0|  0.00%|        """ Class of the underlying data (read-only). """
  3575|         0|            0|            0|  0.00%|        return self._baseclass
  3576|         0|            0|            0|  0.00%|
  3577|         0|            0|            0|  0.00%|    def _get_data(self):
  3578|         0|            0|            0|  0.00%|        """
  3579|         0|            0|            0|  0.00%|        Returns the underlying data, as a view of the masked array.
  3580|         0|            0|            0|  0.00%|
  3581|         0|            0|            0|  0.00%|        If the underlying data is a subclass of :class:`numpy.ndarray`, it is
  3582|         0|            0|            0|  0.00%|        returned as such.
  3583|         0|            0|            0|  0.00%|
  3584|         0|            0|            0|  0.00%|        >>> x = np.ma.array(np.matrix([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
  3585|         0|            0|            0|  0.00%|        >>> x.data
  3586|         0|            0|            0|  0.00%|        matrix([[1, 2],
  3587|         0|            0|            0|  0.00%|                [3, 4]])
  3588|         0|            0|            0|  0.00%|
  3589|         0|            0|            0|  0.00%|        The type of the data can be accessed through the :attr:`baseclass`
  3590|         0|            0|            0|  0.00%|        attribute.
  3591|         0|            0|            0|  0.00%|        """
  3592|         0|            0|            0|  0.00%|        return ndarray.view(self, self._baseclass)
  3593|         0|            0|            0|  0.00%|
  3594|         0|            0|            0|  0.00%|    _data = property(fget=_get_data)
  3595|         0|            0|            0|  0.00%|    data = property(fget=_get_data)
  3596|         0|            0|            0|  0.00%|
  3597|         0|            0|            0|  0.00%|    @property
  3598|         0|            0|            0|  0.00%|    def flat(self):
  3599|         0|            0|            0|  0.00%|        """ Return a flat iterator, or set a flattened version of self to value. """
  3600|         0|            0|            0|  0.00%|        return MaskedIterator(self)
  3601|         0|            0|            0|  0.00%|
  3602|         0|            0|            0|  0.00%|    @flat.setter
  3603|         0|            0|            0|  0.00%|    def flat(self, value):
  3604|         0|            0|            0|  0.00%|        y = self.ravel()
  3605|         0|            0|            0|  0.00%|        y[:] = value
  3606|         0|            0|            0|  0.00%|
  3607|         0|            0|            0|  0.00%|    @property
  3608|         0|            0|            0|  0.00%|    def fill_value(self):
  3609|         0|            0|            0|  0.00%|        """
  3610|         0|            0|            0|  0.00%|        The filling value of the masked array is a scalar. When setting, None
  3611|         0|            0|            0|  0.00%|        will set to a default based on the data type.
  3612|         0|            0|            0|  0.00%|
  3613|         0|            0|            0|  0.00%|        Examples
  3614|         0|            0|            0|  0.00%|        --------
  3615|         0|            0|            0|  0.00%|        >>> for dt in [np.int32, np.int64, np.float64, np.complex128]:
  3616|         0|            0|            0|  0.00%|        ...     np.ma.array([0, 1], dtype=dt).get_fill_value()
  3617|         0|            0|            0|  0.00%|        ...
  3618|         0|            0|            0|  0.00%|        999999
  3619|         0|            0|            0|  0.00%|        999999
  3620|         0|            0|            0|  0.00%|        1e+20
  3621|         0|            0|            0|  0.00%|        (1e+20+0j)
  3622|         0|            0|            0|  0.00%|
  3623|         0|            0|            0|  0.00%|        >>> x = np.ma.array([0, 1.], fill_value=-np.inf)
  3624|         0|            0|            0|  0.00%|        >>> x.fill_value
  3625|         0|            0|            0|  0.00%|        -inf
  3626|         0|            0|            0|  0.00%|        >>> x.fill_value = np.pi
  3627|         0|            0|            0|  0.00%|        >>> x.fill_value
  3628|         0|            0|            0|  0.00%|        3.1415926535897931 # may vary
  3629|         0|            0|            0|  0.00%|
  3630|         0|            0|            0|  0.00%|        Reset to default:
  3631|         0|            0|            0|  0.00%|
  3632|         0|            0|            0|  0.00%|        >>> x.fill_value = None
  3633|         0|            0|            0|  0.00%|        >>> x.fill_value
  3634|         0|            0|            0|  0.00%|        1e+20
  3635|         0|            0|            0|  0.00%|
  3636|         0|            0|            0|  0.00%|        """
  3637|         0|            0|            0|  0.00%|        if self._fill_value is None:
  3638|         0|            0|            0|  0.00%|            self._fill_value = _check_fill_value(None, self.dtype)
  3639|         0|            0|            0|  0.00%|
  3640|         0|            0|            0|  0.00%|        # Temporary workaround to account for the fact that str and bytes
  3641|         0|            0|            0|  0.00%|        # scalars cannot be indexed with (), whereas all other numpy
  3642|         0|            0|            0|  0.00%|        # scalars can. See issues #7259 and #7267.
  3643|         0|            0|            0|  0.00%|        # The if-block can be removed after #7267 has been fixed.
  3644|         0|            0|            0|  0.00%|        if isinstance(self._fill_value, ndarray):
  3645|         0|            0|            0|  0.00%|            return self._fill_value[()]
  3646|         0|            0|            0|  0.00%|        return self._fill_value
  3647|         0|            0|            0|  0.00%|
  3648|         0|            0|            0|  0.00%|    @fill_value.setter
  3649|         0|            0|            0|  0.00%|    def fill_value(self, value=None):
  3650|         0|            0|            0|  0.00%|        target = _check_fill_value(value, self.dtype)
  3651|         0|            0|            0|  0.00%|        _fill_value = self._fill_value
  3652|         0|            0|            0|  0.00%|        if _fill_value is None:
  3653|         0|            0|            0|  0.00%|            # Create the attribute if it was undefined
  3654|         0|            0|            0|  0.00%|            self._fill_value = target
  3655|         0|            0|            0|  0.00%|        else:
  3656|         0|            0|            0|  0.00%|            # Don't overwrite the attribute, just fill it (for propagation)
  3657|         0|            0|            0|  0.00%|            _fill_value[()] = target
  3658|         0|            0|            0|  0.00%|
  3659|         0|            0|            0|  0.00%|    # kept for compatibility
  3660|         0|            0|            0|  0.00%|    get_fill_value = fill_value.fget
  3661|         0|            0|            0|  0.00%|    set_fill_value = fill_value.fset
  3662|         0|            0|            0|  0.00%|
  3663|         0|            0|            0|  0.00%|    def filled(self, fill_value=None):
  3664|         0|            0|            0|  0.00%|        """
  3665|         0|            0|            0|  0.00%|        Return a copy of self, with masked values filled with a given value.
  3666|         0|            0|            0|  0.00%|        **However**, if there are no masked values to fill, self will be
  3667|         0|            0|            0|  0.00%|        returned instead as an ndarray.
  3668|         0|            0|            0|  0.00%|
  3669|         0|            0|            0|  0.00%|        Parameters
  3670|         0|            0|            0|  0.00%|        ----------
  3671|         0|            0|            0|  0.00%|        fill_value : scalar, optional
  3672|         0|            0|            0|  0.00%|            The value to use for invalid entries (None by default).
  3673|         0|            0|            0|  0.00%|            If None, the `fill_value` attribute of the array is used instead.
  3674|         0|            0|            0|  0.00%|
  3675|         0|            0|            0|  0.00%|        Returns
  3676|         0|            0|            0|  0.00%|        -------
  3677|         0|            0|            0|  0.00%|        filled_array : ndarray
  3678|         0|            0|            0|  0.00%|            A copy of ``self`` with invalid entries replaced by *fill_value*
  3679|         0|            0|            0|  0.00%|            (be it the function argument or the attribute of ``self``), or
  3680|         0|            0|            0|  0.00%|            ``self`` itself as an ndarray if there are no invalid entries to
  3681|         0|            0|            0|  0.00%|            be replaced.
  3682|         0|            0|            0|  0.00%|
  3683|         0|            0|            0|  0.00%|        Notes
  3684|         0|            0|            0|  0.00%|        -----
  3685|         0|            0|            0|  0.00%|        The result is **not** a MaskedArray!
  3686|         0|            0|            0|  0.00%|
  3687|         0|            0|            0|  0.00%|        Examples
  3688|         0|            0|            0|  0.00%|        --------
  3689|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1,2,3,4,5], mask=[0,0,1,0,1], fill_value=-999)
  3690|         0|            0|            0|  0.00%|        >>> x.filled()
  3691|         0|            0|            0|  0.00%|        array([   1,    2, -999,    4, -999])
  3692|         0|            0|            0|  0.00%|        >>> type(x.filled())
  3693|         0|            0|            0|  0.00%|        <class 'numpy.ndarray'>
  3694|         0|            0|            0|  0.00%|
  3695|         0|            0|            0|  0.00%|        Subclassing is preserved. This means that if, e.g., the data part of
  3696|         0|            0|            0|  0.00%|        the masked array is a recarray, `filled` returns a recarray:
  3697|         0|            0|            0|  0.00%|
  3698|         0|            0|            0|  0.00%|        >>> x = np.array([(-1, 2), (-3, 4)], dtype='i8,i8').view(np.recarray)
  3699|         0|            0|            0|  0.00%|        >>> m = np.ma.array(x, mask=[(True, False), (False, True)])
  3700|         0|            0|            0|  0.00%|        >>> m.filled()
  3701|         0|            0|            0|  0.00%|        rec.array([(999999,      2), (    -3, 999999)],
  3702|         0|            0|            0|  0.00%|                  dtype=[('f0', '<i8'), ('f1', '<i8')])
  3703|         0|            0|            0|  0.00%|        """
  3704|         0|            0|            0|  0.00%|        m = self._mask
  3705|         0|            0|            0|  0.00%|        if m is nomask:
  3706|         0|            0|            0|  0.00%|            return self._data
  3707|         0|            0|            0|  0.00%|
  3708|         0|            0|            0|  0.00%|        if fill_value is None:
  3709|         0|            0|            0|  0.00%|            fill_value = self.fill_value
  3710|         0|            0|            0|  0.00%|        else:
  3711|         0|            0|            0|  0.00%|            fill_value = _check_fill_value(fill_value, self.dtype)
  3712|         0|            0|            0|  0.00%|
  3713|         0|            0|            0|  0.00%|        if self is masked_singleton:
  3714|         0|            0|            0|  0.00%|            return np.asanyarray(fill_value)
  3715|         0|            0|            0|  0.00%|
  3716|         0|            0|            0|  0.00%|        if m.dtype.names is not None:
  3717|         0|            0|            0|  0.00%|            result = self._data.copy('K')
  3718|         0|            0|            0|  0.00%|            _recursive_filled(result, self._mask, fill_value)
  3719|         0|            0|            0|  0.00%|        elif not m.any():
  3720|         0|            0|            0|  0.00%|            return self._data
  3721|         0|            0|            0|  0.00%|        else:
  3722|         0|            0|            0|  0.00%|            result = self._data.copy('K')
  3723|         0|            0|            0|  0.00%|            try:
  3724|         0|            0|            0|  0.00%|                np.copyto(result, fill_value, where=m)
  3725|         0|            0|            0|  0.00%|            except (TypeError, AttributeError):
  3726|         0|            0|            0|  0.00%|                fill_value = narray(fill_value, dtype=object)
  3727|         0|            0|            0|  0.00%|                d = result.astype(object)
  3728|         0|            0|            0|  0.00%|                result = np.choose(m, (d, fill_value))
  3729|         0|            0|            0|  0.00%|            except IndexError:
  3730|         0|            0|            0|  0.00%|                # ok, if scalar
  3731|         0|            0|            0|  0.00%|                if self._data.shape:
  3732|         0|            0|            0|  0.00%|                    raise
  3733|         0|            0|            0|  0.00%|                elif m:
  3734|         0|            0|            0|  0.00%|                    result = np.array(fill_value, dtype=self.dtype)
  3735|         0|            0|            0|  0.00%|                else:
  3736|         0|            0|            0|  0.00%|                    result = self._data
  3737|         0|            0|            0|  0.00%|        return result
  3738|         0|            0|            0|  0.00%|
  3739|         0|            0|            0|  0.00%|    def compressed(self):
  3740|         0|            0|            0|  0.00%|        """
  3741|         0|            0|            0|  0.00%|        Return all the non-masked data as a 1-D array.
  3742|         0|            0|            0|  0.00%|
  3743|         0|            0|            0|  0.00%|        Returns
  3744|         0|            0|            0|  0.00%|        -------
  3745|         0|            0|            0|  0.00%|        data : ndarray
  3746|         0|            0|            0|  0.00%|            A new `ndarray` holding the non-masked data is returned.
  3747|         0|            0|            0|  0.00%|
  3748|         0|            0|            0|  0.00%|        Notes
  3749|         0|            0|            0|  0.00%|        -----
  3750|         0|            0|            0|  0.00%|        The result is **not** a MaskedArray!
  3751|         0|            0|            0|  0.00%|
  3752|         0|            0|            0|  0.00%|        Examples
  3753|         0|            0|            0|  0.00%|        --------
  3754|         0|            0|            0|  0.00%|        >>> x = np.ma.array(np.arange(5), mask=[0]*2 + [1]*3)
  3755|         0|            0|            0|  0.00%|        >>> x.compressed()
  3756|         0|            0|            0|  0.00%|        array([0, 1])
  3757|         0|            0|            0|  0.00%|        >>> type(x.compressed())
  3758|         0|            0|            0|  0.00%|        <class 'numpy.ndarray'>
  3759|         0|            0|            0|  0.00%|
  3760|         0|            0|            0|  0.00%|        """
  3761|         0|            0|            0|  0.00%|        data = ndarray.ravel(self._data)
  3762|         0|            0|            0|  0.00%|        if self._mask is not nomask:
  3763|         0|            0|            0|  0.00%|            data = data.compress(np.logical_not(ndarray.ravel(self._mask)))
  3764|         0|            0|            0|  0.00%|        return data
  3765|         0|            0|            0|  0.00%|
  3766|         0|            0|            0|  0.00%|    def compress(self, condition, axis=None, out=None):
  3767|         0|            0|            0|  0.00%|        """
  3768|         0|            0|            0|  0.00%|        Return `a` where condition is ``True``.
  3769|         0|            0|            0|  0.00%|
  3770|         0|            0|            0|  0.00%|        If condition is a `MaskedArray`, missing values are considered
  3771|         0|            0|            0|  0.00%|        as ``False``.
  3772|         0|            0|            0|  0.00%|
  3773|         0|            0|            0|  0.00%|        Parameters
  3774|         0|            0|            0|  0.00%|        ----------
  3775|         0|            0|            0|  0.00%|        condition : var
  3776|         0|            0|            0|  0.00%|            Boolean 1-d array selecting which entries to return. If len(condition)
  3777|         0|            0|            0|  0.00%|            is less than the size of a along the axis, then output is truncated
  3778|         0|            0|            0|  0.00%|            to length of condition array.
  3779|         0|            0|            0|  0.00%|        axis : {None, int}, optional
  3780|         0|            0|            0|  0.00%|            Axis along which the operation must be performed.
  3781|         0|            0|            0|  0.00%|        out : {None, ndarray}, optional
  3782|         0|            0|            0|  0.00%|            Alternative output array in which to place the result. It must have
  3783|         0|            0|            0|  0.00%|            the same shape as the expected output but the type will be cast if
  3784|         0|            0|            0|  0.00%|            necessary.
  3785|         0|            0|            0|  0.00%|
  3786|         0|            0|            0|  0.00%|        Returns
  3787|         0|            0|            0|  0.00%|        -------
  3788|         0|            0|            0|  0.00%|        result : MaskedArray
  3789|         0|            0|            0|  0.00%|            A :class:`MaskedArray` object.
  3790|         0|            0|            0|  0.00%|
  3791|         0|            0|            0|  0.00%|        Notes
  3792|         0|            0|            0|  0.00%|        -----
  3793|         0|            0|            0|  0.00%|        Please note the difference with :meth:`compressed` !
  3794|         0|            0|            0|  0.00%|        The output of :meth:`compress` has a mask, the output of
  3795|         0|            0|            0|  0.00%|        :meth:`compressed` does not.
  3796|         0|            0|            0|  0.00%|
  3797|         0|            0|            0|  0.00%|        Examples
  3798|         0|            0|            0|  0.00%|        --------
  3799|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
  3800|         0|            0|            0|  0.00%|        >>> x
  3801|         0|            0|            0|  0.00%|        masked_array(
  3802|         0|            0|            0|  0.00%|          data=[[1, --, 3],
  3803|         0|            0|            0|  0.00%|                [--, 5, --],
  3804|         0|            0|            0|  0.00%|                [7, --, 9]],
  3805|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  3806|         0|            0|            0|  0.00%|                [ True, False,  True],
  3807|         0|            0|            0|  0.00%|                [False,  True, False]],
  3808|         0|            0|            0|  0.00%|          fill_value=999999)
  3809|         0|            0|            0|  0.00%|        >>> x.compress([1, 0, 1])
  3810|         0|            0|            0|  0.00%|        masked_array(data=[1, 3],
  3811|         0|            0|            0|  0.00%|                     mask=[False, False],
  3812|         0|            0|            0|  0.00%|               fill_value=999999)
  3813|         0|            0|            0|  0.00%|
  3814|         0|            0|            0|  0.00%|        >>> x.compress([1, 0, 1], axis=1)
  3815|         0|            0|            0|  0.00%|        masked_array(
  3816|         0|            0|            0|  0.00%|          data=[[1, 3],
  3817|         0|            0|            0|  0.00%|                [--, --],
  3818|         0|            0|            0|  0.00%|                [7, 9]],
  3819|         0|            0|            0|  0.00%|          mask=[[False, False],
  3820|         0|            0|            0|  0.00%|                [ True,  True],
  3821|         0|            0|            0|  0.00%|                [False, False]],
  3822|         0|            0|            0|  0.00%|          fill_value=999999)
  3823|         0|            0|            0|  0.00%|
  3824|         0|            0|            0|  0.00%|        """
  3825|         0|            0|            0|  0.00%|        # Get the basic components
  3826|         0|            0|            0|  0.00%|        (_data, _mask) = (self._data, self._mask)
  3827|         0|            0|            0|  0.00%|
  3828|         0|            0|            0|  0.00%|        # Force the condition to a regular ndarray and forget the missing
  3829|         0|            0|            0|  0.00%|        # values.
  3830|         0|            0|            0|  0.00%|        condition = np.array(condition, copy=False, subok=False)
  3831|         0|            0|            0|  0.00%|
  3832|         0|            0|            0|  0.00%|        _new = _data.compress(condition, axis=axis, out=out).view(type(self))
  3833|         0|            0|            0|  0.00%|        _new._update_from(self)
  3834|         0|            0|            0|  0.00%|        if _mask is not nomask:
  3835|         0|            0|            0|  0.00%|            _new._mask = _mask.compress(condition, axis=axis)
  3836|         0|            0|            0|  0.00%|        return _new
  3837|         0|            0|            0|  0.00%|
  3838|         0|            0|            0|  0.00%|    def _insert_masked_print(self):
  3839|         0|            0|            0|  0.00%|        """
  3840|         0|            0|            0|  0.00%|        Replace masked values with masked_print_option, casting all innermost
  3841|         0|            0|            0|  0.00%|        dtypes to object.
  3842|         0|            0|            0|  0.00%|        """
  3843|         0|            0|            0|  0.00%|        if masked_print_option.enabled():
  3844|         0|            0|            0|  0.00%|            mask = self._mask
  3845|         0|            0|            0|  0.00%|            if mask is nomask:
  3846|         0|            0|            0|  0.00%|                res = self._data
  3847|         0|            0|            0|  0.00%|            else:
  3848|         0|            0|            0|  0.00%|                # convert to object array to make filled work
  3849|         0|            0|            0|  0.00%|                data = self._data
  3850|         0|            0|            0|  0.00%|                # For big arrays, to avoid a costly conversion to the
  3851|         0|            0|            0|  0.00%|                # object dtype, extract the corners before the conversion.
  3852|         0|            0|            0|  0.00%|                print_width = (self._print_width if self.ndim > 1
  3853|         0|            0|            0|  0.00%|                               else self._print_width_1d)
  3854|         0|            0|            0|  0.00%|                for axis in range(self.ndim):
  3855|         0|            0|            0|  0.00%|                    if data.shape[axis] > print_width:
  3856|         0|            0|            0|  0.00%|                        ind = print_width // 2
  3857|         0|            0|            0|  0.00%|                        arr = np.split(data, (ind, -ind), axis=axis)
  3858|         0|            0|            0|  0.00%|                        data = np.concatenate((arr[0], arr[2]), axis=axis)
  3859|         0|            0|            0|  0.00%|                        arr = np.split(mask, (ind, -ind), axis=axis)
  3860|         0|            0|            0|  0.00%|                        mask = np.concatenate((arr[0], arr[2]), axis=axis)
  3861|         0|            0|            0|  0.00%|
  3862|         0|            0|            0|  0.00%|                rdtype = _replace_dtype_fields(self.dtype, "O")
  3863|         0|            0|            0|  0.00%|                res = data.astype(rdtype)
  3864|         0|            0|            0|  0.00%|                _recursive_printoption(res, mask, masked_print_option)
  3865|         0|            0|            0|  0.00%|        else:
  3866|         0|            0|            0|  0.00%|            res = self.filled(self.fill_value)
  3867|         0|            0|            0|  0.00%|        return res
  3868|         0|            0|            0|  0.00%|
  3869|         0|            0|            0|  0.00%|    def __str__(self):
  3870|         0|            0|            0|  0.00%|        return str(self._insert_masked_print())
  3871|         0|            0|            0|  0.00%|
  3872|         0|            0|            0|  0.00%|    if sys.version_info.major < 3:
  3873|         0|            0|            0|  0.00%|        def __unicode__(self):
  3874|         0|            0|            0|  0.00%|            return unicode(self._insert_masked_print())
  3875|         0|            0|            0|  0.00%|
  3876|         0|            0|            0|  0.00%|    def __repr__(self):
  3877|         0|            0|            0|  0.00%|        """
  3878|         0|            0|            0|  0.00%|        Literal string representation.
  3879|         0|            0|            0|  0.00%|
  3880|         0|            0|            0|  0.00%|        """
  3881|         0|            0|            0|  0.00%|        if self._baseclass is np.ndarray:
  3882|         0|            0|            0|  0.00%|            name = 'array'
  3883|         0|            0|            0|  0.00%|        else:
  3884|         0|            0|            0|  0.00%|            name = self._baseclass.__name__
  3885|         0|            0|            0|  0.00%|
  3886|         0|            0|            0|  0.00%|
  3887|         0|            0|            0|  0.00%|        # 2016-11-19: Demoted to legacy format
  3888|         0|            0|            0|  0.00%|        if np.get_printoptions()['legacy'] == '1.13':
  3889|         0|            0|            0|  0.00%|            is_long = self.ndim > 1
  3890|         0|            0|            0|  0.00%|            parameters = dict(
  3891|         0|            0|            0|  0.00%|                name=name,
  3892|         0|            0|            0|  0.00%|                nlen=" " * len(name),
  3893|         0|            0|            0|  0.00%|                data=str(self),
  3894|         0|            0|            0|  0.00%|                mask=str(self._mask),
  3895|         0|            0|            0|  0.00%|                fill=str(self.fill_value),
  3896|         0|            0|            0|  0.00%|                dtype=str(self.dtype)
  3897|         0|            0|            0|  0.00%|            )
  3898|         0|            0|            0|  0.00%|            is_structured = bool(self.dtype.names)
  3899|         0|            0|            0|  0.00%|            key = '{}_{}'.format(
  3900|         0|            0|            0|  0.00%|                'long' if is_long else 'short',
  3901|         0|            0|            0|  0.00%|                'flx' if is_structured else 'std'
  3902|         0|            0|            0|  0.00%|            )
  3903|         0|            0|            0|  0.00%|            return _legacy_print_templates[key] % parameters
  3904|         0|            0|            0|  0.00%|
  3905|         0|            0|            0|  0.00%|        prefix = 'masked_{}('.format(name)
  3906|         0|            0|            0|  0.00%|
  3907|         0|            0|            0|  0.00%|        dtype_needed = (
  3908|         0|            0|            0|  0.00%|            not np.core.arrayprint.dtype_is_implied(self.dtype) or
  3909|         0|            0|            0|  0.00%|            np.all(self.mask) or
  3910|         0|            0|            0|  0.00%|            self.size == 0
  3911|         0|            0|            0|  0.00%|        )
  3912|         0|            0|            0|  0.00%|
  3913|         0|            0|            0|  0.00%|        # determine which keyword args need to be shown
  3914|         0|            0|            0|  0.00%|        keys = ['data', 'mask', 'fill_value']
  3915|         0|            0|            0|  0.00%|        if dtype_needed:
  3916|         0|            0|            0|  0.00%|            keys.append('dtype')
  3917|         0|            0|            0|  0.00%|
  3918|         0|            0|            0|  0.00%|        # array has only one row (non-column)
  3919|         0|            0|            0|  0.00%|        is_one_row = builtins.all(dim == 1 for dim in self.shape[:-1])
  3920|         0|            0|            0|  0.00%|
  3921|         0|            0|            0|  0.00%|        # choose what to indent each keyword with
  3922|         0|            0|            0|  0.00%|        min_indent = 2
  3923|         0|            0|            0|  0.00%|        if is_one_row:
  3924|         0|            0|            0|  0.00%|            # first key on the same line as the type, remaining keys
  3925|         0|            0|            0|  0.00%|            # aligned by equals
  3926|         0|            0|            0|  0.00%|            indents = {}
  3927|         0|            0|            0|  0.00%|            indents[keys[0]] = prefix
  3928|         0|            0|            0|  0.00%|            for k in keys[1:]:
  3929|         0|            0|            0|  0.00%|                n = builtins.max(min_indent, len(prefix + keys[0]) - len(k))
  3930|         0|            0|            0|  0.00%|                indents[k] = ' ' * n
  3931|         0|            0|            0|  0.00%|            prefix = ''  # absorbed into the first indent
  3932|         0|            0|            0|  0.00%|        else:
  3933|         0|            0|            0|  0.00%|            # each key on its own line, indented by two spaces
  3934|         0|            0|            0|  0.00%|            indents = {k: ' ' * min_indent for k in keys}
  3935|         0|            0|            0|  0.00%|            prefix = prefix + '\n'  # first key on the next line
  3936|         0|            0|            0|  0.00%|
  3937|         0|            0|            0|  0.00%|        # format the field values
  3938|         0|            0|            0|  0.00%|        reprs = {}
  3939|         0|            0|            0|  0.00%|        reprs['data'] = np.array2string(
  3940|         0|            0|            0|  0.00%|            self._insert_masked_print(),
  3941|         0|            0|            0|  0.00%|            separator=", ",
  3942|         0|            0|            0|  0.00%|            prefix=indents['data'] + 'data=',
  3943|         0|            0|            0|  0.00%|            suffix=',')
  3944|         0|            0|            0|  0.00%|        reprs['mask'] = np.array2string(
  3945|         0|            0|            0|  0.00%|            self._mask,
  3946|         0|            0|            0|  0.00%|            separator=", ",
  3947|         0|            0|            0|  0.00%|            prefix=indents['mask'] + 'mask=',
  3948|         0|            0|            0|  0.00%|            suffix=',')
  3949|         0|            0|            0|  0.00%|        reprs['fill_value'] = repr(self.fill_value)
  3950|         0|            0|            0|  0.00%|        if dtype_needed:
  3951|         0|            0|            0|  0.00%|            reprs['dtype'] = np.core.arrayprint.dtype_short_repr(self.dtype)
  3952|         0|            0|            0|  0.00%|
  3953|         0|            0|            0|  0.00%|        # join keys with values and indentations
  3954|         0|            0|            0|  0.00%|        result = ',\n'.join(
  3955|         0|            0|            0|  0.00%|            '{}{}={}'.format(indents[k], k, reprs[k])
  3956|         0|            0|            0|  0.00%|            for k in keys
  3957|         0|            0|            0|  0.00%|        )
  3958|         0|            0|            0|  0.00%|        return prefix + result + ')'
  3959|         0|            0|            0|  0.00%|
  3960|         0|            0|            0|  0.00%|    def _delegate_binop(self, other):
  3961|         0|            0|            0|  0.00%|        # This emulates the logic in
  3962|         0|            0|            0|  0.00%|        #     private/binop_override.h:forward_binop_should_defer
  3963|         0|            0|            0|  0.00%|        if isinstance(other, type(self)):
  3964|         0|            0|            0|  0.00%|            return False
  3965|         0|            0|            0|  0.00%|        array_ufunc = getattr(other, "__array_ufunc__", False)
  3966|         0|            0|            0|  0.00%|        if array_ufunc is False:
  3967|         0|            0|            0|  0.00%|            other_priority = getattr(other, "__array_priority__", -1000000)
  3968|         0|            0|            0|  0.00%|            return self.__array_priority__ < other_priority
  3969|         0|            0|            0|  0.00%|        else:
  3970|         0|            0|            0|  0.00%|            # If array_ufunc is not None, it will be called inside the ufunc;
  3971|         0|            0|            0|  0.00%|            # None explicitly tells us to not call the ufunc, i.e., defer.
  3972|         0|            0|            0|  0.00%|            return array_ufunc is None
  3973|         0|            0|            0|  0.00%|
  3974|         0|            0|            0|  0.00%|    def _comparison(self, other, compare):
  3975|         0|            0|            0|  0.00%|        """Compare self with other using operator.eq or operator.ne.
  3976|         0|            0|            0|  0.00%|
  3977|         0|            0|            0|  0.00%|        When either of the elements is masked, the result is masked as well,
  3978|         0|            0|            0|  0.00%|        but the underlying boolean data are still set, with self and other
  3979|         0|            0|            0|  0.00%|        considered equal if both are masked, and unequal otherwise.
  3980|         0|            0|            0|  0.00%|
  3981|         0|            0|            0|  0.00%|        For structured arrays, all fields are combined, with masked values
  3982|         0|            0|            0|  0.00%|        ignored. The result is masked if all fields were masked, with self
  3983|         0|            0|            0|  0.00%|        and other considered equal only if both were fully masked.
  3984|         0|            0|            0|  0.00%|        """
  3985|         0|            0|            0|  0.00%|        omask = getmask(other)
  3986|         0|            0|            0|  0.00%|        smask = self.mask
  3987|         0|            0|            0|  0.00%|        mask = mask_or(smask, omask, copy=True)
  3988|         0|            0|            0|  0.00%|
  3989|         0|            0|            0|  0.00%|        odata = getdata(other)
  3990|         0|            0|            0|  0.00%|        if mask.dtype.names is not None:
  3991|         0|            0|            0|  0.00%|            # For possibly masked structured arrays we need to be careful,
  3992|         0|            0|            0|  0.00%|            # since the standard structured array comparison will use all
  3993|         0|            0|            0|  0.00%|            # fields, masked or not. To avoid masked fields influencing the
  3994|         0|            0|            0|  0.00%|            # outcome, we set all masked fields in self to other, so they'll
  3995|         0|            0|            0|  0.00%|            # count as equal.  To prepare, we ensure we have the right shape.
  3996|         0|            0|            0|  0.00%|            broadcast_shape = np.broadcast(self, odata).shape
  3997|         0|            0|            0|  0.00%|            sbroadcast = np.broadcast_to(self, broadcast_shape, subok=True)
  3998|         0|            0|            0|  0.00%|            sbroadcast._mask = mask
  3999|         0|            0|            0|  0.00%|            sdata = sbroadcast.filled(odata)
  4000|         0|            0|            0|  0.00%|            # Now take care of the mask; the merged mask should have an item
  4001|         0|            0|            0|  0.00%|            # masked if all fields were masked (in one and/or other).
  4002|         0|            0|            0|  0.00%|            mask = (mask == np.ones((), mask.dtype))
  4003|         0|            0|            0|  0.00%|
  4004|         0|            0|            0|  0.00%|        else:
  4005|         0|            0|            0|  0.00%|            # For regular arrays, just use the data as they come.
  4006|         0|            0|            0|  0.00%|            sdata = self.data
  4007|         0|            0|            0|  0.00%|
  4008|         0|            0|            0|  0.00%|        check = compare(sdata, odata)
  4009|         0|            0|            0|  0.00%|
  4010|         0|            0|            0|  0.00%|        if isinstance(check, (np.bool_, bool)):
  4011|         0|            0|            0|  0.00%|            return masked if mask else check
  4012|         0|            0|            0|  0.00%|
  4013|         0|            0|            0|  0.00%|        if mask is not nomask:
  4014|         0|            0|            0|  0.00%|            # Adjust elements that were masked, which should be treated
  4015|         0|            0|            0|  0.00%|            # as equal if masked in both, unequal if masked in one.
  4016|         0|            0|            0|  0.00%|            # Note that this works automatically for structured arrays too.
  4017|         0|            0|            0|  0.00%|            check = np.where(mask, compare(smask, omask), check)
  4018|         0|            0|            0|  0.00%|            if mask.shape != check.shape:
  4019|         0|            0|            0|  0.00%|                # Guarantee consistency of the shape, making a copy since the
  4020|         0|            0|            0|  0.00%|                # the mask may need to get written to later.
  4021|         0|            0|            0|  0.00%|                mask = np.broadcast_to(mask, check.shape).copy()
  4022|         0|            0|            0|  0.00%|
  4023|         0|            0|            0|  0.00%|        check = check.view(type(self))
  4024|         0|            0|            0|  0.00%|        check._update_from(self)
  4025|         0|            0|            0|  0.00%|        check._mask = mask
  4026|         0|            0|            0|  0.00%|
  4027|         0|            0|            0|  0.00%|        # Cast fill value to bool_ if needed. If it cannot be cast, the
  4028|         0|            0|            0|  0.00%|        # default boolean fill value is used.
  4029|         0|            0|            0|  0.00%|        if check._fill_value is not None:
  4030|         0|            0|            0|  0.00%|            try:
  4031|         0|            0|            0|  0.00%|                fill = _check_fill_value(check._fill_value, np.bool_)
  4032|         0|            0|            0|  0.00%|            except (TypeError, ValueError):
  4033|         0|            0|            0|  0.00%|                fill = _check_fill_value(None, np.bool_)
  4034|         0|            0|            0|  0.00%|            check._fill_value = fill
  4035|         0|            0|            0|  0.00%|
  4036|         0|            0|            0|  0.00%|        return check
  4037|         0|            0|            0|  0.00%|
  4038|         0|            0|            0|  0.00%|    def __eq__(self, other):
  4039|         0|            0|            0|  0.00%|        """Check whether other equals self elementwise.
  4040|         0|            0|            0|  0.00%|
  4041|         0|            0|            0|  0.00%|        When either of the elements is masked, the result is masked as well,
  4042|         0|            0|            0|  0.00%|        but the underlying boolean data are still set, with self and other
  4043|         0|            0|            0|  0.00%|        considered equal if both are masked, and unequal otherwise.
  4044|         0|            0|            0|  0.00%|
  4045|         0|            0|            0|  0.00%|        For structured arrays, all fields are combined, with masked values
  4046|         0|            0|            0|  0.00%|        ignored. The result is masked if all fields were masked, with self
  4047|         0|            0|            0|  0.00%|        and other considered equal only if both were fully masked.
  4048|         0|            0|            0|  0.00%|        """
  4049|         0|            0|            0|  0.00%|        return self._comparison(other, operator.eq)
  4050|         0|            0|            0|  0.00%|
  4051|         0|            0|            0|  0.00%|    def __ne__(self, other):
  4052|         0|            0|            0|  0.00%|        """Check whether other does not equal self elementwise.
  4053|         0|            0|            0|  0.00%|
  4054|         0|            0|            0|  0.00%|        When either of the elements is masked, the result is masked as well,
  4055|         0|            0|            0|  0.00%|        but the underlying boolean data are still set, with self and other
  4056|         0|            0|            0|  0.00%|        considered equal if both are masked, and unequal otherwise.
  4057|         0|            0|            0|  0.00%|
  4058|         0|            0|            0|  0.00%|        For structured arrays, all fields are combined, with masked values
  4059|         0|            0|            0|  0.00%|        ignored. The result is masked if all fields were masked, with self
  4060|         0|            0|            0|  0.00%|        and other considered equal only if both were fully masked.
  4061|         0|            0|            0|  0.00%|        """
  4062|         0|            0|            0|  0.00%|        return self._comparison(other, operator.ne)
  4063|         0|            0|            0|  0.00%|
  4064|         0|            0|            0|  0.00%|    def __add__(self, other):
  4065|         0|            0|            0|  0.00%|        """
  4066|         0|            0|            0|  0.00%|        Add self to other, and return a new masked array.
  4067|         0|            0|            0|  0.00%|
  4068|         0|            0|            0|  0.00%|        """
  4069|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4070|         0|            0|            0|  0.00%|            return NotImplemented
  4071|         0|            0|            0|  0.00%|        return add(self, other)
  4072|         0|            0|            0|  0.00%|
  4073|         0|            0|            0|  0.00%|    def __radd__(self, other):
  4074|         0|            0|            0|  0.00%|        """
  4075|         0|            0|            0|  0.00%|        Add other to self, and return a new masked array.
  4076|         0|            0|            0|  0.00%|
  4077|         0|            0|            0|  0.00%|        """
  4078|         0|            0|            0|  0.00%|        # In analogy with __rsub__ and __rdiv__, use original order:
  4079|         0|            0|            0|  0.00%|        # we get here from `other + self`.
  4080|         0|            0|            0|  0.00%|        return add(other, self)
  4081|         0|            0|            0|  0.00%|
  4082|         0|            0|            0|  0.00%|    def __sub__(self, other):
  4083|         0|            0|            0|  0.00%|        """
  4084|         0|            0|            0|  0.00%|        Subtract other from self, and return a new masked array.
  4085|         0|            0|            0|  0.00%|
  4086|         0|            0|            0|  0.00%|        """
  4087|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4088|         0|            0|            0|  0.00%|            return NotImplemented
  4089|         0|            0|            0|  0.00%|        return subtract(self, other)
  4090|         0|            0|            0|  0.00%|
  4091|         0|            0|            0|  0.00%|    def __rsub__(self, other):
  4092|         0|            0|            0|  0.00%|        """
  4093|         0|            0|            0|  0.00%|        Subtract self from other, and return a new masked array.
  4094|         0|            0|            0|  0.00%|
  4095|         0|            0|            0|  0.00%|        """
  4096|         0|            0|            0|  0.00%|        return subtract(other, self)
  4097|         0|            0|            0|  0.00%|
  4098|         0|            0|            0|  0.00%|    def __mul__(self, other):
  4099|         0|            0|            0|  0.00%|        "Multiply self by other, and return a new masked array."
  4100|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4101|         0|            0|            0|  0.00%|            return NotImplemented
  4102|         0|            0|            0|  0.00%|        return multiply(self, other)
  4103|         0|            0|            0|  0.00%|
  4104|         0|            0|            0|  0.00%|    def __rmul__(self, other):
  4105|         0|            0|            0|  0.00%|        """
  4106|         0|            0|            0|  0.00%|        Multiply other by self, and return a new masked array.
  4107|         0|            0|            0|  0.00%|
  4108|         0|            0|            0|  0.00%|        """
  4109|         0|            0|            0|  0.00%|        # In analogy with __rsub__ and __rdiv__, use original order:
  4110|         0|            0|            0|  0.00%|        # we get here from `other * self`.
  4111|         0|            0|            0|  0.00%|        return multiply(other, self)
  4112|         0|            0|            0|  0.00%|
  4113|         0|            0|            0|  0.00%|    def __div__(self, other):
  4114|         0|            0|            0|  0.00%|        """
  4115|         0|            0|            0|  0.00%|        Divide other into self, and return a new masked array.
  4116|         0|            0|            0|  0.00%|
  4117|         0|            0|            0|  0.00%|        """
  4118|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4119|         0|            0|            0|  0.00%|            return NotImplemented
  4120|         0|            0|            0|  0.00%|        return divide(self, other)
  4121|         0|            0|            0|  0.00%|
  4122|         0|            0|            0|  0.00%|    def __truediv__(self, other):
  4123|         0|            0|            0|  0.00%|        """
  4124|         0|            0|            0|  0.00%|        Divide other into self, and return a new masked array.
  4125|         0|            0|            0|  0.00%|
  4126|         0|            0|            0|  0.00%|        """
  4127|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4128|         0|            0|            0|  0.00%|            return NotImplemented
  4129|         0|            0|            0|  0.00%|        return true_divide(self, other)
  4130|         0|            0|            0|  0.00%|
  4131|         0|            0|            0|  0.00%|    def __rtruediv__(self, other):
  4132|         0|            0|            0|  0.00%|        """
  4133|         0|            0|            0|  0.00%|        Divide self into other, and return a new masked array.
  4134|         0|            0|            0|  0.00%|
  4135|         0|            0|            0|  0.00%|        """
  4136|         0|            0|            0|  0.00%|        return true_divide(other, self)
  4137|         0|            0|            0|  0.00%|
  4138|         0|            0|            0|  0.00%|    def __floordiv__(self, other):
  4139|         0|            0|            0|  0.00%|        """
  4140|         0|            0|            0|  0.00%|        Divide other into self, and return a new masked array.
  4141|         0|            0|            0|  0.00%|
  4142|         0|            0|            0|  0.00%|        """
  4143|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4144|         0|            0|            0|  0.00%|            return NotImplemented
  4145|         0|            0|            0|  0.00%|        return floor_divide(self, other)
  4146|         0|            0|            0|  0.00%|
  4147|         0|            0|            0|  0.00%|    def __rfloordiv__(self, other):
  4148|         0|            0|            0|  0.00%|        """
  4149|         0|            0|            0|  0.00%|        Divide self into other, and return a new masked array.
  4150|         0|            0|            0|  0.00%|
  4151|         0|            0|            0|  0.00%|        """
  4152|         0|            0|            0|  0.00%|        return floor_divide(other, self)
  4153|         0|            0|            0|  0.00%|
  4154|         0|            0|            0|  0.00%|    def __pow__(self, other):
  4155|         0|            0|            0|  0.00%|        """
  4156|         0|            0|            0|  0.00%|        Raise self to the power other, masking the potential NaNs/Infs
  4157|         0|            0|            0|  0.00%|
  4158|         0|            0|            0|  0.00%|        """
  4159|         0|            0|            0|  0.00%|        if self._delegate_binop(other):
  4160|         0|            0|            0|  0.00%|            return NotImplemented
  4161|         0|            0|            0|  0.00%|        return power(self, other)
  4162|         0|            0|            0|  0.00%|
  4163|         0|            0|            0|  0.00%|    def __rpow__(self, other):
  4164|         0|            0|            0|  0.00%|        """
  4165|         0|            0|            0|  0.00%|        Raise other to the power self, masking the potential NaNs/Infs
  4166|         0|            0|            0|  0.00%|
  4167|         0|            0|            0|  0.00%|        """
  4168|         0|            0|            0|  0.00%|        return power(other, self)
  4169|         0|            0|            0|  0.00%|
  4170|         0|            0|            0|  0.00%|    def __iadd__(self, other):
  4171|         0|            0|            0|  0.00%|        """
  4172|         0|            0|            0|  0.00%|        Add other to self in-place.
  4173|         0|            0|            0|  0.00%|
  4174|         0|            0|            0|  0.00%|        """
  4175|         0|            0|            0|  0.00%|        m = getmask(other)
  4176|         0|            0|            0|  0.00%|        if self._mask is nomask:
  4177|         0|            0|            0|  0.00%|            if m is not nomask and m.any():
  4178|         0|            0|            0|  0.00%|                self._mask = make_mask_none(self.shape, self.dtype)
  4179|         0|            0|            0|  0.00%|                self._mask += m
  4180|         0|            0|            0|  0.00%|        else:
  4181|         0|            0|            0|  0.00%|            if m is not nomask:
  4182|         0|            0|            0|  0.00%|                self._mask += m
  4183|         0|            0|            0|  0.00%|        self._data.__iadd__(np.where(self._mask, self.dtype.type(0),
  4184|         0|            0|            0|  0.00%|                                     getdata(other)))
  4185|         0|            0|            0|  0.00%|        return self
  4186|         0|            0|            0|  0.00%|
  4187|         0|            0|            0|  0.00%|    def __isub__(self, other):
  4188|         0|            0|            0|  0.00%|        """
  4189|         0|            0|            0|  0.00%|        Subtract other from self in-place.
  4190|         0|            0|            0|  0.00%|
  4191|         0|            0|            0|  0.00%|        """
  4192|         0|            0|            0|  0.00%|        m = getmask(other)
  4193|         0|            0|            0|  0.00%|        if self._mask is nomask:
  4194|         0|            0|            0|  0.00%|            if m is not nomask and m.any():
  4195|         0|            0|            0|  0.00%|                self._mask = make_mask_none(self.shape, self.dtype)
  4196|         0|            0|            0|  0.00%|                self._mask += m
  4197|         0|            0|            0|  0.00%|        elif m is not nomask:
  4198|         0|            0|            0|  0.00%|            self._mask += m
  4199|         0|            0|            0|  0.00%|        self._data.__isub__(np.where(self._mask, self.dtype.type(0),
  4200|         0|            0|            0|  0.00%|                                     getdata(other)))
  4201|         0|            0|            0|  0.00%|        return self
  4202|         0|            0|            0|  0.00%|
  4203|         0|            0|            0|  0.00%|    def __imul__(self, other):
  4204|         0|            0|            0|  0.00%|        """
  4205|         0|            0|            0|  0.00%|        Multiply self by other in-place.
  4206|         0|            0|            0|  0.00%|
  4207|         0|            0|            0|  0.00%|        """
  4208|         0|            0|            0|  0.00%|        m = getmask(other)
  4209|         0|            0|            0|  0.00%|        if self._mask is nomask:
  4210|         0|            0|            0|  0.00%|            if m is not nomask and m.any():
  4211|         0|            0|            0|  0.00%|                self._mask = make_mask_none(self.shape, self.dtype)
  4212|         0|            0|            0|  0.00%|                self._mask += m
  4213|         0|            0|            0|  0.00%|        elif m is not nomask:
  4214|         0|            0|            0|  0.00%|            self._mask += m
  4215|         0|            0|            0|  0.00%|        self._data.__imul__(np.where(self._mask, self.dtype.type(1),
  4216|         0|            0|            0|  0.00%|                                     getdata(other)))
  4217|         0|            0|            0|  0.00%|        return self
  4218|         0|            0|            0|  0.00%|
  4219|         0|            0|            0|  0.00%|    def __idiv__(self, other):
  4220|         0|            0|            0|  0.00%|        """
  4221|         0|            0|            0|  0.00%|        Divide self by other in-place.
  4222|         0|            0|            0|  0.00%|
  4223|         0|            0|            0|  0.00%|        """
  4224|         0|            0|            0|  0.00%|        other_data = getdata(other)
  4225|         0|            0|            0|  0.00%|        dom_mask = _DomainSafeDivide().__call__(self._data, other_data)
  4226|         0|            0|            0|  0.00%|        other_mask = getmask(other)
  4227|         0|            0|            0|  0.00%|        new_mask = mask_or(other_mask, dom_mask)
  4228|         0|            0|            0|  0.00%|        # The following 3 lines control the domain filling
  4229|         0|            0|            0|  0.00%|        if dom_mask.any():
  4230|         0|            0|            0|  0.00%|            (_, fval) = ufunc_fills[np.divide]
  4231|         0|            0|            0|  0.00%|            other_data = np.where(dom_mask, fval, other_data)
  4232|         0|            0|            0|  0.00%|        self._mask |= new_mask
  4233|         0|            0|            0|  0.00%|        self._data.__idiv__(np.where(self._mask, self.dtype.type(1),
  4234|         0|            0|            0|  0.00%|                                     other_data))
  4235|         0|            0|            0|  0.00%|        return self
  4236|         0|            0|            0|  0.00%|
  4237|         0|            0|            0|  0.00%|    def __ifloordiv__(self, other):
  4238|         0|            0|            0|  0.00%|        """
  4239|         0|            0|            0|  0.00%|        Floor divide self by other in-place.
  4240|         0|            0|            0|  0.00%|
  4241|         0|            0|            0|  0.00%|        """
  4242|         0|            0|            0|  0.00%|        other_data = getdata(other)
  4243|         0|            0|            0|  0.00%|        dom_mask = _DomainSafeDivide().__call__(self._data, other_data)
  4244|         0|            0|            0|  0.00%|        other_mask = getmask(other)
  4245|         0|            0|            0|  0.00%|        new_mask = mask_or(other_mask, dom_mask)
  4246|         0|            0|            0|  0.00%|        # The following 3 lines control the domain filling
  4247|         0|            0|            0|  0.00%|        if dom_mask.any():
  4248|         0|            0|            0|  0.00%|            (_, fval) = ufunc_fills[np.floor_divide]
  4249|         0|            0|            0|  0.00%|            other_data = np.where(dom_mask, fval, other_data)
  4250|         0|            0|            0|  0.00%|        self._mask |= new_mask
  4251|         0|            0|            0|  0.00%|        self._data.__ifloordiv__(np.where(self._mask, self.dtype.type(1),
  4252|         0|            0|            0|  0.00%|                                          other_data))
  4253|         0|            0|            0|  0.00%|        return self
  4254|         0|            0|            0|  0.00%|
  4255|         0|            0|            0|  0.00%|    def __itruediv__(self, other):
  4256|         0|            0|            0|  0.00%|        """
  4257|         0|            0|            0|  0.00%|        True divide self by other in-place.
  4258|         0|            0|            0|  0.00%|
  4259|         0|            0|            0|  0.00%|        """
  4260|         0|            0|            0|  0.00%|        other_data = getdata(other)
  4261|         0|            0|            0|  0.00%|        dom_mask = _DomainSafeDivide().__call__(self._data, other_data)
  4262|         0|            0|            0|  0.00%|        other_mask = getmask(other)
  4263|         0|            0|            0|  0.00%|        new_mask = mask_or(other_mask, dom_mask)
  4264|         0|            0|            0|  0.00%|        # The following 3 lines control the domain filling
  4265|         0|            0|            0|  0.00%|        if dom_mask.any():
  4266|         0|            0|            0|  0.00%|            (_, fval) = ufunc_fills[np.true_divide]
  4267|         0|            0|            0|  0.00%|            other_data = np.where(dom_mask, fval, other_data)
  4268|         0|            0|            0|  0.00%|        self._mask |= new_mask
  4269|         0|            0|            0|  0.00%|        self._data.__itruediv__(np.where(self._mask, self.dtype.type(1),
  4270|         0|            0|            0|  0.00%|                                         other_data))
  4271|         0|            0|            0|  0.00%|        return self
  4272|         0|            0|            0|  0.00%|
  4273|         0|            0|            0|  0.00%|    def __ipow__(self, other):
  4274|         0|            0|            0|  0.00%|        """
  4275|         0|            0|            0|  0.00%|        Raise self to the power other, in place.
  4276|         0|            0|            0|  0.00%|
  4277|         0|            0|            0|  0.00%|        """
  4278|         0|            0|            0|  0.00%|        other_data = getdata(other)
  4279|         0|            0|            0|  0.00%|        other_mask = getmask(other)
  4280|         0|            0|            0|  0.00%|        with np.errstate(divide='ignore', invalid='ignore'):
  4281|         0|            0|            0|  0.00%|            self._data.__ipow__(np.where(self._mask, self.dtype.type(1),
  4282|         0|            0|            0|  0.00%|                                         other_data))
  4283|         0|            0|            0|  0.00%|        invalid = np.logical_not(np.isfinite(self._data))
  4284|         0|            0|            0|  0.00%|        if invalid.any():
  4285|         0|            0|            0|  0.00%|            if self._mask is not nomask:
  4286|         0|            0|            0|  0.00%|                self._mask |= invalid
  4287|         0|            0|            0|  0.00%|            else:
  4288|         0|            0|            0|  0.00%|                self._mask = invalid
  4289|         0|            0|            0|  0.00%|            np.copyto(self._data, self.fill_value, where=invalid)
  4290|         0|            0|            0|  0.00%|        new_mask = mask_or(other_mask, invalid)
  4291|         0|            0|            0|  0.00%|        self._mask = mask_or(self._mask, new_mask)
  4292|         0|            0|            0|  0.00%|        return self
  4293|         0|            0|            0|  0.00%|
  4294|         0|            0|            0|  0.00%|    def __float__(self):
  4295|         0|            0|            0|  0.00%|        """
  4296|         0|            0|            0|  0.00%|        Convert to float.
  4297|         0|            0|            0|  0.00%|
  4298|         0|            0|            0|  0.00%|        """
  4299|         0|            0|            0|  0.00%|        if self.size > 1:
  4300|         0|            0|            0|  0.00%|            raise TypeError("Only length-1 arrays can be converted "
  4301|         0|            0|            0|  0.00%|                            "to Python scalars")
  4302|         0|            0|            0|  0.00%|        elif self._mask:
  4303|         0|            0|            0|  0.00%|            warnings.warn("Warning: converting a masked element to nan.", stacklevel=2)
  4304|         0|            0|            0|  0.00%|            return np.nan
  4305|         0|            0|            0|  0.00%|        return float(self.item())
  4306|         0|            0|            0|  0.00%|
  4307|         0|            0|            0|  0.00%|    def __int__(self):
  4308|         0|            0|            0|  0.00%|        """
  4309|         0|            0|            0|  0.00%|        Convert to int.
  4310|         0|            0|            0|  0.00%|
  4311|         0|            0|            0|  0.00%|        """
  4312|         0|            0|            0|  0.00%|        if self.size > 1:
  4313|         0|            0|            0|  0.00%|            raise TypeError("Only length-1 arrays can be converted "
  4314|         0|            0|            0|  0.00%|                            "to Python scalars")
  4315|         0|            0|            0|  0.00%|        elif self._mask:
  4316|         0|            0|            0|  0.00%|            raise MaskError('Cannot convert masked element to a Python int.')
  4317|         0|            0|            0|  0.00%|        return int(self.item())
  4318|         0|            0|            0|  0.00%|
  4319|         0|            0|            0|  0.00%|    def __long__(self):
  4320|         0|            0|            0|  0.00%|        """
  4321|         0|            0|            0|  0.00%|        Convert to long.
  4322|         0|            0|            0|  0.00%|        """
  4323|         0|            0|            0|  0.00%|        if self.size > 1:
  4324|         0|            0|            0|  0.00%|            raise TypeError("Only length-1 arrays can be converted "
  4325|         0|            0|            0|  0.00%|                            "to Python scalars")
  4326|         0|            0|            0|  0.00%|        elif self._mask:
  4327|         0|            0|            0|  0.00%|            raise MaskError('Cannot convert masked element to a Python long.')
  4328|         0|            0|            0|  0.00%|        return long(self.item())
  4329|         0|            0|            0|  0.00%|
  4330|         0|            0|            0|  0.00%|    @property
  4331|         0|            0|            0|  0.00%|    def imag(self):
  4332|         0|            0|            0|  0.00%|        """
  4333|         0|            0|            0|  0.00%|        The imaginary part of the masked array.
  4334|         0|            0|            0|  0.00%|
  4335|         0|            0|            0|  0.00%|        This property is a view on the imaginary part of this `MaskedArray`.
  4336|         0|            0|            0|  0.00%|
  4337|         0|            0|            0|  0.00%|        See Also
  4338|         0|            0|            0|  0.00%|        --------
  4339|         0|            0|            0|  0.00%|        real
  4340|         0|            0|            0|  0.00%|
  4341|         0|            0|            0|  0.00%|        Examples
  4342|         0|            0|            0|  0.00%|        --------
  4343|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
  4344|         0|            0|            0|  0.00%|        >>> x.imag
  4345|         0|            0|            0|  0.00%|        masked_array(data=[1.0, --, 1.6],
  4346|         0|            0|            0|  0.00%|                     mask=[False,  True, False],
  4347|         0|            0|            0|  0.00%|               fill_value=1e+20)
  4348|         0|            0|            0|  0.00%|
  4349|         0|            0|            0|  0.00%|        """
  4350|         0|            0|            0|  0.00%|        result = self._data.imag.view(type(self))
  4351|         0|            0|            0|  0.00%|        result.__setmask__(self._mask)
  4352|         0|            0|            0|  0.00%|        return result
  4353|         0|            0|            0|  0.00%|
  4354|         0|            0|            0|  0.00%|    # kept for compatibility
  4355|         0|            0|            0|  0.00%|    get_imag = imag.fget
  4356|         0|            0|            0|  0.00%|
  4357|         0|            0|            0|  0.00%|    @property
  4358|         0|            0|            0|  0.00%|    def real(self):
  4359|         0|            0|            0|  0.00%|        """
  4360|         0|            0|            0|  0.00%|        The real part of the masked array.
  4361|         0|            0|            0|  0.00%|
  4362|         0|            0|            0|  0.00%|        This property is a view on the real part of this `MaskedArray`.
  4363|         0|            0|            0|  0.00%|
  4364|         0|            0|            0|  0.00%|        See Also
  4365|         0|            0|            0|  0.00%|        --------
  4366|         0|            0|            0|  0.00%|        imag
  4367|         0|            0|            0|  0.00%|
  4368|         0|            0|            0|  0.00%|        Examples
  4369|         0|            0|            0|  0.00%|        --------
  4370|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1+1.j, -2j, 3.45+1.6j], mask=[False, True, False])
  4371|         0|            0|            0|  0.00%|        >>> x.real
  4372|         0|            0|            0|  0.00%|        masked_array(data=[1.0, --, 3.45],
  4373|         0|            0|            0|  0.00%|                     mask=[False,  True, False],
  4374|         0|            0|            0|  0.00%|               fill_value=1e+20)
  4375|         0|            0|            0|  0.00%|
  4376|         0|            0|            0|  0.00%|        """
  4377|         0|            0|            0|  0.00%|        result = self._data.real.view(type(self))
  4378|         0|            0|            0|  0.00%|        result.__setmask__(self._mask)
  4379|         0|            0|            0|  0.00%|        return result
  4380|         0|            0|            0|  0.00%|
  4381|         0|            0|            0|  0.00%|    # kept for compatibility
  4382|         0|            0|            0|  0.00%|    get_real = real.fget
  4383|         0|            0|            0|  0.00%|
  4384|         0|            0|            0|  0.00%|    def count(self, axis=None, keepdims=np._NoValue):
  4385|         0|            0|            0|  0.00%|        """
  4386|         0|            0|            0|  0.00%|        Count the non-masked elements of the array along the given axis.
  4387|         0|            0|            0|  0.00%|
  4388|         0|            0|            0|  0.00%|        Parameters
  4389|         0|            0|            0|  0.00%|        ----------
  4390|         0|            0|            0|  0.00%|        axis : None or int or tuple of ints, optional
  4391|         0|            0|            0|  0.00%|            Axis or axes along which the count is performed.
  4392|         0|            0|            0|  0.00%|            The default (`axis` = `None`) performs the count over all
  4393|         0|            0|            0|  0.00%|            the dimensions of the input array. `axis` may be negative, in
  4394|         0|            0|            0|  0.00%|            which case it counts from the last to the first axis.
  4395|         0|            0|            0|  0.00%|
  4396|         0|            0|            0|  0.00%|            .. versionadded:: 1.10.0
  4397|         0|            0|            0|  0.00%|
  4398|         0|            0|            0|  0.00%|            If this is a tuple of ints, the count is performed on multiple
  4399|         0|            0|            0|  0.00%|            axes, instead of a single axis or all the axes as before.
  4400|         0|            0|            0|  0.00%|        keepdims : bool, optional
  4401|         0|            0|            0|  0.00%|            If this is set to True, the axes which are reduced are left
  4402|         0|            0|            0|  0.00%|            in the result as dimensions with size one. With this option,
  4403|         0|            0|            0|  0.00%|            the result will broadcast correctly against the array.
  4404|         0|            0|            0|  0.00%|
  4405|         0|            0|            0|  0.00%|        Returns
  4406|         0|            0|            0|  0.00%|        -------
  4407|         0|            0|            0|  0.00%|        result : ndarray or scalar
  4408|         0|            0|            0|  0.00%|            An array with the same shape as the input array, with the specified
  4409|         0|            0|            0|  0.00%|            axis removed. If the array is a 0-d array, or if `axis` is None, a
  4410|         0|            0|            0|  0.00%|            scalar is returned.
  4411|         0|            0|            0|  0.00%|
  4412|         0|            0|            0|  0.00%|        See Also
  4413|         0|            0|            0|  0.00%|        --------
  4414|         0|            0|            0|  0.00%|        count_masked : Count masked elements in array or along a given axis.
  4415|         0|            0|            0|  0.00%|
  4416|         0|            0|            0|  0.00%|        Examples
  4417|         0|            0|            0|  0.00%|        --------
  4418|         0|            0|            0|  0.00%|        >>> import numpy.ma as ma
  4419|         0|            0|            0|  0.00%|        >>> a = ma.arange(6).reshape((2, 3))
  4420|         0|            0|            0|  0.00%|        >>> a[1, :] = ma.masked
  4421|         0|            0|            0|  0.00%|        >>> a
  4422|         0|            0|            0|  0.00%|        masked_array(
  4423|         0|            0|            0|  0.00%|          data=[[0, 1, 2],
  4424|         0|            0|            0|  0.00%|                [--, --, --]],
  4425|         0|            0|            0|  0.00%|          mask=[[False, False, False],
  4426|         0|            0|            0|  0.00%|                [ True,  True,  True]],
  4427|         0|            0|            0|  0.00%|          fill_value=999999)
  4428|         0|            0|            0|  0.00%|        >>> a.count()
  4429|         0|            0|            0|  0.00%|        3
  4430|         0|            0|            0|  0.00%|
  4431|         0|            0|            0|  0.00%|        When the `axis` keyword is specified an array of appropriate size is
  4432|         0|            0|            0|  0.00%|        returned.
  4433|         0|            0|            0|  0.00%|
  4434|         0|            0|            0|  0.00%|        >>> a.count(axis=0)
  4435|         0|            0|            0|  0.00%|        array([1, 1, 1])
  4436|         0|            0|            0|  0.00%|        >>> a.count(axis=1)
  4437|         0|            0|            0|  0.00%|        array([3, 0])
  4438|         0|            0|            0|  0.00%|
  4439|         0|            0|            0|  0.00%|        """
  4440|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  4441|         0|            0|            0|  0.00%|
  4442|         0|            0|            0|  0.00%|        m = self._mask
  4443|         0|            0|            0|  0.00%|        # special case for matrices (we assume no other subclasses modify
  4444|         0|            0|            0|  0.00%|        # their dimensions)
  4445|         0|            0|            0|  0.00%|        if isinstance(self.data, np.matrix):
  4446|         0|            0|            0|  0.00%|            if m is nomask:
  4447|         0|            0|            0|  0.00%|                m = np.zeros(self.shape, dtype=np.bool_)
  4448|         0|            0|            0|  0.00%|            m = m.view(type(self.data))
  4449|         0|            0|            0|  0.00%|
  4450|         0|            0|            0|  0.00%|        if m is nomask:
  4451|         0|            0|            0|  0.00%|            # compare to _count_reduce_items in _methods.py
  4452|         0|            0|            0|  0.00%|
  4453|         0|            0|            0|  0.00%|            if self.shape == ():
  4454|         0|            0|            0|  0.00%|                if axis not in (None, 0):
  4455|         0|            0|            0|  0.00%|                    raise np.AxisError(axis=axis, ndim=self.ndim)
  4456|         0|            0|            0|  0.00%|                return 1
  4457|         0|            0|            0|  0.00%|            elif axis is None:
  4458|         0|            0|            0|  0.00%|                if kwargs.get('keepdims', False):
  4459|         0|            0|            0|  0.00%|                    return np.array(self.size, dtype=np.intp, ndmin=self.ndim)
  4460|         0|            0|            0|  0.00%|                return self.size
  4461|         0|            0|            0|  0.00%|
  4462|         0|            0|            0|  0.00%|            axes = normalize_axis_tuple(axis, self.ndim)
  4463|         0|            0|            0|  0.00%|            items = 1
  4464|         0|            0|            0|  0.00%|            for ax in axes:
  4465|         0|            0|            0|  0.00%|                items *= self.shape[ax]
  4466|         0|            0|            0|  0.00%|
  4467|         0|            0|            0|  0.00%|            if kwargs.get('keepdims', False):
  4468|         0|            0|            0|  0.00%|                out_dims = list(self.shape)
  4469|         0|            0|            0|  0.00%|                for a in axes:
  4470|         0|            0|            0|  0.00%|                    out_dims[a] = 1
  4471|         0|            0|            0|  0.00%|            else:
  4472|         0|            0|            0|  0.00%|                out_dims = [d for n, d in enumerate(self.shape)
  4473|         0|            0|            0|  0.00%|                            if n not in axes]
  4474|         0|            0|            0|  0.00%|            # make sure to return a 0-d array if axis is supplied
  4475|         0|            0|            0|  0.00%|            return np.full(out_dims, items, dtype=np.intp)
  4476|         0|            0|            0|  0.00%|
  4477|         0|            0|            0|  0.00%|        # take care of the masked singleton
  4478|         0|            0|            0|  0.00%|        if self is masked:
  4479|         0|            0|            0|  0.00%|            return 0
  4480|         0|            0|            0|  0.00%|
  4481|         0|            0|            0|  0.00%|        return (~m).sum(axis=axis, dtype=np.intp, **kwargs)
  4482|         0|            0|            0|  0.00%|
  4483|         0|            0|            0|  0.00%|    def ravel(self, order='C'):
  4484|         0|            0|            0|  0.00%|        """
  4485|         0|            0|            0|  0.00%|        Returns a 1D version of self, as a view.
  4486|         0|            0|            0|  0.00%|
  4487|         0|            0|            0|  0.00%|        Parameters
  4488|         0|            0|            0|  0.00%|        ----------
  4489|         0|            0|            0|  0.00%|        order : {'C', 'F', 'A', 'K'}, optional
  4490|         0|            0|            0|  0.00%|            The elements of `a` are read using this index order. 'C' means to
  4491|         0|            0|            0|  0.00%|            index the elements in C-like order, with the last axis index
  4492|         0|            0|            0|  0.00%|            changing fastest, back to the first axis index changing slowest.
  4493|         0|            0|            0|  0.00%|            'F' means to index the elements in Fortran-like index order, with
  4494|         0|            0|            0|  0.00%|            the first index changing fastest, and the last index changing
  4495|         0|            0|            0|  0.00%|            slowest. Note that the 'C' and 'F' options take no account of the
  4496|         0|            0|            0|  0.00%|            memory layout of the underlying array, and only refer to the order
  4497|         0|            0|            0|  0.00%|            of axis indexing.  'A' means to read the elements in Fortran-like
  4498|         0|            0|            0|  0.00%|            index order if `m` is Fortran *contiguous* in memory, C-like order
  4499|         0|            0|            0|  0.00%|            otherwise.  'K' means to read the elements in the order they occur
  4500|         0|            0|            0|  0.00%|            in memory, except for reversing the data when strides are negative.
  4501|         0|            0|            0|  0.00%|            By default, 'C' index order is used.
  4502|         0|            0|            0|  0.00%|
  4503|         0|            0|            0|  0.00%|        Returns
  4504|         0|            0|            0|  0.00%|        -------
  4505|         0|            0|            0|  0.00%|        MaskedArray
  4506|         0|            0|            0|  0.00%|            Output view is of shape ``(self.size,)`` (or
  4507|         0|            0|            0|  0.00%|            ``(np.ma.product(self.shape),)``).
  4508|         0|            0|            0|  0.00%|
  4509|         0|            0|            0|  0.00%|        Examples
  4510|         0|            0|            0|  0.00%|        --------
  4511|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
  4512|         0|            0|            0|  0.00%|        >>> x
  4513|         0|            0|            0|  0.00%|        masked_array(
  4514|         0|            0|            0|  0.00%|          data=[[1, --, 3],
  4515|         0|            0|            0|  0.00%|                [--, 5, --],
  4516|         0|            0|            0|  0.00%|                [7, --, 9]],
  4517|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  4518|         0|            0|            0|  0.00%|                [ True, False,  True],
  4519|         0|            0|            0|  0.00%|                [False,  True, False]],
  4520|         0|            0|            0|  0.00%|          fill_value=999999)
  4521|         0|            0|            0|  0.00%|        >>> x.ravel()
  4522|         0|            0|            0|  0.00%|        masked_array(data=[1, --, 3, --, 5, --, 7, --, 9],
  4523|         0|            0|            0|  0.00%|                     mask=[False,  True, False,  True, False,  True, False,  True,
  4524|         0|            0|            0|  0.00%|                           False],
  4525|         0|            0|            0|  0.00%|               fill_value=999999)
  4526|         0|            0|            0|  0.00%|
  4527|         0|            0|            0|  0.00%|        """
  4528|         0|            0|            0|  0.00%|        r = ndarray.ravel(self._data, order=order).view(type(self))
  4529|         0|            0|            0|  0.00%|        r._update_from(self)
  4530|         0|            0|            0|  0.00%|        if self._mask is not nomask:
  4531|         0|            0|            0|  0.00%|            r._mask = ndarray.ravel(self._mask, order=order).reshape(r.shape)
  4532|         0|            0|            0|  0.00%|        else:
  4533|         0|            0|            0|  0.00%|            r._mask = nomask
  4534|         0|            0|            0|  0.00%|        return r
  4535|         0|            0|            0|  0.00%|
  4536|         0|            0|            0|  0.00%|
  4537|         0|            0|            0|  0.00%|    def reshape(self, *s, **kwargs):
  4538|         0|            0|            0|  0.00%|        """
  4539|         0|            0|            0|  0.00%|        Give a new shape to the array without changing its data.
  4540|         0|            0|            0|  0.00%|
  4541|         0|            0|            0|  0.00%|        Returns a masked array containing the same data, but with a new shape.
  4542|         0|            0|            0|  0.00%|        The result is a view on the original array; if this is not possible, a
  4543|         0|            0|            0|  0.00%|        ValueError is raised.
  4544|         0|            0|            0|  0.00%|
  4545|         0|            0|            0|  0.00%|        Parameters
  4546|         0|            0|            0|  0.00%|        ----------
  4547|         0|            0|            0|  0.00%|        shape : int or tuple of ints
  4548|         0|            0|            0|  0.00%|            The new shape should be compatible with the original shape. If an
  4549|         0|            0|            0|  0.00%|            integer is supplied, then the result will be a 1-D array of that
  4550|         0|            0|            0|  0.00%|            length.
  4551|         0|            0|            0|  0.00%|        order : {'C', 'F'}, optional
  4552|         0|            0|            0|  0.00%|            Determines whether the array data should be viewed as in C
  4553|         0|            0|            0|  0.00%|            (row-major) or FORTRAN (column-major) order.
  4554|         0|            0|            0|  0.00%|
  4555|         0|            0|            0|  0.00%|        Returns
  4556|         0|            0|            0|  0.00%|        -------
  4557|         0|            0|            0|  0.00%|        reshaped_array : array
  4558|         0|            0|            0|  0.00%|            A new view on the array.
  4559|         0|            0|            0|  0.00%|
  4560|         0|            0|            0|  0.00%|        See Also
  4561|         0|            0|            0|  0.00%|        --------
  4562|         0|            0|            0|  0.00%|        reshape : Equivalent function in the masked array module.
  4563|         0|            0|            0|  0.00%|        numpy.ndarray.reshape : Equivalent method on ndarray object.
  4564|         0|            0|            0|  0.00%|        numpy.reshape : Equivalent function in the NumPy module.
  4565|         0|            0|            0|  0.00%|
  4566|         0|            0|            0|  0.00%|        Notes
  4567|         0|            0|            0|  0.00%|        -----
  4568|         0|            0|            0|  0.00%|        The reshaping operation cannot guarantee that a copy will not be made,
  4569|         0|            0|            0|  0.00%|        to modify the shape in place, use ``a.shape = s``
  4570|         0|            0|            0|  0.00%|
  4571|         0|            0|            0|  0.00%|        Examples
  4572|         0|            0|            0|  0.00%|        --------
  4573|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2],[3,4]], mask=[1,0,0,1])
  4574|         0|            0|            0|  0.00%|        >>> x
  4575|         0|            0|            0|  0.00%|        masked_array(
  4576|         0|            0|            0|  0.00%|          data=[[--, 2],
  4577|         0|            0|            0|  0.00%|                [3, --]],
  4578|         0|            0|            0|  0.00%|          mask=[[ True, False],
  4579|         0|            0|            0|  0.00%|                [False,  True]],
  4580|         0|            0|            0|  0.00%|          fill_value=999999)
  4581|         0|            0|            0|  0.00%|        >>> x = x.reshape((4,1))
  4582|         0|            0|            0|  0.00%|        >>> x
  4583|         0|            0|            0|  0.00%|        masked_array(
  4584|         0|            0|            0|  0.00%|          data=[[--],
  4585|         0|            0|            0|  0.00%|                [2],
  4586|         0|            0|            0|  0.00%|                [3],
  4587|         0|            0|            0|  0.00%|                [--]],
  4588|         0|            0|            0|  0.00%|          mask=[[ True],
  4589|         0|            0|            0|  0.00%|                [False],
  4590|         0|            0|            0|  0.00%|                [False],
  4591|         0|            0|            0|  0.00%|                [ True]],
  4592|         0|            0|            0|  0.00%|          fill_value=999999)
  4593|         0|            0|            0|  0.00%|
  4594|         0|            0|            0|  0.00%|        """
  4595|         0|            0|            0|  0.00%|        kwargs.update(order=kwargs.get('order', 'C'))
  4596|         0|            0|            0|  0.00%|        result = self._data.reshape(*s, **kwargs).view(type(self))
  4597|         0|            0|            0|  0.00%|        result._update_from(self)
  4598|         0|            0|            0|  0.00%|        mask = self._mask
  4599|         0|            0|            0|  0.00%|        if mask is not nomask:
  4600|         0|            0|            0|  0.00%|            result._mask = mask.reshape(*s, **kwargs)
  4601|         0|            0|            0|  0.00%|        return result
  4602|         0|            0|            0|  0.00%|
  4603|         0|            0|            0|  0.00%|    def resize(self, newshape, refcheck=True, order=False):
  4604|         0|            0|            0|  0.00%|        """
  4605|         0|            0|            0|  0.00%|        .. warning::
  4606|         0|            0|            0|  0.00%|
  4607|         0|            0|            0|  0.00%|            This method does nothing, except raise a ValueError exception. A
  4608|         0|            0|            0|  0.00%|            masked array does not own its data and therefore cannot safely be
  4609|         0|            0|            0|  0.00%|            resized in place. Use the `numpy.ma.resize` function instead.
  4610|         0|            0|            0|  0.00%|
  4611|         0|            0|            0|  0.00%|        This method is difficult to implement safely and may be deprecated in
  4612|         0|            0|            0|  0.00%|        future releases of NumPy.
  4613|         0|            0|            0|  0.00%|
  4614|         0|            0|            0|  0.00%|        """
  4615|         0|            0|            0|  0.00%|        # Note : the 'order' keyword looks broken, let's just drop it
  4616|         0|            0|            0|  0.00%|        errmsg = "A masked array does not own its data "\
  4617|         0|            0|            0|  0.00%|                 "and therefore cannot be resized.\n" \
  4618|         0|            0|            0|  0.00%|                 "Use the numpy.ma.resize function instead."
  4619|         0|            0|            0|  0.00%|        raise ValueError(errmsg)
  4620|         0|            0|            0|  0.00%|
  4621|         0|            0|            0|  0.00%|    def put(self, indices, values, mode='raise'):
  4622|         0|            0|            0|  0.00%|        """
  4623|         0|            0|            0|  0.00%|        Set storage-indexed locations to corresponding values.
  4624|         0|            0|            0|  0.00%|
  4625|         0|            0|            0|  0.00%|        Sets self._data.flat[n] = values[n] for each n in indices.
  4626|         0|            0|            0|  0.00%|        If `values` is shorter than `indices` then it will repeat.
  4627|         0|            0|            0|  0.00%|        If `values` has some masked values, the initial mask is updated
  4628|         0|            0|            0|  0.00%|        in consequence, else the corresponding values are unmasked.
  4629|         0|            0|            0|  0.00%|
  4630|         0|            0|            0|  0.00%|        Parameters
  4631|         0|            0|            0|  0.00%|        ----------
  4632|         0|            0|            0|  0.00%|        indices : 1-D array_like
  4633|         0|            0|            0|  0.00%|            Target indices, interpreted as integers.
  4634|         0|            0|            0|  0.00%|        values : array_like
  4635|         0|            0|            0|  0.00%|            Values to place in self._data copy at target indices.
  4636|         0|            0|            0|  0.00%|        mode : {'raise', 'wrap', 'clip'}, optional
  4637|         0|            0|            0|  0.00%|            Specifies how out-of-bounds indices will behave.
  4638|         0|            0|            0|  0.00%|            'raise' : raise an error.
  4639|         0|            0|            0|  0.00%|            'wrap' : wrap around.
  4640|         0|            0|            0|  0.00%|            'clip' : clip to the range.
  4641|         0|            0|            0|  0.00%|
  4642|         0|            0|            0|  0.00%|        Notes
  4643|         0|            0|            0|  0.00%|        -----
  4644|         0|            0|            0|  0.00%|        `values` can be a scalar or length 1 array.
  4645|         0|            0|            0|  0.00%|
  4646|         0|            0|            0|  0.00%|        Examples
  4647|         0|            0|            0|  0.00%|        --------
  4648|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
  4649|         0|            0|            0|  0.00%|        >>> x
  4650|         0|            0|            0|  0.00%|        masked_array(
  4651|         0|            0|            0|  0.00%|          data=[[1, --, 3],
  4652|         0|            0|            0|  0.00%|                [--, 5, --],
  4653|         0|            0|            0|  0.00%|                [7, --, 9]],
  4654|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  4655|         0|            0|            0|  0.00%|                [ True, False,  True],
  4656|         0|            0|            0|  0.00%|                [False,  True, False]],
  4657|         0|            0|            0|  0.00%|          fill_value=999999)
  4658|         0|            0|            0|  0.00%|        >>> x.put([0,4,8],[10,20,30])
  4659|         0|            0|            0|  0.00%|        >>> x
  4660|         0|            0|            0|  0.00%|        masked_array(
  4661|         0|            0|            0|  0.00%|          data=[[10, --, 3],
  4662|         0|            0|            0|  0.00%|                [--, 20, --],
  4663|         0|            0|            0|  0.00%|                [7, --, 30]],
  4664|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  4665|         0|            0|            0|  0.00%|                [ True, False,  True],
  4666|         0|            0|            0|  0.00%|                [False,  True, False]],
  4667|         0|            0|            0|  0.00%|          fill_value=999999)
  4668|         0|            0|            0|  0.00%|
  4669|         0|            0|            0|  0.00%|        >>> x.put(4,999)
  4670|         0|            0|            0|  0.00%|        >>> x
  4671|         0|            0|            0|  0.00%|        masked_array(
  4672|         0|            0|            0|  0.00%|          data=[[10, --, 3],
  4673|         0|            0|            0|  0.00%|                [--, 999, --],
  4674|         0|            0|            0|  0.00%|                [7, --, 30]],
  4675|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  4676|         0|            0|            0|  0.00%|                [ True, False,  True],
  4677|         0|            0|            0|  0.00%|                [False,  True, False]],
  4678|         0|            0|            0|  0.00%|          fill_value=999999)
  4679|         0|            0|            0|  0.00%|
  4680|         0|            0|            0|  0.00%|        """
  4681|         0|            0|            0|  0.00%|        # Hard mask: Get rid of the values/indices that fall on masked data
  4682|         0|            0|            0|  0.00%|        if self._hardmask and self._mask is not nomask:
  4683|         0|            0|            0|  0.00%|            mask = self._mask[indices]
  4684|         0|            0|            0|  0.00%|            indices = narray(indices, copy=False)
  4685|         0|            0|            0|  0.00%|            values = narray(values, copy=False, subok=True)
  4686|         0|            0|            0|  0.00%|            values.resize(indices.shape)
  4687|         0|            0|            0|  0.00%|            indices = indices[~mask]
  4688|         0|            0|            0|  0.00%|            values = values[~mask]
  4689|         0|            0|            0|  0.00%|
  4690|         0|            0|            0|  0.00%|        self._data.put(indices, values, mode=mode)
  4691|         0|            0|            0|  0.00%|
  4692|         0|            0|            0|  0.00%|        # short circuit if neither self nor values are masked
  4693|         0|            0|            0|  0.00%|        if self._mask is nomask and getmask(values) is nomask:
  4694|         0|            0|            0|  0.00%|            return
  4695|         0|            0|            0|  0.00%|
  4696|         0|            0|            0|  0.00%|        m = getmaskarray(self)
  4697|         0|            0|            0|  0.00%|
  4698|         0|            0|            0|  0.00%|        if getmask(values) is nomask:
  4699|         0|            0|            0|  0.00%|            m.put(indices, False, mode=mode)
  4700|         0|            0|            0|  0.00%|        else:
  4701|         0|            0|            0|  0.00%|            m.put(indices, values._mask, mode=mode)
  4702|         0|            0|            0|  0.00%|        m = make_mask(m, copy=False, shrink=True)
  4703|         0|            0|            0|  0.00%|        self._mask = m
  4704|         0|            0|            0|  0.00%|        return
  4705|         0|            0|            0|  0.00%|
  4706|         0|            0|            0|  0.00%|    def ids(self):
  4707|         0|            0|            0|  0.00%|        """
  4708|         0|            0|            0|  0.00%|        Return the addresses of the data and mask areas.
  4709|         0|            0|            0|  0.00%|
  4710|         0|            0|            0|  0.00%|        Parameters
  4711|         0|            0|            0|  0.00%|        ----------
  4712|         0|            0|            0|  0.00%|        None
  4713|         0|            0|            0|  0.00%|
  4714|         0|            0|            0|  0.00%|        Examples
  4715|         0|            0|            0|  0.00%|        --------
  4716|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1, 2, 3], mask=[0, 1, 1])
  4717|         0|            0|            0|  0.00%|        >>> x.ids()
  4718|         0|            0|            0|  0.00%|        (166670640, 166659832) # may vary
  4719|         0|            0|            0|  0.00%|
  4720|         0|            0|            0|  0.00%|        If the array has no mask, the address of `nomask` is returned. This address
  4721|         0|            0|            0|  0.00%|        is typically not close to the data in memory:
  4722|         0|            0|            0|  0.00%|
  4723|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1, 2, 3])
  4724|         0|            0|            0|  0.00%|        >>> x.ids()
  4725|         0|            0|            0|  0.00%|        (166691080, 3083169284L) # may vary
  4726|         0|            0|            0|  0.00%|
  4727|         0|            0|            0|  0.00%|        """
  4728|         0|            0|            0|  0.00%|        if self._mask is nomask:
  4729|         0|            0|            0|  0.00%|            return (self.ctypes.data, id(nomask))
  4730|         0|            0|            0|  0.00%|        return (self.ctypes.data, self._mask.ctypes.data)
  4731|         0|            0|            0|  0.00%|
  4732|         0|            0|            0|  0.00%|    def iscontiguous(self):
  4733|         0|            0|            0|  0.00%|        """
  4734|         0|            0|            0|  0.00%|        Return a boolean indicating whether the data is contiguous.
  4735|         0|            0|            0|  0.00%|
  4736|         0|            0|            0|  0.00%|        Parameters
  4737|         0|            0|            0|  0.00%|        ----------
  4738|         0|            0|            0|  0.00%|        None
  4739|         0|            0|            0|  0.00%|
  4740|         0|            0|            0|  0.00%|        Examples
  4741|         0|            0|            0|  0.00%|        --------
  4742|         0|            0|            0|  0.00%|        >>> x = np.ma.array([1, 2, 3])
  4743|         0|            0|            0|  0.00%|        >>> x.iscontiguous()
  4744|         0|            0|            0|  0.00%|        True
  4745|         0|            0|            0|  0.00%|
  4746|         0|            0|            0|  0.00%|        `iscontiguous` returns one of the flags of the masked array:
  4747|         0|            0|            0|  0.00%|
  4748|         0|            0|            0|  0.00%|        >>> x.flags
  4749|         0|            0|            0|  0.00%|          C_CONTIGUOUS : True
  4750|         0|            0|            0|  0.00%|          F_CONTIGUOUS : True
  4751|         0|            0|            0|  0.00%|          OWNDATA : False
  4752|         0|            0|            0|  0.00%|          WRITEABLE : True
  4753|         0|            0|            0|  0.00%|          ALIGNED : True
  4754|         0|            0|            0|  0.00%|          WRITEBACKIFCOPY : False
  4755|         0|            0|            0|  0.00%|          UPDATEIFCOPY : False
  4756|         0|            0|            0|  0.00%|
  4757|         0|            0|            0|  0.00%|        """
  4758|         0|            0|            0|  0.00%|        return self.flags['CONTIGUOUS']
  4759|         0|            0|            0|  0.00%|
  4760|         0|            0|            0|  0.00%|    def all(self, axis=None, out=None, keepdims=np._NoValue):
  4761|         0|            0|            0|  0.00%|        """
  4762|         0|            0|            0|  0.00%|        Returns True if all elements evaluate to True.
  4763|         0|            0|            0|  0.00%|
  4764|         0|            0|            0|  0.00%|        The output array is masked where all the values along the given axis
  4765|         0|            0|            0|  0.00%|        are masked: if the output would have been a scalar and that all the
  4766|         0|            0|            0|  0.00%|        values are masked, then the output is `masked`.
  4767|         0|            0|            0|  0.00%|
  4768|         0|            0|            0|  0.00%|        Refer to `numpy.all` for full documentation.
  4769|         0|            0|            0|  0.00%|
  4770|         0|            0|            0|  0.00%|        See Also
  4771|         0|            0|            0|  0.00%|        --------
  4772|         0|            0|            0|  0.00%|        ndarray.all : corresponding function for ndarrays
  4773|         0|            0|            0|  0.00%|        numpy.all : equivalent function
  4774|         0|            0|            0|  0.00%|
  4775|         0|            0|            0|  0.00%|        Examples
  4776|         0|            0|            0|  0.00%|        --------
  4777|         0|            0|            0|  0.00%|        >>> np.ma.array([1,2,3]).all()
  4778|         0|            0|            0|  0.00%|        True
  4779|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1,2,3], mask=True)
  4780|         0|            0|            0|  0.00%|        >>> (a.all() is np.ma.masked)
  4781|         0|            0|            0|  0.00%|        True
  4782|         0|            0|            0|  0.00%|
  4783|         0|            0|            0|  0.00%|        """
  4784|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  4785|         0|            0|            0|  0.00%|
  4786|         0|            0|            0|  0.00%|        mask = _check_mask_axis(self._mask, axis, **kwargs)
  4787|         0|            0|            0|  0.00%|        if out is None:
  4788|         0|            0|            0|  0.00%|            d = self.filled(True).all(axis=axis, **kwargs).view(type(self))
  4789|         0|            0|            0|  0.00%|            if d.ndim:
  4790|         0|            0|            0|  0.00%|                d.__setmask__(mask)
  4791|         0|            0|            0|  0.00%|            elif mask:
  4792|         0|            0|            0|  0.00%|                return masked
  4793|         0|            0|            0|  0.00%|            return d
  4794|         0|            0|            0|  0.00%|        self.filled(True).all(axis=axis, out=out, **kwargs)
  4795|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  4796|         0|            0|            0|  0.00%|            if out.ndim or mask:
  4797|         0|            0|            0|  0.00%|                out.__setmask__(mask)
  4798|         0|            0|            0|  0.00%|        return out
  4799|         0|            0|            0|  0.00%|
  4800|         0|            0|            0|  0.00%|    def any(self, axis=None, out=None, keepdims=np._NoValue):
  4801|         0|            0|            0|  0.00%|        """
  4802|         0|            0|            0|  0.00%|        Returns True if any of the elements of `a` evaluate to True.
  4803|         0|            0|            0|  0.00%|
  4804|         0|            0|            0|  0.00%|        Masked values are considered as False during computation.
  4805|         0|            0|            0|  0.00%|
  4806|         0|            0|            0|  0.00%|        Refer to `numpy.any` for full documentation.
  4807|         0|            0|            0|  0.00%|
  4808|         0|            0|            0|  0.00%|        See Also
  4809|         0|            0|            0|  0.00%|        --------
  4810|         0|            0|            0|  0.00%|        ndarray.any : corresponding function for ndarrays
  4811|         0|            0|            0|  0.00%|        numpy.any : equivalent function
  4812|         0|            0|            0|  0.00%|
  4813|         0|            0|            0|  0.00%|        """
  4814|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  4815|         0|            0|            0|  0.00%|
  4816|         0|            0|            0|  0.00%|        mask = _check_mask_axis(self._mask, axis, **kwargs)
  4817|         0|            0|            0|  0.00%|        if out is None:
  4818|         0|            0|            0|  0.00%|            d = self.filled(False).any(axis=axis, **kwargs).view(type(self))
  4819|         0|            0|            0|  0.00%|            if d.ndim:
  4820|         0|            0|            0|  0.00%|                d.__setmask__(mask)
  4821|         0|            0|            0|  0.00%|            elif mask:
  4822|         0|            0|            0|  0.00%|                d = masked
  4823|         0|            0|            0|  0.00%|            return d
  4824|         0|            0|            0|  0.00%|        self.filled(False).any(axis=axis, out=out, **kwargs)
  4825|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  4826|         0|            0|            0|  0.00%|            if out.ndim or mask:
  4827|         0|            0|            0|  0.00%|                out.__setmask__(mask)
  4828|         0|            0|            0|  0.00%|        return out
  4829|         0|            0|            0|  0.00%|
  4830|         0|            0|            0|  0.00%|    def nonzero(self):
  4831|         0|            0|            0|  0.00%|        """
  4832|         0|            0|            0|  0.00%|        Return the indices of unmasked elements that are not zero.
  4833|         0|            0|            0|  0.00%|
  4834|         0|            0|            0|  0.00%|        Returns a tuple of arrays, one for each dimension, containing the
  4835|         0|            0|            0|  0.00%|        indices of the non-zero elements in that dimension. The corresponding
  4836|         0|            0|            0|  0.00%|        non-zero values can be obtained with::
  4837|         0|            0|            0|  0.00%|
  4838|         0|            0|            0|  0.00%|            a[a.nonzero()]
  4839|         0|            0|            0|  0.00%|
  4840|         0|            0|            0|  0.00%|        To group the indices by element, rather than dimension, use
  4841|         0|            0|            0|  0.00%|        instead::
  4842|         0|            0|            0|  0.00%|
  4843|         0|            0|            0|  0.00%|            np.transpose(a.nonzero())
  4844|         0|            0|            0|  0.00%|
  4845|         0|            0|            0|  0.00%|        The result of this is always a 2d array, with a row for each non-zero
  4846|         0|            0|            0|  0.00%|        element.
  4847|         0|            0|            0|  0.00%|
  4848|         0|            0|            0|  0.00%|        Parameters
  4849|         0|            0|            0|  0.00%|        ----------
  4850|         0|            0|            0|  0.00%|        None
  4851|         0|            0|            0|  0.00%|
  4852|         0|            0|            0|  0.00%|        Returns
  4853|         0|            0|            0|  0.00%|        -------
  4854|         0|            0|            0|  0.00%|        tuple_of_arrays : tuple
  4855|         0|            0|            0|  0.00%|            Indices of elements that are non-zero.
  4856|         0|            0|            0|  0.00%|
  4857|         0|            0|            0|  0.00%|        See Also
  4858|         0|            0|            0|  0.00%|        --------
  4859|         0|            0|            0|  0.00%|        numpy.nonzero :
  4860|         0|            0|            0|  0.00%|            Function operating on ndarrays.
  4861|         0|            0|            0|  0.00%|        flatnonzero :
  4862|         0|            0|            0|  0.00%|            Return indices that are non-zero in the flattened version of the input
  4863|         0|            0|            0|  0.00%|            array.
  4864|         0|            0|            0|  0.00%|        ndarray.nonzero :
  4865|         0|            0|            0|  0.00%|            Equivalent ndarray method.
  4866|         0|            0|            0|  0.00%|        count_nonzero :
  4867|         0|            0|            0|  0.00%|            Counts the number of non-zero elements in the input array.
  4868|         0|            0|            0|  0.00%|
  4869|         0|            0|            0|  0.00%|        Examples
  4870|         0|            0|            0|  0.00%|        --------
  4871|         0|            0|            0|  0.00%|        >>> import numpy.ma as ma
  4872|         0|            0|            0|  0.00%|        >>> x = ma.array(np.eye(3))
  4873|         0|            0|            0|  0.00%|        >>> x
  4874|         0|            0|            0|  0.00%|        masked_array(
  4875|         0|            0|            0|  0.00%|          data=[[1., 0., 0.],
  4876|         0|            0|            0|  0.00%|                [0., 1., 0.],
  4877|         0|            0|            0|  0.00%|                [0., 0., 1.]],
  4878|         0|            0|            0|  0.00%|          mask=False,
  4879|         0|            0|            0|  0.00%|          fill_value=1e+20)
  4880|         0|            0|            0|  0.00%|        >>> x.nonzero()
  4881|         0|            0|            0|  0.00%|        (array([0, 1, 2]), array([0, 1, 2]))
  4882|         0|            0|            0|  0.00%|
  4883|         0|            0|            0|  0.00%|        Masked elements are ignored.
  4884|         0|            0|            0|  0.00%|
  4885|         0|            0|            0|  0.00%|        >>> x[1, 1] = ma.masked
  4886|         0|            0|            0|  0.00%|        >>> x
  4887|         0|            0|            0|  0.00%|        masked_array(
  4888|         0|            0|            0|  0.00%|          data=[[1.0, 0.0, 0.0],
  4889|         0|            0|            0|  0.00%|                [0.0, --, 0.0],
  4890|         0|            0|            0|  0.00%|                [0.0, 0.0, 1.0]],
  4891|         0|            0|            0|  0.00%|          mask=[[False, False, False],
  4892|         0|            0|            0|  0.00%|                [False,  True, False],
  4893|         0|            0|            0|  0.00%|                [False, False, False]],
  4894|         0|            0|            0|  0.00%|          fill_value=1e+20)
  4895|         0|            0|            0|  0.00%|        >>> x.nonzero()
  4896|         0|            0|            0|  0.00%|        (array([0, 2]), array([0, 2]))
  4897|         0|            0|            0|  0.00%|
  4898|         0|            0|            0|  0.00%|        Indices can also be grouped by element.
  4899|         0|            0|            0|  0.00%|
  4900|         0|            0|            0|  0.00%|        >>> np.transpose(x.nonzero())
  4901|         0|            0|            0|  0.00%|        array([[0, 0],
  4902|         0|            0|            0|  0.00%|               [2, 2]])
  4903|         0|            0|            0|  0.00%|
  4904|         0|            0|            0|  0.00%|        A common use for ``nonzero`` is to find the indices of an array, where
  4905|         0|            0|            0|  0.00%|        a condition is True.  Given an array `a`, the condition `a` > 3 is a
  4906|         0|            0|            0|  0.00%|        boolean array and since False is interpreted as 0, ma.nonzero(a > 3)
  4907|         0|            0|            0|  0.00%|        yields the indices of the `a` where the condition is true.
  4908|         0|            0|            0|  0.00%|
  4909|         0|            0|            0|  0.00%|        >>> a = ma.array([[1,2,3],[4,5,6],[7,8,9]])
  4910|         0|            0|            0|  0.00%|        >>> a > 3
  4911|         0|            0|            0|  0.00%|        masked_array(
  4912|         0|            0|            0|  0.00%|          data=[[False, False, False],
  4913|         0|            0|            0|  0.00%|                [ True,  True,  True],
  4914|         0|            0|            0|  0.00%|                [ True,  True,  True]],
  4915|         0|            0|            0|  0.00%|          mask=False,
  4916|         0|            0|            0|  0.00%|          fill_value=True)
  4917|         0|            0|            0|  0.00%|        >>> ma.nonzero(a > 3)
  4918|         0|            0|            0|  0.00%|        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  4919|         0|            0|            0|  0.00%|
  4920|         0|            0|            0|  0.00%|        The ``nonzero`` method of the condition array can also be called.
  4921|         0|            0|            0|  0.00%|
  4922|         0|            0|            0|  0.00%|        >>> (a > 3).nonzero()
  4923|         0|            0|            0|  0.00%|        (array([1, 1, 1, 2, 2, 2]), array([0, 1, 2, 0, 1, 2]))
  4924|         0|            0|            0|  0.00%|
  4925|         0|            0|            0|  0.00%|        """
  4926|         0|            0|            0|  0.00%|        return narray(self.filled(0), copy=False).nonzero()
  4927|         0|            0|            0|  0.00%|
  4928|         0|            0|            0|  0.00%|    def trace(self, offset=0, axis1=0, axis2=1, dtype=None, out=None):
  4929|         0|            0|            0|  0.00%|        """
  4930|         0|            0|            0|  0.00%|        (this docstring should be overwritten)
  4931|         0|            0|            0|  0.00%|        """
  4932|         0|            0|            0|  0.00%|        #!!!: implement out + test!
  4933|         0|            0|            0|  0.00%|        m = self._mask
  4934|         0|            0|            0|  0.00%|        if m is nomask:
  4935|         0|            0|            0|  0.00%|            result = super(MaskedArray, self).trace(offset=offset, axis1=axis1,
  4936|         0|            0|            0|  0.00%|                                                    axis2=axis2, out=out)
  4937|         0|            0|            0|  0.00%|            return result.astype(dtype)
  4938|         0|            0|            0|  0.00%|        else:
  4939|         0|            0|            0|  0.00%|            D = self.diagonal(offset=offset, axis1=axis1, axis2=axis2)
  4940|         0|            0|            0|  0.00%|            return D.astype(dtype).filled(0).sum(axis=-1, out=out)
  4941|         0|            0|            0|  0.00%|    trace.__doc__ = ndarray.trace.__doc__
  4942|         0|            0|            0|  0.00%|
  4943|         0|            0|            0|  0.00%|    def dot(self, b, out=None, strict=False):
  4944|         0|            0|            0|  0.00%|        """
  4945|         0|            0|            0|  0.00%|        a.dot(b, out=None)
  4946|         0|            0|            0|  0.00%|
  4947|         0|            0|            0|  0.00%|        Masked dot product of two arrays. Note that `out` and `strict` are
  4948|         0|            0|            0|  0.00%|        located in different positions than in `ma.dot`. In order to
  4949|         0|            0|            0|  0.00%|        maintain compatibility with the functional version, it is
  4950|         0|            0|            0|  0.00%|        recommended that the optional arguments be treated as keyword only.
  4951|         0|            0|            0|  0.00%|        At some point that may be mandatory.
  4952|         0|            0|            0|  0.00%|
  4953|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.0
  4954|         0|            0|            0|  0.00%|
  4955|         0|            0|            0|  0.00%|        Parameters
  4956|         0|            0|            0|  0.00%|        ----------
  4957|         0|            0|            0|  0.00%|        b : masked_array_like
  4958|         0|            0|            0|  0.00%|            Inputs array.
  4959|         0|            0|            0|  0.00%|        out : masked_array, optional
  4960|         0|            0|            0|  0.00%|            Output argument. This must have the exact kind that would be
  4961|         0|            0|            0|  0.00%|            returned if it was not used. In particular, it must have the
  4962|         0|            0|            0|  0.00%|            right type, must be C-contiguous, and its dtype must be the
  4963|         0|            0|            0|  0.00%|            dtype that would be returned for `ma.dot(a,b)`. This is a
  4964|         0|            0|            0|  0.00%|            performance feature. Therefore, if these conditions are not
  4965|         0|            0|            0|  0.00%|            met, an exception is raised, instead of attempting to be
  4966|         0|            0|            0|  0.00%|            flexible.
  4967|         0|            0|            0|  0.00%|        strict : bool, optional
  4968|         0|            0|            0|  0.00%|            Whether masked data are propagated (True) or set to 0 (False)
  4969|         0|            0|            0|  0.00%|            for the computation. Default is False.  Propagating the mask
  4970|         0|            0|            0|  0.00%|            means that if a masked value appears in a row or column, the
  4971|         0|            0|            0|  0.00%|            whole row or column is considered masked.
  4972|         0|            0|            0|  0.00%|
  4973|         0|            0|            0|  0.00%|            .. versionadded:: 1.10.2
  4974|         0|            0|            0|  0.00%|
  4975|         0|            0|            0|  0.00%|        See Also
  4976|         0|            0|            0|  0.00%|        --------
  4977|         0|            0|            0|  0.00%|        numpy.ma.dot : equivalent function
  4978|         0|            0|            0|  0.00%|
  4979|         0|            0|            0|  0.00%|        """
  4980|         0|            0|            0|  0.00%|        return dot(self, b, out=out, strict=strict)
  4981|         0|            0|            0|  0.00%|
  4982|         0|            0|            0|  0.00%|    def sum(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
  4983|         0|            0|            0|  0.00%|        """
  4984|         0|            0|            0|  0.00%|        Return the sum of the array elements over the given axis.
  4985|         0|            0|            0|  0.00%|
  4986|         0|            0|            0|  0.00%|        Masked elements are set to 0 internally.
  4987|         0|            0|            0|  0.00%|
  4988|         0|            0|            0|  0.00%|        Refer to `numpy.sum` for full documentation.
  4989|         0|            0|            0|  0.00%|
  4990|         0|            0|            0|  0.00%|        See Also
  4991|         0|            0|            0|  0.00%|        --------
  4992|         0|            0|            0|  0.00%|        ndarray.sum : corresponding function for ndarrays
  4993|         0|            0|            0|  0.00%|        numpy.sum : equivalent function
  4994|         0|            0|            0|  0.00%|
  4995|         0|            0|            0|  0.00%|        Examples
  4996|         0|            0|            0|  0.00%|        --------
  4997|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
  4998|         0|            0|            0|  0.00%|        >>> x
  4999|         0|            0|            0|  0.00%|        masked_array(
  5000|         0|            0|            0|  0.00%|          data=[[1, --, 3],
  5001|         0|            0|            0|  0.00%|                [--, 5, --],
  5002|         0|            0|            0|  0.00%|                [7, --, 9]],
  5003|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  5004|         0|            0|            0|  0.00%|                [ True, False,  True],
  5005|         0|            0|            0|  0.00%|                [False,  True, False]],
  5006|         0|            0|            0|  0.00%|          fill_value=999999)
  5007|         0|            0|            0|  0.00%|        >>> x.sum()
  5008|         0|            0|            0|  0.00%|        25
  5009|         0|            0|            0|  0.00%|        >>> x.sum(axis=1)
  5010|         0|            0|            0|  0.00%|        masked_array(data=[4, 5, 16],
  5011|         0|            0|            0|  0.00%|                     mask=[False, False, False],
  5012|         0|            0|            0|  0.00%|               fill_value=999999)
  5013|         0|            0|            0|  0.00%|        >>> x.sum(axis=0)
  5014|         0|            0|            0|  0.00%|        masked_array(data=[8, 5, 12],
  5015|         0|            0|            0|  0.00%|                     mask=[False, False, False],
  5016|         0|            0|            0|  0.00%|               fill_value=999999)
  5017|         0|            0|            0|  0.00%|        >>> print(type(x.sum(axis=0, dtype=np.int64)[0]))
  5018|         0|            0|            0|  0.00%|        <class 'numpy.int64'>
  5019|         0|            0|            0|  0.00%|
  5020|         0|            0|            0|  0.00%|        """
  5021|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5022|         0|            0|            0|  0.00%|
  5023|         0|            0|            0|  0.00%|        _mask = self._mask
  5024|         0|            0|            0|  0.00%|        newmask = _check_mask_axis(_mask, axis, **kwargs)
  5025|         0|            0|            0|  0.00%|        # No explicit output
  5026|         0|            0|            0|  0.00%|        if out is None:
  5027|         0|            0|            0|  0.00%|            result = self.filled(0).sum(axis, dtype=dtype, **kwargs)
  5028|         0|            0|            0|  0.00%|            rndim = getattr(result, 'ndim', 0)
  5029|         0|            0|            0|  0.00%|            if rndim:
  5030|         0|            0|            0|  0.00%|                result = result.view(type(self))
  5031|         0|            0|            0|  0.00%|                result.__setmask__(newmask)
  5032|         0|            0|            0|  0.00%|            elif newmask:
  5033|         0|            0|            0|  0.00%|                result = masked
  5034|         0|            0|            0|  0.00%|            return result
  5035|         0|            0|            0|  0.00%|        # Explicit output
  5036|         0|            0|            0|  0.00%|        result = self.filled(0).sum(axis, dtype=dtype, out=out, **kwargs)
  5037|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5038|         0|            0|            0|  0.00%|            outmask = getmask(out)
  5039|         0|            0|            0|  0.00%|            if (outmask is nomask):
  5040|         0|            0|            0|  0.00%|                outmask = out._mask = make_mask_none(out.shape)
  5041|         0|            0|            0|  0.00%|            outmask.flat = newmask
  5042|         0|            0|            0|  0.00%|        return out
  5043|         0|            0|            0|  0.00%|
  5044|         0|            0|            0|  0.00%|    def cumsum(self, axis=None, dtype=None, out=None):
  5045|         0|            0|            0|  0.00%|        """
  5046|         0|            0|            0|  0.00%|        Return the cumulative sum of the array elements over the given axis.
  5047|         0|            0|            0|  0.00%|
  5048|         0|            0|            0|  0.00%|        Masked values are set to 0 internally during the computation.
  5049|         0|            0|            0|  0.00%|        However, their position is saved, and the result will be masked at
  5050|         0|            0|            0|  0.00%|        the same locations.
  5051|         0|            0|            0|  0.00%|
  5052|         0|            0|            0|  0.00%|        Refer to `numpy.cumsum` for full documentation.
  5053|         0|            0|            0|  0.00%|
  5054|         0|            0|            0|  0.00%|        Notes
  5055|         0|            0|            0|  0.00%|        -----
  5056|         0|            0|            0|  0.00%|        The mask is lost if `out` is not a valid :class:`MaskedArray` !
  5057|         0|            0|            0|  0.00%|
  5058|         0|            0|            0|  0.00%|        Arithmetic is modular when using integer types, and no error is
  5059|         0|            0|            0|  0.00%|        raised on overflow.
  5060|         0|            0|            0|  0.00%|
  5061|         0|            0|            0|  0.00%|        See Also
  5062|         0|            0|            0|  0.00%|        --------
  5063|         0|            0|            0|  0.00%|        ndarray.cumsum : corresponding function for ndarrays
  5064|         0|            0|            0|  0.00%|        numpy.cumsum : equivalent function
  5065|         0|            0|            0|  0.00%|
  5066|         0|            0|            0|  0.00%|        Examples
  5067|         0|            0|            0|  0.00%|        --------
  5068|         0|            0|            0|  0.00%|        >>> marr = np.ma.array(np.arange(10), mask=[0,0,0,1,1,1,0,0,0,0])
  5069|         0|            0|            0|  0.00%|        >>> marr.cumsum()
  5070|         0|            0|            0|  0.00%|        masked_array(data=[0, 1, 3, --, --, --, 9, 16, 24, 33],
  5071|         0|            0|            0|  0.00%|                     mask=[False, False, False,  True,  True,  True, False, False,
  5072|         0|            0|            0|  0.00%|                           False, False],
  5073|         0|            0|            0|  0.00%|               fill_value=999999)
  5074|         0|            0|            0|  0.00%|
  5075|         0|            0|            0|  0.00%|        """
  5076|         0|            0|            0|  0.00%|        result = self.filled(0).cumsum(axis=axis, dtype=dtype, out=out)
  5077|         0|            0|            0|  0.00%|        if out is not None:
  5078|         0|            0|            0|  0.00%|            if isinstance(out, MaskedArray):
  5079|         0|            0|            0|  0.00%|                out.__setmask__(self.mask)
  5080|         0|            0|            0|  0.00%|            return out
  5081|         0|            0|            0|  0.00%|        result = result.view(type(self))
  5082|         0|            0|            0|  0.00%|        result.__setmask__(self._mask)
  5083|         0|            0|            0|  0.00%|        return result
  5084|         0|            0|            0|  0.00%|
  5085|         0|            0|            0|  0.00%|    def prod(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
  5086|         0|            0|            0|  0.00%|        """
  5087|         0|            0|            0|  0.00%|        Return the product of the array elements over the given axis.
  5088|         0|            0|            0|  0.00%|
  5089|         0|            0|            0|  0.00%|        Masked elements are set to 1 internally for computation.
  5090|         0|            0|            0|  0.00%|
  5091|         0|            0|            0|  0.00%|        Refer to `numpy.prod` for full documentation.
  5092|         0|            0|            0|  0.00%|
  5093|         0|            0|            0|  0.00%|        Notes
  5094|         0|            0|            0|  0.00%|        -----
  5095|         0|            0|            0|  0.00%|        Arithmetic is modular when using integer types, and no error is raised
  5096|         0|            0|            0|  0.00%|        on overflow.
  5097|         0|            0|            0|  0.00%|
  5098|         0|            0|            0|  0.00%|        See Also
  5099|         0|            0|            0|  0.00%|        --------
  5100|         0|            0|            0|  0.00%|        ndarray.prod : corresponding function for ndarrays
  5101|         0|            0|            0|  0.00%|        numpy.prod : equivalent function
  5102|         0|            0|            0|  0.00%|        """
  5103|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5104|         0|            0|            0|  0.00%|
  5105|         0|            0|            0|  0.00%|        _mask = self._mask
  5106|         0|            0|            0|  0.00%|        newmask = _check_mask_axis(_mask, axis, **kwargs)
  5107|         0|            0|            0|  0.00%|        # No explicit output
  5108|         0|            0|            0|  0.00%|        if out is None:
  5109|         0|            0|            0|  0.00%|            result = self.filled(1).prod(axis, dtype=dtype, **kwargs)
  5110|         0|            0|            0|  0.00%|            rndim = getattr(result, 'ndim', 0)
  5111|         0|            0|            0|  0.00%|            if rndim:
  5112|         0|            0|            0|  0.00%|                result = result.view(type(self))
  5113|         0|            0|            0|  0.00%|                result.__setmask__(newmask)
  5114|         0|            0|            0|  0.00%|            elif newmask:
  5115|         0|            0|            0|  0.00%|                result = masked
  5116|         0|            0|            0|  0.00%|            return result
  5117|         0|            0|            0|  0.00%|        # Explicit output
  5118|         0|            0|            0|  0.00%|        result = self.filled(1).prod(axis, dtype=dtype, out=out, **kwargs)
  5119|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5120|         0|            0|            0|  0.00%|            outmask = getmask(out)
  5121|         0|            0|            0|  0.00%|            if (outmask is nomask):
  5122|         0|            0|            0|  0.00%|                outmask = out._mask = make_mask_none(out.shape)
  5123|         0|            0|            0|  0.00%|            outmask.flat = newmask
  5124|         0|            0|            0|  0.00%|        return out
  5125|         0|            0|            0|  0.00%|    product = prod
  5126|         0|            0|            0|  0.00%|
  5127|         0|            0|            0|  0.00%|    def cumprod(self, axis=None, dtype=None, out=None):
  5128|         0|            0|            0|  0.00%|        """
  5129|         0|            0|            0|  0.00%|        Return the cumulative product of the array elements over the given axis.
  5130|         0|            0|            0|  0.00%|
  5131|         0|            0|            0|  0.00%|        Masked values are set to 1 internally during the computation.
  5132|         0|            0|            0|  0.00%|        However, their position is saved, and the result will be masked at
  5133|         0|            0|            0|  0.00%|        the same locations.
  5134|         0|            0|            0|  0.00%|
  5135|         0|            0|            0|  0.00%|        Refer to `numpy.cumprod` for full documentation.
  5136|         0|            0|            0|  0.00%|
  5137|         0|            0|            0|  0.00%|        Notes
  5138|         0|            0|            0|  0.00%|        -----
  5139|         0|            0|            0|  0.00%|        The mask is lost if `out` is not a valid MaskedArray !
  5140|         0|            0|            0|  0.00%|
  5141|         0|            0|            0|  0.00%|        Arithmetic is modular when using integer types, and no error is
  5142|         0|            0|            0|  0.00%|        raised on overflow.
  5143|         0|            0|            0|  0.00%|
  5144|         0|            0|            0|  0.00%|        See Also
  5145|         0|            0|            0|  0.00%|        --------
  5146|         0|            0|            0|  0.00%|        ndarray.cumprod : corresponding function for ndarrays
  5147|         0|            0|            0|  0.00%|        numpy.cumprod : equivalent function
  5148|         0|            0|            0|  0.00%|        """
  5149|         0|            0|            0|  0.00%|        result = self.filled(1).cumprod(axis=axis, dtype=dtype, out=out)
  5150|         0|            0|            0|  0.00%|        if out is not None:
  5151|         0|            0|            0|  0.00%|            if isinstance(out, MaskedArray):
  5152|         0|            0|            0|  0.00%|                out.__setmask__(self._mask)
  5153|         0|            0|            0|  0.00%|            return out
  5154|         0|            0|            0|  0.00%|        result = result.view(type(self))
  5155|         0|            0|            0|  0.00%|        result.__setmask__(self._mask)
  5156|         0|            0|            0|  0.00%|        return result
  5157|         0|            0|            0|  0.00%|
  5158|         0|            0|            0|  0.00%|    def mean(self, axis=None, dtype=None, out=None, keepdims=np._NoValue):
  5159|         0|            0|            0|  0.00%|        """
  5160|         0|            0|            0|  0.00%|        Returns the average of the array elements along given axis.
  5161|         0|            0|            0|  0.00%|
  5162|         0|            0|            0|  0.00%|        Masked entries are ignored, and result elements which are not
  5163|         0|            0|            0|  0.00%|        finite will be masked.
  5164|         0|            0|            0|  0.00%|
  5165|         0|            0|            0|  0.00%|        Refer to `numpy.mean` for full documentation.
  5166|         0|            0|            0|  0.00%|
  5167|         0|            0|            0|  0.00%|        See Also
  5168|         0|            0|            0|  0.00%|        --------
  5169|         0|            0|            0|  0.00%|        ndarray.mean : corresponding function for ndarrays
  5170|         0|            0|            0|  0.00%|        numpy.mean : Equivalent function
  5171|         0|            0|            0|  0.00%|        numpy.ma.average: Weighted average.
  5172|         0|            0|            0|  0.00%|
  5173|         0|            0|            0|  0.00%|        Examples
  5174|         0|            0|            0|  0.00%|        --------
  5175|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1,2,3], mask=[False, False, True])
  5176|         0|            0|            0|  0.00%|        >>> a
  5177|         0|            0|            0|  0.00%|        masked_array(data=[1, 2, --],
  5178|         0|            0|            0|  0.00%|                     mask=[False, False,  True],
  5179|         0|            0|            0|  0.00%|               fill_value=999999)
  5180|         0|            0|            0|  0.00%|        >>> a.mean()
  5181|         0|            0|            0|  0.00%|        1.5
  5182|         0|            0|            0|  0.00%|
  5183|         0|            0|            0|  0.00%|        """
  5184|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5185|         0|            0|            0|  0.00%|
  5186|         0|            0|            0|  0.00%|        if self._mask is nomask:
  5187|         0|            0|            0|  0.00%|            result = super(MaskedArray, self).mean(axis=axis,
  5188|         0|            0|            0|  0.00%|                                                   dtype=dtype, **kwargs)[()]
  5189|         0|            0|            0|  0.00%|        else:
  5190|         0|            0|            0|  0.00%|            dsum = self.sum(axis=axis, dtype=dtype, **kwargs)
  5191|         0|            0|            0|  0.00%|            cnt = self.count(axis=axis, **kwargs)
  5192|         0|            0|            0|  0.00%|            if cnt.shape == () and (cnt == 0):
  5193|         0|            0|            0|  0.00%|                result = masked
  5194|         0|            0|            0|  0.00%|            else:
  5195|         0|            0|            0|  0.00%|                result = dsum * 1. / cnt
  5196|         0|            0|            0|  0.00%|        if out is not None:
  5197|         0|            0|            0|  0.00%|            out.flat = result
  5198|         0|            0|            0|  0.00%|            if isinstance(out, MaskedArray):
  5199|         0|            0|            0|  0.00%|                outmask = getmask(out)
  5200|         0|            0|            0|  0.00%|                if (outmask is nomask):
  5201|         0|            0|            0|  0.00%|                    outmask = out._mask = make_mask_none(out.shape)
  5202|         0|            0|            0|  0.00%|                outmask.flat = getmask(result)
  5203|         0|            0|            0|  0.00%|            return out
  5204|         0|            0|            0|  0.00%|        return result
  5205|         0|            0|            0|  0.00%|
  5206|         0|            0|            0|  0.00%|    def anom(self, axis=None, dtype=None):
  5207|         0|            0|            0|  0.00%|        """
  5208|         0|            0|            0|  0.00%|        Compute the anomalies (deviations from the arithmetic mean)
  5209|         0|            0|            0|  0.00%|        along the given axis.
  5210|         0|            0|            0|  0.00%|
  5211|         0|            0|            0|  0.00%|        Returns an array of anomalies, with the same shape as the input and
  5212|         0|            0|            0|  0.00%|        where the arithmetic mean is computed along the given axis.
  5213|         0|            0|            0|  0.00%|
  5214|         0|            0|            0|  0.00%|        Parameters
  5215|         0|            0|            0|  0.00%|        ----------
  5216|         0|            0|            0|  0.00%|        axis : int, optional
  5217|         0|            0|            0|  0.00%|            Axis over which the anomalies are taken.
  5218|         0|            0|            0|  0.00%|            The default is to use the mean of the flattened array as reference.
  5219|         0|            0|            0|  0.00%|        dtype : dtype, optional
  5220|         0|            0|            0|  0.00%|            Type to use in computing the variance. For arrays of integer type
  5221|         0|            0|            0|  0.00%|             the default is float32; for arrays of float types it is the same as
  5222|         0|            0|            0|  0.00%|             the array type.
  5223|         0|            0|            0|  0.00%|
  5224|         0|            0|            0|  0.00%|        See Also
  5225|         0|            0|            0|  0.00%|        --------
  5226|         0|            0|            0|  0.00%|        mean : Compute the mean of the array.
  5227|         0|            0|            0|  0.00%|
  5228|         0|            0|            0|  0.00%|        Examples
  5229|         0|            0|            0|  0.00%|        --------
  5230|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1,2,3])
  5231|         0|            0|            0|  0.00%|        >>> a.anom()
  5232|         0|            0|            0|  0.00%|        masked_array(data=[-1.,  0.,  1.],
  5233|         0|            0|            0|  0.00%|                     mask=False,
  5234|         0|            0|            0|  0.00%|               fill_value=1e+20)
  5235|         0|            0|            0|  0.00%|
  5236|         0|            0|            0|  0.00%|        """
  5237|         0|            0|            0|  0.00%|        m = self.mean(axis, dtype)
  5238|         0|            0|            0|  0.00%|        if m is masked:
  5239|         0|            0|            0|  0.00%|            return m
  5240|         0|            0|            0|  0.00%|
  5241|         0|            0|            0|  0.00%|        if not axis:
  5242|         0|            0|            0|  0.00%|            return (self - m)
  5243|         0|            0|            0|  0.00%|        else:
  5244|         0|            0|            0|  0.00%|            return (self - expand_dims(m, axis))
  5245|         0|            0|            0|  0.00%|
  5246|         0|            0|            0|  0.00%|    def var(self, axis=None, dtype=None, out=None, ddof=0,
  5247|         0|            0|            0|  0.00%|            keepdims=np._NoValue):
  5248|         0|            0|            0|  0.00%|        """
  5249|         0|            0|            0|  0.00%|        Returns the variance of the array elements along given axis.
  5250|         0|            0|            0|  0.00%|
  5251|         0|            0|            0|  0.00%|        Masked entries are ignored, and result elements which are not
  5252|         0|            0|            0|  0.00%|        finite will be masked.
  5253|         0|            0|            0|  0.00%|
  5254|         0|            0|            0|  0.00%|        Refer to `numpy.var` for full documentation.
  5255|         0|            0|            0|  0.00%|
  5256|         0|            0|            0|  0.00%|        See Also
  5257|         0|            0|            0|  0.00%|        --------
  5258|         0|            0|            0|  0.00%|        ndarray.var : corresponding function for ndarrays
  5259|         0|            0|            0|  0.00%|        numpy.var : Equivalent function
  5260|         0|            0|            0|  0.00%|        """
  5261|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5262|         0|            0|            0|  0.00%|
  5263|         0|            0|            0|  0.00%|        # Easy case: nomask, business as usual
  5264|         0|            0|            0|  0.00%|        if self._mask is nomask:
  5265|         0|            0|            0|  0.00%|            ret = super(MaskedArray, self).var(axis=axis, dtype=dtype, out=out,
  5266|         0|            0|            0|  0.00%|                                               ddof=ddof, **kwargs)[()]
  5267|         0|            0|            0|  0.00%|            if out is not None:
  5268|         0|            0|            0|  0.00%|                if isinstance(out, MaskedArray):
  5269|         0|            0|            0|  0.00%|                    out.__setmask__(nomask)
  5270|         0|            0|            0|  0.00%|                return out
  5271|         0|            0|            0|  0.00%|            return ret
  5272|         0|            0|            0|  0.00%|
  5273|         0|            0|            0|  0.00%|        # Some data are masked, yay!
  5274|         0|            0|            0|  0.00%|        cnt = self.count(axis=axis, **kwargs) - ddof
  5275|         0|            0|            0|  0.00%|        danom = self - self.mean(axis, dtype, keepdims=True)
  5276|         0|            0|            0|  0.00%|        if iscomplexobj(self):
  5277|         0|            0|            0|  0.00%|            danom = umath.absolute(danom) ** 2
  5278|         0|            0|            0|  0.00%|        else:
  5279|         0|            0|            0|  0.00%|            danom *= danom
  5280|         0|            0|            0|  0.00%|        dvar = divide(danom.sum(axis, **kwargs), cnt).view(type(self))
  5281|         0|            0|            0|  0.00%|        # Apply the mask if it's not a scalar
  5282|         0|            0|            0|  0.00%|        if dvar.ndim:
  5283|         0|            0|            0|  0.00%|            dvar._mask = mask_or(self._mask.all(axis, **kwargs), (cnt <= 0))
  5284|         0|            0|            0|  0.00%|            dvar._update_from(self)
  5285|         0|            0|            0|  0.00%|        elif getmask(dvar):
  5286|         0|            0|            0|  0.00%|            # Make sure that masked is returned when the scalar is masked.
  5287|         0|            0|            0|  0.00%|            dvar = masked
  5288|         0|            0|            0|  0.00%|            if out is not None:
  5289|         0|            0|            0|  0.00%|                if isinstance(out, MaskedArray):
  5290|         0|            0|            0|  0.00%|                    out.flat = 0
  5291|         0|            0|            0|  0.00%|                    out.__setmask__(True)
  5292|         0|            0|            0|  0.00%|                elif out.dtype.kind in 'biu':
  5293|         0|            0|            0|  0.00%|                    errmsg = "Masked data information would be lost in one or "\
  5294|         0|            0|            0|  0.00%|                             "more location."
  5295|         0|            0|            0|  0.00%|                    raise MaskError(errmsg)
  5296|         0|            0|            0|  0.00%|                else:
  5297|         0|            0|            0|  0.00%|                    out.flat = np.nan
  5298|         0|            0|            0|  0.00%|                return out
  5299|         0|            0|            0|  0.00%|        # In case with have an explicit output
  5300|         0|            0|            0|  0.00%|        if out is not None:
  5301|         0|            0|            0|  0.00%|            # Set the data
  5302|         0|            0|            0|  0.00%|            out.flat = dvar
  5303|         0|            0|            0|  0.00%|            # Set the mask if needed
  5304|         0|            0|            0|  0.00%|            if isinstance(out, MaskedArray):
  5305|         0|            0|            0|  0.00%|                out.__setmask__(dvar.mask)
  5306|         0|            0|            0|  0.00%|            return out
  5307|         0|            0|            0|  0.00%|        return dvar
  5308|         0|            0|            0|  0.00%|    var.__doc__ = np.var.__doc__
  5309|         0|            0|            0|  0.00%|
  5310|         0|            0|            0|  0.00%|    def std(self, axis=None, dtype=None, out=None, ddof=0,
  5311|         0|            0|            0|  0.00%|            keepdims=np._NoValue):
  5312|         0|            0|            0|  0.00%|        """
  5313|         0|            0|            0|  0.00%|        Returns the standard deviation of the array elements along given axis.
  5314|         0|            0|            0|  0.00%|
  5315|         0|            0|            0|  0.00%|        Masked entries are ignored.
  5316|         0|            0|            0|  0.00%|
  5317|         0|            0|            0|  0.00%|        Refer to `numpy.std` for full documentation.
  5318|         0|            0|            0|  0.00%|
  5319|         0|            0|            0|  0.00%|        See Also
  5320|         0|            0|            0|  0.00%|        --------
  5321|         0|            0|            0|  0.00%|        ndarray.std : corresponding function for ndarrays
  5322|         0|            0|            0|  0.00%|        numpy.std : Equivalent function
  5323|         0|            0|            0|  0.00%|        """
  5324|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5325|         0|            0|            0|  0.00%|
  5326|         0|            0|            0|  0.00%|        dvar = self.var(axis, dtype, out, ddof, **kwargs)
  5327|         0|            0|            0|  0.00%|        if dvar is not masked:
  5328|         0|            0|            0|  0.00%|            if out is not None:
  5329|         0|            0|            0|  0.00%|                np.power(out, 0.5, out=out, casting='unsafe')
  5330|         0|            0|            0|  0.00%|                return out
  5331|         0|            0|            0|  0.00%|            dvar = sqrt(dvar)
  5332|         0|            0|            0|  0.00%|        return dvar
  5333|         0|            0|            0|  0.00%|
  5334|         0|            0|            0|  0.00%|    def round(self, decimals=0, out=None):
  5335|         0|            0|            0|  0.00%|        """
  5336|         0|            0|            0|  0.00%|        Return each element rounded to the given number of decimals.
  5337|         0|            0|            0|  0.00%|
  5338|         0|            0|            0|  0.00%|        Refer to `numpy.around` for full documentation.
  5339|         0|            0|            0|  0.00%|
  5340|         0|            0|            0|  0.00%|        See Also
  5341|         0|            0|            0|  0.00%|        --------
  5342|         0|            0|            0|  0.00%|        ndarray.around : corresponding function for ndarrays
  5343|         0|            0|            0|  0.00%|        numpy.around : equivalent function
  5344|         0|            0|            0|  0.00%|        """
  5345|         0|            0|            0|  0.00%|        result = self._data.round(decimals=decimals, out=out).view(type(self))
  5346|         0|            0|            0|  0.00%|        if result.ndim > 0:
  5347|         0|            0|            0|  0.00%|            result._mask = self._mask
  5348|         0|            0|            0|  0.00%|            result._update_from(self)
  5349|         0|            0|            0|  0.00%|        elif self._mask:
  5350|         0|            0|            0|  0.00%|            # Return masked when the scalar is masked
  5351|         0|            0|            0|  0.00%|            result = masked
  5352|         0|            0|            0|  0.00%|        # No explicit output: we're done
  5353|         0|            0|            0|  0.00%|        if out is None:
  5354|         0|            0|            0|  0.00%|            return result
  5355|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5356|         0|            0|            0|  0.00%|            out.__setmask__(self._mask)
  5357|         0|            0|            0|  0.00%|        return out
  5358|         0|            0|            0|  0.00%|
  5359|         0|            0|            0|  0.00%|    def argsort(self, axis=np._NoValue, kind=None, order=None,
  5360|         0|            0|            0|  0.00%|                endwith=True, fill_value=None):
  5361|         0|            0|            0|  0.00%|        """
  5362|         0|            0|            0|  0.00%|        Return an ndarray of indices that sort the array along the
  5363|         0|            0|            0|  0.00%|        specified axis.  Masked values are filled beforehand to
  5364|         0|            0|            0|  0.00%|        `fill_value`.
  5365|         0|            0|            0|  0.00%|
  5366|         0|            0|            0|  0.00%|        Parameters
  5367|         0|            0|            0|  0.00%|        ----------
  5368|         0|            0|            0|  0.00%|        axis : int, optional
  5369|         0|            0|            0|  0.00%|            Axis along which to sort. If None, the default, the flattened array
  5370|         0|            0|            0|  0.00%|            is used.
  5371|         0|            0|            0|  0.00%|
  5372|         0|            0|            0|  0.00%|            ..  versionchanged:: 1.13.0
  5373|         0|            0|            0|  0.00%|                Previously, the default was documented to be -1, but that was
  5374|         0|            0|            0|  0.00%|                in error. At some future date, the default will change to -1, as
  5375|         0|            0|            0|  0.00%|                originally intended.
  5376|         0|            0|            0|  0.00%|                Until then, the axis should be given explicitly when
  5377|         0|            0|            0|  0.00%|                ``arr.ndim > 1``, to avoid a FutureWarning.
  5378|         0|            0|            0|  0.00%|        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
  5379|         0|            0|            0|  0.00%|            The sorting algorithm used.
  5380|         0|            0|            0|  0.00%|        order : list, optional
  5381|         0|            0|            0|  0.00%|            When `a` is an array with fields defined, this argument specifies
  5382|         0|            0|            0|  0.00%|            which fields to compare first, second, etc.  Not all fields need be
  5383|         0|            0|            0|  0.00%|            specified.
  5384|         0|            0|            0|  0.00%|        endwith : {True, False}, optional
  5385|         0|            0|            0|  0.00%|            Whether missing values (if any) should be treated as the largest values
  5386|         0|            0|            0|  0.00%|            (True) or the smallest values (False)
  5387|         0|            0|            0|  0.00%|            When the array contains unmasked values at the same extremes of the
  5388|         0|            0|            0|  0.00%|            datatype, the ordering of these values and the masked values is
  5389|         0|            0|            0|  0.00%|            undefined.
  5390|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5391|         0|            0|            0|  0.00%|            Value used internally for the masked values.
  5392|         0|            0|            0|  0.00%|            If ``fill_value`` is not None, it supersedes ``endwith``.
  5393|         0|            0|            0|  0.00%|
  5394|         0|            0|            0|  0.00%|        Returns
  5395|         0|            0|            0|  0.00%|        -------
  5396|         0|            0|            0|  0.00%|        index_array : ndarray, int
  5397|         0|            0|            0|  0.00%|            Array of indices that sort `a` along the specified axis.
  5398|         0|            0|            0|  0.00%|            In other words, ``a[index_array]`` yields a sorted `a`.
  5399|         0|            0|            0|  0.00%|
  5400|         0|            0|            0|  0.00%|        See Also
  5401|         0|            0|            0|  0.00%|        --------
  5402|         0|            0|            0|  0.00%|        MaskedArray.sort : Describes sorting algorithms used.
  5403|         0|            0|            0|  0.00%|        lexsort : Indirect stable sort with multiple keys.
  5404|         0|            0|            0|  0.00%|        ndarray.sort : Inplace sort.
  5405|         0|            0|            0|  0.00%|
  5406|         0|            0|            0|  0.00%|        Notes
  5407|         0|            0|            0|  0.00%|        -----
  5408|         0|            0|            0|  0.00%|        See `sort` for notes on the different sorting algorithms.
  5409|         0|            0|            0|  0.00%|
  5410|         0|            0|            0|  0.00%|        Examples
  5411|         0|            0|            0|  0.00%|        --------
  5412|         0|            0|            0|  0.00%|        >>> a = np.ma.array([3,2,1], mask=[False, False, True])
  5413|         0|            0|            0|  0.00%|        >>> a
  5414|         0|            0|            0|  0.00%|        masked_array(data=[3, 2, --],
  5415|         0|            0|            0|  0.00%|                     mask=[False, False,  True],
  5416|         0|            0|            0|  0.00%|               fill_value=999999)
  5417|         0|            0|            0|  0.00%|        >>> a.argsort()
  5418|         0|            0|            0|  0.00%|        array([1, 0, 2])
  5419|         0|            0|            0|  0.00%|
  5420|         0|            0|            0|  0.00%|        """
  5421|         0|            0|            0|  0.00%|
  5422|         0|            0|            0|  0.00%|        # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
  5423|         0|            0|            0|  0.00%|        if axis is np._NoValue:
  5424|         0|            0|            0|  0.00%|            axis = _deprecate_argsort_axis(self)
  5425|         0|            0|            0|  0.00%|
  5426|         0|            0|            0|  0.00%|        if fill_value is None:
  5427|         0|            0|            0|  0.00%|            if endwith:
  5428|         0|            0|            0|  0.00%|                # nan > inf
  5429|         0|            0|            0|  0.00%|                if np.issubdtype(self.dtype, np.floating):
  5430|         0|            0|            0|  0.00%|                    fill_value = np.nan
  5431|         0|            0|            0|  0.00%|                else:
  5432|         0|            0|            0|  0.00%|                    fill_value = minimum_fill_value(self)
  5433|         0|            0|            0|  0.00%|            else:
  5434|         0|            0|            0|  0.00%|                fill_value = maximum_fill_value(self)
  5435|         0|            0|            0|  0.00%|
  5436|         0|            0|            0|  0.00%|        filled = self.filled(fill_value)
  5437|         0|            0|            0|  0.00%|        return filled.argsort(axis=axis, kind=kind, order=order)
  5438|         0|            0|            0|  0.00%|
  5439|         0|            0|            0|  0.00%|    def argmin(self, axis=None, fill_value=None, out=None):
  5440|         0|            0|            0|  0.00%|        """
  5441|         0|            0|            0|  0.00%|        Return array of indices to the minimum values along the given axis.
  5442|         0|            0|            0|  0.00%|
  5443|         0|            0|            0|  0.00%|        Parameters
  5444|         0|            0|            0|  0.00%|        ----------
  5445|         0|            0|            0|  0.00%|        axis : {None, integer}
  5446|         0|            0|            0|  0.00%|            If None, the index is into the flattened array, otherwise along
  5447|         0|            0|            0|  0.00%|            the specified axis
  5448|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5449|         0|            0|            0|  0.00%|            Value used to fill in the masked values.  If None, the output of
  5450|         0|            0|            0|  0.00%|            minimum_fill_value(self._data) is used instead.
  5451|         0|            0|            0|  0.00%|        out : {None, array}, optional
  5452|         0|            0|            0|  0.00%|            Array into which the result can be placed. Its type is preserved
  5453|         0|            0|            0|  0.00%|            and it must be of the right shape to hold the output.
  5454|         0|            0|            0|  0.00%|
  5455|         0|            0|            0|  0.00%|        Returns
  5456|         0|            0|            0|  0.00%|        -------
  5457|         0|            0|            0|  0.00%|        ndarray or scalar
  5458|         0|            0|            0|  0.00%|            If multi-dimension input, returns a new ndarray of indices to the
  5459|         0|            0|            0|  0.00%|            minimum values along the given axis.  Otherwise, returns a scalar
  5460|         0|            0|            0|  0.00%|            of index to the minimum values along the given axis.
  5461|         0|            0|            0|  0.00%|
  5462|         0|            0|            0|  0.00%|        Examples
  5463|         0|            0|            0|  0.00%|        --------
  5464|         0|            0|            0|  0.00%|        >>> x = np.ma.array(np.arange(4), mask=[1,1,0,0])
  5465|         0|            0|            0|  0.00%|        >>> x.shape = (2,2)
  5466|         0|            0|            0|  0.00%|        >>> x
  5467|         0|            0|            0|  0.00%|        masked_array(
  5468|         0|            0|            0|  0.00%|          data=[[--, --],
  5469|         0|            0|            0|  0.00%|                [2, 3]],
  5470|         0|            0|            0|  0.00%|          mask=[[ True,  True],
  5471|         0|            0|            0|  0.00%|                [False, False]],
  5472|         0|            0|            0|  0.00%|          fill_value=999999)
  5473|         0|            0|            0|  0.00%|        >>> x.argmin(axis=0, fill_value=-1)
  5474|         0|            0|            0|  0.00%|        array([0, 0])
  5475|         0|            0|            0|  0.00%|        >>> x.argmin(axis=0, fill_value=9)
  5476|         0|            0|            0|  0.00%|        array([1, 1])
  5477|         0|            0|            0|  0.00%|
  5478|         0|            0|            0|  0.00%|        """
  5479|         0|            0|            0|  0.00%|        if fill_value is None:
  5480|         0|            0|            0|  0.00%|            fill_value = minimum_fill_value(self)
  5481|         0|            0|            0|  0.00%|        d = self.filled(fill_value).view(ndarray)
  5482|         0|            0|            0|  0.00%|        return d.argmin(axis, out=out)
  5483|         0|            0|            0|  0.00%|
  5484|         0|            0|            0|  0.00%|    def argmax(self, axis=None, fill_value=None, out=None):
  5485|         0|            0|            0|  0.00%|        """
  5486|         0|            0|            0|  0.00%|        Returns array of indices of the maximum values along the given axis.
  5487|         0|            0|            0|  0.00%|        Masked values are treated as if they had the value fill_value.
  5488|         0|            0|            0|  0.00%|
  5489|         0|            0|            0|  0.00%|        Parameters
  5490|         0|            0|            0|  0.00%|        ----------
  5491|         0|            0|            0|  0.00%|        axis : {None, integer}
  5492|         0|            0|            0|  0.00%|            If None, the index is into the flattened array, otherwise along
  5493|         0|            0|            0|  0.00%|            the specified axis
  5494|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5495|         0|            0|            0|  0.00%|            Value used to fill in the masked values.  If None, the output of
  5496|         0|            0|            0|  0.00%|            maximum_fill_value(self._data) is used instead.
  5497|         0|            0|            0|  0.00%|        out : {None, array}, optional
  5498|         0|            0|            0|  0.00%|            Array into which the result can be placed. Its type is preserved
  5499|         0|            0|            0|  0.00%|            and it must be of the right shape to hold the output.
  5500|         0|            0|            0|  0.00%|
  5501|         0|            0|            0|  0.00%|        Returns
  5502|         0|            0|            0|  0.00%|        -------
  5503|         0|            0|            0|  0.00%|        index_array : {integer_array}
  5504|         0|            0|            0|  0.00%|
  5505|         0|            0|            0|  0.00%|        Examples
  5506|         0|            0|            0|  0.00%|        --------
  5507|         0|            0|            0|  0.00%|        >>> a = np.arange(6).reshape(2,3)
  5508|         0|            0|            0|  0.00%|        >>> a.argmax()
  5509|         0|            0|            0|  0.00%|        5
  5510|         0|            0|            0|  0.00%|        >>> a.argmax(0)
  5511|         0|            0|            0|  0.00%|        array([1, 1, 1])
  5512|         0|            0|            0|  0.00%|        >>> a.argmax(1)
  5513|         0|            0|            0|  0.00%|        array([2, 2])
  5514|         0|            0|            0|  0.00%|
  5515|         0|            0|            0|  0.00%|        """
  5516|         0|            0|            0|  0.00%|        if fill_value is None:
  5517|         0|            0|            0|  0.00%|            fill_value = maximum_fill_value(self._data)
  5518|         0|            0|            0|  0.00%|        d = self.filled(fill_value).view(ndarray)
  5519|         0|            0|            0|  0.00%|        return d.argmax(axis, out=out)
  5520|         0|            0|            0|  0.00%|
  5521|         0|            0|            0|  0.00%|    def sort(self, axis=-1, kind=None, order=None,
  5522|         0|            0|            0|  0.00%|             endwith=True, fill_value=None):
  5523|         0|            0|            0|  0.00%|        """
  5524|         0|            0|            0|  0.00%|        Sort the array, in-place
  5525|         0|            0|            0|  0.00%|
  5526|         0|            0|            0|  0.00%|        Parameters
  5527|         0|            0|            0|  0.00%|        ----------
  5528|         0|            0|            0|  0.00%|        a : array_like
  5529|         0|            0|            0|  0.00%|            Array to be sorted.
  5530|         0|            0|            0|  0.00%|        axis : int, optional
  5531|         0|            0|            0|  0.00%|            Axis along which to sort. If None, the array is flattened before
  5532|         0|            0|            0|  0.00%|            sorting. The default is -1, which sorts along the last axis.
  5533|         0|            0|            0|  0.00%|        kind : {'quicksort', 'mergesort', 'heapsort', 'stable'}, optional
  5534|         0|            0|            0|  0.00%|            The sorting algorithm used.
  5535|         0|            0|            0|  0.00%|        order : list, optional
  5536|         0|            0|            0|  0.00%|            When `a` is a structured array, this argument specifies which fields
  5537|         0|            0|            0|  0.00%|            to compare first, second, and so on.  This list does not need to
  5538|         0|            0|            0|  0.00%|            include all of the fields.
  5539|         0|            0|            0|  0.00%|        endwith : {True, False}, optional
  5540|         0|            0|            0|  0.00%|            Whether missing values (if any) should be treated as the largest values
  5541|         0|            0|            0|  0.00%|            (True) or the smallest values (False)
  5542|         0|            0|            0|  0.00%|            When the array contains unmasked values sorting at the same extremes of the
  5543|         0|            0|            0|  0.00%|            datatype, the ordering of these values and the masked values is
  5544|         0|            0|            0|  0.00%|            undefined.
  5545|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5546|         0|            0|            0|  0.00%|            Value used internally for the masked values.
  5547|         0|            0|            0|  0.00%|            If ``fill_value`` is not None, it supersedes ``endwith``.
  5548|         0|            0|            0|  0.00%|
  5549|         0|            0|            0|  0.00%|        Returns
  5550|         0|            0|            0|  0.00%|        -------
  5551|         0|            0|            0|  0.00%|        sorted_array : ndarray
  5552|         0|            0|            0|  0.00%|            Array of the same type and shape as `a`.
  5553|         0|            0|            0|  0.00%|
  5554|         0|            0|            0|  0.00%|        See Also
  5555|         0|            0|            0|  0.00%|        --------
  5556|         0|            0|            0|  0.00%|        ndarray.sort : Method to sort an array in-place.
  5557|         0|            0|            0|  0.00%|        argsort : Indirect sort.
  5558|         0|            0|            0|  0.00%|        lexsort : Indirect stable sort on multiple keys.
  5559|         0|            0|            0|  0.00%|        searchsorted : Find elements in a sorted array.
  5560|         0|            0|            0|  0.00%|
  5561|         0|            0|            0|  0.00%|        Notes
  5562|         0|            0|            0|  0.00%|        -----
  5563|         0|            0|            0|  0.00%|        See ``sort`` for notes on the different sorting algorithms.
  5564|         0|            0|            0|  0.00%|
  5565|         0|            0|            0|  0.00%|        Examples
  5566|         0|            0|            0|  0.00%|        --------
  5567|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
  5568|         0|            0|            0|  0.00%|        >>> # Default
  5569|         0|            0|            0|  0.00%|        >>> a.sort()
  5570|         0|            0|            0|  0.00%|        >>> a
  5571|         0|            0|            0|  0.00%|        masked_array(data=[1, 3, 5, --, --],
  5572|         0|            0|            0|  0.00%|                     mask=[False, False, False,  True,  True],
  5573|         0|            0|            0|  0.00%|               fill_value=999999)
  5574|         0|            0|            0|  0.00%|
  5575|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
  5576|         0|            0|            0|  0.00%|        >>> # Put missing values in the front
  5577|         0|            0|            0|  0.00%|        >>> a.sort(endwith=False)
  5578|         0|            0|            0|  0.00%|        >>> a
  5579|         0|            0|            0|  0.00%|        masked_array(data=[--, --, 1, 3, 5],
  5580|         0|            0|            0|  0.00%|                     mask=[ True,  True, False, False, False],
  5581|         0|            0|            0|  0.00%|               fill_value=999999)
  5582|         0|            0|            0|  0.00%|
  5583|         0|            0|            0|  0.00%|        >>> a = np.ma.array([1, 2, 5, 4, 3],mask=[0, 1, 0, 1, 0])
  5584|         0|            0|            0|  0.00%|        >>> # fill_value takes over endwith
  5585|         0|            0|            0|  0.00%|        >>> a.sort(endwith=False, fill_value=3)
  5586|         0|            0|            0|  0.00%|        >>> a
  5587|         0|            0|            0|  0.00%|        masked_array(data=[1, --, --, 3, 5],
  5588|         0|            0|            0|  0.00%|                     mask=[False,  True,  True, False, False],
  5589|         0|            0|            0|  0.00%|               fill_value=999999)
  5590|         0|            0|            0|  0.00%|
  5591|         0|            0|            0|  0.00%|        """
  5592|         0|            0|            0|  0.00%|        if self._mask is nomask:
  5593|         0|            0|            0|  0.00%|            ndarray.sort(self, axis=axis, kind=kind, order=order)
  5594|         0|            0|            0|  0.00%|            return
  5595|         0|            0|            0|  0.00%|
  5596|         0|            0|            0|  0.00%|        if self is masked:
  5597|         0|            0|            0|  0.00%|            return
  5598|         0|            0|            0|  0.00%|
  5599|         0|            0|            0|  0.00%|        sidx = self.argsort(axis=axis, kind=kind, order=order,
  5600|         0|            0|            0|  0.00%|                            fill_value=fill_value, endwith=endwith)
  5601|         0|            0|            0|  0.00%|
  5602|         0|            0|            0|  0.00%|        self[...] = np.take_along_axis(self, sidx, axis=axis)
  5603|         0|            0|            0|  0.00%|
  5604|         0|            0|            0|  0.00%|    def min(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
  5605|         0|            0|            0|  0.00%|        """
  5606|         0|            0|            0|  0.00%|        Return the minimum along a given axis.
  5607|         0|            0|            0|  0.00%|
  5608|         0|            0|            0|  0.00%|        Parameters
  5609|         0|            0|            0|  0.00%|        ----------
  5610|         0|            0|            0|  0.00%|        axis : {None, int}, optional
  5611|         0|            0|            0|  0.00%|            Axis along which to operate.  By default, ``axis`` is None and the
  5612|         0|            0|            0|  0.00%|            flattened input is used.
  5613|         0|            0|            0|  0.00%|        out : array_like, optional
  5614|         0|            0|            0|  0.00%|            Alternative output array in which to place the result.  Must be of
  5615|         0|            0|            0|  0.00%|            the same shape and buffer length as the expected output.
  5616|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5617|         0|            0|            0|  0.00%|            Value used to fill in the masked values.
  5618|         0|            0|            0|  0.00%|            If None, use the output of `minimum_fill_value`.
  5619|         0|            0|            0|  0.00%|
  5620|         0|            0|            0|  0.00%|        Returns
  5621|         0|            0|            0|  0.00%|        -------
  5622|         0|            0|            0|  0.00%|        amin : array_like
  5623|         0|            0|            0|  0.00%|            New array holding the result.
  5624|         0|            0|            0|  0.00%|            If ``out`` was specified, ``out`` is returned.
  5625|         0|            0|            0|  0.00%|
  5626|         0|            0|            0|  0.00%|        See Also
  5627|         0|            0|            0|  0.00%|        --------
  5628|         0|            0|            0|  0.00%|        minimum_fill_value
  5629|         0|            0|            0|  0.00%|            Returns the minimum filling value for a given datatype.
  5630|         0|            0|            0|  0.00%|
  5631|         0|            0|            0|  0.00%|        """
  5632|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5633|         0|            0|            0|  0.00%|
  5634|         0|            0|            0|  0.00%|        _mask = self._mask
  5635|         0|            0|            0|  0.00%|        newmask = _check_mask_axis(_mask, axis, **kwargs)
  5636|         0|            0|            0|  0.00%|        if fill_value is None:
  5637|         0|            0|            0|  0.00%|            fill_value = minimum_fill_value(self)
  5638|         0|            0|            0|  0.00%|        # No explicit output
  5639|         0|            0|            0|  0.00%|        if out is None:
  5640|         0|            0|            0|  0.00%|            result = self.filled(fill_value).min(
  5641|         0|            0|            0|  0.00%|                axis=axis, out=out, **kwargs).view(type(self))
  5642|         0|            0|            0|  0.00%|            if result.ndim:
  5643|         0|            0|            0|  0.00%|                # Set the mask
  5644|         0|            0|            0|  0.00%|                result.__setmask__(newmask)
  5645|         0|            0|            0|  0.00%|                # Get rid of Infs
  5646|         0|            0|            0|  0.00%|                if newmask.ndim:
  5647|         0|            0|            0|  0.00%|                    np.copyto(result, result.fill_value, where=newmask)
  5648|         0|            0|            0|  0.00%|            elif newmask:
  5649|         0|            0|            0|  0.00%|                result = masked
  5650|         0|            0|            0|  0.00%|            return result
  5651|         0|            0|            0|  0.00%|        # Explicit output
  5652|         0|            0|            0|  0.00%|        result = self.filled(fill_value).min(axis=axis, out=out, **kwargs)
  5653|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5654|         0|            0|            0|  0.00%|            outmask = getmask(out)
  5655|         0|            0|            0|  0.00%|            if (outmask is nomask):
  5656|         0|            0|            0|  0.00%|                outmask = out._mask = make_mask_none(out.shape)
  5657|         0|            0|            0|  0.00%|            outmask.flat = newmask
  5658|         0|            0|            0|  0.00%|        else:
  5659|         0|            0|            0|  0.00%|            if out.dtype.kind in 'biu':
  5660|         0|            0|            0|  0.00%|                errmsg = "Masked data information would be lost in one or more"\
  5661|         0|            0|            0|  0.00%|                         " location."
  5662|         0|            0|            0|  0.00%|                raise MaskError(errmsg)
  5663|         0|            0|            0|  0.00%|            np.copyto(out, np.nan, where=newmask)
  5664|         0|            0|            0|  0.00%|        return out
  5665|         0|            0|            0|  0.00%|
  5666|         0|            0|            0|  0.00%|    # unique to masked arrays
  5667|         0|            0|            0|  0.00%|    def mini(self, axis=None):
  5668|         0|            0|            0|  0.00%|        """
  5669|         0|            0|            0|  0.00%|        Return the array minimum along the specified axis.
  5670|         0|            0|            0|  0.00%|
  5671|         0|            0|            0|  0.00%|        .. deprecated:: 1.13.0
  5672|         0|            0|            0|  0.00%|           This function is identical to both:
  5673|         0|            0|            0|  0.00%|
  5674|         0|            0|            0|  0.00%|            * ``self.min(keepdims=True, axis=axis).squeeze(axis=axis)``
  5675|         0|            0|            0|  0.00%|            * ``np.ma.minimum.reduce(self, axis=axis)``
  5676|         0|            0|            0|  0.00%|
  5677|         0|            0|            0|  0.00%|           Typically though, ``self.min(axis=axis)`` is sufficient.
  5678|         0|            0|            0|  0.00%|
  5679|         0|            0|            0|  0.00%|        Parameters
  5680|         0|            0|            0|  0.00%|        ----------
  5681|         0|            0|            0|  0.00%|        axis : int, optional
  5682|         0|            0|            0|  0.00%|            The axis along which to find the minima. Default is None, in which case
  5683|         0|            0|            0|  0.00%|            the minimum value in the whole array is returned.
  5684|         0|            0|            0|  0.00%|
  5685|         0|            0|            0|  0.00%|        Returns
  5686|         0|            0|            0|  0.00%|        -------
  5687|         0|            0|            0|  0.00%|        min : scalar or MaskedArray
  5688|         0|            0|            0|  0.00%|            If `axis` is None, the result is a scalar. Otherwise, if `axis` is
  5689|         0|            0|            0|  0.00%|            given and the array is at least 2-D, the result is a masked array with
  5690|         0|            0|            0|  0.00%|            dimension one smaller than the array on which `mini` is called.
  5691|         0|            0|            0|  0.00%|
  5692|         0|            0|            0|  0.00%|        Examples
  5693|         0|            0|            0|  0.00%|        --------
  5694|         0|            0|            0|  0.00%|        >>> x = np.ma.array(np.arange(6), mask=[0 ,1, 0, 0, 0 ,1]).reshape(3, 2)
  5695|         0|            0|            0|  0.00%|        >>> x
  5696|         0|            0|            0|  0.00%|        masked_array(
  5697|         0|            0|            0|  0.00%|          data=[[0, --],
  5698|         0|            0|            0|  0.00%|                [2, 3],
  5699|         0|            0|            0|  0.00%|                [4, --]],
  5700|         0|            0|            0|  0.00%|          mask=[[False,  True],
  5701|         0|            0|            0|  0.00%|                [False, False],
  5702|         0|            0|            0|  0.00%|                [False,  True]],
  5703|         0|            0|            0|  0.00%|          fill_value=999999)
  5704|         0|            0|            0|  0.00%|        >>> x.mini()
  5705|         0|            0|            0|  0.00%|        masked_array(data=0,
  5706|         0|            0|            0|  0.00%|                     mask=False,
  5707|         0|            0|            0|  0.00%|               fill_value=999999)
  5708|         0|            0|            0|  0.00%|        >>> x.mini(axis=0)
  5709|         0|            0|            0|  0.00%|        masked_array(data=[0, 3],
  5710|         0|            0|            0|  0.00%|                     mask=[False, False],
  5711|         0|            0|            0|  0.00%|               fill_value=999999)
  5712|         0|            0|            0|  0.00%|        >>> x.mini(axis=1)
  5713|         0|            0|            0|  0.00%|        masked_array(data=[0, 2, 4],
  5714|         0|            0|            0|  0.00%|                     mask=[False, False, False],
  5715|         0|            0|            0|  0.00%|               fill_value=999999)
  5716|         0|            0|            0|  0.00%|
  5717|         0|            0|            0|  0.00%|        There is a small difference between `mini` and `min`:
  5718|         0|            0|            0|  0.00%|
  5719|         0|            0|            0|  0.00%|        >>> x[:,1].mini(axis=0)
  5720|         0|            0|            0|  0.00%|        masked_array(data=3,
  5721|         0|            0|            0|  0.00%|                     mask=False,
  5722|         0|            0|            0|  0.00%|               fill_value=999999)
  5723|         0|            0|            0|  0.00%|        >>> x[:,1].min(axis=0)
  5724|         0|            0|            0|  0.00%|        3
  5725|         0|            0|            0|  0.00%|        """
  5726|         0|            0|            0|  0.00%|
  5727|         0|            0|            0|  0.00%|        # 2016-04-13, 1.13.0, gh-8764
  5728|         0|            0|            0|  0.00%|        warnings.warn(
  5729|         0|            0|            0|  0.00%|            "`mini` is deprecated; use the `min` method or "
  5730|         0|            0|            0|  0.00%|            "`np.ma.minimum.reduce instead.",
  5731|         0|            0|            0|  0.00%|            DeprecationWarning, stacklevel=2)
  5732|         0|            0|            0|  0.00%|        return minimum.reduce(self, axis)
  5733|         0|            0|            0|  0.00%|
  5734|         0|            0|            0|  0.00%|    def max(self, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
  5735|         0|            0|            0|  0.00%|        """
  5736|         0|            0|            0|  0.00%|        Return the maximum along a given axis.
  5737|         0|            0|            0|  0.00%|
  5738|         0|            0|            0|  0.00%|        Parameters
  5739|         0|            0|            0|  0.00%|        ----------
  5740|         0|            0|            0|  0.00%|        axis : {None, int}, optional
  5741|         0|            0|            0|  0.00%|            Axis along which to operate.  By default, ``axis`` is None and the
  5742|         0|            0|            0|  0.00%|            flattened input is used.
  5743|         0|            0|            0|  0.00%|        out : array_like, optional
  5744|         0|            0|            0|  0.00%|            Alternative output array in which to place the result.  Must
  5745|         0|            0|            0|  0.00%|            be of the same shape and buffer length as the expected output.
  5746|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5747|         0|            0|            0|  0.00%|            Value used to fill in the masked values.
  5748|         0|            0|            0|  0.00%|            If None, use the output of maximum_fill_value().
  5749|         0|            0|            0|  0.00%|
  5750|         0|            0|            0|  0.00%|        Returns
  5751|         0|            0|            0|  0.00%|        -------
  5752|         0|            0|            0|  0.00%|        amax : array_like
  5753|         0|            0|            0|  0.00%|            New array holding the result.
  5754|         0|            0|            0|  0.00%|            If ``out`` was specified, ``out`` is returned.
  5755|         0|            0|            0|  0.00%|
  5756|         0|            0|            0|  0.00%|        See Also
  5757|         0|            0|            0|  0.00%|        --------
  5758|         0|            0|            0|  0.00%|        maximum_fill_value
  5759|         0|            0|            0|  0.00%|            Returns the maximum filling value for a given datatype.
  5760|         0|            0|            0|  0.00%|
  5761|         0|            0|            0|  0.00%|        """
  5762|         0|            0|            0|  0.00%|        kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  5763|         0|            0|            0|  0.00%|
  5764|         0|            0|            0|  0.00%|        _mask = self._mask
  5765|         0|            0|            0|  0.00%|        newmask = _check_mask_axis(_mask, axis, **kwargs)
  5766|         0|            0|            0|  0.00%|        if fill_value is None:
  5767|         0|            0|            0|  0.00%|            fill_value = maximum_fill_value(self)
  5768|         0|            0|            0|  0.00%|        # No explicit output
  5769|         0|            0|            0|  0.00%|        if out is None:
  5770|         0|            0|            0|  0.00%|            result = self.filled(fill_value).max(
  5771|         0|            0|            0|  0.00%|                axis=axis, out=out, **kwargs).view(type(self))
  5772|         0|            0|            0|  0.00%|            if result.ndim:
  5773|         0|            0|            0|  0.00%|                # Set the mask
  5774|         0|            0|            0|  0.00%|                result.__setmask__(newmask)
  5775|         0|            0|            0|  0.00%|                # Get rid of Infs
  5776|         0|            0|            0|  0.00%|                if newmask.ndim:
  5777|         0|            0|            0|  0.00%|                    np.copyto(result, result.fill_value, where=newmask)
  5778|         0|            0|            0|  0.00%|            elif newmask:
  5779|         0|            0|            0|  0.00%|                result = masked
  5780|         0|            0|            0|  0.00%|            return result
  5781|         0|            0|            0|  0.00%|        # Explicit output
  5782|         0|            0|            0|  0.00%|        result = self.filled(fill_value).max(axis=axis, out=out, **kwargs)
  5783|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5784|         0|            0|            0|  0.00%|            outmask = getmask(out)
  5785|         0|            0|            0|  0.00%|            if (outmask is nomask):
  5786|         0|            0|            0|  0.00%|                outmask = out._mask = make_mask_none(out.shape)
  5787|         0|            0|            0|  0.00%|            outmask.flat = newmask
  5788|         0|            0|            0|  0.00%|        else:
  5789|         0|            0|            0|  0.00%|
  5790|         0|            0|            0|  0.00%|            if out.dtype.kind in 'biu':
  5791|         0|            0|            0|  0.00%|                errmsg = "Masked data information would be lost in one or more"\
  5792|         0|            0|            0|  0.00%|                         " location."
  5793|         0|            0|            0|  0.00%|                raise MaskError(errmsg)
  5794|         0|            0|            0|  0.00%|            np.copyto(out, np.nan, where=newmask)
  5795|         0|            0|            0|  0.00%|        return out
  5796|         0|            0|            0|  0.00%|
  5797|         0|            0|            0|  0.00%|    def ptp(self, axis=None, out=None, fill_value=None, keepdims=False):
  5798|         0|            0|            0|  0.00%|        """
  5799|         0|            0|            0|  0.00%|        Return (maximum - minimum) along the given dimension
  5800|         0|            0|            0|  0.00%|        (i.e. peak-to-peak value).
  5801|         0|            0|            0|  0.00%|
  5802|         0|            0|            0|  0.00%|        Parameters
  5803|         0|            0|            0|  0.00%|        ----------
  5804|         0|            0|            0|  0.00%|        axis : {None, int}, optional
  5805|         0|            0|            0|  0.00%|            Axis along which to find the peaks.  If None (default) the
  5806|         0|            0|            0|  0.00%|            flattened array is used.
  5807|         0|            0|            0|  0.00%|        out : {None, array_like}, optional
  5808|         0|            0|            0|  0.00%|            Alternative output array in which to place the result. It must
  5809|         0|            0|            0|  0.00%|            have the same shape and buffer length as the expected output
  5810|         0|            0|            0|  0.00%|            but the type will be cast if necessary.
  5811|         0|            0|            0|  0.00%|        fill_value : {var}, optional
  5812|         0|            0|            0|  0.00%|            Value used to fill in the masked values.
  5813|         0|            0|            0|  0.00%|
  5814|         0|            0|            0|  0.00%|        Returns
  5815|         0|            0|            0|  0.00%|        -------
  5816|         0|            0|            0|  0.00%|        ptp : ndarray.
  5817|         0|            0|            0|  0.00%|            A new array holding the result, unless ``out`` was
  5818|         0|            0|            0|  0.00%|            specified, in which case a reference to ``out`` is returned.
  5819|         0|            0|            0|  0.00%|
  5820|         0|            0|            0|  0.00%|        """
  5821|         0|            0|            0|  0.00%|        if out is None:
  5822|         0|            0|            0|  0.00%|            result = self.max(axis=axis, fill_value=fill_value,
  5823|         0|            0|            0|  0.00%|                              keepdims=keepdims)
  5824|         0|            0|            0|  0.00%|            result -= self.min(axis=axis, fill_value=fill_value,
  5825|         0|            0|            0|  0.00%|                               keepdims=keepdims)
  5826|         0|            0|            0|  0.00%|            return result
  5827|         0|            0|            0|  0.00%|        out.flat = self.max(axis=axis, out=out, fill_value=fill_value,
  5828|         0|            0|            0|  0.00%|                            keepdims=keepdims)
  5829|         0|            0|            0|  0.00%|        min_value = self.min(axis=axis, fill_value=fill_value,
  5830|         0|            0|            0|  0.00%|                             keepdims=keepdims)
  5831|         0|            0|            0|  0.00%|        np.subtract(out, min_value, out=out, casting='unsafe')
  5832|         0|            0|            0|  0.00%|        return out
  5833|         0|            0|            0|  0.00%|
  5834|         0|            0|            0|  0.00%|    def partition(self, *args, **kwargs):
  5835|         0|            0|            0|  0.00%|        warnings.warn("Warning: 'partition' will ignore the 'mask' "
  5836|         0|            0|            0|  0.00%|                      "of the {}.".format(self.__class__.__name__),
  5837|         0|            0|            0|  0.00%|                      stacklevel=2)
  5838|         0|            0|            0|  0.00%|        return super(MaskedArray, self).partition(*args, **kwargs)
  5839|         0|            0|            0|  0.00%|
  5840|         0|            0|            0|  0.00%|    def argpartition(self, *args, **kwargs):
  5841|         0|            0|            0|  0.00%|        warnings.warn("Warning: 'argpartition' will ignore the 'mask' "
  5842|         0|            0|            0|  0.00%|                      "of the {}.".format(self.__class__.__name__),
  5843|         0|            0|            0|  0.00%|                      stacklevel=2)
  5844|         0|            0|            0|  0.00%|        return super(MaskedArray, self).argpartition(*args, **kwargs)
  5845|         0|            0|            0|  0.00%|
  5846|         0|            0|            0|  0.00%|    def take(self, indices, axis=None, out=None, mode='raise'):
  5847|         0|            0|            0|  0.00%|        """
  5848|         0|            0|            0|  0.00%|        """
  5849|         0|            0|            0|  0.00%|        (_data, _mask) = (self._data, self._mask)
  5850|         0|            0|            0|  0.00%|        cls = type(self)
  5851|         0|            0|            0|  0.00%|        # Make sure the indices are not masked
  5852|         0|            0|            0|  0.00%|        maskindices = getmask(indices)
  5853|         0|            0|            0|  0.00%|        if maskindices is not nomask:
  5854|         0|            0|            0|  0.00%|            indices = indices.filled(0)
  5855|         0|            0|            0|  0.00%|        # Get the data, promoting scalars to 0d arrays with [...] so that
  5856|         0|            0|            0|  0.00%|        # .view works correctly
  5857|         0|            0|            0|  0.00%|        if out is None:
  5858|         0|            0|            0|  0.00%|            out = _data.take(indices, axis=axis, mode=mode)[...].view(cls)
  5859|         0|            0|            0|  0.00%|        else:
  5860|         0|            0|            0|  0.00%|            np.take(_data, indices, axis=axis, mode=mode, out=out)
  5861|         0|            0|            0|  0.00%|        # Get the mask
  5862|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  5863|         0|            0|            0|  0.00%|            if _mask is nomask:
  5864|         0|            0|            0|  0.00%|                outmask = maskindices
  5865|         0|            0|            0|  0.00%|            else:
  5866|         0|            0|            0|  0.00%|                outmask = _mask.take(indices, axis=axis, mode=mode)
  5867|         0|            0|            0|  0.00%|                outmask |= maskindices
  5868|         0|            0|            0|  0.00%|            out.__setmask__(outmask)
  5869|         0|            0|            0|  0.00%|        # demote 0d arrays back to scalars, for consistency with ndarray.take
  5870|         0|            0|            0|  0.00%|        return out[()]
  5871|         0|            0|            0|  0.00%|
  5872|         0|            0|            0|  0.00%|    # Array methods
  5873|         0|            0|            0|  0.00%|    copy = _arraymethod('copy')
  5874|         0|            0|            0|  0.00%|    diagonal = _arraymethod('diagonal')
  5875|         0|            0|            0|  0.00%|    flatten = _arraymethod('flatten')
  5876|         0|            0|            0|  0.00%|    repeat = _arraymethod('repeat')
  5877|         0|            0|            0|  0.00%|    squeeze = _arraymethod('squeeze')
  5878|         0|            0|            0|  0.00%|    swapaxes = _arraymethod('swapaxes')
  5879|         0|            0|            0|  0.00%|    T = property(fget=lambda self: self.transpose())
  5880|         0|            0|            0|  0.00%|    transpose = _arraymethod('transpose')
  5881|         0|            0|            0|  0.00%|
  5882|         0|            0|            0|  0.00%|    def tolist(self, fill_value=None):
  5883|         0|            0|            0|  0.00%|        """
  5884|         0|            0|            0|  0.00%|        Return the data portion of the masked array as a hierarchical Python list.
  5885|         0|            0|            0|  0.00%|
  5886|         0|            0|            0|  0.00%|        Data items are converted to the nearest compatible Python type.
  5887|         0|            0|            0|  0.00%|        Masked values are converted to `fill_value`. If `fill_value` is None,
  5888|         0|            0|            0|  0.00%|        the corresponding entries in the output list will be ``None``.
  5889|         0|            0|            0|  0.00%|
  5890|         0|            0|            0|  0.00%|        Parameters
  5891|         0|            0|            0|  0.00%|        ----------
  5892|         0|            0|            0|  0.00%|        fill_value : scalar, optional
  5893|         0|            0|            0|  0.00%|            The value to use for invalid entries. Default is None.
  5894|         0|            0|            0|  0.00%|
  5895|         0|            0|            0|  0.00%|        Returns
  5896|         0|            0|            0|  0.00%|        -------
  5897|         0|            0|            0|  0.00%|        result : list
  5898|         0|            0|            0|  0.00%|            The Python list representation of the masked array.
  5899|         0|            0|            0|  0.00%|
  5900|         0|            0|            0|  0.00%|        Examples
  5901|         0|            0|            0|  0.00%|        --------
  5902|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3], [4,5,6], [7,8,9]], mask=[0] + [1,0]*4)
  5903|         0|            0|            0|  0.00%|        >>> x.tolist()
  5904|         0|            0|            0|  0.00%|        [[1, None, 3], [None, 5, None], [7, None, 9]]
  5905|         0|            0|            0|  0.00%|        >>> x.tolist(-999)
  5906|         0|            0|            0|  0.00%|        [[1, -999, 3], [-999, 5, -999], [7, -999, 9]]
  5907|         0|            0|            0|  0.00%|
  5908|         0|            0|            0|  0.00%|        """
  5909|         0|            0|            0|  0.00%|        _mask = self._mask
  5910|         0|            0|            0|  0.00%|        # No mask ? Just return .data.tolist ?
  5911|         0|            0|            0|  0.00%|        if _mask is nomask:
  5912|         0|            0|            0|  0.00%|            return self._data.tolist()
  5913|         0|            0|            0|  0.00%|        # Explicit fill_value: fill the array and get the list
  5914|         0|            0|            0|  0.00%|        if fill_value is not None:
  5915|         0|            0|            0|  0.00%|            return self.filled(fill_value).tolist()
  5916|         0|            0|            0|  0.00%|        # Structured array.
  5917|         0|            0|            0|  0.00%|        names = self.dtype.names
  5918|         0|            0|            0|  0.00%|        if names:
  5919|         0|            0|            0|  0.00%|            result = self._data.astype([(_, object) for _ in names])
  5920|         0|            0|            0|  0.00%|            for n in names:
  5921|         0|            0|            0|  0.00%|                result[n][_mask[n]] = None
  5922|         0|            0|            0|  0.00%|            return result.tolist()
  5923|         0|            0|            0|  0.00%|        # Standard arrays.
  5924|         0|            0|            0|  0.00%|        if _mask is nomask:
  5925|         0|            0|            0|  0.00%|            return [None]
  5926|         0|            0|            0|  0.00%|        # Set temps to save time when dealing w/ marrays.
  5927|         0|            0|            0|  0.00%|        inishape = self.shape
  5928|         0|            0|            0|  0.00%|        result = np.array(self._data.ravel(), dtype=object)
  5929|         0|            0|            0|  0.00%|        result[_mask.ravel()] = None
  5930|         0|            0|            0|  0.00%|        result.shape = inishape
  5931|         0|            0|            0|  0.00%|        return result.tolist()
  5932|         0|            0|            0|  0.00%|
  5933|         0|            0|            0|  0.00%|    def tostring(self, fill_value=None, order='C'):
  5934|         0|            0|            0|  0.00%|        """
  5935|         0|            0|            0|  0.00%|        This function is a compatibility alias for tobytes. Despite its name it
  5936|         0|            0|            0|  0.00%|        returns bytes not strings.
  5937|         0|            0|            0|  0.00%|        """
  5938|         0|            0|            0|  0.00%|
  5939|         0|            0|            0|  0.00%|        return self.tobytes(fill_value, order=order)
  5940|         0|            0|            0|  0.00%|
  5941|         0|            0|            0|  0.00%|    def tobytes(self, fill_value=None, order='C'):
  5942|         0|            0|            0|  0.00%|        """
  5943|         0|            0|            0|  0.00%|        Return the array data as a string containing the raw bytes in the array.
  5944|         0|            0|            0|  0.00%|
  5945|         0|            0|            0|  0.00%|        The array is filled with a fill value before the string conversion.
  5946|         0|            0|            0|  0.00%|
  5947|         0|            0|            0|  0.00%|        .. versionadded:: 1.9.0
  5948|         0|            0|            0|  0.00%|
  5949|         0|            0|            0|  0.00%|        Parameters
  5950|         0|            0|            0|  0.00%|        ----------
  5951|         0|            0|            0|  0.00%|        fill_value : scalar, optional
  5952|         0|            0|            0|  0.00%|            Value used to fill in the masked values. Default is None, in which
  5953|         0|            0|            0|  0.00%|            case `MaskedArray.fill_value` is used.
  5954|         0|            0|            0|  0.00%|        order : {'C','F','A'}, optional
  5955|         0|            0|            0|  0.00%|            Order of the data item in the copy. Default is 'C'.
  5956|         0|            0|            0|  0.00%|
  5957|         0|            0|            0|  0.00%|            - 'C'   -- C order (row major).
  5958|         0|            0|            0|  0.00%|            - 'F'   -- Fortran order (column major).
  5959|         0|            0|            0|  0.00%|            - 'A'   -- Any, current order of array.
  5960|         0|            0|            0|  0.00%|            - None  -- Same as 'A'.
  5961|         0|            0|            0|  0.00%|
  5962|         0|            0|            0|  0.00%|        See Also
  5963|         0|            0|            0|  0.00%|        --------
  5964|         0|            0|            0|  0.00%|        ndarray.tobytes
  5965|         0|            0|            0|  0.00%|        tolist, tofile
  5966|         0|            0|            0|  0.00%|
  5967|         0|            0|            0|  0.00%|        Notes
  5968|         0|            0|            0|  0.00%|        -----
  5969|         0|            0|            0|  0.00%|        As for `ndarray.tobytes`, information about the shape, dtype, etc.,
  5970|         0|            0|            0|  0.00%|        but also about `fill_value`, will be lost.
  5971|         0|            0|            0|  0.00%|
  5972|         0|            0|            0|  0.00%|        Examples
  5973|         0|            0|            0|  0.00%|        --------
  5974|         0|            0|            0|  0.00%|        >>> x = np.ma.array(np.array([[1, 2], [3, 4]]), mask=[[0, 1], [1, 0]])
  5975|         0|            0|            0|  0.00%|        >>> x.tobytes()
  5976|         0|            0|            0|  0.00%|        b'\\x01\\x00\\x00\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00?B\\x0f\\x00\\x00\\x00\\x00\\x00\\x04\\x00\\x00\\x00\\x00\\x00\\x00\\x00'
  5977|         0|            0|            0|  0.00%|
  5978|         0|            0|            0|  0.00%|        """
  5979|         0|            0|            0|  0.00%|        return self.filled(fill_value).tobytes(order=order)
  5980|         0|            0|            0|  0.00%|
  5981|         0|            0|            0|  0.00%|    def tofile(self, fid, sep="", format="%s"):
  5982|         0|            0|            0|  0.00%|        """
  5983|         0|            0|            0|  0.00%|        Save a masked array to a file in binary format.
  5984|         0|            0|            0|  0.00%|
  5985|         0|            0|            0|  0.00%|        .. warning::
  5986|         0|            0|            0|  0.00%|          This function is not implemented yet.
  5987|         0|            0|            0|  0.00%|
  5988|         0|            0|            0|  0.00%|        Raises
  5989|         0|            0|            0|  0.00%|        ------
  5990|         0|            0|            0|  0.00%|        NotImplementedError
  5991|         0|            0|            0|  0.00%|            When `tofile` is called.
  5992|         0|            0|            0|  0.00%|
  5993|         0|            0|            0|  0.00%|        """
  5994|         0|            0|            0|  0.00%|        raise NotImplementedError("MaskedArray.tofile() not implemented yet.")
  5995|         0|            0|            0|  0.00%|
  5996|         0|            0|            0|  0.00%|    def toflex(self):
  5997|         0|            0|            0|  0.00%|        """
  5998|         0|            0|            0|  0.00%|        Transforms a masked array into a flexible-type array.
  5999|         0|            0|            0|  0.00%|
  6000|         0|            0|            0|  0.00%|        The flexible type array that is returned will have two fields:
  6001|         0|            0|            0|  0.00%|
  6002|         0|            0|            0|  0.00%|        * the ``_data`` field stores the ``_data`` part of the array.
  6003|         0|            0|            0|  0.00%|        * the ``_mask`` field stores the ``_mask`` part of the array.
  6004|         0|            0|            0|  0.00%|
  6005|         0|            0|            0|  0.00%|        Parameters
  6006|         0|            0|            0|  0.00%|        ----------
  6007|         0|            0|            0|  0.00%|        None
  6008|         0|            0|            0|  0.00%|
  6009|         0|            0|            0|  0.00%|        Returns
  6010|         0|            0|            0|  0.00%|        -------
  6011|         0|            0|            0|  0.00%|        record : ndarray
  6012|         0|            0|            0|  0.00%|            A new flexible-type `ndarray` with two fields: the first element
  6013|         0|            0|            0|  0.00%|            containing a value, the second element containing the corresponding
  6014|         0|            0|            0|  0.00%|            mask boolean. The returned record shape matches self.shape.
  6015|         0|            0|            0|  0.00%|
  6016|         0|            0|            0|  0.00%|        Notes
  6017|         0|            0|            0|  0.00%|        -----
  6018|         0|            0|            0|  0.00%|        A side-effect of transforming a masked array into a flexible `ndarray` is
  6019|         0|            0|            0|  0.00%|        that meta information (``fill_value``, ...) will be lost.
  6020|         0|            0|            0|  0.00%|
  6021|         0|            0|            0|  0.00%|        Examples
  6022|         0|            0|            0|  0.00%|        --------
  6023|         0|            0|            0|  0.00%|        >>> x = np.ma.array([[1,2,3],[4,5,6],[7,8,9]], mask=[0] + [1,0]*4)
  6024|         0|            0|            0|  0.00%|        >>> x
  6025|         0|            0|            0|  0.00%|        masked_array(
  6026|         0|            0|            0|  0.00%|          data=[[1, --, 3],
  6027|         0|            0|            0|  0.00%|                [--, 5, --],
  6028|         0|            0|            0|  0.00%|                [7, --, 9]],
  6029|         0|            0|            0|  0.00%|          mask=[[False,  True, False],
  6030|         0|            0|            0|  0.00%|                [ True, False,  True],
  6031|         0|            0|            0|  0.00%|                [False,  True, False]],
  6032|         0|            0|            0|  0.00%|          fill_value=999999)
  6033|         0|            0|            0|  0.00%|        >>> x.toflex()
  6034|         0|            0|            0|  0.00%|        array([[(1, False), (2,  True), (3, False)],
  6035|         0|            0|            0|  0.00%|               [(4,  True), (5, False), (6,  True)],
  6036|         0|            0|            0|  0.00%|               [(7, False), (8,  True), (9, False)]],
  6037|         0|            0|            0|  0.00%|              dtype=[('_data', '<i8'), ('_mask', '?')])
  6038|         0|            0|            0|  0.00%|
  6039|         0|            0|            0|  0.00%|        """
  6040|         0|            0|            0|  0.00%|        # Get the basic dtype.
  6041|         0|            0|            0|  0.00%|        ddtype = self.dtype
  6042|         0|            0|            0|  0.00%|        # Make sure we have a mask
  6043|         0|            0|            0|  0.00%|        _mask = self._mask
  6044|         0|            0|            0|  0.00%|        if _mask is None:
  6045|         0|            0|            0|  0.00%|            _mask = make_mask_none(self.shape, ddtype)
  6046|         0|            0|            0|  0.00%|        # And get its dtype
  6047|         0|            0|            0|  0.00%|        mdtype = self._mask.dtype
  6048|         0|            0|            0|  0.00%|
  6049|         0|            0|            0|  0.00%|        record = np.ndarray(shape=self.shape,
  6050|         0|            0|            0|  0.00%|                            dtype=[('_data', ddtype), ('_mask', mdtype)])
  6051|         0|            0|            0|  0.00%|        record['_data'] = self._data
  6052|         0|            0|            0|  0.00%|        record['_mask'] = self._mask
  6053|         0|            0|            0|  0.00%|        return record
  6054|         0|            0|            0|  0.00%|    torecords = toflex
  6055|         0|            0|            0|  0.00%|
  6056|         0|            0|            0|  0.00%|    # Pickling
  6057|         0|            0|            0|  0.00%|    def __getstate__(self):
  6058|         0|            0|            0|  0.00%|        """Return the internal state of the masked array, for pickling
  6059|         0|            0|            0|  0.00%|        purposes.
  6060|         0|            0|            0|  0.00%|
  6061|         0|            0|            0|  0.00%|        """
  6062|         0|            0|            0|  0.00%|        cf = 'CF'[self.flags.fnc]
  6063|         0|            0|            0|  0.00%|        data_state = super(MaskedArray, self).__reduce__()[2]
  6064|         0|            0|            0|  0.00%|        return data_state + (getmaskarray(self).tobytes(cf), self._fill_value)
  6065|         0|            0|            0|  0.00%|
  6066|         0|            0|            0|  0.00%|    def __setstate__(self, state):
  6067|         0|            0|            0|  0.00%|        """Restore the internal state of the masked array, for
  6068|         0|            0|            0|  0.00%|        pickling purposes.  ``state`` is typically the output of the
  6069|         0|            0|            0|  0.00%|        ``__getstate__`` output, and is a 5-tuple:
  6070|         0|            0|            0|  0.00%|
  6071|         0|            0|            0|  0.00%|        - class name
  6072|         0|            0|            0|  0.00%|        - a tuple giving the shape of the data
  6073|         0|            0|            0|  0.00%|        - a typecode for the data
  6074|         0|            0|            0|  0.00%|        - a binary string for the data
  6075|         0|            0|            0|  0.00%|        - a binary string for the mask.
  6076|         0|            0|            0|  0.00%|
  6077|         0|            0|            0|  0.00%|        """
  6078|         0|            0|            0|  0.00%|        (_, shp, typ, isf, raw, msk, flv) = state
  6079|         0|            0|            0|  0.00%|        super(MaskedArray, self).__setstate__((shp, typ, isf, raw))
  6080|         0|            0|            0|  0.00%|        self._mask.__setstate__((shp, make_mask_descr(typ), isf, msk))
  6081|         0|            0|            0|  0.00%|        self.fill_value = flv
  6082|         0|            0|            0|  0.00%|
  6083|         0|            0|            0|  0.00%|    def __reduce__(self):
  6084|         0|            0|            0|  0.00%|        """Return a 3-tuple for pickling a MaskedArray.
  6085|         0|            0|            0|  0.00%|
  6086|         0|            0|            0|  0.00%|        """
  6087|         0|            0|            0|  0.00%|        return (_mareconstruct,
  6088|         0|            0|            0|  0.00%|                (self.__class__, self._baseclass, (0,), 'b',),
  6089|         0|            0|            0|  0.00%|                self.__getstate__())
  6090|         0|            0|            0|  0.00%|
  6091|         0|            0|            0|  0.00%|    def __deepcopy__(self, memo=None):
  6092|         0|            0|            0|  0.00%|        from copy import deepcopy
  6093|         0|            0|            0|  0.00%|        copied = MaskedArray.__new__(type(self), self, copy=True)
  6094|         0|            0|            0|  0.00%|        if memo is None:
  6095|         0|            0|            0|  0.00%|            memo = {}
  6096|         0|            0|            0|  0.00%|        memo[id(self)] = copied
  6097|         0|            0|            0|  0.00%|        for (k, v) in self.__dict__.items():
  6098|         0|            0|            0|  0.00%|            copied.__dict__[k] = deepcopy(v, memo)
  6099|         0|            0|            0|  0.00%|        return copied
  6100|         0|            0|            0|  0.00%|
  6101|         0|            0|            0|  0.00%|
  6102|         0|            0|            0|  0.00%|def _mareconstruct(subtype, baseclass, baseshape, basetype,):
  6103|         0|            0|            0|  0.00%|    """Internal function that builds a new MaskedArray from the
  6104|         0|            0|            0|  0.00%|    information stored in a pickle.
  6105|         0|            0|            0|  0.00%|
  6106|         0|            0|            0|  0.00%|    """
  6107|         0|            0|            0|  0.00%|    _data = ndarray.__new__(baseclass, baseshape, basetype)
  6108|         0|            0|            0|  0.00%|    _mask = ndarray.__new__(ndarray, baseshape, make_mask_descr(basetype))
  6109|         0|            0|            0|  0.00%|    return subtype.__new__(subtype, _data, mask=_mask, dtype=basetype,)
  6110|         0|            0|            0|  0.00%|
  6111|         0|            0|            0|  0.00%|
  6112|         0|            0|            0|  0.00%|class mvoid(MaskedArray):
  6113|         0|            0|            0|  0.00%|    """
  6114|         0|            0|            0|  0.00%|    Fake a 'void' object to use for masked array with structured dtypes.
  6115|         0|            0|            0|  0.00%|    """
  6116|         0|            0|            0|  0.00%|
  6117|         0|            0|            0|  0.00%|    def __new__(self, data, mask=nomask, dtype=None, fill_value=None,
  6118|         0|            0|            0|  0.00%|                hardmask=False, copy=False, subok=True):
  6119|         0|            0|            0|  0.00%|        _data = np.array(data, copy=copy, subok=subok, dtype=dtype)
  6120|         0|            0|            0|  0.00%|        _data = _data.view(self)
  6121|         0|            0|            0|  0.00%|        _data._hardmask = hardmask
  6122|         0|            0|            0|  0.00%|        if mask is not nomask:
  6123|         0|            0|            0|  0.00%|            if isinstance(mask, np.void):
  6124|         0|            0|            0|  0.00%|                _data._mask = mask
  6125|         0|            0|            0|  0.00%|            else:
  6126|         0|            0|            0|  0.00%|                try:
  6127|         0|            0|            0|  0.00%|                    # Mask is already a 0D array
  6128|         0|            0|            0|  0.00%|                    _data._mask = np.void(mask)
  6129|         0|            0|            0|  0.00%|                except TypeError:
  6130|         0|            0|            0|  0.00%|                    # Transform the mask to a void
  6131|         0|            0|            0|  0.00%|                    mdtype = make_mask_descr(dtype)
  6132|         0|            0|            0|  0.00%|                    _data._mask = np.array(mask, dtype=mdtype)[()]
  6133|         0|            0|            0|  0.00%|        if fill_value is not None:
  6134|         0|            0|            0|  0.00%|            _data.fill_value = fill_value
  6135|         0|            0|            0|  0.00%|        return _data
  6136|         0|            0|            0|  0.00%|
  6137|         0|            0|            0|  0.00%|    @property
  6138|         0|            0|            0|  0.00%|    def _data(self):
  6139|         0|            0|            0|  0.00%|        # Make sure that the _data part is a np.void
  6140|         0|            0|            0|  0.00%|        return super(mvoid, self)._data[()]
  6141|         0|            0|            0|  0.00%|
  6142|         0|            0|            0|  0.00%|    def __getitem__(self, indx):
  6143|         0|            0|            0|  0.00%|        """
  6144|         0|            0|            0|  0.00%|        Get the index.
  6145|         0|            0|            0|  0.00%|
  6146|         0|            0|            0|  0.00%|        """
  6147|         0|            0|            0|  0.00%|        m = self._mask
  6148|         0|            0|            0|  0.00%|        if isinstance(m[indx], ndarray):
  6149|         0|            0|            0|  0.00%|            # Can happen when indx is a multi-dimensional field:
  6150|         0|            0|            0|  0.00%|            # A = ma.masked_array(data=[([0,1],)], mask=[([True,
  6151|         0|            0|            0|  0.00%|            #                     False],)], dtype=[("A", ">i2", (2,))])
  6152|         0|            0|            0|  0.00%|            # x = A[0]; y = x["A"]; then y.mask["A"].size==2
  6153|         0|            0|            0|  0.00%|            # and we can not say masked/unmasked.
  6154|         0|            0|            0|  0.00%|            # The result is no longer mvoid!
  6155|         0|            0|            0|  0.00%|            # See also issue #6724.
  6156|         0|            0|            0|  0.00%|            return masked_array(
  6157|         0|            0|            0|  0.00%|                data=self._data[indx], mask=m[indx],
  6158|         0|            0|            0|  0.00%|                fill_value=self._fill_value[indx],
  6159|         0|            0|            0|  0.00%|                hard_mask=self._hardmask)
  6160|         0|            0|            0|  0.00%|        if m is not nomask and m[indx]:
  6161|         0|            0|            0|  0.00%|            return masked
  6162|         0|            0|            0|  0.00%|        return self._data[indx]
  6163|         0|            0|            0|  0.00%|
  6164|         0|            0|            0|  0.00%|    def __setitem__(self, indx, value):
  6165|         0|            0|            0|  0.00%|        self._data[indx] = value
  6166|         0|            0|            0|  0.00%|        if self._hardmask:
  6167|         0|            0|            0|  0.00%|            self._mask[indx] |= getattr(value, "_mask", False)
  6168|         0|            0|            0|  0.00%|        else:
  6169|         0|            0|            0|  0.00%|            self._mask[indx] = getattr(value, "_mask", False)
  6170|         0|            0|            0|  0.00%|
  6171|         0|            0|            0|  0.00%|    def __str__(self):
  6172|         0|            0|            0|  0.00%|        m = self._mask
  6173|         0|            0|            0|  0.00%|        if m is nomask:
  6174|         0|            0|            0|  0.00%|            return str(self._data)
  6175|         0|            0|            0|  0.00%|
  6176|         0|            0|            0|  0.00%|        rdtype = _replace_dtype_fields(self._data.dtype, "O")
  6177|         0|            0|            0|  0.00%|        data_arr = super(mvoid, self)._data
  6178|         0|            0|            0|  0.00%|        res = data_arr.astype(rdtype)
  6179|         0|            0|            0|  0.00%|        _recursive_printoption(res, self._mask, masked_print_option)
  6180|         0|            0|            0|  0.00%|        return str(res)
  6181|         0|            0|            0|  0.00%|
  6182|         0|            0|            0|  0.00%|    __repr__ = __str__
  6183|         0|            0|            0|  0.00%|
  6184|         0|            0|            0|  0.00%|    def __iter__(self):
  6185|         0|            0|            0|  0.00%|        "Defines an iterator for mvoid"
  6186|         0|            0|            0|  0.00%|        (_data, _mask) = (self._data, self._mask)
  6187|         0|            0|            0|  0.00%|        if _mask is nomask:
  6188|         0|            0|            0|  0.00%|            for d in _data:
  6189|         0|            0|            0|  0.00%|                yield d
  6190|         0|            0|            0|  0.00%|        else:
  6191|         0|            0|            0|  0.00%|            for (d, m) in zip(_data, _mask):
  6192|         0|            0|            0|  0.00%|                if m:
  6193|         0|            0|            0|  0.00%|                    yield masked
  6194|         0|            0|            0|  0.00%|                else:
  6195|         0|            0|            0|  0.00%|                    yield d
  6196|         0|            0|            0|  0.00%|
  6197|         0|            0|            0|  0.00%|    def __len__(self):
  6198|         0|            0|            0|  0.00%|        return self._data.__len__()
  6199|         0|            0|            0|  0.00%|
  6200|         0|            0|            0|  0.00%|    def filled(self, fill_value=None):
  6201|         0|            0|            0|  0.00%|        """
  6202|         0|            0|            0|  0.00%|        Return a copy with masked fields filled with a given value.
  6203|         0|            0|            0|  0.00%|
  6204|         0|            0|            0|  0.00%|        Parameters
  6205|         0|            0|            0|  0.00%|        ----------
  6206|         0|            0|            0|  0.00%|        fill_value : scalar, optional
  6207|         0|            0|            0|  0.00%|            The value to use for invalid entries (None by default).
  6208|         0|            0|            0|  0.00%|            If None, the `fill_value` attribute is used instead.
  6209|         0|            0|            0|  0.00%|
  6210|         0|            0|            0|  0.00%|        Returns
  6211|         0|            0|            0|  0.00%|        -------
  6212|         0|            0|            0|  0.00%|        filled_void
  6213|         0|            0|            0|  0.00%|            A `np.void` object
  6214|         0|            0|            0|  0.00%|
  6215|         0|            0|            0|  0.00%|        See Also
  6216|         0|            0|            0|  0.00%|        --------
  6217|         0|            0|            0|  0.00%|        MaskedArray.filled
  6218|         0|            0|            0|  0.00%|
  6219|         0|            0|            0|  0.00%|        """
  6220|         0|            0|            0|  0.00%|        return asarray(self).filled(fill_value)[()]
  6221|         0|            0|            0|  0.00%|
  6222|         0|            0|            0|  0.00%|    def tolist(self):
  6223|         0|            0|            0|  0.00%|        """
  6224|         0|            0|            0|  0.00%|    Transforms the mvoid object into a tuple.
  6225|         0|            0|            0|  0.00%|
  6226|         0|            0|            0|  0.00%|    Masked fields are replaced by None.
  6227|         0|            0|            0|  0.00%|
  6228|         0|            0|            0|  0.00%|    Returns
  6229|         0|            0|            0|  0.00%|    -------
  6230|         0|            0|            0|  0.00%|    returned_tuple
  6231|         0|            0|            0|  0.00%|        Tuple of fields
  6232|         0|            0|            0|  0.00%|        """
  6233|         0|            0|            0|  0.00%|        _mask = self._mask
  6234|         0|            0|            0|  0.00%|        if _mask is nomask:
  6235|         0|            0|            0|  0.00%|            return self._data.tolist()
  6236|         0|            0|            0|  0.00%|        result = []
  6237|         0|            0|            0|  0.00%|        for (d, m) in zip(self._data, self._mask):
  6238|         0|            0|            0|  0.00%|            if m:
  6239|         0|            0|            0|  0.00%|                result.append(None)
  6240|         0|            0|            0|  0.00%|            else:
  6241|         0|            0|            0|  0.00%|                # .item() makes sure we return a standard Python object
  6242|         0|            0|            0|  0.00%|                result.append(d.item())
  6243|         0|            0|            0|  0.00%|        return tuple(result)
  6244|         0|            0|            0|  0.00%|
  6245|         0|            0|            0|  0.00%|
  6246|         0|            0|            0|  0.00%|##############################################################################
  6247|         0|            0|            0|  0.00%|#                                Shortcuts                                   #
  6248|         0|            0|            0|  0.00%|##############################################################################
  6249|         0|            0|            0|  0.00%|
  6250|         0|            0|            0|  0.00%|
  6251|         1|  5.96046e-06|  5.96046e-06|  0.00%|def isMaskedArray(x):
  6252|         0|            0|            0|  0.00%|    """
  6253|         0|            0|            0|  0.00%|    Test whether input is an instance of MaskedArray.
  6254|         0|            0|            0|  0.00%|
  6255|         0|            0|            0|  0.00%|    This function returns True if `x` is an instance of MaskedArray
  6256|         0|            0|            0|  0.00%|    and returns False otherwise.  Any object is accepted as input.
  6257|         0|            0|            0|  0.00%|
  6258|         0|            0|            0|  0.00%|    Parameters
  6259|         0|            0|            0|  0.00%|    ----------
  6260|         0|            0|            0|  0.00%|    x : object
  6261|         0|            0|            0|  0.00%|        Object to test.
  6262|         0|            0|            0|  0.00%|
  6263|         0|            0|            0|  0.00%|    Returns
  6264|         0|            0|            0|  0.00%|    -------
  6265|         0|            0|            0|  0.00%|    result : bool
  6266|         0|            0|            0|  0.00%|        True if `x` is a MaskedArray.
  6267|         0|            0|            0|  0.00%|
  6268|         0|            0|            0|  0.00%|    See Also
  6269|         0|            0|            0|  0.00%|    --------
  6270|         0|            0|            0|  0.00%|    isMA : Alias to isMaskedArray.
  6271|         0|            0|            0|  0.00%|    isarray : Alias to isMaskedArray.
  6272|         0|            0|            0|  0.00%|
  6273|         0|            0|            0|  0.00%|    Examples
  6274|         0|            0|            0|  0.00%|    --------
  6275|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  6276|         0|            0|            0|  0.00%|    >>> a = np.eye(3, 3)
  6277|         0|            0|            0|  0.00%|    >>> a
  6278|         0|            0|            0|  0.00%|    array([[ 1.,  0.,  0.],
  6279|         0|            0|            0|  0.00%|           [ 0.,  1.,  0.],
  6280|         0|            0|            0|  0.00%|           [ 0.,  0.,  1.]])
  6281|         0|            0|            0|  0.00%|    >>> m = ma.masked_values(a, 0)
  6282|         0|            0|            0|  0.00%|    >>> m
  6283|         0|            0|            0|  0.00%|    masked_array(
  6284|         0|            0|            0|  0.00%|      data=[[1.0, --, --],
  6285|         0|            0|            0|  0.00%|            [--, 1.0, --],
  6286|         0|            0|            0|  0.00%|            [--, --, 1.0]],
  6287|         0|            0|            0|  0.00%|      mask=[[False,  True,  True],
  6288|         0|            0|            0|  0.00%|            [ True, False,  True],
  6289|         0|            0|            0|  0.00%|            [ True,  True, False]],
  6290|         0|            0|            0|  0.00%|      fill_value=0.0)
  6291|         0|            0|            0|  0.00%|    >>> ma.isMaskedArray(a)
  6292|         0|            0|            0|  0.00%|    False
  6293|         0|            0|            0|  0.00%|    >>> ma.isMaskedArray(m)
  6294|         0|            0|            0|  0.00%|    True
  6295|         0|            0|            0|  0.00%|    >>> ma.isMaskedArray([0, 1, 2])
  6296|         0|            0|            0|  0.00%|    False
  6297|         0|            0|            0|  0.00%|
  6298|         0|            0|            0|  0.00%|    """
  6299|         1|  1.09673e-05|  1.09673e-05|  0.00%|    return isinstance(x, MaskedArray)
  6300|         0|            0|            0|  0.00%|
  6301|         0|            0|            0|  0.00%|
  6302|         0|            0|            0|  0.00%|isarray = isMaskedArray
  6303|         0|            0|            0|  0.00%|isMA = isMaskedArray  # backward compatibility
  6304|         0|            0|            0|  0.00%|
  6305|         0|            0|            0|  0.00%|
  6306|         0|            0|            0|  0.00%|class MaskedConstant(MaskedArray):
  6307|         0|            0|            0|  0.00%|    # the lone np.ma.masked instance
  6308|         0|            0|            0|  0.00%|    __singleton = None
  6309|         0|            0|            0|  0.00%|
  6310|         0|            0|            0|  0.00%|    @classmethod
  6311|         0|            0|            0|  0.00%|    def __has_singleton(cls):
  6312|         0|            0|            0|  0.00%|        # second case ensures `cls.__singleton` is not just a view on the
  6313|         0|            0|            0|  0.00%|        # superclass singleton
  6314|         0|            0|            0|  0.00%|        return cls.__singleton is not None and type(cls.__singleton) is cls
  6315|         0|            0|            0|  0.00%|
  6316|         0|            0|            0|  0.00%|    def __new__(cls):
  6317|         0|            0|            0|  0.00%|        if not cls.__has_singleton():
  6318|         0|            0|            0|  0.00%|            # We define the masked singleton as a float for higher precedence.
  6319|         0|            0|            0|  0.00%|            # Note that it can be tricky sometimes w/ type comparison
  6320|         0|            0|            0|  0.00%|            data = np.array(0.)
  6321|         0|            0|            0|  0.00%|            mask = np.array(True)
  6322|         0|            0|            0|  0.00%|
  6323|         0|            0|            0|  0.00%|            # prevent any modifications
  6324|         0|            0|            0|  0.00%|            data.flags.writeable = False
  6325|         0|            0|            0|  0.00%|            mask.flags.writeable = False
  6326|         0|            0|            0|  0.00%|
  6327|         0|            0|            0|  0.00%|            # don't fall back on MaskedArray.__new__(MaskedConstant), since
  6328|         0|            0|            0|  0.00%|            # that might confuse it - this way, the construction is entirely
  6329|         0|            0|            0|  0.00%|            # within our control
  6330|         0|            0|            0|  0.00%|            cls.__singleton = MaskedArray(data, mask=mask).view(cls)
  6331|         0|            0|            0|  0.00%|
  6332|         0|            0|            0|  0.00%|        return cls.__singleton
  6333|         0|            0|            0|  0.00%|
  6334|         0|            0|            0|  0.00%|    def __array_finalize__(self, obj):
  6335|         0|            0|            0|  0.00%|        if not self.__has_singleton():
  6336|         0|            0|            0|  0.00%|            # this handles the `.view` in __new__, which we want to copy across
  6337|         0|            0|            0|  0.00%|            # properties normally
  6338|         0|            0|            0|  0.00%|            return super(MaskedConstant, self).__array_finalize__(obj)
  6339|         0|            0|            0|  0.00%|        elif self is self.__singleton:
  6340|         0|            0|            0|  0.00%|            # not clear how this can happen, play it safe
  6341|         0|            0|            0|  0.00%|            pass
  6342|         0|            0|            0|  0.00%|        else:
  6343|         0|            0|            0|  0.00%|            # everywhere else, we want to downcast to MaskedArray, to prevent a
  6344|         0|            0|            0|  0.00%|            # duplicate maskedconstant.
  6345|         0|            0|            0|  0.00%|            self.__class__ = MaskedArray
  6346|         0|            0|            0|  0.00%|            MaskedArray.__array_finalize__(self, obj)
  6347|         0|            0|            0|  0.00%|
  6348|         0|            0|            0|  0.00%|    def __array_prepare__(self, obj, context=None):
  6349|         0|            0|            0|  0.00%|        return self.view(MaskedArray).__array_prepare__(obj, context)
  6350|         0|            0|            0|  0.00%|
  6351|         0|            0|            0|  0.00%|    def __array_wrap__(self, obj, context=None):
  6352|         0|            0|            0|  0.00%|        return self.view(MaskedArray).__array_wrap__(obj, context)
  6353|         0|            0|            0|  0.00%|
  6354|         0|            0|            0|  0.00%|    def __str__(self):
  6355|         0|            0|            0|  0.00%|        return str(masked_print_option._display)
  6356|         0|            0|            0|  0.00%|
  6357|         0|            0|            0|  0.00%|    if sys.version_info.major < 3:
  6358|         0|            0|            0|  0.00%|        def __unicode__(self):
  6359|         0|            0|            0|  0.00%|            return unicode(masked_print_option._display)
  6360|         0|            0|            0|  0.00%|
  6361|         0|            0|            0|  0.00%|    def __repr__(self):
  6362|         0|            0|            0|  0.00%|        if self is MaskedConstant.__singleton:
  6363|         0|            0|            0|  0.00%|            return 'masked'
  6364|         0|            0|            0|  0.00%|        else:
  6365|         0|            0|            0|  0.00%|            # it's a subclass, or something is wrong, make it obvious
  6366|         0|            0|            0|  0.00%|            return object.__repr__(self)
  6367|         0|            0|            0|  0.00%|
  6368|         0|            0|            0|  0.00%|    def __reduce__(self):
  6369|         0|            0|            0|  0.00%|        """Override of MaskedArray's __reduce__.
  6370|         0|            0|            0|  0.00%|        """
  6371|         0|            0|            0|  0.00%|        return (self.__class__, ())
  6372|         0|            0|            0|  0.00%|
  6373|         0|            0|            0|  0.00%|    # inplace operations have no effect. We have to override them to avoid
  6374|         0|            0|            0|  0.00%|    # trying to modify the readonly data and mask arrays
  6375|         0|            0|            0|  0.00%|    def __iop__(self, other):
  6376|         0|            0|            0|  0.00%|        return self
  6377|         0|            0|            0|  0.00%|    __iadd__ = \
  6378|         0|            0|            0|  0.00%|    __isub__ = \
  6379|         0|            0|            0|  0.00%|    __imul__ = \
  6380|         0|            0|            0|  0.00%|    __ifloordiv__ = \
  6381|         0|            0|            0|  0.00%|    __itruediv__ = \
  6382|         0|            0|            0|  0.00%|    __ipow__ = \
  6383|         0|            0|            0|  0.00%|        __iop__
  6384|         0|            0|            0|  0.00%|    del __iop__  # don't leave this around
  6385|         0|            0|            0|  0.00%|
  6386|         0|            0|            0|  0.00%|    def copy(self, *args, **kwargs):
  6387|         0|            0|            0|  0.00%|        """ Copy is a no-op on the maskedconstant, as it is a scalar """
  6388|         0|            0|            0|  0.00%|        # maskedconstant is a scalar, so copy doesn't need to copy. There's
  6389|         0|            0|            0|  0.00%|        # precedent for this with `np.bool_` scalars.
  6390|         0|            0|            0|  0.00%|        return self
  6391|         0|            0|            0|  0.00%|
  6392|         0|            0|            0|  0.00%|    def __copy__(self):
  6393|         0|            0|            0|  0.00%|        return self
  6394|         0|            0|            0|  0.00%|
  6395|         0|            0|            0|  0.00%|    def __deepcopy__(self, memo):
  6396|         0|            0|            0|  0.00%|        return self
  6397|         0|            0|            0|  0.00%|
  6398|         0|            0|            0|  0.00%|    def __setattr__(self, attr, value):
  6399|         0|            0|            0|  0.00%|        if not self.__has_singleton():
  6400|         0|            0|            0|  0.00%|            # allow the singleton to be initialized
  6401|         0|            0|            0|  0.00%|            return super(MaskedConstant, self).__setattr__(attr, value)
  6402|         0|            0|            0|  0.00%|        elif self is self.__singleton:
  6403|         0|            0|            0|  0.00%|            raise AttributeError(
  6404|         0|            0|            0|  0.00%|                "attributes of {!r} are not writeable".format(self))
  6405|         0|            0|            0|  0.00%|        else:
  6406|         0|            0|            0|  0.00%|            # duplicate instance - we can end up here from __array_finalize__,
  6407|         0|            0|            0|  0.00%|            # where we set the __class__ attribute
  6408|         0|            0|            0|  0.00%|            return super(MaskedConstant, self).__setattr__(attr, value)
  6409|         0|            0|            0|  0.00%|
  6410|         0|            0|            0|  0.00%|
  6411|         0|            0|            0|  0.00%|masked = masked_singleton = MaskedConstant()
  6412|         0|            0|            0|  0.00%|masked_array = MaskedArray
  6413|         0|            0|            0|  0.00%|
  6414|         0|            0|            0|  0.00%|
  6415|         0|            0|            0|  0.00%|def array(data, dtype=None, copy=False, order=None,
  6416|         0|            0|            0|  0.00%|          mask=nomask, fill_value=None, keep_mask=True,
  6417|         0|            0|            0|  0.00%|          hard_mask=False, shrink=True, subok=True, ndmin=0):
  6418|         0|            0|            0|  0.00%|    """
  6419|         0|            0|            0|  0.00%|    Shortcut to MaskedArray.
  6420|         0|            0|            0|  0.00%|
  6421|         0|            0|            0|  0.00%|    The options are in a different order for convenience and backwards
  6422|         0|            0|            0|  0.00%|    compatibility.
  6423|         0|            0|            0|  0.00%|
  6424|         0|            0|            0|  0.00%|    """
  6425|         0|            0|            0|  0.00%|    return MaskedArray(data, mask=mask, dtype=dtype, copy=copy,
  6426|         0|            0|            0|  0.00%|                       subok=subok, keep_mask=keep_mask,
  6427|         0|            0|            0|  0.00%|                       hard_mask=hard_mask, fill_value=fill_value,
  6428|         0|            0|            0|  0.00%|                       ndmin=ndmin, shrink=shrink, order=order)
  6429|         0|            0|            0|  0.00%|array.__doc__ = masked_array.__doc__
  6430|         0|            0|            0|  0.00%|
  6431|         0|            0|            0|  0.00%|
  6432|         0|            0|            0|  0.00%|def is_masked(x):
  6433|         0|            0|            0|  0.00%|    """
  6434|         0|            0|            0|  0.00%|    Determine whether input has masked values.
  6435|         0|            0|            0|  0.00%|
  6436|         0|            0|            0|  0.00%|    Accepts any object as input, but always returns False unless the
  6437|         0|            0|            0|  0.00%|    input is a MaskedArray containing masked values.
  6438|         0|            0|            0|  0.00%|
  6439|         0|            0|            0|  0.00%|    Parameters
  6440|         0|            0|            0|  0.00%|    ----------
  6441|         0|            0|            0|  0.00%|    x : array_like
  6442|         0|            0|            0|  0.00%|        Array to check for masked values.
  6443|         0|            0|            0|  0.00%|
  6444|         0|            0|            0|  0.00%|    Returns
  6445|         0|            0|            0|  0.00%|    -------
  6446|         0|            0|            0|  0.00%|    result : bool
  6447|         0|            0|            0|  0.00%|        True if `x` is a MaskedArray with masked values, False otherwise.
  6448|         0|            0|            0|  0.00%|
  6449|         0|            0|            0|  0.00%|    Examples
  6450|         0|            0|            0|  0.00%|    --------
  6451|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  6452|         0|            0|            0|  0.00%|    >>> x = ma.masked_equal([0, 1, 0, 2, 3], 0)
  6453|         0|            0|            0|  0.00%|    >>> x
  6454|         0|            0|            0|  0.00%|    masked_array(data=[--, 1, --, 2, 3],
  6455|         0|            0|            0|  0.00%|                 mask=[ True, False,  True, False, False],
  6456|         0|            0|            0|  0.00%|           fill_value=0)
  6457|         0|            0|            0|  0.00%|    >>> ma.is_masked(x)
  6458|         0|            0|            0|  0.00%|    True
  6459|         0|            0|            0|  0.00%|    >>> x = ma.masked_equal([0, 1, 0, 2, 3], 42)
  6460|         0|            0|            0|  0.00%|    >>> x
  6461|         0|            0|            0|  0.00%|    masked_array(data=[0, 1, 0, 2, 3],
  6462|         0|            0|            0|  0.00%|                 mask=False,
  6463|         0|            0|            0|  0.00%|           fill_value=42)
  6464|         0|            0|            0|  0.00%|    >>> ma.is_masked(x)
  6465|         0|            0|            0|  0.00%|    False
  6466|         0|            0|            0|  0.00%|
  6467|         0|            0|            0|  0.00%|    Always returns False if `x` isn't a MaskedArray.
  6468|         0|            0|            0|  0.00%|
  6469|         0|            0|            0|  0.00%|    >>> x = [False, True, False]
  6470|         0|            0|            0|  0.00%|    >>> ma.is_masked(x)
  6471|         0|            0|            0|  0.00%|    False
  6472|         0|            0|            0|  0.00%|    >>> x = 'a string'
  6473|         0|            0|            0|  0.00%|    >>> ma.is_masked(x)
  6474|         0|            0|            0|  0.00%|    False
  6475|         0|            0|            0|  0.00%|
  6476|         0|            0|            0|  0.00%|    """
  6477|         0|            0|            0|  0.00%|    m = getmask(x)
  6478|         0|            0|            0|  0.00%|    if m is nomask:
  6479|         0|            0|            0|  0.00%|        return False
  6480|         0|            0|            0|  0.00%|    elif m.any():
  6481|         0|            0|            0|  0.00%|        return True
  6482|         0|            0|            0|  0.00%|    return False
  6483|         0|            0|            0|  0.00%|
  6484|         0|            0|            0|  0.00%|
  6485|         0|            0|            0|  0.00%|##############################################################################
  6486|         0|            0|            0|  0.00%|#                             Extrema functions                              #
  6487|         0|            0|            0|  0.00%|##############################################################################
  6488|         0|            0|            0|  0.00%|
  6489|         0|            0|            0|  0.00%|
  6490|         0|            0|            0|  0.00%|class _extrema_operation(_MaskedUFunc):
  6491|         0|            0|            0|  0.00%|    """
  6492|         0|            0|            0|  0.00%|    Generic class for maximum/minimum functions.
  6493|         0|            0|            0|  0.00%|
  6494|         0|            0|            0|  0.00%|    .. note::
  6495|         0|            0|            0|  0.00%|      This is the base class for `_maximum_operation` and
  6496|         0|            0|            0|  0.00%|      `_minimum_operation`.
  6497|         0|            0|            0|  0.00%|
  6498|         0|            0|            0|  0.00%|    """
  6499|         0|            0|            0|  0.00%|    def __init__(self, ufunc, compare, fill_value):
  6500|         0|            0|            0|  0.00%|        super(_extrema_operation, self).__init__(ufunc)
  6501|         0|            0|            0|  0.00%|        self.compare = compare
  6502|         0|            0|            0|  0.00%|        self.fill_value_func = fill_value
  6503|         0|            0|            0|  0.00%|
  6504|         0|            0|            0|  0.00%|    def __call__(self, a, b=None):
  6505|         0|            0|            0|  0.00%|        "Executes the call behavior."
  6506|         0|            0|            0|  0.00%|        if b is None:
  6507|         0|            0|            0|  0.00%|            # 2016-04-13, 1.13.0
  6508|         0|            0|            0|  0.00%|            warnings.warn(
  6509|         0|            0|            0|  0.00%|                "Single-argument form of np.ma.{0} is deprecated. Use "
  6510|         0|            0|            0|  0.00%|                "np.ma.{0}.reduce instead.".format(self.__name__),
  6511|         0|            0|            0|  0.00%|                DeprecationWarning, stacklevel=2)
  6512|         0|            0|            0|  0.00%|            return self.reduce(a)
  6513|         0|            0|            0|  0.00%|        return where(self.compare(a, b), a, b)
  6514|         0|            0|            0|  0.00%|
  6515|         0|            0|            0|  0.00%|    def reduce(self, target, axis=np._NoValue):
  6516|         0|            0|            0|  0.00%|        "Reduce target along the given axis."
  6517|         0|            0|            0|  0.00%|        target = narray(target, copy=False, subok=True)
  6518|         0|            0|            0|  0.00%|        m = getmask(target)
  6519|         0|            0|            0|  0.00%|
  6520|         0|            0|            0|  0.00%|        if axis is np._NoValue and target.ndim > 1:
  6521|         0|            0|            0|  0.00%|            # 2017-05-06, Numpy 1.13.0: warn on axis default
  6522|         0|            0|            0|  0.00%|            warnings.warn(
  6523|         0|            0|            0|  0.00%|                "In the future the default for ma.{0}.reduce will be axis=0, "
  6524|         0|            0|            0|  0.00%|                "not the current None, to match np.{0}.reduce. "
  6525|         0|            0|            0|  0.00%|                "Explicitly pass 0 or None to silence this warning.".format(
  6526|         0|            0|            0|  0.00%|                    self.__name__
  6527|         0|            0|            0|  0.00%|                ),
  6528|         0|            0|            0|  0.00%|                MaskedArrayFutureWarning, stacklevel=2)
  6529|         0|            0|            0|  0.00%|            axis = None
  6530|         0|            0|            0|  0.00%|
  6531|         0|            0|            0|  0.00%|        if axis is not np._NoValue:
  6532|         0|            0|            0|  0.00%|            kwargs = dict(axis=axis)
  6533|         0|            0|            0|  0.00%|        else:
  6534|         0|            0|            0|  0.00%|            kwargs = dict()
  6535|         0|            0|            0|  0.00%|
  6536|         0|            0|            0|  0.00%|        if m is nomask:
  6537|         0|            0|            0|  0.00%|            t = self.f.reduce(target, **kwargs)
  6538|         0|            0|            0|  0.00%|        else:
  6539|         0|            0|            0|  0.00%|            target = target.filled(
  6540|         0|            0|            0|  0.00%|                self.fill_value_func(target)).view(type(target))
  6541|         0|            0|            0|  0.00%|            t = self.f.reduce(target, **kwargs)
  6542|         0|            0|            0|  0.00%|            m = umath.logical_and.reduce(m, **kwargs)
  6543|         0|            0|            0|  0.00%|            if hasattr(t, '_mask'):
  6544|         0|            0|            0|  0.00%|                t._mask = m
  6545|         0|            0|            0|  0.00%|            elif m:
  6546|         0|            0|            0|  0.00%|                t = masked
  6547|         0|            0|            0|  0.00%|        return t
  6548|         0|            0|            0|  0.00%|
  6549|         0|            0|            0|  0.00%|    def outer(self, a, b):
  6550|         0|            0|            0|  0.00%|        "Return the function applied to the outer product of a and b."
  6551|         0|            0|            0|  0.00%|        ma = getmask(a)
  6552|         0|            0|            0|  0.00%|        mb = getmask(b)
  6553|         0|            0|            0|  0.00%|        if ma is nomask and mb is nomask:
  6554|         0|            0|            0|  0.00%|            m = nomask
  6555|         0|            0|            0|  0.00%|        else:
  6556|         0|            0|            0|  0.00%|            ma = getmaskarray(a)
  6557|         0|            0|            0|  0.00%|            mb = getmaskarray(b)
  6558|         0|            0|            0|  0.00%|            m = logical_or.outer(ma, mb)
  6559|         0|            0|            0|  0.00%|        result = self.f.outer(filled(a), filled(b))
  6560|         0|            0|            0|  0.00%|        if not isinstance(result, MaskedArray):
  6561|         0|            0|            0|  0.00%|            result = result.view(MaskedArray)
  6562|         0|            0|            0|  0.00%|        result._mask = m
  6563|         0|            0|            0|  0.00%|        return result
  6564|         0|            0|            0|  0.00%|
  6565|         0|            0|            0|  0.00%|def min(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
  6566|         0|            0|            0|  0.00%|    kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  6567|         0|            0|            0|  0.00%|
  6568|         0|            0|            0|  0.00%|    try:
  6569|         0|            0|            0|  0.00%|        return obj.min(axis=axis, fill_value=fill_value, out=out, **kwargs)
  6570|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
  6571|         0|            0|            0|  0.00%|        # If obj doesn't have a min method, or if the method doesn't accept a
  6572|         0|            0|            0|  0.00%|        # fill_value argument
  6573|         0|            0|            0|  0.00%|        return asanyarray(obj).min(axis=axis, fill_value=fill_value,
  6574|         0|            0|            0|  0.00%|                                   out=out, **kwargs)
  6575|         0|            0|            0|  0.00%|min.__doc__ = MaskedArray.min.__doc__
  6576|         0|            0|            0|  0.00%|
  6577|         0|            0|            0|  0.00%|def max(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
  6578|         0|            0|            0|  0.00%|    kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  6579|         0|            0|            0|  0.00%|
  6580|         0|            0|            0|  0.00%|    try:
  6581|         0|            0|            0|  0.00%|        return obj.max(axis=axis, fill_value=fill_value, out=out, **kwargs)
  6582|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
  6583|         0|            0|            0|  0.00%|        # If obj doesn't have a max method, or if the method doesn't accept a
  6584|         0|            0|            0|  0.00%|        # fill_value argument
  6585|         0|            0|            0|  0.00%|        return asanyarray(obj).max(axis=axis, fill_value=fill_value,
  6586|         0|            0|            0|  0.00%|                                   out=out, **kwargs)
  6587|         0|            0|            0|  0.00%|max.__doc__ = MaskedArray.max.__doc__
  6588|         0|            0|            0|  0.00%|
  6589|         0|            0|            0|  0.00%|
  6590|         0|            0|            0|  0.00%|def ptp(obj, axis=None, out=None, fill_value=None, keepdims=np._NoValue):
  6591|         0|            0|            0|  0.00%|    kwargs = {} if keepdims is np._NoValue else {'keepdims': keepdims}
  6592|         0|            0|            0|  0.00%|    try:
  6593|         0|            0|            0|  0.00%|        return obj.ptp(axis, out=out, fill_value=fill_value, **kwargs)
  6594|         0|            0|            0|  0.00%|    except (AttributeError, TypeError):
  6595|         0|            0|            0|  0.00%|        # If obj doesn't have a ptp method or if the method doesn't accept
  6596|         0|            0|            0|  0.00%|        # a fill_value argument
  6597|         0|            0|            0|  0.00%|        return asanyarray(obj).ptp(axis=axis, fill_value=fill_value,
  6598|         0|            0|            0|  0.00%|                                   out=out, **kwargs)
  6599|         0|            0|            0|  0.00%|ptp.__doc__ = MaskedArray.ptp.__doc__
  6600|         0|            0|            0|  0.00%|
  6601|         0|            0|            0|  0.00%|
  6602|         0|            0|            0|  0.00%|##############################################################################
  6603|         0|            0|            0|  0.00%|#           Definition of functions from the corresponding methods           #
  6604|         0|            0|            0|  0.00%|##############################################################################
  6605|         0|            0|            0|  0.00%|
  6606|         0|            0|            0|  0.00%|
  6607|         0|            0|            0|  0.00%|class _frommethod(object):
  6608|         0|            0|            0|  0.00%|    """
  6609|         0|            0|            0|  0.00%|    Define functions from existing MaskedArray methods.
  6610|         0|            0|            0|  0.00%|
  6611|         0|            0|            0|  0.00%|    Parameters
  6612|         0|            0|            0|  0.00%|    ----------
  6613|         0|            0|            0|  0.00%|    methodname : str
  6614|         0|            0|            0|  0.00%|        Name of the method to transform.
  6615|         0|            0|            0|  0.00%|
  6616|         0|            0|            0|  0.00%|    """
  6617|         0|            0|            0|  0.00%|
  6618|         0|            0|            0|  0.00%|    def __init__(self, methodname, reversed=False):
  6619|         0|            0|            0|  0.00%|        self.__name__ = methodname
  6620|         0|            0|            0|  0.00%|        self.__doc__ = self.getdoc()
  6621|         0|            0|            0|  0.00%|        self.reversed = reversed
  6622|         0|            0|            0|  0.00%|
  6623|         0|            0|            0|  0.00%|    def getdoc(self):
  6624|         0|            0|            0|  0.00%|        "Return the doc of the function (from the doc of the method)."
  6625|         0|            0|            0|  0.00%|        meth = getattr(MaskedArray, self.__name__, None) or\
  6626|         0|            0|            0|  0.00%|            getattr(np, self.__name__, None)
  6627|         0|            0|            0|  0.00%|        signature = self.__name__ + get_object_signature(meth)
  6628|         0|            0|            0|  0.00%|        if meth is not None:
  6629|         0|            0|            0|  0.00%|            doc = """    %s\n%s""" % (
  6630|         0|            0|            0|  0.00%|                signature, getattr(meth, '__doc__', None))
  6631|         0|            0|            0|  0.00%|            return doc
  6632|         0|            0|            0|  0.00%|
  6633|         0|            0|            0|  0.00%|    def __call__(self, a, *args, **params):
  6634|         0|            0|            0|  0.00%|        if self.reversed:
  6635|         0|            0|            0|  0.00%|            args = list(args)
  6636|         0|            0|            0|  0.00%|            a, args[0] = args[0], a
  6637|         0|            0|            0|  0.00%|
  6638|         0|            0|            0|  0.00%|        marr = asanyarray(a)
  6639|         0|            0|            0|  0.00%|        method_name = self.__name__
  6640|         0|            0|            0|  0.00%|        method = getattr(type(marr), method_name, None)
  6641|         0|            0|            0|  0.00%|        if method is None:
  6642|         0|            0|            0|  0.00%|            # use the corresponding np function
  6643|         0|            0|            0|  0.00%|            method = getattr(np, method_name)
  6644|         0|            0|            0|  0.00%|
  6645|         0|            0|            0|  0.00%|        return method(marr, *args, **params)
  6646|         0|            0|            0|  0.00%|
  6647|         0|            0|            0|  0.00%|
  6648|         0|            0|            0|  0.00%|all = _frommethod('all')
  6649|         0|            0|            0|  0.00%|anomalies = anom = _frommethod('anom')
  6650|         0|            0|            0|  0.00%|any = _frommethod('any')
  6651|         0|            0|            0|  0.00%|compress = _frommethod('compress', reversed=True)
  6652|         0|            0|            0|  0.00%|cumprod = _frommethod('cumprod')
  6653|         0|            0|            0|  0.00%|cumsum = _frommethod('cumsum')
  6654|         0|            0|            0|  0.00%|copy = _frommethod('copy')
  6655|         0|            0|            0|  0.00%|diagonal = _frommethod('diagonal')
  6656|         0|            0|            0|  0.00%|harden_mask = _frommethod('harden_mask')
  6657|         0|            0|            0|  0.00%|ids = _frommethod('ids')
  6658|         0|            0|            0|  0.00%|maximum = _extrema_operation(umath.maximum, greater, maximum_fill_value)
  6659|         0|            0|            0|  0.00%|mean = _frommethod('mean')
  6660|         0|            0|            0|  0.00%|minimum = _extrema_operation(umath.minimum, less, minimum_fill_value)
  6661|         0|            0|            0|  0.00%|nonzero = _frommethod('nonzero')
  6662|         0|            0|            0|  0.00%|prod = _frommethod('prod')
  6663|         0|            0|            0|  0.00%|product = _frommethod('prod')
  6664|         0|            0|            0|  0.00%|ravel = _frommethod('ravel')
  6665|         0|            0|            0|  0.00%|repeat = _frommethod('repeat')
  6666|         0|            0|            0|  0.00%|shrink_mask = _frommethod('shrink_mask')
  6667|         0|            0|            0|  0.00%|soften_mask = _frommethod('soften_mask')
  6668|         0|            0|            0|  0.00%|std = _frommethod('std')
  6669|         0|            0|            0|  0.00%|sum = _frommethod('sum')
  6670|         0|            0|            0|  0.00%|swapaxes = _frommethod('swapaxes')
  6671|         0|            0|            0|  0.00%|#take = _frommethod('take')
  6672|         0|            0|            0|  0.00%|trace = _frommethod('trace')
  6673|         0|            0|            0|  0.00%|var = _frommethod('var')
  6674|         0|            0|            0|  0.00%|
  6675|         0|            0|            0|  0.00%|count = _frommethod('count')
  6676|         0|            0|            0|  0.00%|
  6677|         0|            0|            0|  0.00%|def take(a, indices, axis=None, out=None, mode='raise'):
  6678|         0|            0|            0|  0.00%|    """
  6679|         0|            0|            0|  0.00%|    """
  6680|         0|            0|            0|  0.00%|    a = masked_array(a)
  6681|         0|            0|            0|  0.00%|    return a.take(indices, axis=axis, out=out, mode=mode)
  6682|         0|            0|            0|  0.00%|
  6683|         0|            0|            0|  0.00%|
  6684|         0|            0|            0|  0.00%|def power(a, b, third=None):
  6685|         0|            0|            0|  0.00%|    """
  6686|         0|            0|            0|  0.00%|    Returns element-wise base array raised to power from second array.
  6687|         0|            0|            0|  0.00%|
  6688|         0|            0|            0|  0.00%|    This is the masked array version of `numpy.power`. For details see
  6689|         0|            0|            0|  0.00%|    `numpy.power`.
  6690|         0|            0|            0|  0.00%|
  6691|         0|            0|            0|  0.00%|    See Also
  6692|         0|            0|            0|  0.00%|    --------
  6693|         0|            0|            0|  0.00%|    numpy.power
  6694|         0|            0|            0|  0.00%|
  6695|         0|            0|            0|  0.00%|    Notes
  6696|         0|            0|            0|  0.00%|    -----
  6697|         0|            0|            0|  0.00%|    The *out* argument to `numpy.power` is not supported, `third` has to be
  6698|         0|            0|            0|  0.00%|    None.
  6699|         0|            0|            0|  0.00%|
  6700|         0|            0|            0|  0.00%|    """
  6701|         0|            0|            0|  0.00%|    if third is not None:
  6702|         0|            0|            0|  0.00%|        raise MaskError("3-argument power not supported.")
  6703|         0|            0|            0|  0.00%|    # Get the masks
  6704|         0|            0|            0|  0.00%|    ma = getmask(a)
  6705|         0|            0|            0|  0.00%|    mb = getmask(b)
  6706|         0|            0|            0|  0.00%|    m = mask_or(ma, mb)
  6707|         0|            0|            0|  0.00%|    # Get the rawdata
  6708|         0|            0|            0|  0.00%|    fa = getdata(a)
  6709|         0|            0|            0|  0.00%|    fb = getdata(b)
  6710|         0|            0|            0|  0.00%|    # Get the type of the result (so that we preserve subclasses)
  6711|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
  6712|         0|            0|            0|  0.00%|        basetype = type(a)
  6713|         0|            0|            0|  0.00%|    else:
  6714|         0|            0|            0|  0.00%|        basetype = MaskedArray
  6715|         0|            0|            0|  0.00%|    # Get the result and view it as a (subclass of) MaskedArray
  6716|         0|            0|            0|  0.00%|    with np.errstate(divide='ignore', invalid='ignore'):
  6717|         0|            0|            0|  0.00%|        result = np.where(m, fa, umath.power(fa, fb)).view(basetype)
  6718|         0|            0|            0|  0.00%|    result._update_from(a)
  6719|         0|            0|            0|  0.00%|    # Find where we're in trouble w/ NaNs and Infs
  6720|         0|            0|            0|  0.00%|    invalid = np.logical_not(np.isfinite(result.view(ndarray)))
  6721|         0|            0|            0|  0.00%|    # Add the initial mask
  6722|         0|            0|            0|  0.00%|    if m is not nomask:
  6723|         0|            0|            0|  0.00%|        if not (result.ndim):
  6724|         0|            0|            0|  0.00%|            return masked
  6725|         0|            0|            0|  0.00%|        result._mask = np.logical_or(m, invalid)
  6726|         0|            0|            0|  0.00%|    # Fix the invalid parts
  6727|         0|            0|            0|  0.00%|    if invalid.any():
  6728|         0|            0|            0|  0.00%|        if not result.ndim:
  6729|         0|            0|            0|  0.00%|            return masked
  6730|         0|            0|            0|  0.00%|        elif result._mask is nomask:
  6731|         0|            0|            0|  0.00%|            result._mask = invalid
  6732|         0|            0|            0|  0.00%|        result._data[invalid] = result.fill_value
  6733|         0|            0|            0|  0.00%|    return result
  6734|         0|            0|            0|  0.00%|
  6735|         0|            0|            0|  0.00%|argmin = _frommethod('argmin')
  6736|         0|            0|            0|  0.00%|argmax = _frommethod('argmax')
  6737|         0|            0|            0|  0.00%|
  6738|         0|            0|            0|  0.00%|def argsort(a, axis=np._NoValue, kind=None, order=None, endwith=True, fill_value=None):
  6739|         0|            0|            0|  0.00%|    "Function version of the eponymous method."
  6740|         0|            0|            0|  0.00%|    a = np.asanyarray(a)
  6741|         0|            0|            0|  0.00%|
  6742|         0|            0|            0|  0.00%|    # 2017-04-11, Numpy 1.13.0, gh-8701: warn on axis default
  6743|         0|            0|            0|  0.00%|    if axis is np._NoValue:
  6744|         0|            0|            0|  0.00%|        axis = _deprecate_argsort_axis(a)
  6745|         0|            0|            0|  0.00%|
  6746|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
  6747|         0|            0|            0|  0.00%|        return a.argsort(axis=axis, kind=kind, order=order,
  6748|         0|            0|            0|  0.00%|                         endwith=endwith, fill_value=fill_value)
  6749|         0|            0|            0|  0.00%|    else:
  6750|         0|            0|            0|  0.00%|        return a.argsort(axis=axis, kind=kind, order=order)
  6751|         0|            0|            0|  0.00%|argsort.__doc__ = MaskedArray.argsort.__doc__
  6752|         0|            0|            0|  0.00%|
  6753|         0|            0|            0|  0.00%|def sort(a, axis=-1, kind=None, order=None, endwith=True, fill_value=None):
  6754|         0|            0|            0|  0.00%|    "Function version of the eponymous method."
  6755|         0|            0|            0|  0.00%|    a = np.array(a, copy=True, subok=True)
  6756|         0|            0|            0|  0.00%|    if axis is None:
  6757|         0|            0|            0|  0.00%|        a = a.flatten()
  6758|         0|            0|            0|  0.00%|        axis = 0
  6759|         0|            0|            0|  0.00%|
  6760|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray):
  6761|         0|            0|            0|  0.00%|        a.sort(axis=axis, kind=kind, order=order,
  6762|         0|            0|            0|  0.00%|               endwith=endwith, fill_value=fill_value)
  6763|         0|            0|            0|  0.00%|    else:
  6764|         0|            0|            0|  0.00%|        a.sort(axis=axis, kind=kind, order=order)
  6765|         0|            0|            0|  0.00%|    return a
  6766|         0|            0|            0|  0.00%|sort.__doc__ = MaskedArray.sort.__doc__
  6767|         0|            0|            0|  0.00%|
  6768|         0|            0|            0|  0.00%|
  6769|         0|            0|            0|  0.00%|def compressed(x):
  6770|         0|            0|            0|  0.00%|    """
  6771|         0|            0|            0|  0.00%|    Return all the non-masked data as a 1-D array.
  6772|         0|            0|            0|  0.00%|
  6773|         0|            0|            0|  0.00%|    This function is equivalent to calling the "compressed" method of a
  6774|         0|            0|            0|  0.00%|    `MaskedArray`, see `MaskedArray.compressed` for details.
  6775|         0|            0|            0|  0.00%|
  6776|         0|            0|            0|  0.00%|    See Also
  6777|         0|            0|            0|  0.00%|    --------
  6778|         0|            0|            0|  0.00%|    MaskedArray.compressed
  6779|         0|            0|            0|  0.00%|        Equivalent method.
  6780|         0|            0|            0|  0.00%|
  6781|         0|            0|            0|  0.00%|    """
  6782|         0|            0|            0|  0.00%|    return asanyarray(x).compressed()
  6783|         0|            0|            0|  0.00%|
  6784|         0|            0|            0|  0.00%|
  6785|         0|            0|            0|  0.00%|def concatenate(arrays, axis=0):
  6786|         0|            0|            0|  0.00%|    """
  6787|         0|            0|            0|  0.00%|    Concatenate a sequence of arrays along the given axis.
  6788|         0|            0|            0|  0.00%|
  6789|         0|            0|            0|  0.00%|    Parameters
  6790|         0|            0|            0|  0.00%|    ----------
  6791|         0|            0|            0|  0.00%|    arrays : sequence of array_like
  6792|         0|            0|            0|  0.00%|        The arrays must have the same shape, except in the dimension
  6793|         0|            0|            0|  0.00%|        corresponding to `axis` (the first, by default).
  6794|         0|            0|            0|  0.00%|    axis : int, optional
  6795|         0|            0|            0|  0.00%|        The axis along which the arrays will be joined. Default is 0.
  6796|         0|            0|            0|  0.00%|
  6797|         0|            0|            0|  0.00%|    Returns
  6798|         0|            0|            0|  0.00%|    -------
  6799|         0|            0|            0|  0.00%|    result : MaskedArray
  6800|         0|            0|            0|  0.00%|        The concatenated array with any masked entries preserved.
  6801|         0|            0|            0|  0.00%|
  6802|         0|            0|            0|  0.00%|    See Also
  6803|         0|            0|            0|  0.00%|    --------
  6804|         0|            0|            0|  0.00%|    numpy.concatenate : Equivalent function in the top-level NumPy module.
  6805|         0|            0|            0|  0.00%|
  6806|         0|            0|            0|  0.00%|    Examples
  6807|         0|            0|            0|  0.00%|    --------
  6808|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  6809|         0|            0|            0|  0.00%|    >>> a = ma.arange(3)
  6810|         0|            0|            0|  0.00%|    >>> a[1] = ma.masked
  6811|         0|            0|            0|  0.00%|    >>> b = ma.arange(2, 5)
  6812|         0|            0|            0|  0.00%|    >>> a
  6813|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2],
  6814|         0|            0|            0|  0.00%|                 mask=[False,  True, False],
  6815|         0|            0|            0|  0.00%|           fill_value=999999)
  6816|         0|            0|            0|  0.00%|    >>> b
  6817|         0|            0|            0|  0.00%|    masked_array(data=[2, 3, 4],
  6818|         0|            0|            0|  0.00%|                 mask=False,
  6819|         0|            0|            0|  0.00%|           fill_value=999999)
  6820|         0|            0|            0|  0.00%|    >>> ma.concatenate([a, b])
  6821|         0|            0|            0|  0.00%|    masked_array(data=[0, --, 2, 2, 3, 4],
  6822|         0|            0|            0|  0.00%|                 mask=[False,  True, False, False, False, False],
  6823|         0|            0|            0|  0.00%|           fill_value=999999)
  6824|         0|            0|            0|  0.00%|
  6825|         0|            0|            0|  0.00%|    """
  6826|         0|            0|            0|  0.00%|    d = np.concatenate([getdata(a) for a in arrays], axis)
  6827|         0|            0|            0|  0.00%|    rcls = get_masked_subclass(*arrays)
  6828|         0|            0|            0|  0.00%|    data = d.view(rcls)
  6829|         0|            0|            0|  0.00%|    # Check whether one of the arrays has a non-empty mask.
  6830|         0|            0|            0|  0.00%|    for x in arrays:
  6831|         0|            0|            0|  0.00%|        if getmask(x) is not nomask:
  6832|         0|            0|            0|  0.00%|            break
  6833|         0|            0|            0|  0.00%|    else:
  6834|         0|            0|            0|  0.00%|        return data
  6835|         0|            0|            0|  0.00%|    # OK, so we have to concatenate the masks
  6836|         0|            0|            0|  0.00%|    dm = np.concatenate([getmaskarray(a) for a in arrays], axis)
  6837|         0|            0|            0|  0.00%|    dm = dm.reshape(d.shape)
  6838|         0|            0|            0|  0.00%|
  6839|         0|            0|            0|  0.00%|    # If we decide to keep a '_shrinkmask' option, we want to check that
  6840|         0|            0|            0|  0.00%|    # all of them are True, and then check for dm.any()
  6841|         0|            0|            0|  0.00%|    data._mask = _shrink_mask(dm)
  6842|         0|            0|            0|  0.00%|    return data
  6843|         0|            0|            0|  0.00%|
  6844|         0|            0|            0|  0.00%|
  6845|         0|            0|            0|  0.00%|def diag(v, k=0):
  6846|         0|            0|            0|  0.00%|    """
  6847|         0|            0|            0|  0.00%|    Extract a diagonal or construct a diagonal array.
  6848|         0|            0|            0|  0.00%|
  6849|         0|            0|            0|  0.00%|    This function is the equivalent of `numpy.diag` that takes masked
  6850|         0|            0|            0|  0.00%|    values into account, see `numpy.diag` for details.
  6851|         0|            0|            0|  0.00%|
  6852|         0|            0|            0|  0.00%|    See Also
  6853|         0|            0|            0|  0.00%|    --------
  6854|         0|            0|            0|  0.00%|    numpy.diag : Equivalent function for ndarrays.
  6855|         0|            0|            0|  0.00%|
  6856|         0|            0|            0|  0.00%|    """
  6857|         0|            0|            0|  0.00%|    output = np.diag(v, k).view(MaskedArray)
  6858|         0|            0|            0|  0.00%|    if getmask(v) is not nomask:
  6859|         0|            0|            0|  0.00%|        output._mask = np.diag(v._mask, k)
  6860|         0|            0|            0|  0.00%|    return output
  6861|         0|            0|            0|  0.00%|
  6862|         0|            0|            0|  0.00%|
  6863|         0|            0|            0|  0.00%|def left_shift(a, n):
  6864|         0|            0|            0|  0.00%|    """
  6865|         0|            0|            0|  0.00%|    Shift the bits of an integer to the left.
  6866|         0|            0|            0|  0.00%|
  6867|         0|            0|            0|  0.00%|    This is the masked array version of `numpy.left_shift`, for details
  6868|         0|            0|            0|  0.00%|    see that function.
  6869|         0|            0|            0|  0.00%|
  6870|         0|            0|            0|  0.00%|    See Also
  6871|         0|            0|            0|  0.00%|    --------
  6872|         0|            0|            0|  0.00%|    numpy.left_shift
  6873|         0|            0|            0|  0.00%|
  6874|         0|            0|            0|  0.00%|    """
  6875|         0|            0|            0|  0.00%|    m = getmask(a)
  6876|         0|            0|            0|  0.00%|    if m is nomask:
  6877|         0|            0|            0|  0.00%|        d = umath.left_shift(filled(a), n)
  6878|         0|            0|            0|  0.00%|        return masked_array(d)
  6879|         0|            0|            0|  0.00%|    else:
  6880|         0|            0|            0|  0.00%|        d = umath.left_shift(filled(a, 0), n)
  6881|         0|            0|            0|  0.00%|        return masked_array(d, mask=m)
  6882|         0|            0|            0|  0.00%|
  6883|         0|            0|            0|  0.00%|
  6884|         0|            0|            0|  0.00%|def right_shift(a, n):
  6885|         0|            0|            0|  0.00%|    """
  6886|         0|            0|            0|  0.00%|    Shift the bits of an integer to the right.
  6887|         0|            0|            0|  0.00%|
  6888|         0|            0|            0|  0.00%|    This is the masked array version of `numpy.right_shift`, for details
  6889|         0|            0|            0|  0.00%|    see that function.
  6890|         0|            0|            0|  0.00%|
  6891|         0|            0|            0|  0.00%|    See Also
  6892|         0|            0|            0|  0.00%|    --------
  6893|         0|            0|            0|  0.00%|    numpy.right_shift
  6894|         0|            0|            0|  0.00%|
  6895|         0|            0|            0|  0.00%|    """
  6896|         0|            0|            0|  0.00%|    m = getmask(a)
  6897|         0|            0|            0|  0.00%|    if m is nomask:
  6898|         0|            0|            0|  0.00%|        d = umath.right_shift(filled(a), n)
  6899|         0|            0|            0|  0.00%|        return masked_array(d)
  6900|         0|            0|            0|  0.00%|    else:
  6901|         0|            0|            0|  0.00%|        d = umath.right_shift(filled(a, 0), n)
  6902|         0|            0|            0|  0.00%|        return masked_array(d, mask=m)
  6903|         0|            0|            0|  0.00%|
  6904|         0|            0|            0|  0.00%|
  6905|         0|            0|            0|  0.00%|def put(a, indices, values, mode='raise'):
  6906|         0|            0|            0|  0.00%|    """
  6907|         0|            0|            0|  0.00%|    Set storage-indexed locations to corresponding values.
  6908|         0|            0|            0|  0.00%|
  6909|         0|            0|            0|  0.00%|    This function is equivalent to `MaskedArray.put`, see that method
  6910|         0|            0|            0|  0.00%|    for details.
  6911|         0|            0|            0|  0.00%|
  6912|         0|            0|            0|  0.00%|    See Also
  6913|         0|            0|            0|  0.00%|    --------
  6914|         0|            0|            0|  0.00%|    MaskedArray.put
  6915|         0|            0|            0|  0.00%|
  6916|         0|            0|            0|  0.00%|    """
  6917|         0|            0|            0|  0.00%|    # We can't use 'frommethod', the order of arguments is different
  6918|         0|            0|            0|  0.00%|    try:
  6919|         0|            0|            0|  0.00%|        return a.put(indices, values, mode=mode)
  6920|         0|            0|            0|  0.00%|    except AttributeError:
  6921|         0|            0|            0|  0.00%|        return narray(a, copy=False).put(indices, values, mode=mode)
  6922|         0|            0|            0|  0.00%|
  6923|         0|            0|            0|  0.00%|
  6924|         0|            0|            0|  0.00%|def putmask(a, mask, values):  # , mode='raise'):
  6925|         0|            0|            0|  0.00%|    """
  6926|         0|            0|            0|  0.00%|    Changes elements of an array based on conditional and input values.
  6927|         0|            0|            0|  0.00%|
  6928|         0|            0|            0|  0.00%|    This is the masked array version of `numpy.putmask`, for details see
  6929|         0|            0|            0|  0.00%|    `numpy.putmask`.
  6930|         0|            0|            0|  0.00%|
  6931|         0|            0|            0|  0.00%|    See Also
  6932|         0|            0|            0|  0.00%|    --------
  6933|         0|            0|            0|  0.00%|    numpy.putmask
  6934|         0|            0|            0|  0.00%|
  6935|         0|            0|            0|  0.00%|    Notes
  6936|         0|            0|            0|  0.00%|    -----
  6937|         0|            0|            0|  0.00%|    Using a masked array as `values` will **not** transform a `ndarray` into
  6938|         0|            0|            0|  0.00%|    a `MaskedArray`.
  6939|         0|            0|            0|  0.00%|
  6940|         0|            0|            0|  0.00%|    """
  6941|         0|            0|            0|  0.00%|    # We can't use 'frommethod', the order of arguments is different
  6942|         0|            0|            0|  0.00%|    if not isinstance(a, MaskedArray):
  6943|         0|            0|            0|  0.00%|        a = a.view(MaskedArray)
  6944|         0|            0|            0|  0.00%|    (valdata, valmask) = (getdata(values), getmask(values))
  6945|         0|            0|            0|  0.00%|    if getmask(a) is nomask:
  6946|         0|            0|            0|  0.00%|        if valmask is not nomask:
  6947|         0|            0|            0|  0.00%|            a._sharedmask = True
  6948|         0|            0|            0|  0.00%|            a._mask = make_mask_none(a.shape, a.dtype)
  6949|         0|            0|            0|  0.00%|            np.copyto(a._mask, valmask, where=mask)
  6950|         0|            0|            0|  0.00%|    elif a._hardmask:
  6951|         0|            0|            0|  0.00%|        if valmask is not nomask:
  6952|         0|            0|            0|  0.00%|            m = a._mask.copy()
  6953|         0|            0|            0|  0.00%|            np.copyto(m, valmask, where=mask)
  6954|         0|            0|            0|  0.00%|            a.mask |= m
  6955|         0|            0|            0|  0.00%|    else:
  6956|         0|            0|            0|  0.00%|        if valmask is nomask:
  6957|         0|            0|            0|  0.00%|            valmask = getmaskarray(values)
  6958|         0|            0|            0|  0.00%|        np.copyto(a._mask, valmask, where=mask)
  6959|         0|            0|            0|  0.00%|    np.copyto(a._data, valdata, where=mask)
  6960|         0|            0|            0|  0.00%|    return
  6961|         0|            0|            0|  0.00%|
  6962|         0|            0|            0|  0.00%|
  6963|         0|            0|            0|  0.00%|def transpose(a, axes=None):
  6964|         0|            0|            0|  0.00%|    """
  6965|         0|            0|            0|  0.00%|    Permute the dimensions of an array.
  6966|         0|            0|            0|  0.00%|
  6967|         0|            0|            0|  0.00%|    This function is exactly equivalent to `numpy.transpose`.
  6968|         0|            0|            0|  0.00%|
  6969|         0|            0|            0|  0.00%|    See Also
  6970|         0|            0|            0|  0.00%|    --------
  6971|         0|            0|            0|  0.00%|    numpy.transpose : Equivalent function in top-level NumPy module.
  6972|         0|            0|            0|  0.00%|
  6973|         0|            0|            0|  0.00%|    Examples
  6974|         0|            0|            0|  0.00%|    --------
  6975|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  6976|         0|            0|            0|  0.00%|    >>> x = ma.arange(4).reshape((2,2))
  6977|         0|            0|            0|  0.00%|    >>> x[1, 1] = ma.masked
  6978|         0|            0|            0|  0.00%|    >>> x
  6979|         0|            0|            0|  0.00%|    masked_array(
  6980|         0|            0|            0|  0.00%|      data=[[0, 1],
  6981|         0|            0|            0|  0.00%|            [2, --]],
  6982|         0|            0|            0|  0.00%|      mask=[[False, False],
  6983|         0|            0|            0|  0.00%|            [False,  True]],
  6984|         0|            0|            0|  0.00%|      fill_value=999999)
  6985|         0|            0|            0|  0.00%|
  6986|         0|            0|            0|  0.00%|    >>> ma.transpose(x)
  6987|         0|            0|            0|  0.00%|    masked_array(
  6988|         0|            0|            0|  0.00%|      data=[[0, 2],
  6989|         0|            0|            0|  0.00%|            [1, --]],
  6990|         0|            0|            0|  0.00%|      mask=[[False, False],
  6991|         0|            0|            0|  0.00%|            [False,  True]],
  6992|         0|            0|            0|  0.00%|      fill_value=999999)
  6993|         0|            0|            0|  0.00%|    """
  6994|         0|            0|            0|  0.00%|    # We can't use 'frommethod', as 'transpose' doesn't take keywords
  6995|         0|            0|            0|  0.00%|    try:
  6996|         0|            0|            0|  0.00%|        return a.transpose(axes)
  6997|         0|            0|            0|  0.00%|    except AttributeError:
  6998|         0|            0|            0|  0.00%|        return narray(a, copy=False).transpose(axes).view(MaskedArray)
  6999|         0|            0|            0|  0.00%|
  7000|         0|            0|            0|  0.00%|
  7001|         0|            0|            0|  0.00%|def reshape(a, new_shape, order='C'):
  7002|         0|            0|            0|  0.00%|    """
  7003|         0|            0|            0|  0.00%|    Returns an array containing the same data with a new shape.
  7004|         0|            0|            0|  0.00%|
  7005|         0|            0|            0|  0.00%|    Refer to `MaskedArray.reshape` for full documentation.
  7006|         0|            0|            0|  0.00%|
  7007|         0|            0|            0|  0.00%|    See Also
  7008|         0|            0|            0|  0.00%|    --------
  7009|         0|            0|            0|  0.00%|    MaskedArray.reshape : equivalent function
  7010|         0|            0|            0|  0.00%|
  7011|         0|            0|            0|  0.00%|    """
  7012|         0|            0|            0|  0.00%|    # We can't use 'frommethod', it whine about some parameters. Dmmit.
  7013|         0|            0|            0|  0.00%|    try:
  7014|         0|            0|            0|  0.00%|        return a.reshape(new_shape, order=order)
  7015|         0|            0|            0|  0.00%|    except AttributeError:
  7016|         0|            0|            0|  0.00%|        _tmp = narray(a, copy=False).reshape(new_shape, order=order)
  7017|         0|            0|            0|  0.00%|        return _tmp.view(MaskedArray)
  7018|         0|            0|            0|  0.00%|
  7019|         0|            0|            0|  0.00%|
  7020|         0|            0|            0|  0.00%|def resize(x, new_shape):
  7021|         0|            0|            0|  0.00%|    """
  7022|         0|            0|            0|  0.00%|    Return a new masked array with the specified size and shape.
  7023|         0|            0|            0|  0.00%|
  7024|         0|            0|            0|  0.00%|    This is the masked equivalent of the `numpy.resize` function. The new
  7025|         0|            0|            0|  0.00%|    array is filled with repeated copies of `x` (in the order that the
  7026|         0|            0|            0|  0.00%|    data are stored in memory). If `x` is masked, the new array will be
  7027|         0|            0|            0|  0.00%|    masked, and the new mask will be a repetition of the old one.
  7028|         0|            0|            0|  0.00%|
  7029|         0|            0|            0|  0.00%|    See Also
  7030|         0|            0|            0|  0.00%|    --------
  7031|         0|            0|            0|  0.00%|    numpy.resize : Equivalent function in the top level NumPy module.
  7032|         0|            0|            0|  0.00%|
  7033|         0|            0|            0|  0.00%|    Examples
  7034|         0|            0|            0|  0.00%|    --------
  7035|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  7036|         0|            0|            0|  0.00%|    >>> a = ma.array([[1, 2] ,[3, 4]])
  7037|         0|            0|            0|  0.00%|    >>> a[0, 1] = ma.masked
  7038|         0|            0|            0|  0.00%|    >>> a
  7039|         0|            0|            0|  0.00%|    masked_array(
  7040|         0|            0|            0|  0.00%|      data=[[1, --],
  7041|         0|            0|            0|  0.00%|            [3, 4]],
  7042|         0|            0|            0|  0.00%|      mask=[[False,  True],
  7043|         0|            0|            0|  0.00%|            [False, False]],
  7044|         0|            0|            0|  0.00%|      fill_value=999999)
  7045|         0|            0|            0|  0.00%|    >>> np.resize(a, (3, 3))
  7046|         0|            0|            0|  0.00%|    masked_array(
  7047|         0|            0|            0|  0.00%|      data=[[1, 2, 3],
  7048|         0|            0|            0|  0.00%|            [4, 1, 2],
  7049|         0|            0|            0|  0.00%|            [3, 4, 1]],
  7050|         0|            0|            0|  0.00%|      mask=False,
  7051|         0|            0|            0|  0.00%|      fill_value=999999)
  7052|         0|            0|            0|  0.00%|    >>> ma.resize(a, (3, 3))
  7053|         0|            0|            0|  0.00%|    masked_array(
  7054|         0|            0|            0|  0.00%|      data=[[1, --, 3],
  7055|         0|            0|            0|  0.00%|            [4, 1, --],
  7056|         0|            0|            0|  0.00%|            [3, 4, 1]],
  7057|         0|            0|            0|  0.00%|      mask=[[False,  True, False],
  7058|         0|            0|            0|  0.00%|            [False, False,  True],
  7059|         0|            0|            0|  0.00%|            [False, False, False]],
  7060|         0|            0|            0|  0.00%|      fill_value=999999)
  7061|         0|            0|            0|  0.00%|
  7062|         0|            0|            0|  0.00%|    A MaskedArray is always returned, regardless of the input type.
  7063|         0|            0|            0|  0.00%|
  7064|         0|            0|            0|  0.00%|    >>> a = np.array([[1, 2] ,[3, 4]])
  7065|         0|            0|            0|  0.00%|    >>> ma.resize(a, (3, 3))
  7066|         0|            0|            0|  0.00%|    masked_array(
  7067|         0|            0|            0|  0.00%|      data=[[1, 2, 3],
  7068|         0|            0|            0|  0.00%|            [4, 1, 2],
  7069|         0|            0|            0|  0.00%|            [3, 4, 1]],
  7070|         0|            0|            0|  0.00%|      mask=False,
  7071|         0|            0|            0|  0.00%|      fill_value=999999)
  7072|         0|            0|            0|  0.00%|
  7073|         0|            0|            0|  0.00%|    """
  7074|         0|            0|            0|  0.00%|    # We can't use _frommethods here, as N.resize is notoriously whiny.
  7075|         0|            0|            0|  0.00%|    m = getmask(x)
  7076|         0|            0|            0|  0.00%|    if m is not nomask:
  7077|         0|            0|            0|  0.00%|        m = np.resize(m, new_shape)
  7078|         0|            0|            0|  0.00%|    result = np.resize(x, new_shape).view(get_masked_subclass(x))
  7079|         0|            0|            0|  0.00%|    if result.ndim:
  7080|         0|            0|            0|  0.00%|        result._mask = m
  7081|         0|            0|            0|  0.00%|    return result
  7082|         0|            0|            0|  0.00%|
  7083|         0|            0|            0|  0.00%|
  7084|         0|            0|            0|  0.00%|def rank(obj):
  7085|         0|            0|            0|  0.00%|    """
  7086|         0|            0|            0|  0.00%|    maskedarray version of the numpy function.
  7087|         0|            0|            0|  0.00%|
  7088|         0|            0|            0|  0.00%|    .. note::
  7089|         0|            0|            0|  0.00%|        Deprecated since 1.10.0
  7090|         0|            0|            0|  0.00%|
  7091|         0|            0|            0|  0.00%|    """
  7092|         0|            0|            0|  0.00%|    # 2015-04-12, 1.10.0
  7093|         0|            0|            0|  0.00%|    warnings.warn(
  7094|         0|            0|            0|  0.00%|        "`rank` is deprecated; use the `ndim` function instead. ",
  7095|         0|            0|            0|  0.00%|        np.VisibleDeprecationWarning, stacklevel=2)
  7096|         0|            0|            0|  0.00%|    return np.ndim(getdata(obj))
  7097|         0|            0|            0|  0.00%|
  7098|         0|            0|            0|  0.00%|rank.__doc__ = np.rank.__doc__
  7099|         0|            0|            0|  0.00%|
  7100|         0|            0|            0|  0.00%|
  7101|         0|            0|            0|  0.00%|def ndim(obj):
  7102|         0|            0|            0|  0.00%|    """
  7103|         0|            0|            0|  0.00%|    maskedarray version of the numpy function.
  7104|         0|            0|            0|  0.00%|
  7105|         0|            0|            0|  0.00%|    """
  7106|         0|            0|            0|  0.00%|    return np.ndim(getdata(obj))
  7107|         0|            0|            0|  0.00%|
  7108|         0|            0|            0|  0.00%|ndim.__doc__ = np.ndim.__doc__
  7109|         0|            0|            0|  0.00%|
  7110|         0|            0|            0|  0.00%|
  7111|         0|            0|            0|  0.00%|def shape(obj):
  7112|         0|            0|            0|  0.00%|    "maskedarray version of the numpy function."
  7113|         0|            0|            0|  0.00%|    return np.shape(getdata(obj))
  7114|         0|            0|            0|  0.00%|shape.__doc__ = np.shape.__doc__
  7115|         0|            0|            0|  0.00%|
  7116|         0|            0|            0|  0.00%|
  7117|         0|            0|            0|  0.00%|def size(obj, axis=None):
  7118|         0|            0|            0|  0.00%|    "maskedarray version of the numpy function."
  7119|         0|            0|            0|  0.00%|    return np.size(getdata(obj), axis)
  7120|         0|            0|            0|  0.00%|size.__doc__ = np.size.__doc__
  7121|         0|            0|            0|  0.00%|
  7122|         0|            0|            0|  0.00%|
  7123|         0|            0|            0|  0.00%|##############################################################################
  7124|         0|            0|            0|  0.00%|#                            Extra functions                                 #
  7125|         0|            0|            0|  0.00%|##############################################################################
  7126|         0|            0|            0|  0.00%|
  7127|         0|            0|            0|  0.00%|
  7128|         0|            0|            0|  0.00%|def where(condition, x=_NoValue, y=_NoValue):
  7129|         0|            0|            0|  0.00%|    """
  7130|         0|            0|            0|  0.00%|    Return a masked array with elements from `x` or `y`, depending on condition.
  7131|         0|            0|            0|  0.00%|
  7132|         0|            0|            0|  0.00%|    .. note::
  7133|         0|            0|            0|  0.00%|        When only `condition` is provided, this function is identical to
  7134|         0|            0|            0|  0.00%|        `nonzero`. The rest of this documentation covers only the case where
  7135|         0|            0|            0|  0.00%|        all three arguments are provided.
  7136|         0|            0|            0|  0.00%|
  7137|         0|            0|            0|  0.00%|    Parameters
  7138|         0|            0|            0|  0.00%|    ----------
  7139|         0|            0|            0|  0.00%|    condition : array_like, bool
  7140|         0|            0|            0|  0.00%|        Where True, yield `x`, otherwise yield `y`.
  7141|         0|            0|            0|  0.00%|    x, y : array_like, optional
  7142|         0|            0|            0|  0.00%|        Values from which to choose. `x`, `y` and `condition` need to be
  7143|         0|            0|            0|  0.00%|        broadcastable to some shape.
  7144|         0|            0|            0|  0.00%|
  7145|         0|            0|            0|  0.00%|    Returns
  7146|         0|            0|            0|  0.00%|    -------
  7147|         0|            0|            0|  0.00%|    out : MaskedArray
  7148|         0|            0|            0|  0.00%|        An masked array with `masked` elements where the condition is masked,
  7149|         0|            0|            0|  0.00%|        elements from `x` where `condition` is True, and elements from `y`
  7150|         0|            0|            0|  0.00%|        elsewhere.
  7151|         0|            0|            0|  0.00%|
  7152|         0|            0|            0|  0.00%|    See Also
  7153|         0|            0|            0|  0.00%|    --------
  7154|         0|            0|            0|  0.00%|    numpy.where : Equivalent function in the top-level NumPy module.
  7155|         0|            0|            0|  0.00%|    nonzero : The function that is called when x and y are omitted
  7156|         0|            0|            0|  0.00%|
  7157|         0|            0|            0|  0.00%|    Examples
  7158|         0|            0|            0|  0.00%|    --------
  7159|         0|            0|            0|  0.00%|    >>> x = np.ma.array(np.arange(9.).reshape(3, 3), mask=[[0, 1, 0],
  7160|         0|            0|            0|  0.00%|    ...                                                    [1, 0, 1],
  7161|         0|            0|            0|  0.00%|    ...                                                    [0, 1, 0]])
  7162|         0|            0|            0|  0.00%|    >>> x
  7163|         0|            0|            0|  0.00%|    masked_array(
  7164|         0|            0|            0|  0.00%|      data=[[0.0, --, 2.0],
  7165|         0|            0|            0|  0.00%|            [--, 4.0, --],
  7166|         0|            0|            0|  0.00%|            [6.0, --, 8.0]],
  7167|         0|            0|            0|  0.00%|      mask=[[False,  True, False],
  7168|         0|            0|            0|  0.00%|            [ True, False,  True],
  7169|         0|            0|            0|  0.00%|            [False,  True, False]],
  7170|         0|            0|            0|  0.00%|      fill_value=1e+20)
  7171|         0|            0|            0|  0.00%|    >>> np.ma.where(x > 5, x, -3.1416)
  7172|         0|            0|            0|  0.00%|    masked_array(
  7173|         0|            0|            0|  0.00%|      data=[[-3.1416, --, -3.1416],
  7174|         0|            0|            0|  0.00%|            [--, -3.1416, --],
  7175|         0|            0|            0|  0.00%|            [6.0, --, 8.0]],
  7176|         0|            0|            0|  0.00%|      mask=[[False,  True, False],
  7177|         0|            0|            0|  0.00%|            [ True, False,  True],
  7178|         0|            0|            0|  0.00%|            [False,  True, False]],
  7179|         0|            0|            0|  0.00%|      fill_value=1e+20)
  7180|         0|            0|            0|  0.00%|
  7181|         0|            0|            0|  0.00%|    """
  7182|         0|            0|            0|  0.00%|
  7183|         0|            0|            0|  0.00%|    # handle the single-argument case
  7184|         0|            0|            0|  0.00%|    missing = (x is _NoValue, y is _NoValue).count(True)
  7185|         0|            0|            0|  0.00%|    if missing == 1:
  7186|         0|            0|            0|  0.00%|        raise ValueError("Must provide both 'x' and 'y' or neither.")
  7187|         0|            0|            0|  0.00%|    if missing == 2:
  7188|         0|            0|            0|  0.00%|        return nonzero(condition)
  7189|         0|            0|            0|  0.00%|
  7190|         0|            0|            0|  0.00%|    # we only care if the condition is true - false or masked pick y
  7191|         0|            0|            0|  0.00%|    cf = filled(condition, False)
  7192|         0|            0|            0|  0.00%|    xd = getdata(x)
  7193|         0|            0|            0|  0.00%|    yd = getdata(y)
  7194|         0|            0|            0|  0.00%|
  7195|         0|            0|            0|  0.00%|    # we need the full arrays here for correct final dimensions
  7196|         0|            0|            0|  0.00%|    cm = getmaskarray(condition)
  7197|         0|            0|            0|  0.00%|    xm = getmaskarray(x)
  7198|         0|            0|            0|  0.00%|    ym = getmaskarray(y)
  7199|         0|            0|            0|  0.00%|
  7200|         0|            0|            0|  0.00%|    # deal with the fact that masked.dtype == float64, but we don't actually
  7201|         0|            0|            0|  0.00%|    # want to treat it as that.
  7202|         0|            0|            0|  0.00%|    if x is masked and y is not masked:
  7203|         0|            0|            0|  0.00%|        xd = np.zeros((), dtype=yd.dtype)
  7204|         0|            0|            0|  0.00%|        xm = np.ones((),  dtype=ym.dtype)
  7205|         0|            0|            0|  0.00%|    elif y is masked and x is not masked:
  7206|         0|            0|            0|  0.00%|        yd = np.zeros((), dtype=xd.dtype)
  7207|         0|            0|            0|  0.00%|        ym = np.ones((),  dtype=xm.dtype)
  7208|         0|            0|            0|  0.00%|
  7209|         0|            0|            0|  0.00%|    data = np.where(cf, xd, yd)
  7210|         0|            0|            0|  0.00%|    mask = np.where(cf, xm, ym)
  7211|         0|            0|            0|  0.00%|    mask = np.where(cm, np.ones((), dtype=mask.dtype), mask)
  7212|         0|            0|            0|  0.00%|
  7213|         0|            0|            0|  0.00%|    # collapse the mask, for backwards compatibility
  7214|         0|            0|            0|  0.00%|    mask = _shrink_mask(mask)
  7215|         0|            0|            0|  0.00%|
  7216|         0|            0|            0|  0.00%|    return masked_array(data, mask=mask)
  7217|         0|            0|            0|  0.00%|
  7218|         0|            0|            0|  0.00%|
  7219|         0|            0|            0|  0.00%|def choose(indices, choices, out=None, mode='raise'):
  7220|         0|            0|            0|  0.00%|    """
  7221|         0|            0|            0|  0.00%|    Use an index array to construct a new array from a set of choices.
  7222|         0|            0|            0|  0.00%|
  7223|         0|            0|            0|  0.00%|    Given an array of integers and a set of n choice arrays, this method
  7224|         0|            0|            0|  0.00%|    will create a new array that merges each of the choice arrays.  Where a
  7225|         0|            0|            0|  0.00%|    value in `a` is i, the new array will have the value that choices[i]
  7226|         0|            0|            0|  0.00%|    contains in the same place.
  7227|         0|            0|            0|  0.00%|
  7228|         0|            0|            0|  0.00%|    Parameters
  7229|         0|            0|            0|  0.00%|    ----------
  7230|         0|            0|            0|  0.00%|    a : ndarray of ints
  7231|         0|            0|            0|  0.00%|        This array must contain integers in ``[0, n-1]``, where n is the
  7232|         0|            0|            0|  0.00%|        number of choices.
  7233|         0|            0|            0|  0.00%|    choices : sequence of arrays
  7234|         0|            0|            0|  0.00%|        Choice arrays. The index array and all of the choices should be
  7235|         0|            0|            0|  0.00%|        broadcastable to the same shape.
  7236|         0|            0|            0|  0.00%|    out : array, optional
  7237|         0|            0|            0|  0.00%|        If provided, the result will be inserted into this array. It should
  7238|         0|            0|            0|  0.00%|        be of the appropriate shape and `dtype`.
  7239|         0|            0|            0|  0.00%|    mode : {'raise', 'wrap', 'clip'}, optional
  7240|         0|            0|            0|  0.00%|        Specifies how out-of-bounds indices will behave.
  7241|         0|            0|            0|  0.00%|
  7242|         0|            0|            0|  0.00%|        * 'raise' : raise an error
  7243|         0|            0|            0|  0.00%|        * 'wrap' : wrap around
  7244|         0|            0|            0|  0.00%|        * 'clip' : clip to the range
  7245|         0|            0|            0|  0.00%|
  7246|         0|            0|            0|  0.00%|    Returns
  7247|         0|            0|            0|  0.00%|    -------
  7248|         0|            0|            0|  0.00%|    merged_array : array
  7249|         0|            0|            0|  0.00%|
  7250|         0|            0|            0|  0.00%|    See Also
  7251|         0|            0|            0|  0.00%|    --------
  7252|         0|            0|            0|  0.00%|    choose : equivalent function
  7253|         0|            0|            0|  0.00%|
  7254|         0|            0|            0|  0.00%|    Examples
  7255|         0|            0|            0|  0.00%|    --------
  7256|         0|            0|            0|  0.00%|    >>> choice = np.array([[1,1,1], [2,2,2], [3,3,3]])
  7257|         0|            0|            0|  0.00%|    >>> a = np.array([2, 1, 0])
  7258|         0|            0|            0|  0.00%|    >>> np.ma.choose(a, choice)
  7259|         0|            0|            0|  0.00%|    masked_array(data=[3, 2, 1],
  7260|         0|            0|            0|  0.00%|                 mask=False,
  7261|         0|            0|            0|  0.00%|           fill_value=999999)
  7262|         0|            0|            0|  0.00%|
  7263|         0|            0|            0|  0.00%|    """
  7264|         0|            0|            0|  0.00%|    def fmask(x):
  7265|         0|            0|            0|  0.00%|        "Returns the filled array, or True if masked."
  7266|         0|            0|            0|  0.00%|        if x is masked:
  7267|         0|            0|            0|  0.00%|            return True
  7268|         0|            0|            0|  0.00%|        return filled(x)
  7269|         0|            0|            0|  0.00%|
  7270|         0|            0|            0|  0.00%|    def nmask(x):
  7271|         0|            0|            0|  0.00%|        "Returns the mask, True if ``masked``, False if ``nomask``."
  7272|         0|            0|            0|  0.00%|        if x is masked:
  7273|         0|            0|            0|  0.00%|            return True
  7274|         0|            0|            0|  0.00%|        return getmask(x)
  7275|         0|            0|            0|  0.00%|    # Get the indices.
  7276|         0|            0|            0|  0.00%|    c = filled(indices, 0)
  7277|         0|            0|            0|  0.00%|    # Get the masks.
  7278|         0|            0|            0|  0.00%|    masks = [nmask(x) for x in choices]
  7279|         0|            0|            0|  0.00%|    data = [fmask(x) for x in choices]
  7280|         0|            0|            0|  0.00%|    # Construct the mask
  7281|         0|            0|            0|  0.00%|    outputmask = np.choose(c, masks, mode=mode)
  7282|         0|            0|            0|  0.00%|    outputmask = make_mask(mask_or(outputmask, getmask(indices)),
  7283|         0|            0|            0|  0.00%|                           copy=0, shrink=True)
  7284|         0|            0|            0|  0.00%|    # Get the choices.
  7285|         0|            0|            0|  0.00%|    d = np.choose(c, data, mode=mode, out=out).view(MaskedArray)
  7286|         0|            0|            0|  0.00%|    if out is not None:
  7287|         0|            0|            0|  0.00%|        if isinstance(out, MaskedArray):
  7288|         0|            0|            0|  0.00%|            out.__setmask__(outputmask)
  7289|         0|            0|            0|  0.00%|        return out
  7290|         0|            0|            0|  0.00%|    d.__setmask__(outputmask)
  7291|         0|            0|            0|  0.00%|    return d
  7292|         0|            0|            0|  0.00%|
  7293|         0|            0|            0|  0.00%|
  7294|         0|            0|            0|  0.00%|def round_(a, decimals=0, out=None):
  7295|         0|            0|            0|  0.00%|    """
  7296|         0|            0|            0|  0.00%|    Return a copy of a, rounded to 'decimals' places.
  7297|         0|            0|            0|  0.00%|
  7298|         0|            0|            0|  0.00%|    When 'decimals' is negative, it specifies the number of positions
  7299|         0|            0|            0|  0.00%|    to the left of the decimal point.  The real and imaginary parts of
  7300|         0|            0|            0|  0.00%|    complex numbers are rounded separately. Nothing is done if the
  7301|         0|            0|            0|  0.00%|    array is not of float type and 'decimals' is greater than or equal
  7302|         0|            0|            0|  0.00%|    to 0.
  7303|         0|            0|            0|  0.00%|
  7304|         0|            0|            0|  0.00%|    Parameters
  7305|         0|            0|            0|  0.00%|    ----------
  7306|         0|            0|            0|  0.00%|    decimals : int
  7307|         0|            0|            0|  0.00%|        Number of decimals to round to. May be negative.
  7308|         0|            0|            0|  0.00%|    out : array_like
  7309|         0|            0|            0|  0.00%|        Existing array to use for output.
  7310|         0|            0|            0|  0.00%|        If not given, returns a default copy of a.
  7311|         0|            0|            0|  0.00%|
  7312|         0|            0|            0|  0.00%|    Notes
  7313|         0|            0|            0|  0.00%|    -----
  7314|         0|            0|            0|  0.00%|    If out is given and does not have a mask attribute, the mask of a
  7315|         0|            0|            0|  0.00%|    is lost!
  7316|         0|            0|            0|  0.00%|
  7317|         0|            0|            0|  0.00%|    """
  7318|         0|            0|            0|  0.00%|    if out is None:
  7319|         0|            0|            0|  0.00%|        return np.round_(a, decimals, out)
  7320|         0|            0|            0|  0.00%|    else:
  7321|         0|            0|            0|  0.00%|        np.round_(getdata(a), decimals, out)
  7322|         0|            0|            0|  0.00%|        if hasattr(out, '_mask'):
  7323|         0|            0|            0|  0.00%|            out._mask = getmask(a)
  7324|         0|            0|            0|  0.00%|        return out
  7325|         0|            0|            0|  0.00%|round = round_
  7326|         0|            0|            0|  0.00%|
  7327|         0|            0|            0|  0.00%|
  7328|         0|            0|            0|  0.00%|# Needed by dot, so move here from extras.py. It will still be exported
  7329|         0|            0|            0|  0.00%|# from extras.py for compatibility.
  7330|         0|            0|            0|  0.00%|def mask_rowcols(a, axis=None):
  7331|         0|            0|            0|  0.00%|    """
  7332|         0|            0|            0|  0.00%|    Mask rows and/or columns of a 2D array that contain masked values.
  7333|         0|            0|            0|  0.00%|
  7334|         0|            0|            0|  0.00%|    Mask whole rows and/or columns of a 2D array that contain
  7335|         0|            0|            0|  0.00%|    masked values.  The masking behavior is selected using the
  7336|         0|            0|            0|  0.00%|    `axis` parameter.
  7337|         0|            0|            0|  0.00%|
  7338|         0|            0|            0|  0.00%|      - If `axis` is None, rows *and* columns are masked.
  7339|         0|            0|            0|  0.00%|      - If `axis` is 0, only rows are masked.
  7340|         0|            0|            0|  0.00%|      - If `axis` is 1 or -1, only columns are masked.
  7341|         0|            0|            0|  0.00%|
  7342|         0|            0|            0|  0.00%|    Parameters
  7343|         0|            0|            0|  0.00%|    ----------
  7344|         0|            0|            0|  0.00%|    a : array_like, MaskedArray
  7345|         0|            0|            0|  0.00%|        The array to mask.  If not a MaskedArray instance (or if no array
  7346|         0|            0|            0|  0.00%|        elements are masked).  The result is a MaskedArray with `mask` set
  7347|         0|            0|            0|  0.00%|        to `nomask` (False). Must be a 2D array.
  7348|         0|            0|            0|  0.00%|    axis : int, optional
  7349|         0|            0|            0|  0.00%|        Axis along which to perform the operation. If None, applies to a
  7350|         0|            0|            0|  0.00%|        flattened version of the array.
  7351|         0|            0|            0|  0.00%|
  7352|         0|            0|            0|  0.00%|    Returns
  7353|         0|            0|            0|  0.00%|    -------
  7354|         0|            0|            0|  0.00%|    a : MaskedArray
  7355|         0|            0|            0|  0.00%|        A modified version of the input array, masked depending on the value
  7356|         0|            0|            0|  0.00%|        of the `axis` parameter.
  7357|         0|            0|            0|  0.00%|
  7358|         0|            0|            0|  0.00%|    Raises
  7359|         0|            0|            0|  0.00%|    ------
  7360|         0|            0|            0|  0.00%|    NotImplementedError
  7361|         0|            0|            0|  0.00%|        If input array `a` is not 2D.
  7362|         0|            0|            0|  0.00%|
  7363|         0|            0|            0|  0.00%|    See Also
  7364|         0|            0|            0|  0.00%|    --------
  7365|         0|            0|            0|  0.00%|    mask_rows : Mask rows of a 2D array that contain masked values.
  7366|         0|            0|            0|  0.00%|    mask_cols : Mask cols of a 2D array that contain masked values.
  7367|         0|            0|            0|  0.00%|    masked_where : Mask where a condition is met.
  7368|         0|            0|            0|  0.00%|
  7369|         0|            0|            0|  0.00%|    Notes
  7370|         0|            0|            0|  0.00%|    -----
  7371|         0|            0|            0|  0.00%|    The input array's mask is modified by this function.
  7372|         0|            0|            0|  0.00%|
  7373|         0|            0|            0|  0.00%|    Examples
  7374|         0|            0|            0|  0.00%|    --------
  7375|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  7376|         0|            0|            0|  0.00%|    >>> a = np.zeros((3, 3), dtype=int)
  7377|         0|            0|            0|  0.00%|    >>> a[1, 1] = 1
  7378|         0|            0|            0|  0.00%|    >>> a
  7379|         0|            0|            0|  0.00%|    array([[0, 0, 0],
  7380|         0|            0|            0|  0.00%|           [0, 1, 0],
  7381|         0|            0|            0|  0.00%|           [0, 0, 0]])
  7382|         0|            0|            0|  0.00%|    >>> a = ma.masked_equal(a, 1)
  7383|         0|            0|            0|  0.00%|    >>> a
  7384|         0|            0|            0|  0.00%|    masked_array(
  7385|         0|            0|            0|  0.00%|      data=[[0, 0, 0],
  7386|         0|            0|            0|  0.00%|            [0, --, 0],
  7387|         0|            0|            0|  0.00%|            [0, 0, 0]],
  7388|         0|            0|            0|  0.00%|      mask=[[False, False, False],
  7389|         0|            0|            0|  0.00%|            [False,  True, False],
  7390|         0|            0|            0|  0.00%|            [False, False, False]],
  7391|         0|            0|            0|  0.00%|      fill_value=1)
  7392|         0|            0|            0|  0.00%|    >>> ma.mask_rowcols(a)
  7393|         0|            0|            0|  0.00%|    masked_array(
  7394|         0|            0|            0|  0.00%|      data=[[0, --, 0],
  7395|         0|            0|            0|  0.00%|            [--, --, --],
  7396|         0|            0|            0|  0.00%|            [0, --, 0]],
  7397|         0|            0|            0|  0.00%|      mask=[[False,  True, False],
  7398|         0|            0|            0|  0.00%|            [ True,  True,  True],
  7399|         0|            0|            0|  0.00%|            [False,  True, False]],
  7400|         0|            0|            0|  0.00%|      fill_value=1)
  7401|         0|            0|            0|  0.00%|
  7402|         0|            0|            0|  0.00%|    """
  7403|         0|            0|            0|  0.00%|    a = array(a, subok=False)
  7404|         0|            0|            0|  0.00%|    if a.ndim != 2:
  7405|         0|            0|            0|  0.00%|        raise NotImplementedError("mask_rowcols works for 2D arrays only.")
  7406|         0|            0|            0|  0.00%|    m = getmask(a)
  7407|         0|            0|            0|  0.00%|    # Nothing is masked: return a
  7408|         0|            0|            0|  0.00%|    if m is nomask or not m.any():
  7409|         0|            0|            0|  0.00%|        return a
  7410|         0|            0|            0|  0.00%|    maskedval = m.nonzero()
  7411|         0|            0|            0|  0.00%|    a._mask = a._mask.copy()
  7412|         0|            0|            0|  0.00%|    if not axis:
  7413|         0|            0|            0|  0.00%|        a[np.unique(maskedval[0])] = masked
  7414|         0|            0|            0|  0.00%|    if axis in [None, 1, -1]:
  7415|         0|            0|            0|  0.00%|        a[:, np.unique(maskedval[1])] = masked
  7416|         0|            0|            0|  0.00%|    return a
  7417|         0|            0|            0|  0.00%|
  7418|         0|            0|            0|  0.00%|
  7419|         0|            0|            0|  0.00%|# Include masked dot here to avoid import problems in getting it from
  7420|         0|            0|            0|  0.00%|# extras.py. Note that it is not included in __all__, but rather exported
  7421|         0|            0|            0|  0.00%|# from extras in order to avoid backward compatibility problems.
  7422|         0|            0|            0|  0.00%|def dot(a, b, strict=False, out=None):
  7423|         0|            0|            0|  0.00%|    """
  7424|         0|            0|            0|  0.00%|    Return the dot product of two arrays.
  7425|         0|            0|            0|  0.00%|
  7426|         0|            0|            0|  0.00%|    This function is the equivalent of `numpy.dot` that takes masked values
  7427|         0|            0|            0|  0.00%|    into account. Note that `strict` and `out` are in different position
  7428|         0|            0|            0|  0.00%|    than in the method version. In order to maintain compatibility with the
  7429|         0|            0|            0|  0.00%|    corresponding method, it is recommended that the optional arguments be
  7430|         0|            0|            0|  0.00%|    treated as keyword only.  At some point that may be mandatory.
  7431|         0|            0|            0|  0.00%|
  7432|         0|            0|            0|  0.00%|    .. note::
  7433|         0|            0|            0|  0.00%|      Works only with 2-D arrays at the moment.
  7434|         0|            0|            0|  0.00%|
  7435|         0|            0|            0|  0.00%|
  7436|         0|            0|            0|  0.00%|    Parameters
  7437|         0|            0|            0|  0.00%|    ----------
  7438|         0|            0|            0|  0.00%|    a, b : masked_array_like
  7439|         0|            0|            0|  0.00%|        Inputs arrays.
  7440|         0|            0|            0|  0.00%|    strict : bool, optional
  7441|         0|            0|            0|  0.00%|        Whether masked data are propagated (True) or set to 0 (False) for
  7442|         0|            0|            0|  0.00%|        the computation. Default is False.  Propagating the mask means that
  7443|         0|            0|            0|  0.00%|        if a masked value appears in a row or column, the whole row or
  7444|         0|            0|            0|  0.00%|        column is considered masked.
  7445|         0|            0|            0|  0.00%|    out : masked_array, optional
  7446|         0|            0|            0|  0.00%|        Output argument. This must have the exact kind that would be returned
  7447|         0|            0|            0|  0.00%|        if it was not used. In particular, it must have the right type, must be
  7448|         0|            0|            0|  0.00%|        C-contiguous, and its dtype must be the dtype that would be returned
  7449|         0|            0|            0|  0.00%|        for `dot(a,b)`. This is a performance feature. Therefore, if these
  7450|         0|            0|            0|  0.00%|        conditions are not met, an exception is raised, instead of attempting
  7451|         0|            0|            0|  0.00%|        to be flexible.
  7452|         0|            0|            0|  0.00%|
  7453|         0|            0|            0|  0.00%|        .. versionadded:: 1.10.2
  7454|         0|            0|            0|  0.00%|
  7455|         0|            0|            0|  0.00%|    See Also
  7456|         0|            0|            0|  0.00%|    --------
  7457|         0|            0|            0|  0.00%|    numpy.dot : Equivalent function for ndarrays.
  7458|         0|            0|            0|  0.00%|
  7459|         0|            0|            0|  0.00%|    Examples
  7460|         0|            0|            0|  0.00%|    --------
  7461|         0|            0|            0|  0.00%|    >>> a = np.ma.array([[1, 2, 3], [4, 5, 6]], mask=[[1, 0, 0], [0, 0, 0]])
  7462|         0|            0|            0|  0.00%|    >>> b = np.ma.array([[1, 2], [3, 4], [5, 6]], mask=[[1, 0], [0, 0], [0, 0]])
  7463|         0|            0|            0|  0.00%|    >>> np.ma.dot(a, b)
  7464|         0|            0|            0|  0.00%|    masked_array(
  7465|         0|            0|            0|  0.00%|      data=[[21, 26],
  7466|         0|            0|            0|  0.00%|            [45, 64]],
  7467|         0|            0|            0|  0.00%|      mask=[[False, False],
  7468|         0|            0|            0|  0.00%|            [False, False]],
  7469|         0|            0|            0|  0.00%|      fill_value=999999)
  7470|         0|            0|            0|  0.00%|    >>> np.ma.dot(a, b, strict=True)
  7471|         0|            0|            0|  0.00%|    masked_array(
  7472|         0|            0|            0|  0.00%|      data=[[--, --],
  7473|         0|            0|            0|  0.00%|            [--, 64]],
  7474|         0|            0|            0|  0.00%|      mask=[[ True,  True],
  7475|         0|            0|            0|  0.00%|            [ True, False]],
  7476|         0|            0|            0|  0.00%|      fill_value=999999)
  7477|         0|            0|            0|  0.00%|
  7478|         0|            0|            0|  0.00%|    """
  7479|         0|            0|            0|  0.00%|    # !!!: Works only with 2D arrays. There should be a way to get it to run
  7480|         0|            0|            0|  0.00%|    # with higher dimension
  7481|         0|            0|            0|  0.00%|    if strict and (a.ndim == 2) and (b.ndim == 2):
  7482|         0|            0|            0|  0.00%|        a = mask_rowcols(a, 0)
  7483|         0|            0|            0|  0.00%|        b = mask_rowcols(b, 1)
  7484|         0|            0|            0|  0.00%|    am = ~getmaskarray(a)
  7485|         0|            0|            0|  0.00%|    bm = ~getmaskarray(b)
  7486|         0|            0|            0|  0.00%|
  7487|         0|            0|            0|  0.00%|    if out is None:
  7488|         0|            0|            0|  0.00%|        d = np.dot(filled(a, 0), filled(b, 0))
  7489|         0|            0|            0|  0.00%|        m = ~np.dot(am, bm)
  7490|         0|            0|            0|  0.00%|        if d.ndim == 0:
  7491|         0|            0|            0|  0.00%|            d = np.asarray(d)
  7492|         0|            0|            0|  0.00%|        r = d.view(get_masked_subclass(a, b))
  7493|         0|            0|            0|  0.00%|        r.__setmask__(m)
  7494|         0|            0|            0|  0.00%|        return r
  7495|         0|            0|            0|  0.00%|    else:
  7496|         0|            0|            0|  0.00%|        d = np.dot(filled(a, 0), filled(b, 0), out._data)
  7497|         0|            0|            0|  0.00%|        if out.mask.shape != d.shape:
  7498|         0|            0|            0|  0.00%|            out._mask = np.empty(d.shape, MaskType)
  7499|         0|            0|            0|  0.00%|        np.dot(am, bm, out._mask)
  7500|         0|            0|            0|  0.00%|        np.logical_not(out._mask, out._mask)
  7501|         0|            0|            0|  0.00%|        return out
  7502|         0|            0|            0|  0.00%|
  7503|         0|            0|            0|  0.00%|
  7504|         0|            0|            0|  0.00%|def inner(a, b):
  7505|         0|            0|            0|  0.00%|    """
  7506|         0|            0|            0|  0.00%|    Returns the inner product of a and b for arrays of floating point types.
  7507|         0|            0|            0|  0.00%|
  7508|         0|            0|            0|  0.00%|    Like the generic NumPy equivalent the product sum is over the last dimension
  7509|         0|            0|            0|  0.00%|    of a and b. The first argument is not conjugated.
  7510|         0|            0|            0|  0.00%|
  7511|         0|            0|            0|  0.00%|    """
  7512|         0|            0|            0|  0.00%|    fa = filled(a, 0)
  7513|         0|            0|            0|  0.00%|    fb = filled(b, 0)
  7514|         0|            0|            0|  0.00%|    if fa.ndim == 0:
  7515|         0|            0|            0|  0.00%|        fa.shape = (1,)
  7516|         0|            0|            0|  0.00%|    if fb.ndim == 0:
  7517|         0|            0|            0|  0.00%|        fb.shape = (1,)
  7518|         0|            0|            0|  0.00%|    return np.inner(fa, fb).view(MaskedArray)
  7519|         0|            0|            0|  0.00%|inner.__doc__ = doc_note(np.inner.__doc__,
  7520|         0|            0|            0|  0.00%|                         "Masked values are replaced by 0.")
  7521|         0|            0|            0|  0.00%|innerproduct = inner
  7522|         0|            0|            0|  0.00%|
  7523|         0|            0|            0|  0.00%|
  7524|         0|            0|            0|  0.00%|def outer(a, b):
  7525|         0|            0|            0|  0.00%|    "maskedarray version of the numpy function."
  7526|         0|            0|            0|  0.00%|    fa = filled(a, 0).ravel()
  7527|         0|            0|            0|  0.00%|    fb = filled(b, 0).ravel()
  7528|         0|            0|            0|  0.00%|    d = np.outer(fa, fb)
  7529|         0|            0|            0|  0.00%|    ma = getmask(a)
  7530|         0|            0|            0|  0.00%|    mb = getmask(b)
  7531|         0|            0|            0|  0.00%|    if ma is nomask and mb is nomask:
  7532|         0|            0|            0|  0.00%|        return masked_array(d)
  7533|         0|            0|            0|  0.00%|    ma = getmaskarray(a)
  7534|         0|            0|            0|  0.00%|    mb = getmaskarray(b)
  7535|         0|            0|            0|  0.00%|    m = make_mask(1 - np.outer(1 - ma, 1 - mb), copy=0)
  7536|         0|            0|            0|  0.00%|    return masked_array(d, mask=m)
  7537|         0|            0|            0|  0.00%|outer.__doc__ = doc_note(np.outer.__doc__,
  7538|         0|            0|            0|  0.00%|                         "Masked values are replaced by 0.")
  7539|         0|            0|            0|  0.00%|outerproduct = outer
  7540|         0|            0|            0|  0.00%|
  7541|         0|            0|            0|  0.00%|
  7542|         0|            0|            0|  0.00%|def _convolve_or_correlate(f, a, v, mode, propagate_mask):
  7543|         0|            0|            0|  0.00%|    """
  7544|         0|            0|            0|  0.00%|    Helper function for ma.correlate and ma.convolve
  7545|         0|            0|            0|  0.00%|    """
  7546|         0|            0|            0|  0.00%|    if propagate_mask:
  7547|         0|            0|            0|  0.00%|        # results which are contributed to by either item in any pair being invalid
  7548|         0|            0|            0|  0.00%|        mask = (
  7549|         0|            0|            0|  0.00%|            f(getmaskarray(a), np.ones(np.shape(v), dtype=bool), mode=mode)
  7550|         0|            0|            0|  0.00%|          | f(np.ones(np.shape(a), dtype=bool), getmaskarray(v), mode=mode)
  7551|         0|            0|            0|  0.00%|        )
  7552|         0|            0|            0|  0.00%|        data = f(getdata(a), getdata(v), mode=mode)
  7553|         0|            0|            0|  0.00%|    else:
  7554|         0|            0|            0|  0.00%|        # results which are not contributed to by any pair of valid elements
  7555|         0|            0|            0|  0.00%|        mask = ~f(~getmaskarray(a), ~getmaskarray(v))
  7556|         0|            0|            0|  0.00%|        data = f(filled(a, 0), filled(v, 0), mode=mode)
  7557|         0|            0|            0|  0.00%|
  7558|         0|            0|            0|  0.00%|    return masked_array(data, mask=mask)
  7559|         0|            0|            0|  0.00%|
  7560|         0|            0|            0|  0.00%|
  7561|         0|            0|            0|  0.00%|def correlate(a, v, mode='valid', propagate_mask=True):
  7562|         0|            0|            0|  0.00%|    """
  7563|         0|            0|            0|  0.00%|    Cross-correlation of two 1-dimensional sequences.
  7564|         0|            0|            0|  0.00%|
  7565|         0|            0|            0|  0.00%|    Parameters
  7566|         0|            0|            0|  0.00%|    ----------
  7567|         0|            0|            0|  0.00%|    a, v : array_like
  7568|         0|            0|            0|  0.00%|        Input sequences.
  7569|         0|            0|            0|  0.00%|    mode : {'valid', 'same', 'full'}, optional
  7570|         0|            0|            0|  0.00%|        Refer to the `np.convolve` docstring.  Note that the default
  7571|         0|            0|            0|  0.00%|        is 'valid', unlike `convolve`, which uses 'full'.
  7572|         0|            0|            0|  0.00%|    propagate_mask : bool
  7573|         0|            0|            0|  0.00%|        If True, then a result element is masked if any masked element contributes towards it.
  7574|         0|            0|            0|  0.00%|        If False, then a result element is only masked if no non-masked element
  7575|         0|            0|            0|  0.00%|        contribute towards it
  7576|         0|            0|            0|  0.00%|
  7577|         0|            0|            0|  0.00%|    Returns
  7578|         0|            0|            0|  0.00%|    -------
  7579|         0|            0|            0|  0.00%|    out : MaskedArray
  7580|         0|            0|            0|  0.00%|        Discrete cross-correlation of `a` and `v`.
  7581|         0|            0|            0|  0.00%|
  7582|         0|            0|            0|  0.00%|    See Also
  7583|         0|            0|            0|  0.00%|    --------
  7584|         0|            0|            0|  0.00%|    numpy.correlate : Equivalent function in the top-level NumPy module.
  7585|         0|            0|            0|  0.00%|    """
  7586|         0|            0|            0|  0.00%|    return _convolve_or_correlate(np.correlate, a, v, mode, propagate_mask)
  7587|         0|            0|            0|  0.00%|
  7588|         0|            0|            0|  0.00%|
  7589|         0|            0|            0|  0.00%|def convolve(a, v, mode='full', propagate_mask=True):
  7590|         0|            0|            0|  0.00%|    """
  7591|         0|            0|            0|  0.00%|    Returns the discrete, linear convolution of two one-dimensional sequences.
  7592|         0|            0|            0|  0.00%|
  7593|         0|            0|            0|  0.00%|    Parameters
  7594|         0|            0|            0|  0.00%|    ----------
  7595|         0|            0|            0|  0.00%|    a, v : array_like
  7596|         0|            0|            0|  0.00%|        Input sequences.
  7597|         0|            0|            0|  0.00%|    mode : {'valid', 'same', 'full'}, optional
  7598|         0|            0|            0|  0.00%|        Refer to the `np.convolve` docstring.
  7599|         0|            0|            0|  0.00%|    propagate_mask : bool
  7600|         0|            0|            0|  0.00%|        If True, then if any masked element is included in the sum for a result
  7601|         0|            0|            0|  0.00%|        element, then the result is masked.
  7602|         0|            0|            0|  0.00%|        If False, then the result element is only masked if no non-masked cells
  7603|         0|            0|            0|  0.00%|        contribute towards it
  7604|         0|            0|            0|  0.00%|
  7605|         0|            0|            0|  0.00%|    Returns
  7606|         0|            0|            0|  0.00%|    -------
  7607|         0|            0|            0|  0.00%|    out : MaskedArray
  7608|         0|            0|            0|  0.00%|        Discrete, linear convolution of `a` and `v`.
  7609|         0|            0|            0|  0.00%|
  7610|         0|            0|            0|  0.00%|    See Also
  7611|         0|            0|            0|  0.00%|    --------
  7612|         0|            0|            0|  0.00%|    numpy.convolve : Equivalent function in the top-level NumPy module.
  7613|         0|            0|            0|  0.00%|    """
  7614|         0|            0|            0|  0.00%|    return _convolve_or_correlate(np.convolve, a, v, mode, propagate_mask)
  7615|         0|            0|            0|  0.00%|
  7616|         0|            0|            0|  0.00%|
  7617|         0|            0|            0|  0.00%|def allequal(a, b, fill_value=True):
  7618|         0|            0|            0|  0.00%|    """
  7619|         0|            0|            0|  0.00%|    Return True if all entries of a and b are equal, using
  7620|         0|            0|            0|  0.00%|    fill_value as a truth value where either or both are masked.
  7621|         0|            0|            0|  0.00%|
  7622|         0|            0|            0|  0.00%|    Parameters
  7623|         0|            0|            0|  0.00%|    ----------
  7624|         0|            0|            0|  0.00%|    a, b : array_like
  7625|         0|            0|            0|  0.00%|        Input arrays to compare.
  7626|         0|            0|            0|  0.00%|    fill_value : bool, optional
  7627|         0|            0|            0|  0.00%|        Whether masked values in a or b are considered equal (True) or not
  7628|         0|            0|            0|  0.00%|        (False).
  7629|         0|            0|            0|  0.00%|
  7630|         0|            0|            0|  0.00%|    Returns
  7631|         0|            0|            0|  0.00%|    -------
  7632|         0|            0|            0|  0.00%|    y : bool
  7633|         0|            0|            0|  0.00%|        Returns True if the two arrays are equal within the given
  7634|         0|            0|            0|  0.00%|        tolerance, False otherwise. If either array contains NaN,
  7635|         0|            0|            0|  0.00%|        then False is returned.
  7636|         0|            0|            0|  0.00%|
  7637|         0|            0|            0|  0.00%|    See Also
  7638|         0|            0|            0|  0.00%|    --------
  7639|         0|            0|            0|  0.00%|    all, any
  7640|         0|            0|            0|  0.00%|    numpy.ma.allclose
  7641|         0|            0|            0|  0.00%|
  7642|         0|            0|            0|  0.00%|    Examples
  7643|         0|            0|            0|  0.00%|    --------
  7644|         0|            0|            0|  0.00%|    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
  7645|         0|            0|            0|  0.00%|    >>> a
  7646|         0|            0|            0|  0.00%|    masked_array(data=[10000000000.0, 1e-07, --],
  7647|         0|            0|            0|  0.00%|                 mask=[False, False,  True],
  7648|         0|            0|            0|  0.00%|           fill_value=1e+20)
  7649|         0|            0|            0|  0.00%|
  7650|         0|            0|            0|  0.00%|    >>> b = np.array([1e10, 1e-7, -42.0])
  7651|         0|            0|            0|  0.00%|    >>> b
  7652|         0|            0|            0|  0.00%|    array([  1.00000000e+10,   1.00000000e-07,  -4.20000000e+01])
  7653|         0|            0|            0|  0.00%|    >>> np.ma.allequal(a, b, fill_value=False)
  7654|         0|            0|            0|  0.00%|    False
  7655|         0|            0|            0|  0.00%|    >>> np.ma.allequal(a, b)
  7656|         0|            0|            0|  0.00%|    True
  7657|         0|            0|            0|  0.00%|
  7658|         0|            0|            0|  0.00%|    """
  7659|         0|            0|            0|  0.00%|    m = mask_or(getmask(a), getmask(b))
  7660|         0|            0|            0|  0.00%|    if m is nomask:
  7661|         0|            0|            0|  0.00%|        x = getdata(a)
  7662|         0|            0|            0|  0.00%|        y = getdata(b)
  7663|         0|            0|            0|  0.00%|        d = umath.equal(x, y)
  7664|         0|            0|            0|  0.00%|        return d.all()
  7665|         0|            0|            0|  0.00%|    elif fill_value:
  7666|         0|            0|            0|  0.00%|        x = getdata(a)
  7667|         0|            0|            0|  0.00%|        y = getdata(b)
  7668|         0|            0|            0|  0.00%|        d = umath.equal(x, y)
  7669|         0|            0|            0|  0.00%|        dm = array(d, mask=m, copy=False)
  7670|         0|            0|            0|  0.00%|        return dm.filled(True).all(None)
  7671|         0|            0|            0|  0.00%|    else:
  7672|         0|            0|            0|  0.00%|        return False
  7673|         0|            0|            0|  0.00%|
  7674|         0|            0|            0|  0.00%|
  7675|         0|            0|            0|  0.00%|def allclose(a, b, masked_equal=True, rtol=1e-5, atol=1e-8):
  7676|         0|            0|            0|  0.00%|    """
  7677|         0|            0|            0|  0.00%|    Returns True if two arrays are element-wise equal within a tolerance.
  7678|         0|            0|            0|  0.00%|
  7679|         0|            0|            0|  0.00%|    This function is equivalent to `allclose` except that masked values
  7680|         0|            0|            0|  0.00%|    are treated as equal (default) or unequal, depending on the `masked_equal`
  7681|         0|            0|            0|  0.00%|    argument.
  7682|         0|            0|            0|  0.00%|
  7683|         0|            0|            0|  0.00%|    Parameters
  7684|         0|            0|            0|  0.00%|    ----------
  7685|         0|            0|            0|  0.00%|    a, b : array_like
  7686|         0|            0|            0|  0.00%|        Input arrays to compare.
  7687|         0|            0|            0|  0.00%|    masked_equal : bool, optional
  7688|         0|            0|            0|  0.00%|        Whether masked values in `a` and `b` are considered equal (True) or not
  7689|         0|            0|            0|  0.00%|        (False). They are considered equal by default.
  7690|         0|            0|            0|  0.00%|    rtol : float, optional
  7691|         0|            0|            0|  0.00%|        Relative tolerance. The relative difference is equal to ``rtol * b``.
  7692|         0|            0|            0|  0.00%|        Default is 1e-5.
  7693|         0|            0|            0|  0.00%|    atol : float, optional
  7694|         0|            0|            0|  0.00%|        Absolute tolerance. The absolute difference is equal to `atol`.
  7695|         0|            0|            0|  0.00%|        Default is 1e-8.
  7696|         0|            0|            0|  0.00%|
  7697|         0|            0|            0|  0.00%|    Returns
  7698|         0|            0|            0|  0.00%|    -------
  7699|         0|            0|            0|  0.00%|    y : bool
  7700|         0|            0|            0|  0.00%|        Returns True if the two arrays are equal within the given
  7701|         0|            0|            0|  0.00%|        tolerance, False otherwise. If either array contains NaN, then
  7702|         0|            0|            0|  0.00%|        False is returned.
  7703|         0|            0|            0|  0.00%|
  7704|         0|            0|            0|  0.00%|    See Also
  7705|         0|            0|            0|  0.00%|    --------
  7706|         0|            0|            0|  0.00%|    all, any
  7707|         0|            0|            0|  0.00%|    numpy.allclose : the non-masked `allclose`.
  7708|         0|            0|            0|  0.00%|
  7709|         0|            0|            0|  0.00%|    Notes
  7710|         0|            0|            0|  0.00%|    -----
  7711|         0|            0|            0|  0.00%|    If the following equation is element-wise True, then `allclose` returns
  7712|         0|            0|            0|  0.00%|    True::
  7713|         0|            0|            0|  0.00%|
  7714|         0|            0|            0|  0.00%|      absolute(`a` - `b`) <= (`atol` + `rtol` * absolute(`b`))
  7715|         0|            0|            0|  0.00%|
  7716|         0|            0|            0|  0.00%|    Return True if all elements of `a` and `b` are equal subject to
  7717|         0|            0|            0|  0.00%|    given tolerances.
  7718|         0|            0|            0|  0.00%|
  7719|         0|            0|            0|  0.00%|    Examples
  7720|         0|            0|            0|  0.00%|    --------
  7721|         0|            0|            0|  0.00%|    >>> a = np.ma.array([1e10, 1e-7, 42.0], mask=[0, 0, 1])
  7722|         0|            0|            0|  0.00%|    >>> a
  7723|         0|            0|            0|  0.00%|    masked_array(data=[10000000000.0, 1e-07, --],
  7724|         0|            0|            0|  0.00%|                 mask=[False, False,  True],
  7725|         0|            0|            0|  0.00%|           fill_value=1e+20)
  7726|         0|            0|            0|  0.00%|    >>> b = np.ma.array([1e10, 1e-8, -42.0], mask=[0, 0, 1])
  7727|         0|            0|            0|  0.00%|    >>> np.ma.allclose(a, b)
  7728|         0|            0|            0|  0.00%|    False
  7729|         0|            0|            0|  0.00%|
  7730|         0|            0|            0|  0.00%|    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
  7731|         0|            0|            0|  0.00%|    >>> b = np.ma.array([1.00001e10, 1e-9, -42.0], mask=[0, 0, 1])
  7732|         0|            0|            0|  0.00%|    >>> np.ma.allclose(a, b)
  7733|         0|            0|            0|  0.00%|    True
  7734|         0|            0|            0|  0.00%|    >>> np.ma.allclose(a, b, masked_equal=False)
  7735|         0|            0|            0|  0.00%|    False
  7736|         0|            0|            0|  0.00%|
  7737|         0|            0|            0|  0.00%|    Masked values are not compared directly.
  7738|         0|            0|            0|  0.00%|
  7739|         0|            0|            0|  0.00%|    >>> a = np.ma.array([1e10, 1e-8, 42.0], mask=[0, 0, 1])
  7740|         0|            0|            0|  0.00%|    >>> b = np.ma.array([1.00001e10, 1e-9, 42.0], mask=[0, 0, 1])
  7741|         0|            0|            0|  0.00%|    >>> np.ma.allclose(a, b)
  7742|         0|            0|            0|  0.00%|    True
  7743|         0|            0|            0|  0.00%|    >>> np.ma.allclose(a, b, masked_equal=False)
  7744|         0|            0|            0|  0.00%|    False
  7745|         0|            0|            0|  0.00%|
  7746|         0|            0|            0|  0.00%|    """
  7747|         0|            0|            0|  0.00%|    x = masked_array(a, copy=False)
  7748|         0|            0|            0|  0.00%|    y = masked_array(b, copy=False)
  7749|         0|            0|            0|  0.00%|
  7750|         0|            0|            0|  0.00%|    # make sure y is an inexact type to avoid abs(MIN_INT); will cause
  7751|         0|            0|            0|  0.00%|    # casting of x later.
  7752|         0|            0|            0|  0.00%|    dtype = np.result_type(y, 1.)
  7753|         0|            0|            0|  0.00%|    if y.dtype != dtype:
  7754|         0|            0|            0|  0.00%|        y = masked_array(y, dtype=dtype, copy=False)
  7755|         0|            0|            0|  0.00%|
  7756|         0|            0|            0|  0.00%|    m = mask_or(getmask(x), getmask(y))
  7757|         0|            0|            0|  0.00%|    xinf = np.isinf(masked_array(x, copy=False, mask=m)).filled(False)
  7758|         0|            0|            0|  0.00%|    # If we have some infs, they should fall at the same place.
  7759|         0|            0|            0|  0.00%|    if not np.all(xinf == filled(np.isinf(y), False)):
  7760|         0|            0|            0|  0.00%|        return False
  7761|         0|            0|            0|  0.00%|    # No infs at all
  7762|         0|            0|            0|  0.00%|    if not np.any(xinf):
  7763|         0|            0|            0|  0.00%|        d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
  7764|         0|            0|            0|  0.00%|                   masked_equal)
  7765|         0|            0|            0|  0.00%|        return np.all(d)
  7766|         0|            0|            0|  0.00%|
  7767|         0|            0|            0|  0.00%|    if not np.all(filled(x[xinf] == y[xinf], masked_equal)):
  7768|         0|            0|            0|  0.00%|        return False
  7769|         0|            0|            0|  0.00%|    x = x[~xinf]
  7770|         0|            0|            0|  0.00%|    y = y[~xinf]
  7771|         0|            0|            0|  0.00%|
  7772|         0|            0|            0|  0.00%|    d = filled(less_equal(absolute(x - y), atol + rtol * absolute(y)),
  7773|         0|            0|            0|  0.00%|               masked_equal)
  7774|         0|            0|            0|  0.00%|
  7775|         0|            0|            0|  0.00%|    return np.all(d)
  7776|         0|            0|            0|  0.00%|
  7777|         0|            0|            0|  0.00%|
  7778|         0|            0|            0|  0.00%|def asarray(a, dtype=None, order=None):
  7779|         0|            0|            0|  0.00%|    """
  7780|         0|            0|            0|  0.00%|    Convert the input to a masked array of the given data-type.
  7781|         0|            0|            0|  0.00%|
  7782|         0|            0|            0|  0.00%|    No copy is performed if the input is already an `ndarray`. If `a` is
  7783|         0|            0|            0|  0.00%|    a subclass of `MaskedArray`, a base class `MaskedArray` is returned.
  7784|         0|            0|            0|  0.00%|
  7785|         0|            0|            0|  0.00%|    Parameters
  7786|         0|            0|            0|  0.00%|    ----------
  7787|         0|            0|            0|  0.00%|    a : array_like
  7788|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to a masked array. This
  7789|         0|            0|            0|  0.00%|        includes lists, lists of tuples, tuples, tuples of tuples, tuples
  7790|         0|            0|            0|  0.00%|        of lists, ndarrays and masked arrays.
  7791|         0|            0|            0|  0.00%|    dtype : dtype, optional
  7792|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
  7793|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
  7794|         0|            0|            0|  0.00%|        Whether to use row-major ('C') or column-major ('FORTRAN') memory
  7795|         0|            0|            0|  0.00%|        representation.  Default is 'C'.
  7796|         0|            0|            0|  0.00%|
  7797|         0|            0|            0|  0.00%|    Returns
  7798|         0|            0|            0|  0.00%|    -------
  7799|         0|            0|            0|  0.00%|    out : MaskedArray
  7800|         0|            0|            0|  0.00%|        Masked array interpretation of `a`.
  7801|         0|            0|            0|  0.00%|
  7802|         0|            0|            0|  0.00%|    See Also
  7803|         0|            0|            0|  0.00%|    --------
  7804|         0|            0|            0|  0.00%|    asanyarray : Similar to `asarray`, but conserves subclasses.
  7805|         0|            0|            0|  0.00%|
  7806|         0|            0|            0|  0.00%|    Examples
  7807|         0|            0|            0|  0.00%|    --------
  7808|         0|            0|            0|  0.00%|    >>> x = np.arange(10.).reshape(2, 5)
  7809|         0|            0|            0|  0.00%|    >>> x
  7810|         0|            0|            0|  0.00%|    array([[0., 1., 2., 3., 4.],
  7811|         0|            0|            0|  0.00%|           [5., 6., 7., 8., 9.]])
  7812|         0|            0|            0|  0.00%|    >>> np.ma.asarray(x)
  7813|         0|            0|            0|  0.00%|    masked_array(
  7814|         0|            0|            0|  0.00%|      data=[[0., 1., 2., 3., 4.],
  7815|         0|            0|            0|  0.00%|            [5., 6., 7., 8., 9.]],
  7816|         0|            0|            0|  0.00%|      mask=False,
  7817|         0|            0|            0|  0.00%|      fill_value=1e+20)
  7818|         0|            0|            0|  0.00%|    >>> type(np.ma.asarray(x))
  7819|         0|            0|            0|  0.00%|    <class 'numpy.ma.core.MaskedArray'>
  7820|         0|            0|            0|  0.00%|
  7821|         0|            0|            0|  0.00%|    """
  7822|         0|            0|            0|  0.00%|    order = order or 'C'
  7823|         0|            0|            0|  0.00%|    return masked_array(a, dtype=dtype, copy=False, keep_mask=True,
  7824|         0|            0|            0|  0.00%|                        subok=False, order=order)
  7825|         0|            0|            0|  0.00%|
  7826|         0|            0|            0|  0.00%|
  7827|         0|            0|            0|  0.00%|def asanyarray(a, dtype=None):
  7828|         0|            0|            0|  0.00%|    """
  7829|         0|            0|            0|  0.00%|    Convert the input to a masked array, conserving subclasses.
  7830|         0|            0|            0|  0.00%|
  7831|         0|            0|            0|  0.00%|    If `a` is a subclass of `MaskedArray`, its class is conserved.
  7832|         0|            0|            0|  0.00%|    No copy is performed if the input is already an `ndarray`.
  7833|         0|            0|            0|  0.00%|
  7834|         0|            0|            0|  0.00%|    Parameters
  7835|         0|            0|            0|  0.00%|    ----------
  7836|         0|            0|            0|  0.00%|    a : array_like
  7837|         0|            0|            0|  0.00%|        Input data, in any form that can be converted to an array.
  7838|         0|            0|            0|  0.00%|    dtype : dtype, optional
  7839|         0|            0|            0|  0.00%|        By default, the data-type is inferred from the input data.
  7840|         0|            0|            0|  0.00%|    order : {'C', 'F'}, optional
  7841|         0|            0|            0|  0.00%|        Whether to use row-major ('C') or column-major ('FORTRAN') memory
  7842|         0|            0|            0|  0.00%|        representation.  Default is 'C'.
  7843|         0|            0|            0|  0.00%|
  7844|         0|            0|            0|  0.00%|    Returns
  7845|         0|            0|            0|  0.00%|    -------
  7846|         0|            0|            0|  0.00%|    out : MaskedArray
  7847|         0|            0|            0|  0.00%|        MaskedArray interpretation of `a`.
  7848|         0|            0|            0|  0.00%|
  7849|         0|            0|            0|  0.00%|    See Also
  7850|         0|            0|            0|  0.00%|    --------
  7851|         0|            0|            0|  0.00%|    asarray : Similar to `asanyarray`, but does not conserve subclass.
  7852|         0|            0|            0|  0.00%|
  7853|         0|            0|            0|  0.00%|    Examples
  7854|         0|            0|            0|  0.00%|    --------
  7855|         0|            0|            0|  0.00%|    >>> x = np.arange(10.).reshape(2, 5)
  7856|         0|            0|            0|  0.00%|    >>> x
  7857|         0|            0|            0|  0.00%|    array([[0., 1., 2., 3., 4.],
  7858|         0|            0|            0|  0.00%|           [5., 6., 7., 8., 9.]])
  7859|         0|            0|            0|  0.00%|    >>> np.ma.asanyarray(x)
  7860|         0|            0|            0|  0.00%|    masked_array(
  7861|         0|            0|            0|  0.00%|      data=[[0., 1., 2., 3., 4.],
  7862|         0|            0|            0|  0.00%|            [5., 6., 7., 8., 9.]],
  7863|         0|            0|            0|  0.00%|      mask=False,
  7864|         0|            0|            0|  0.00%|      fill_value=1e+20)
  7865|         0|            0|            0|  0.00%|    >>> type(np.ma.asanyarray(x))
  7866|         0|            0|            0|  0.00%|    <class 'numpy.ma.core.MaskedArray'>
  7867|         0|            0|            0|  0.00%|
  7868|         0|            0|            0|  0.00%|    """
  7869|         0|            0|            0|  0.00%|    # workaround for #8666, to preserve identity. Ideally the bottom line
  7870|         0|            0|            0|  0.00%|    # would handle this for us.
  7871|         0|            0|            0|  0.00%|    if isinstance(a, MaskedArray) and (dtype is None or dtype == a.dtype):
  7872|         0|            0|            0|  0.00%|        return a
  7873|         0|            0|            0|  0.00%|    return masked_array(a, dtype=dtype, copy=False, keep_mask=True, subok=True)
  7874|         0|            0|            0|  0.00%|
  7875|         0|            0|            0|  0.00%|
  7876|         0|            0|            0|  0.00%|##############################################################################
  7877|         0|            0|            0|  0.00%|#                               Pickling                                     #
  7878|         0|            0|            0|  0.00%|##############################################################################
  7879|         0|            0|            0|  0.00%|
  7880|         0|            0|            0|  0.00%|def _pickle_warn(method):
  7881|         0|            0|            0|  0.00%|    # NumPy 1.15.0, 2017-12-10
  7882|         0|            0|            0|  0.00%|    warnings.warn(
  7883|         0|            0|            0|  0.00%|        "np.ma.{method} is deprecated, use pickle.{method} instead"
  7884|         0|            0|            0|  0.00%|            .format(method=method),
  7885|         0|            0|            0|  0.00%|        DeprecationWarning,
  7886|         0|            0|            0|  0.00%|        stacklevel=3)
  7887|         0|            0|            0|  0.00%|
  7888|         0|            0|            0|  0.00%|
  7889|         0|            0|            0|  0.00%|def dump(a, F):
  7890|         0|            0|            0|  0.00%|    """
  7891|         0|            0|            0|  0.00%|    Pickle a masked array to a file.
  7892|         0|            0|            0|  0.00%|
  7893|         0|            0|            0|  0.00%|    This is a wrapper around ``cPickle.dump``.
  7894|         0|            0|            0|  0.00%|
  7895|         0|            0|            0|  0.00%|    Parameters
  7896|         0|            0|            0|  0.00%|    ----------
  7897|         0|            0|            0|  0.00%|    a : MaskedArray
  7898|         0|            0|            0|  0.00%|        The array to be pickled.
  7899|         0|            0|            0|  0.00%|    F : str or file-like object
  7900|         0|            0|            0|  0.00%|        The file to pickle `a` to. If a string, the full path to the file.
  7901|         0|            0|            0|  0.00%|
  7902|         0|            0|            0|  0.00%|    """
  7903|         0|            0|            0|  0.00%|    _pickle_warn('dump')
  7904|         0|            0|            0|  0.00%|    if not hasattr(F, 'readline'):
  7905|         0|            0|            0|  0.00%|        with open(F, 'w') as F:
  7906|         0|            0|            0|  0.00%|            pickle.dump(a, F)
  7907|         0|            0|            0|  0.00%|    else:
  7908|         0|            0|            0|  0.00%|        pickle.dump(a, F)
  7909|         0|            0|            0|  0.00%|
  7910|         0|            0|            0|  0.00%|
  7911|         0|            0|            0|  0.00%|def dumps(a):
  7912|         0|            0|            0|  0.00%|    """
  7913|         0|            0|            0|  0.00%|    Return a string corresponding to the pickling of a masked array.
  7914|         0|            0|            0|  0.00%|
  7915|         0|            0|            0|  0.00%|    This is a wrapper around ``cPickle.dumps``.
  7916|         0|            0|            0|  0.00%|
  7917|         0|            0|            0|  0.00%|    Parameters
  7918|         0|            0|            0|  0.00%|    ----------
  7919|         0|            0|            0|  0.00%|    a : MaskedArray
  7920|         0|            0|            0|  0.00%|        The array for which the string representation of the pickle is
  7921|         0|            0|            0|  0.00%|        returned.
  7922|         0|            0|            0|  0.00%|
  7923|         0|            0|            0|  0.00%|    """
  7924|         0|            0|            0|  0.00%|    _pickle_warn('dumps')
  7925|         0|            0|            0|  0.00%|    return pickle.dumps(a)
  7926|         0|            0|            0|  0.00%|
  7927|         0|            0|            0|  0.00%|
  7928|         0|            0|            0|  0.00%|def load(F):
  7929|         0|            0|            0|  0.00%|    """
  7930|         0|            0|            0|  0.00%|    Wrapper around ``cPickle.load`` which accepts either a file-like object
  7931|         0|            0|            0|  0.00%|    or a filename.
  7932|         0|            0|            0|  0.00%|
  7933|         0|            0|            0|  0.00%|    Parameters
  7934|         0|            0|            0|  0.00%|    ----------
  7935|         0|            0|            0|  0.00%|    F : str or file
  7936|         0|            0|            0|  0.00%|        The file or file name to load.
  7937|         0|            0|            0|  0.00%|
  7938|         0|            0|            0|  0.00%|    See Also
  7939|         0|            0|            0|  0.00%|    --------
  7940|         0|            0|            0|  0.00%|    dump : Pickle an array
  7941|         0|            0|            0|  0.00%|
  7942|         0|            0|            0|  0.00%|    Notes
  7943|         0|            0|            0|  0.00%|    -----
  7944|         0|            0|            0|  0.00%|    This is different from `numpy.load`, which does not use cPickle but loads
  7945|         0|            0|            0|  0.00%|    the NumPy binary .npy format.
  7946|         0|            0|            0|  0.00%|
  7947|         0|            0|            0|  0.00%|    """
  7948|         0|            0|            0|  0.00%|    _pickle_warn('load')
  7949|         0|            0|            0|  0.00%|    if not hasattr(F, 'readline'):
  7950|         0|            0|            0|  0.00%|        with open(F, 'r') as F:
  7951|         0|            0|            0|  0.00%|            return pickle.load(F)
  7952|         0|            0|            0|  0.00%|    else:
  7953|         0|            0|            0|  0.00%|        return pickle.load(F)
  7954|         0|            0|            0|  0.00%|
  7955|         0|            0|            0|  0.00%|
  7956|         0|            0|            0|  0.00%|def loads(strg):
  7957|         0|            0|            0|  0.00%|    """
  7958|         0|            0|            0|  0.00%|    Load a pickle from the current string.
  7959|         0|            0|            0|  0.00%|
  7960|         0|            0|            0|  0.00%|    The result of ``cPickle.loads(strg)`` is returned.
  7961|         0|            0|            0|  0.00%|
  7962|         0|            0|            0|  0.00%|    Parameters
  7963|         0|            0|            0|  0.00%|    ----------
  7964|         0|            0|            0|  0.00%|    strg : str
  7965|         0|            0|            0|  0.00%|        The string to load.
  7966|         0|            0|            0|  0.00%|
  7967|         0|            0|            0|  0.00%|    See Also
  7968|         0|            0|            0|  0.00%|    --------
  7969|         0|            0|            0|  0.00%|    dumps : Return a string corresponding to the pickling of a masked array.
  7970|         0|            0|            0|  0.00%|
  7971|         0|            0|            0|  0.00%|    """
  7972|         0|            0|            0|  0.00%|    _pickle_warn('loads')
  7973|         0|            0|            0|  0.00%|    return pickle.loads(strg)
  7974|         0|            0|            0|  0.00%|
  7975|         0|            0|            0|  0.00%|
  7976|         0|            0|            0|  0.00%|def fromfile(file, dtype=float, count=-1, sep=''):
  7977|         0|            0|            0|  0.00%|    raise NotImplementedError(
  7978|         0|            0|            0|  0.00%|        "fromfile() not yet implemented for a MaskedArray.")
  7979|         0|            0|            0|  0.00%|
  7980|         0|            0|            0|  0.00%|
  7981|         0|            0|            0|  0.00%|def fromflex(fxarray):
  7982|         0|            0|            0|  0.00%|    """
  7983|         0|            0|            0|  0.00%|    Build a masked array from a suitable flexible-type array.
  7984|         0|            0|            0|  0.00%|
  7985|         0|            0|            0|  0.00%|    The input array has to have a data-type with ``_data`` and ``_mask``
  7986|         0|            0|            0|  0.00%|    fields. This type of array is output by `MaskedArray.toflex`.
  7987|         0|            0|            0|  0.00%|
  7988|         0|            0|            0|  0.00%|    Parameters
  7989|         0|            0|            0|  0.00%|    ----------
  7990|         0|            0|            0|  0.00%|    fxarray : ndarray
  7991|         0|            0|            0|  0.00%|        The structured input array, containing ``_data`` and ``_mask``
  7992|         0|            0|            0|  0.00%|        fields. If present, other fields are discarded.
  7993|         0|            0|            0|  0.00%|
  7994|         0|            0|            0|  0.00%|    Returns
  7995|         0|            0|            0|  0.00%|    -------
  7996|         0|            0|            0|  0.00%|    result : MaskedArray
  7997|         0|            0|            0|  0.00%|        The constructed masked array.
  7998|         0|            0|            0|  0.00%|
  7999|         0|            0|            0|  0.00%|    See Also
  8000|         0|            0|            0|  0.00%|    --------
  8001|         0|            0|            0|  0.00%|    MaskedArray.toflex : Build a flexible-type array from a masked array.
  8002|         0|            0|            0|  0.00%|
  8003|         0|            0|            0|  0.00%|    Examples
  8004|         0|            0|            0|  0.00%|    --------
  8005|         0|            0|            0|  0.00%|    >>> x = np.ma.array(np.arange(9).reshape(3, 3), mask=[0] + [1, 0] * 4)
  8006|         0|            0|            0|  0.00%|    >>> rec = x.toflex()
  8007|         0|            0|            0|  0.00%|    >>> rec
  8008|         0|            0|            0|  0.00%|    array([[(0, False), (1,  True), (2, False)],
  8009|         0|            0|            0|  0.00%|           [(3,  True), (4, False), (5,  True)],
  8010|         0|            0|            0|  0.00%|           [(6, False), (7,  True), (8, False)]],
  8011|         0|            0|            0|  0.00%|          dtype=[('_data', '<i8'), ('_mask', '?')])
  8012|         0|            0|            0|  0.00%|    >>> x2 = np.ma.fromflex(rec)
  8013|         0|            0|            0|  0.00%|    >>> x2
  8014|         0|            0|            0|  0.00%|    masked_array(
  8015|         0|            0|            0|  0.00%|      data=[[0, --, 2],
  8016|         0|            0|            0|  0.00%|            [--, 4, --],
  8017|         0|            0|            0|  0.00%|            [6, --, 8]],
  8018|         0|            0|            0|  0.00%|      mask=[[False,  True, False],
  8019|         0|            0|            0|  0.00%|            [ True, False,  True],
  8020|         0|            0|            0|  0.00%|            [False,  True, False]],
  8021|         0|            0|            0|  0.00%|      fill_value=999999)
  8022|         0|            0|            0|  0.00%|
  8023|         0|            0|            0|  0.00%|    Extra fields can be present in the structured array but are discarded:
  8024|         0|            0|            0|  0.00%|
  8025|         0|            0|            0|  0.00%|    >>> dt = [('_data', '<i4'), ('_mask', '|b1'), ('field3', '<f4')]
  8026|         0|            0|            0|  0.00%|    >>> rec2 = np.zeros((2, 2), dtype=dt)
  8027|         0|            0|            0|  0.00%|    >>> rec2
  8028|         0|            0|            0|  0.00%|    array([[(0, False, 0.), (0, False, 0.)],
  8029|         0|            0|            0|  0.00%|           [(0, False, 0.), (0, False, 0.)]],
  8030|         0|            0|            0|  0.00%|          dtype=[('_data', '<i4'), ('_mask', '?'), ('field3', '<f4')])
  8031|         0|            0|            0|  0.00%|    >>> y = np.ma.fromflex(rec2)
  8032|         0|            0|            0|  0.00%|    >>> y
  8033|         0|            0|            0|  0.00%|    masked_array(
  8034|         0|            0|            0|  0.00%|      data=[[0, 0],
  8035|         0|            0|            0|  0.00%|            [0, 0]],
  8036|         0|            0|            0|  0.00%|      mask=[[False, False],
  8037|         0|            0|            0|  0.00%|            [False, False]],
  8038|         0|            0|            0|  0.00%|      fill_value=999999,
  8039|         0|            0|            0|  0.00%|      dtype=int32)
  8040|         0|            0|            0|  0.00%|
  8041|         0|            0|            0|  0.00%|    """
  8042|         0|            0|            0|  0.00%|    return masked_array(fxarray['_data'], mask=fxarray['_mask'])
  8043|         0|            0|            0|  0.00%|
  8044|         0|            0|            0|  0.00%|
  8045|         0|            0|            0|  0.00%|class _convert2ma(object):
  8046|         0|            0|            0|  0.00%|
  8047|         0|            0|            0|  0.00%|    """
  8048|         0|            0|            0|  0.00%|    Convert functions from numpy to numpy.ma.
  8049|         0|            0|            0|  0.00%|
  8050|         0|            0|            0|  0.00%|    Parameters
  8051|         0|            0|            0|  0.00%|    ----------
  8052|         0|            0|            0|  0.00%|        _methodname : string
  8053|         0|            0|            0|  0.00%|            Name of the method to transform.
  8054|         0|            0|            0|  0.00%|
  8055|         0|            0|            0|  0.00%|    """
  8056|         0|            0|            0|  0.00%|    __doc__ = None
  8057|         0|            0|            0|  0.00%|
  8058|         0|            0|            0|  0.00%|    def __init__(self, funcname, params=None):
  8059|         0|            0|            0|  0.00%|        self._func = getattr(np, funcname)
  8060|         0|            0|            0|  0.00%|        self.__doc__ = self.getdoc()
  8061|         0|            0|            0|  0.00%|        self._extras = params or {}
  8062|         0|            0|            0|  0.00%|
  8063|         0|            0|            0|  0.00%|    def getdoc(self):
  8064|         0|            0|            0|  0.00%|        "Return the doc of the function (from the doc of the method)."
  8065|         0|            0|            0|  0.00%|        doc = getattr(self._func, '__doc__', None)
  8066|         0|            0|            0|  0.00%|        sig = get_object_signature(self._func)
  8067|         0|            0|            0|  0.00%|        if doc:
  8068|         0|            0|            0|  0.00%|            # Add the signature of the function at the beginning of the doc
  8069|         0|            0|            0|  0.00%|            if sig:
  8070|         0|            0|            0|  0.00%|                sig = "%s%s\n" % (self._func.__name__, sig)
  8071|         0|            0|            0|  0.00%|            doc = sig + doc
  8072|         0|            0|            0|  0.00%|        return doc
  8073|         0|            0|            0|  0.00%|
  8074|         0|            0|            0|  0.00%|    def __call__(self, *args, **params):
  8075|         0|            0|            0|  0.00%|        # Find the common parameters to the call and the definition
  8076|         0|            0|            0|  0.00%|        _extras = self._extras
  8077|         0|            0|            0|  0.00%|        common_params = set(params).intersection(_extras)
  8078|         0|            0|            0|  0.00%|        # Drop the common parameters from the call
  8079|         0|            0|            0|  0.00%|        for p in common_params:
  8080|         0|            0|            0|  0.00%|            _extras[p] = params.pop(p)
  8081|         0|            0|            0|  0.00%|        # Get the result
  8082|         0|            0|            0|  0.00%|        result = self._func.__call__(*args, **params).view(MaskedArray)
  8083|         0|            0|            0|  0.00%|        if "fill_value" in common_params:
  8084|         0|            0|            0|  0.00%|            result.fill_value = _extras.get("fill_value", None)
  8085|         0|            0|            0|  0.00%|        if "hardmask" in common_params:
  8086|         0|            0|            0|  0.00%|            result._hardmask = bool(_extras.get("hard_mask", False))
  8087|         0|            0|            0|  0.00%|        return result
  8088|         0|            0|            0|  0.00%|
  8089|         0|            0|            0|  0.00%|arange = _convert2ma('arange', params=dict(fill_value=None, hardmask=False))
  8090|         0|            0|            0|  0.00%|clip = np.clip
  8091|         0|            0|            0|  0.00%|diff = np.diff
  8092|         0|            0|            0|  0.00%|empty = _convert2ma('empty', params=dict(fill_value=None, hardmask=False))
  8093|         0|            0|            0|  0.00%|empty_like = _convert2ma('empty_like')
  8094|         0|            0|            0|  0.00%|frombuffer = _convert2ma('frombuffer')
  8095|         0|            0|            0|  0.00%|fromfunction = _convert2ma('fromfunction')
  8096|         0|            0|            0|  0.00%|identity = _convert2ma(
  8097|         0|            0|            0|  0.00%|    'identity', params=dict(fill_value=None, hardmask=False))
  8098|         0|            0|            0|  0.00%|indices = np.indices
  8099|         0|            0|            0|  0.00%|ones = _convert2ma('ones', params=dict(fill_value=None, hardmask=False))
  8100|         0|            0|            0|  0.00%|ones_like = np.ones_like
  8101|         0|            0|            0|  0.00%|squeeze = np.squeeze
  8102|         0|            0|            0|  0.00%|zeros = _convert2ma('zeros', params=dict(fill_value=None, hardmask=False))
  8103|         0|            0|            0|  0.00%|zeros_like = np.zeros_like
  8104|         0|            0|            0|  0.00%|
  8105|         0|            0|            0|  0.00%|
  8106|         0|            0|            0|  0.00%|def append(a, b, axis=None):
  8107|         0|            0|            0|  0.00%|    """Append values to the end of an array.
  8108|         0|            0|            0|  0.00%|
  8109|         0|            0|            0|  0.00%|    .. versionadded:: 1.9.0
  8110|         0|            0|            0|  0.00%|
  8111|         0|            0|            0|  0.00%|    Parameters
  8112|         0|            0|            0|  0.00%|    ----------
  8113|         0|            0|            0|  0.00%|    a : array_like
  8114|         0|            0|            0|  0.00%|        Values are appended to a copy of this array.
  8115|         0|            0|            0|  0.00%|    b : array_like
  8116|         0|            0|            0|  0.00%|        These values are appended to a copy of `a`.  It must be of the
  8117|         0|            0|            0|  0.00%|        correct shape (the same shape as `a`, excluding `axis`).  If `axis`
  8118|         0|            0|            0|  0.00%|        is not specified, `b` can be any shape and will be flattened
  8119|         0|            0|            0|  0.00%|        before use.
  8120|         0|            0|            0|  0.00%|    axis : int, optional
  8121|         0|            0|            0|  0.00%|        The axis along which `v` are appended.  If `axis` is not given,
  8122|         0|            0|            0|  0.00%|        both `a` and `b` are flattened before use.
  8123|         0|            0|            0|  0.00%|
  8124|         0|            0|            0|  0.00%|    Returns
  8125|         0|            0|            0|  0.00%|    -------
  8126|         0|            0|            0|  0.00%|    append : MaskedArray
  8127|         0|            0|            0|  0.00%|        A copy of `a` with `b` appended to `axis`.  Note that `append`
  8128|         0|            0|            0|  0.00%|        does not occur in-place: a new array is allocated and filled.  If
  8129|         0|            0|            0|  0.00%|        `axis` is None, the result is a flattened array.
  8130|         0|            0|            0|  0.00%|
  8131|         0|            0|            0|  0.00%|    See Also
  8132|         0|            0|            0|  0.00%|    --------
  8133|         0|            0|            0|  0.00%|    numpy.append : Equivalent function in the top-level NumPy module.
  8134|         0|            0|            0|  0.00%|
  8135|         0|            0|            0|  0.00%|    Examples
  8136|         0|            0|            0|  0.00%|    --------
  8137|         0|            0|            0|  0.00%|    >>> import numpy.ma as ma
  8138|         0|            0|            0|  0.00%|    >>> a = ma.masked_values([1, 2, 3], 2)
  8139|         0|            0|            0|  0.00%|    >>> b = ma.masked_values([[4, 5, 6], [7, 8, 9]], 7)
  8140|         0|            0|            0|  0.00%|    >>> ma.append(a, b)
  8141|         0|            0|            0|  0.00%|    masked_array(data=[1, --, 3, 4, 5, 6, --, 8, 9],
  8142|         0|            0|            0|  0.00%|                 mask=[False,  True, False, False, False, False,  True, False,
  8143|         0|            0|            0|  0.00%|                       False],
  8144|         0|            0|            0|  0.00%|           fill_value=999999)
  8145|         0|            0|            0|  0.00%|    """
  8146|         0|            0|            0|  0.00%|    return concatenate([a, b], axis)
File: test_script_profiler.py
File duration: 0s (0.00%)
Line #|      Hits|         Time| Time per hit|      %|Source code
------+----------+-------------+-------------+-------+-----------
     1|         0|            0|            0|  0.00%|import cython
     2|         0|            0|            0|  0.00%|import wwzs
     3|         0|            0|            0|  0.00%|import numpy as np
     4|         0|            0|            0|  0.00%|import matplotlib.pyplot as plt
     5|         0|            0|            0|  0.00%|from matplotlib.ticker import FormatStrFormatter
     6|         0|            0|            0|  0.00%|import matplotlib.ticker as ticker
     7|         0|            0|            0|  0.00%|import matplotlib.axes as axes
     8|         0|            0|            0|  0.00%|import matplotlib.colors as colors
     9|         0|            0|            0|  0.00%|from datetime import datetime
    10|         0|            0|            0|  0.00%|
    11|         0|            0|            0|  0.00%|
    12|         0|            0|            0|  0.00%|
    13|         0|            0|            0|  0.00%|# generate data for a sine wave observed for 10 years with random noise added
    14|         0|            0|            0|  0.00%|# data = np.loadtxt(data_path+"ogle_merged/sxp327.csv", delimiter=",", dtype=float)
    15|         0|            0|            0|  0.00%|x = np.linspace(0, 249, num=250)
    16|         0|            0|            0|  0.00%|period = 3
    17|         0|            0|            0|  0.00%|f=1/period
    18|         0|            0|            0|  0.00%|y = np.sin(x*f*np.pi*2)#+np.random.normal(0,0.5,size=len(x))
    19|         0|            0|            0|  0.00%|
    20|         0|            0|            0|  0.00%|
    21|         0|            0|            0|  0.00%|# Select the size for the newly generated timestamps (tau), it should be less than the length of the given data.
    22|         0|            0|            0|  0.00%|# This will also limit the minimum possible frequecny
    23|         0|            0|            0|  0.00%|ntau = 10 #(x[-1]-x[0])/4 # no. linear divisions between first and last time stamps of the time series
    24|         0|            0|            0|  0.00%|
    25|         0|            0|            0|  0.00%|# Set the low and high frequency bounds and steps to iterate
    26|         0|            0|            0|  0.00%|frequency_low = 1/125
    27|         0|            0|            0|  0.00%|frequency_high = 1/2
    28|         0|            0|            0|  0.00%|# frequency_steps = np.logspace(np.log10(frequency_low), np.log10(frequency_high), num=1000)
    29|         0|            0|            0|  0.00%|# frequency_steps = frequency_steps[1]-frequency_steps[0]
    30|         0|            0|            0|  0.00%|
    31|         0|            0|            0|  0.00%|# Set the override to False (Setting to True will ignore the low and high frequency limitations)
    32|         0|            0|            0|  0.00%|override = False
    33|         0|            0|            0|  0.00%|
    34|         0|            0|            0|  0.00%|# gather the frequency parameters into a list [freq_low, freq_high, freq_step, override]
    35|         0|            0|            0|  0.00%|frequency_parameters = np.logspace(np.log10(frequency_low), np.log10(frequency_high), num=400)#[frequency_low, frequency_high, frequency_steps, override]
    36|         0|            0|            0|  0.00%|
    37|         0|            0|            0|  0.00%|# We will then select the decay constant for our analyzing wavelet (should be < 0.2), where c = 1/(2*w^2)
    38|         0|            0|            0|  0.00%|# The analyzing wavelet decays significantly in a single cycle 2*pi/w, where w = 2*pi*f
    39|         0|            0|            0|  0.00%|
    40|         0|            0|            0|  0.00%|# f = 20     # we choose 4 since our signal of interest is at 4 h
    41|         0|            0|            0|  0.00%|# w = 2 * np.pi * f
    42|         0|            0|            0|  0.00%|# decay_constant = 1/(2*w**2)
    43|         0|            0|            0|  0.00%|decay_constant = 1/(8*np.pi**2)
    44|         0|            0|            0|  0.00%|# Finally, we select to wether to run with parallization (recommend True)
    45|         0|            0|            0|  0.00%|parallel = True
    46|         0|            0|            0|  0.00%|
    47|         0|            0|            0|  0.00%|
    48|         0|            0|            0|  0.00%|# Using the above settings, we will now compute the WWZ/WWA for the full timeseries and removed timeseries
    49|         0|            0|            0|  0.00%|import pprofile
    50|         0|            0|            0|  0.00%|profiler = pprofile.Profile()
    51|         0|            0|            0|  0.00%|with profiler:
    52|         0|            0|            0|  0.00%|    wwt_spec_Nyq = wwzs.wwt(timestamps=x,
    53|         0|            0|            0|  0.00%|                         magnitudes=y,
    54|         0|            0|            0|  0.00%|                         time_divisions=ntau,
    55|         0|            0|            0|  0.00%|                         freq_params=frequency_parameters,
    56|         0|            0|            0|  0.00%|                         decay_constant=decay_constant)
(call)|         1|  0.000869513|  0.000869513|  0.02%|# <__array_function__ internals>:2 linspace
(call)|         1|  0.000204802|  0.000204802|  0.00%|# <__array_function__ internals>_3:2 diff
(call)|         1|   0.00117278|   0.00117278|  0.02%|# <__array_function__ internals>_4:2 median
(call)|         2|  0.000362873|  0.000181437|  0.01%|# <__array_function__ internals>_8:2 round_
(call)|      4000|     0.691553|  0.000172888| 12.79%|# <__array_function__ internals>_10:2 det
(call)|      4000|     0.773914|  0.000193478| 14.31%|# <__array_function__ internals>_11:2 inv
(call)|      4000|    0.0949147|  2.37287e-05|  1.76%|# <__array_function__ internals>_12:2 dot
    57|         0|            0|            0|  0.00%|# Process profile content: generate a cachegrind file and send it to user.
    58|         0|            0|            0|  0.00%|
    59|         0|            0|            0|  0.00%|
    60|         0|            0|            0|  0.00%|
    61|         0|            0|            0|  0.00%|
    62|         0|            0|            0|  0.00%|
    63|         0|            0|            0|  0.00%|
    64|         0|            0|            0|  0.00%|def make_tau_plot_grid(tau_mat: np.ndarray) -> np.ndarray:
    65|         0|            0|            0|  0.00%|    """
    66|         0|            0|            0|  0.00%|    Used for both octave and linear.
    67|         0|            0|            0|  0.00%|    Takes the TAU output from wwz.py and creates a grid for pcolormesh
    68|         0|            0|            0|  0.00%|    :param tau_mat: TAU output from wwz.py
    69|         0|            0|            0|  0.00%|    :return:
    70|         0|            0|            0|  0.00%|    """
    71|         0|            0|            0|  0.00%|
    72|         0|            0|            0|  0.00%|    # Get the tau values from tau_mat
    73|         0|            0|            0|  0.00%|    taus = tau_mat[:, 0]
    74|         0|            0|            0|  0.00%|
    75|         0|            0|            0|  0.00%|    # Append one tau value for edge limit by adding the step to the largest tau
    76|         0|            0|            0|  0.00%|    taus = np.append(taus, taus[-1] + taus[1] - taus[0])
    77|         0|            0|            0|  0.00%|
    78|         0|            0|            0|  0.00%|    # Tile the taus with an additional column to create grid that matches freq_grid
    79|         0|            0|            0|  0.00%|    tau_grid = np.tile(taus, (tau_mat.shape[1] + 1, 1)).transpose()
    80|         0|            0|            0|  0.00%|
    81|         0|            0|            0|  0.00%|    return tau_grid
    82|         0|            0|            0|  0.00%|
    83|         0|            0|            0|  0.00%|
    84|         0|            0|            0|  0.00%|def make_linear_freq_plot_grid(freq_mat: np.ndarray) -> np.ndarray:
    85|         0|            0|            0|  0.00%|    """
    86|         0|            0|            0|  0.00%|    Used for linear method.
    87|         0|            0|            0|  0.00%|    Takes the FREQ output from wwz.py and creates a grid for pcolormesh.
    88|         0|            0|            0|  0.00%|    :param freq_mat: FREQ output from wwz.py
    89|         0|            0|            0|  0.00%|    :return: freq_grid: np.ndarray with the boundaries for the FREQ output
    90|         0|            0|            0|  0.00%|    """
    91|         0|            0|            0|  0.00%|
    92|         0|            0|            0|  0.00%|    # Get the array of center frequencies from the freq_mat
    93|         0|            0|            0|  0.00%|    freq_centers = freq_mat[0, :]
    94|         0|            0|            0|  0.00%|
    95|         0|            0|            0|  0.00%|    # Get the freq_steps by subtracting the first two freq_centers
    96|         0|            0|            0|  0.00%|    freq_step = freq_centers[1] - freq_centers[0]
    97|         0|            0|            0|  0.00%|
    98|         0|            0|            0|  0.00%|    # Subtract half of the freq_step from the freq_centers to get lower bound
    99|         0|            0|            0|  0.00%|    freq_lows = freq_centers - freq_step / 2
   100|         0|            0|            0|  0.00%|
   101|         0|            0|            0|  0.00%|    # Append the high frequency bound to get all the boundaries
   102|         0|            0|            0|  0.00%|    freq_highest = freq_centers.max() + freq_step / 2
   103|         0|            0|            0|  0.00%|    freq_bounds = np.append(freq_lows, freq_highest)
   104|         0|            0|            0|  0.00%|
   105|         0|            0|            0|  0.00%|    # Tile the freq_bounds to create a grid
   106|         0|            0|            0|  0.00%|    freq_grid = np.tile(freq_bounds, (freq_mat.shape[0] + 1, 1))
   107|         0|            0|            0|  0.00%|
   108|         0|            0|            0|  0.00%|    return freq_grid
   109|         0|            0|            0|  0.00%|
   110|         0|            0|            0|  0.00%|
   111|         0|            0|            0|  0.00%|def linear_plotter_log_1(ax: axes, TAU: np.ndarray, FREQ: np.ndarray, DATA: np.ndarray, clip=None):
   112|         0|            0|            0|  0.00%|    """
   113|         0|            0|            0|  0.00%|    Creates a plot for the 'linear' method.
   114|         0|            0|            0|  0.00%|    You can add titles after calling the plotter.
   115|         0|            0|            0|  0.00%|    :param ax: axis from a matplotlib.pyplot.subplots() to plot the data
   116|         0|            0|            0|  0.00%|    :param TAU: TAU output of the wwz.py (the time shifts)
   117|         0|            0|            0|  0.00%|    :param FREQ: FREQ output of the wwz.py (the frequencies)
   118|         0|            0|            0|  0.00%|    :param DATA: Desired data to be plotted
   119|         0|            0|            0|  0.00%|    :return:
   120|         0|            0|            0|  0.00%|    """
   121|         0|            0|            0|  0.00%|    #mask zero values, required to allow log scale axis
   122|         0|            0|            0|  0.00%|    DATA_masked = np.ma.masked_where(DATA == 0, DATA)
   123|         0|            0|            0|  0.00%|    data_mean = DATA_masked.mean()
   124|         0|            0|            0|  0.00%|    data_std = DATA_masked.std()
   125|         0|            0|            0|  0.00%|    if clip:
   126|         0|            0|            0|  0.00%|        DATA_clipped = np.clip(DATA_masked, clip[0], clip[1])
   127|         0|            0|            0|  0.00%|    else:
   128|         0|            0|            0|  0.00%|        DATA_clipped = DATA_masked
   129|         0|            0|            0|  0.00%|
   130|         0|            0|            0|  0.00%|    # Create grid for pcolormesh boundaries
   131|         0|            0|            0|  0.00%|    tau_grid = make_tau_plot_grid(TAU)
   132|         0|            0|            0|  0.00%|    freq_grid = make_linear_freq_plot_grid(FREQ)
   133|         0|            0|            0|  0.00%|
   134|         0|            0|            0|  0.00%|    # Plot using subplots
   135|         0|            0|            0|  0.00%|    im = ax.pcolormesh(tau_grid, freq_grid, DATA_clipped, norm=colors.LogNorm(vmin=DATA_clipped.min(), vmax=DATA_clipped.max()))
   136|         0|            0|            0|  0.00%|
   137|         0|            0|            0|  0.00%|    # Add color bar and fix y_ticks
   138|         0|            0|            0|  0.00%|    cbar = ax.figure.colorbar(im, ax=ax, pad=0.1)
   139|         0|            0|            0|  0.00%|    ax.set_yticks(FREQ[0, :])
   140|         0|            0|            0|  0.00%|    ax.get_yaxis().set_major_formatter(ticker.ScalarFormatter())
   141|         0|            0|            0|  0.00%|    cbar.ax.set_ylabel('wavelet power (z-statistic)', rotation=90)
   142|         0|            0|            0|  0.00%|
   143|         0|            0|            0|  0.00%|
   144|         0|            0|            0|  0.00%|
   145|         0|            0|            0|  0.00%|
   146|         0|            0|            0|  0.00%|fig, ax = plt.subplots(nrows=1, sharex=False, figsize=[13, 10])
   147|         0|            0|            0|  0.00%|linear_plotter_log_1(ax=ax,
   148|         0|            0|            0|  0.00%|                       TAU=wwt_spec_Nyq[0],
   149|         0|            0|            0|  0.00%|                       FREQ=wwt_spec_Nyq[1],
   150|         0|            0|            0|  0.00%|                       DATA=wwt_spec_Nyq[2],
   151|         0|            0|            0|  0.00%|                    clip=(np.percentile(wwt_spec_Nyq[2], 75),np.percentile(wwt_spec_Nyq[2], 99.9)))
   152|         0|            0|            0|  0.00%|plt.locator_params(axis='y', nbins=100)
   153|         0|            0|            0|  0.00%|# ax.set_ylabel('Frequency (1/day)')
   154|         0|            0|            0|  0.00%|ax.set_yscale('log')
   155|         0|            0|            0|  0.00%|def forward(x):
   156|         0|            0|            0|  0.00%|    return 1 / x
   157|         0|            0|            0|  0.00%|def inverse(x):
   158|         0|            0|            0|  0.00%|    return 1 / x
   159|         0|            0|            0|  0.00%|secax = ax.secondary_yaxis('right')#, functions=(forward, inverse))
   160|         0|            0|            0|  0.00%|secax.set_ylabel('frequency ($days^{-1}$)', labelpad=0)
   161|         0|            0|            0|  0.00%|ax.tick_params(axis='y', which='minor')
   162|         0|            0|            0|  0.00%|# ax.yaxis.set_minor_formatter(ticker.LogFormatterMathtext(labelOnlyBase=False))
   163|         0|            0|            0|  0.00%|ax.yaxis.set_major_formatter(ticker.FuncFormatter(lambda y, _: 1/y))
   164|         0|            0|            0|  0.00%|ax.yaxis.set_minor_formatter(ticker.FuncFormatter(lambda y, _: np.round(1/y, decimals=2)))
   165|         0|            0|            0|  0.00%|ax.set_ylabel('period (days)')
   166|         0|            0|            0|  0.00%|ax.set_xlabel('Date (JD)')
   167|         0|            0|            0|  0.00%|plt.tight_layout()
   168|         0|            0|            0|  0.00%|
   169|         0|            0|            0|  0.00%|now = datetime.now()
   170|         0|            0|            0|  0.00%|dt_string = now.strftime("%d-%m-%Y_%H-%M-%S")
   171|         0|            0|            0|  0.00%|plt.savefig('test_images/test_spectrogram_{}.png'.format(dt_string))
   172|         0|            0|            0|  0.00%|
   173|         0|            0|            0|  0.00%|
   174|         0|            0|            0|  0.00%|print("done")
   175|         0|            0|            0|  0.00%|
   176|         0|            0|            0|  0.00%|
   177|         0|            0|            0|  0.00%|# save profiler repoert to a file:
   178|         0|            0|            0|  0.00%|profiler.dump_stats("profiler_stats.txt")
